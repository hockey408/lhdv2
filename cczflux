-- =========================
-- PARAMETERS (edit as needed)
-- =========================
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,     -- last month-end to include
    12                                       AS lookback_months,  -- 12 + current = 13 months
    0.05::FLOAT                               AS pct_synth_mom_flag,  -- 5%pt MoM change in mix
    10000000::NUMERIC                         AS abs_synth_delta_flag, -- $10M MoM change in synthetic $
    2.5::FLOAT                                AS z_threshold           -- z-score threshold on pct_synth
),

-- =========================
-- (A) Map BANK_CODE to one of 3 categories
--    Replace this with a real DIM table if you have one
-- =========================
bank_map AS (
  SELECT 'BANK001'::VARCHAR(20) AS bank_code, 'CAT1'::VARCHAR(10) AS cat UNION ALL
  SELECT 'BANK002', 'CAT2' UNION ALL
  SELECT 'BANK003', 'CAT3'
  -- TODO: add all BANK_CODEs here or JOIN to your bank dimension
),

-- =========================
-- (B) Pull last 13 months and flag synthetic by category-specific logic
--     >>> Plug your three rule sets into the placeholders <<<
-- =========================
raw AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                         AS eom,
      t.BANK_CODE,                                      -- you said you want to key by BANK_CODE
      bm.cat                                            AS bank_category,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_BALANCE,

      CASE
        WHEN bm.cat = 'CAT1' AND ( /* TODO: CAT1_SYNTHETIC_CONDITION using row fields */ )
          THEN 1
        WHEN bm.cat = 'CAT2' AND ( /* TODO: CAT2_SYNTHETIC_CONDITION */ )
          THEN 1
        WHEN bm.cat = 'CAT3' AND ( /* TODO: CAT3_SYNTHETIC_CONDITION */ )
          THEN 1
        ELSE 0
      END AS is_synth
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  JOIN params p  ON 1=1
  LEFT JOIN bank_map bm
         ON bm.bank_code = t.BANK_CODE
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
),

-- =========================
-- (C) Monthly aggregation: synthetic vs non-synthetic vs total
-- =========================
mth AS (
  SELECT
      eom,
      BANK_CODE,
      bank_category,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      SUM(CASE WHEN is_synth = 1 THEN GL_BALANCE ELSE 0 END)     AS synthetic_balance,
      SUM(CASE WHEN is_synth = 0 THEN GL_BALANCE ELSE 0 END)     AS non_synthetic_balance,
      SUM(GL_BALANCE)                                            AS total_balance,

      CASE
        WHEN SUM(GL_BALANCE) = 0 THEN NULL
        ELSE 1.0 * SUM(CASE WHEN is_synth = 1 THEN GL_BALANCE ELSE 0 END)
               / NULLIF(SUM(GL_BALANCE),0)
      END AS pct_synthetic
  FROM raw
  GROUP BY 1,2,3,4,5
),

-- =========================
-- (D) Time deltas and 12-month rolling statistics
-- =========================
calc AS (
  SELECT
      eom,
      BANK_CODE,
      bank_category,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      synthetic_balance,
      non_synthetic_balance,
      total_balance,
      pct_synthetic,

      -- MoM deltas
      (synthetic_balance - LAG(synthetic_balance) OVER (
         PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       )) AS synth_delta_mom,

      (pct_synthetic - LAG(pct_synthetic) OVER (
         PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       )) AS pct_synth_delta_mom,

      -- Rolling 12 statistics on pct_synthetic (exclude current)
      AVG(pct_synthetic) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS avg_pct_synth_12,

      STDDEV_SAMP(pct_synthetic) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS sd_pct_synth_12
  FROM mth
),

-- =========================
-- (E) Z-score on pct_synthetic for the latest month only
-- =========================
scored AS (
  SELECT
      c.*,
      CASE
        WHEN sd_pct_synth_12 IS NULL OR sd_pct_synth_12 = 0 THEN NULL
        ELSE (pct_synthetic - avg_pct_synth_12) / sd_pct_synth_12
      END AS z_pct_synth
  FROM calc c
  JOIN params p ON 1=1
  WHERE c.eom = p.asof_eom
)

-- =========================
-- (F) Final anomaly list (ranked)
-- =========================
SELECT
    eom,
    BANK_CODE,
    bank_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    synthetic_balance,
    non_synthetic_balance,
    total_balance,
    pct_synthetic,

    synth_delta_mom,
    pct_synth_delta_mom,
    avg_pct_synth_12,
    sd_pct_synth_12,
    z_pct_synth,

    -- Flags
    CASE WHEN ABS(pct_synth_delta_mom) >= (SELECT pct_synth_mom_flag FROM params) THEN 1 ELSE 0 END AS flag_big_mix_change,
    CASE WHEN ABS(synth_delta_mom)      >= (SELECT abs_synth_delta_flag FROM params) THEN 1 ELSE 0 END AS flag_big_abs_change,
    CASE WHEN ABS(z_pct_synth)          >= (SELECT z_threshold FROM params) THEN 1 ELSE 0 END AS flag_z_outlier,

    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(synth_delta_mom) >= (SELECT abs_synth_delta_flag FROM params) THEN 1 ELSE 0 END DESC,
        ABS(z_pct_synth) DESC NULLS LAST,
        ABS(pct_synth_delta_mom) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored
WHERE
    -- keep only interesting rows
    ABS(pct_synth_delta_mom) >= (SELECT pct_synth_mom_flag FROM params)
 OR ABS(synth_delta_mom)      >= (SELECT abs_synth_delta_flag FROM params)
 OR ABS(z_pct_synth)          >= (SELECT z_threshold FROM params)
ORDER BY anomaly_rank;






WITH base AS (
  SELECT
      CAST(END_OF_MONTH_DATE AS DATE)                     AS EOM,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      CAST(SOURCE_SYSTEM_BALANCE AS DECIMAL(18,2))        AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE END_OF_MONTH_DATE BETWEEN DATE '2024-08-31' AND DATE '2025-07-31'
),

deltas AS (
  SELECT
      EOM,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      SOURCE_SYSTEM_BALANCE,
      LAG(SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
        ORDER BY EOM
      )                                                   AS PREV_BAL
  FROM base
),

calc AS (
  SELECT
      EOM,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      SOURCE_SYSTEM_BALANCE,
      PREV_BAL,
      /* $ delta stays in DECIMAL(18,2) */
      (SOURCE_SYSTEM_BALANCE - PREV_BAL)                  AS DELTA_DOLLARS,
      /* % delta computed in DOUBLE PRECISION to avoid DECIMAL precision blowup */
      CASE
        WHEN PREV_BAL IS NULL OR PREV_BAL = 0 THEN NULL
        ELSE
          (
            CAST(SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION)
            - CAST(PREV_BAL AS DOUBLE PRECISION)
          )
          / NULLIF(ABS(CAST(PREV_BAL AS DOUBLE PRECISION)), 0.0)
      END                                                 AS DELTA_PCT
  FROM deltas
),

roll AS (
  SELECT
      c.*,
      /* rolling 12 values (current + 11 prior), all in DOUBLE PRECISION */
      AVG(DELTA_PCT) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
        ORDER BY EOM
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::DOUBLE PRECISION                                 AS MEAN_12,
      STDDEV(DELTA_PCT) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
        ORDER BY EOM
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::DOUBLE PRECISION                                 AS STDEV_12
  FROM calc c
)

SELECT
  EOM,
  BANK_CODE,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  SOURCE_SYSTEM_BALANCE,      -- DECIMAL(18,2)
  PREV_BAL,                   -- DECIMAL(18,2)
  DELTA_DOLLARS,              -- DECIMAL(18,2)
  DELTA_PCT,                  -- DOUBLE PRECISION
  MEAN_12,                    -- DOUBLE PRECISION
  STDEV_12,                   -- DOUBLE PRECISION
  CASE
    WHEN STDEV_12 IS NULL OR STDEV_12 = 0 OR DELTA_PCT IS NULL THEN NULL
    ELSE (DELTA_PCT - MEAN_12) / STDEV_12
  END                         AS Z_SCORE,         -- DOUBLE PRECISION
  CASE
    WHEN ABS(DELTA_DOLLARS) >= 250000
         AND CASE
               WHEN STDEV_12 IS NULL OR STDEV_12 = 0 OR DELTA_PCT IS NULL THEN NULL
               ELSE ABS((DELTA_PCT - MEAN_12) / STDEV_12)
             END >= 3
    THEN 1 ELSE 0
  END                         AS ANOMALY_FLAG
FROM roll
ORDER BY EOM, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE;






-- Option C (revised) â€” safe types to avoid "numeric value requires more than 38 digits"

WITH base AS (
  SELECT
      CAST(END_OF_MONTH_DATE AS DATE)           AS EOM,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      CAST(SOURCE_SYSTEM_BALANCE AS DECIMAL(18,2)) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE END_OF_MONTH_DATE BETWEEN DATE '2024-08-31' AND DATE '2025-07-31'
),

deltas AS (
  SELECT
      EOM,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      SOURCE_SYSTEM_BALANCE,
      LAG(SOURCE_SYSTEM_BALANCE) OVER (
          PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
          ORDER BY EOM
      )                                                AS prev_bal,
      -- $ delta stays DECIMAL(18,2)
      (SOURCE_SYSTEM_BALANCE - LAG(SOURCE_SYSTEM_BALANCE) OVER (
          PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
          ORDER BY EOM
      ))                                              AS delta_dollars,
      -- % delta as FLOAT8 to avoid DECIMAL precision blowups
      CASE
        WHEN LAG(SOURCE_SYSTEM_BALANCE) OVER (
               PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
               ORDER BY EOM
             ) IS NULL
             OR LAG(SOURCE_SYSTEM_BALANCE) OVER (
               PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
               ORDER BY EOM
             ) = 0
        THEN NULL
        ELSE
          ( (SOURCE_SYSTEM_BALANCE::FLOAT8
              - LAG(SOURCE_SYSTEM_BALANCE)::FLOAT8 OVER (
                  PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
                  ORDER BY EOM
                )
            )
            / NULLIF(ABS(LAG(SOURCE_SYSTEM_BALANCE)::FLOAT8 OVER (
                  PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
                  ORDER BY EOM
                )), 0.0)
          )::FLOAT8
      END                                             AS delta_pct
  FROM base
),

roll AS (
  SELECT
      d.*,
      -- rolling stats over last 12 rows, all in FLOAT8
      AVG(delta_pct)      OVER (
          PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
          ORDER BY EOM
          ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8                                   AS mean_12,
      STDDEV_POP(delta_pct) OVER (
          PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
          ORDER BY EOM
          ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8                                   AS stdev_12
  FROM deltas d
)

SELECT
  EOM,
  BANK_CODE,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  SOURCE_SYSTEM_BALANCE,                   -- DECIMAL(18,2)
  prev_bal,                                -- DECIMAL(18,2)
  delta_dollars,                           -- DECIMAL(18,2)
  delta_pct,                               -- FLOAT8
  mean_12,                                 -- FLOAT8
  stdev_12,                                -- FLOAT8
  CASE
    WHEN stdev_12 IS NULL OR stdev_12 = 0 OR delta_pct IS NULL THEN NULL
    ELSE (delta_pct - mean_12) / stdev_12
  END                                      AS z_score,             -- FLOAT8
  CASE
    WHEN ABS(delta_dollars) >= 250000
         AND CASE
               WHEN stdev_12 IS NULL OR stdev_12 = 0 OR delta_pct IS NULL THEN NULL
               ELSE ABS((delta_pct - mean_12) / stdev_12)
             END >= 3
    THEN 1 ELSE 0
  END                                      AS anomaly_flag
FROM roll
ORDER BY EOM, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE;




WITH base AS (
  SELECT
    END_OF_MONTH_DATE::date   AS EOM,
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE END_OF_MONTH_DATE BETWEEN DATE '2024-08-31' AND DATE '2025-07-31'
),
deltas AS (
  SELECT
    EOM, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE,
    SOURCE_SYSTEM_BALANCE,
    LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM) AS prev_bal,
    SOURCE_SYSTEM_BALANCE - LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM) AS delta_$,
    CASE
      WHEN LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM) = 0
        THEN NULL
      ELSE (SOURCE_SYSTEM_BALANCE - LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM)) 
           / NULLIF(ABS(LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM)),0)
    END AS delta_pct
  FROM base
),
roll AS (
  SELECT
    d.*,
    AVG(delta_pct) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS mean_12,
    STDDEV_POP(delta_pct) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY EOM ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS stdev_12
  FROM deltas d
)
SELECT
  EOM, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE,
  SOURCE_SYSTEM_BALANCE, prev_bal, delta_$, delta_pct,
  mean_12, stdev_12,
  CASE 
    WHEN stdev_12 IS NULL OR stdev_12 = 0 OR delta_pct IS NULL THEN NULL
    ELSE (delta_pct - mean_12) / stdev_12
  END AS z_score,
  CASE 
    WHEN ABS(delta_$) >= 250000 AND ABS(
      CASE WHEN stdev_12 IS NULL OR stdev_12 = 0 OR delta_pct IS NULL THEN NULL
           ELSE (delta_pct - mean_12) / stdev_12 END
    ) >= 3 THEN 1
    ELSE 0
  END AS anomaly_flag
FROM roll;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS
),
window_months AS (
  SELECT ADD_MONTHS(max_eom, -11) AS min_eom, max_eom
  FROM latest
),
base AS (
  SELECT
      END_OF_MONTH_DATE,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      GL_BALANCE,
      SOURCE_SYSTEM_BALANCE,
      AVAILABLE_BALANCE,
      COMMITMENT_BALANCE,       -- <- if your table uses COMMITMENT, replace this
      1 AS rec
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  WHERE t.END_OF_MONTH_DATE BETWEEN (SELECT min_eom FROM window_months)
                               AND (SELECT max_eom FROM window_months)
),
agg AS (   -- monthly rollups at the desired grain
  SELECT
      END_OF_MONTH_DATE,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_CODE,
      SUM(GL_BALANCE)              AS GL_BALANCE,
      SUM(SOURCE_SYSTEM_BALANCE)   AS SOURCE_SYSTEM_BALANCE,
      SUM(AVAILABLE_BALANCE)       AS AVAILABLE_BALANCE,
      SUM(COMMITMENT_BALANCE)      AS COMMITMENT,
      COUNT(*)                     AS RECORD_COUNT
  FROM base
  GROUP BY 1,2,3,4
),
lagged AS (  -- add prior-month values for MoM calculations
  SELECT
      a.*,
      LAG(GL_BALANCE)            OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY END_OF_MONTH_DATE) AS prev_GL_BALANCE,
      LAG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY END_OF_MONTH_DATE) AS prev_SOURCE_SYSTEM_BALANCE,
      LAG(AVAILABLE_BALANCE)     OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY END_OF_MONTH_DATE) AS prev_AVAILABLE_BALANCE,
      LAG(COMMITMENT)            OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY END_OF_MONTH_DATE) AS prev_COMMITMENT,
      LAG(RECORD_COUNT)          OVER (PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE ORDER BY END_OF_MONTH_DATE) AS prev_RECORD_COUNT
  FROM agg a
)
SELECT
    END_OF_MONTH_DATE,
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    -- Levels
    GL_BALANCE,
    SOURCE_SYSTEM_BALANCE,
    AVAILABLE_BALANCE,
    COMMITMENT,
    RECORD_COUNT,
    -- MoM $ change
    (GL_BALANCE            - prev_GL_BALANCE)            AS GLBAL_MoM_$,
    (SOURCE_SYSTEM_BALANCE - prev_SOURCE_SYSTEM_BALANCE) AS SRCBAL_MoM_$,
    (AVAILABLE_BALANCE     - prev_AVAILABLE_BALANCE)     AS AVAIL_MoM_$,
    (COMMITMENT            - prev_COMMITMENT)            AS COMM_MoM_$,
    (RECORD_COUNT          - prev_RECORD_COUNT)          AS RECCNT_MoM,
    -- MoM % change (safe divide)
    CASE WHEN prev_GL_BALANCE            IS NULL OR prev_GL_BALANCE            = 0 THEN NULL
         ELSE (GL_BALANCE - prev_GL_BALANCE) / ABS(prev_GL_BALANCE::DOUBLE) END            AS GLBAL_MoM_%,
    CASE WHEN prev_SOURCE_SYSTEM_BALANCE IS NULL OR prev_SOURCE_SYSTEM_BALANCE = 0 THEN NULL
         ELSE (SOURCE_SYSTEM_BALANCE - prev_SOURCE_SYSTEM_BALANCE) / ABS(prev_SOURCE_SYSTEM_BALANCE::DOUBLE) END AS SRCBAL_MoM_%,
    CASE WHEN prev_AVAILABLE_BALANCE     IS NULL OR prev_AVAILABLE_BALANCE     = 0 THEN NULL
         ELSE (AVAILABLE_BALANCE - prev_AVAILABLE_BALANCE) / ABS(prev_AVAILABLE_BALANCE::DOUBLE) END           AS AVAIL_MoM_%,
    CASE WHEN prev_COMMITMENT            IS NULL OR prev_COMMITMENT            = 0 THEN NULL
         ELSE (COMMITMENT - prev_COMMITMENT) / ABS(prev_COMMITMENT::DOUBLE) END                                AS COMM_MoM_%,
    CASE WHEN prev_RECORD_COUNT          IS NULL OR prev_RECORD_COUNT          = 0 THEN NULL
         ELSE (RECORD_COUNT - prev_RECORD_COUNT) / prev_RECORD_COUNT::DOUBLE END                               AS RECCNT_MoM_%
FROM lagged
ORDER BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE, END_OF_MONTH_DATE;





SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    SUM(GL_BALANCE)            AS GL_BALANCE,
    SUM(SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE,
    SUM(AVAILABLE_BALANCE)     AS AVAILABLE_BALANCE,
    SUM(COMMITMENT_BALANCE)    AS COMMITMENT,
    COUNT(*)                   AS RECORD_COUNT
FROM V_DPRT_CREDIT_INSTRUMENTS
WHERE END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT MAX(END_OF_MONTH_DATE) FROM V_DPRT_CREDIT_INSTRUMENTS), -11)
                            AND (SELECT MAX(END_OF_MONTH_DATE) FROM V_DPRT_CREDIT_INSTRUMENTS)
GROUP BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM
ORDER BY CONTRACT_SOURCE_SYSTEM, END_OF_MONTH_DATE;



"""\
# Enterprise Loan Portfolio â€” Month-over-Month Analysis (Notebook Skeleton)

This notebook ingests monthly exports (CSV files) from Netezza, aggregates them, computes MoM metrics,
and produces baseline visuals for:
- `GL_BALANCE`, `SOURCE_SYSTEM_BALANCE`, `AVAILABLE_BALANCE`, `COMMITMENT`
- by `BANK_CODE`, `CONTRACT_SOURCE_SYSTEM`, `GL_ACCOUNT_CODE`

### How to use
1. Export 12 month-end CSVs from Netezza (or one consolidated CSV) into a folder.
2. Point `DATA_FOLDER` to that folder. Ensure required columns exist (see `REQUIRED_COLS`).
3. Run cells top-to-bottom. Outputs and charts are saved to `/mnt/data/exports`.

"""

import os, glob
from pathlib import Path
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
pd.set_option('display.max_columns', 100)
pd.set_option('display.width', 140)
DATA_FOLDER = "/mnt/data/monthly_exports"  # change to your folder
EXPORT_DIR = "/mnt/data/exports"
Path(EXPORT_DIR).mkdir(parents=True, exist_ok=True)
REQUIRED_COLS = [
    "END_OF_MONTH_DATE","BANK_CODE","CONTRACT_SOURCE_SYSTEM","GL_ACCOUNT_CODE",
    "GL_BALANCE","SOURCE_SYSTEM_BALANCE","AVAILABLE_BALANCE"
]
OPTIONAL_COLS = ["RECORD_COUNT","RISK_UNIT","PD_GRADE","INDUSTRY_CODE","INDUSTRY_DESCRIPTION","NON_ACCRUAL_FLAG","DAYS_PAST_DUE","MATURITY_DATE","ORIGINATION_DATE"]
print('Config loaded. Update DATA_FOLDER if needed.')


def _detect_commitment_column(df: pd.DataFrame) -> str:
    if "COMMITMENT" in df.columns: return "COMMITMENT"
    if "COMMITMENT_BALANCE" in df.columns: return "COMMITMENT_BALANCE"
    raise KeyError("Neither 'COMMITMENT' nor 'COMMITMENT_BALANCE' found in data.")

def load_data_from_folder(folder: str) -> pd.DataFrame:
    paths = sorted(glob.glob(os.path.join(folder, "*.csv")))
    if not paths:
        print(f"No CSV files found in {folder}.")
        return pd.DataFrame()
    dfs = []
    for p in paths:
        print('Reading', p)
        df = pd.read_csv(p, parse_dates=["END_OF_MONTH_DATE"], infer_datetime_format=True,
                         dtype={"BANK_CODE":"category","CONTRACT_SOURCE_SYSTEM":"category","GL_ACCOUNT_CODE":"category"})
        dfs.append(df)
    return pd.concat(dfs, ignore_index=True)

def validate_schema(df: pd.DataFrame):
    missing = [c for c in REQUIRED_COLS if c not in df.columns]
    if ("COMMITMENT" not in df.columns) and ("COMMITMENT_BALANCE" not in df.columns):
        missing.append("COMMITMENT or COMMITMENT_BALANCE")
    if missing:
        raise ValueError(f"Missing required columns: {missing}")
    print('Schema looks good.')


def normalize_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    commit_col = _detect_commitment_column(df)
    if commit_col != 'COMMITMENT': df.rename(columns={commit_col:'COMMITMENT'}, inplace=True)
    df['END_OF_MONTH_DATE'] = pd.to_datetime(df['END_OF_MONTH_DATE']).dt.to_period('M').dt.to_timestamp('M')
    for c in ['GL_BALANCE','SOURCE_SYSTEM_BALANCE','AVAILABLE_BALANCE','COMMITMENT']:
        df[c] = pd.to_numeric(df[c], errors='coerce')
    return df

def aggregate_monthly(df: pd.DataFrame) -> pd.DataFrame:
    grp = ['END_OF_MONTH_DATE','BANK_CODE','CONTRACT_SOURCE_SYSTEM','GL_ACCOUNT_CODE']
    return (df.groupby(grp, dropna=False)
              .agg(GL_BALANCE=('GL_BALANCE','sum'),
                   SOURCE_SYSTEM_BALANCE=('SOURCE_SYSTEM_BALANCE','sum'),
                   AVAILABLE_BALANCE=('AVAILABLE_BALANCE','sum'),
                   COMMITMENT=('COMMITMENT','sum'),
                   RECORD_COUNT=('GL_ACCOUNT_CODE','count'))
              .reset_index())

def add_mom_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.sort_values(['BANK_CODE','CONTRACT_SOURCE_SYSTEM','GL_ACCOUNT_CODE','END_OF_MONTH_DATE']).copy()
    key = ['BANK_CODE','CONTRACT_SOURCE_SYSTEM','GL_ACCOUNT_CODE']
    for col in ['GL_BALANCE','SOURCE_SYSTEM_BALANCE','AVAILABLE_BALANCE','COMMITMENT','RECORD_COUNT']:
        prev = df.groupby(key)[col].shift(1)
        df[f'{col}_MoM_$'] = df[col] - prev
        df[f'{col}_MoM_%'] = np.where((prev==0)|prev.isna(), np.nan, (df[col]-prev)/prev.abs())
    return df

def add_yoy_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.sort_values(['BANK_CODE','CONTRACT_SOURCE_SYSTEM','GL_ACCOUNT_CODE','END_OF_MONTH_DATE']).copy()
    key = ['BANK_CODE','CONTRACT_SOURCE_SYSTEM','GL_ACCOUNT_CODE']
    for col in ['GL_BALANCE','SOURCE_SYSTEM_BALANCE','AVAILABLE_BALANCE','COMMITMENT','RECORD_COUNT']:
        prev12 = df.groupby(key)[col].shift(12)
        df[f'{col}_YoY_$'] = df[col] - prev12
        df[f'{col}_YoY_%'] = np.where((prev12==0)|prev12.isna(), np.nan, (df[col]-prev12)/prev12.abs())
    return df


def kpi_totals_plot(df_agg: pd.DataFrame, export_path: str = None):
    latest = df_agg['END_OF_MONTH_DATE'].max()
    snap = df_agg[df_agg['END_OF_MONTH_DATE']==latest]
    totals = snap[['GL_BALANCE','SOURCE_SYSTEM_BALANCE','AVAILABLE_BALANCE','COMMITMENT']].sum()
    plt.figure()
    totals.plot(kind='bar')
    plt.title(f'Portfolio Totals â€” {latest.date()}')
    plt.ylabel('Amount')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    if export_path: plt.savefig(export_path, dpi=150)
    plt.show()

def heatmap_mom_percent(df_mom: pd.DataFrame, metric: str='GL_BALANCE', export_path: str=None):
    latest = df_mom['END_OF_MONTH_DATE'].max()
    recent = df_mom[df_mom['END_OF_MONTH_DATE']==latest]
    pv = recent.pivot_table(index='CONTRACT_SOURCE_SYSTEM', columns='GL_ACCOUNT_CODE', values=f'{metric}_MoM_%', aggfunc='sum')
    plt.figure()
    plt.imshow(pv.fillna(0).values, aspect='auto')
    plt.title(f'MoM % Heatmap â€” {metric} â€” {latest.date()}')
    plt.xlabel('GL_ACCOUNT_CODE'); plt.ylabel('CONTRACT_SOURCE_SYSTEM')
    plt.colorbar(); plt.tight_layout()
    if export_path: plt.savefig(export_path, dpi=150)
    plt.show()

def waterfall_mom_system(df_mom: pd.DataFrame, system: str, metric: str='GL_BALANCE', export_path: str=None):
    latest = df_mom['END_OF_MONTH_DATE'].max()
    scope = df_mom[(df_mom['END_OF_MONTH_DATE']==latest)&(df_mom['CONTRACT_SOURCE_SYSTEM']==system)]
    scope = scope[['GL_ACCOUNT_CODE', f'{metric}_MoM_$']].sort_values(f'{metric}_MoM_$', ascending=False).head(20)
    plt.figure()
    plt.bar(scope['GL_ACCOUNT_CODE'].astype(str), scope[f'{metric}_MoM_$'])
    plt.title(f'Top 20 MoM $ â€” {metric} â€” {system} â€” {latest.date()}')
    plt.xticks(rotation=45, ha='right'); plt.ylabel('MoM $'); plt.tight_layout()
    if export_path: plt.savefig(export_path, dpi=150)
    plt.show()

def line_trend_system_metric(df_agg: pd.DataFrame, system: str, metric: str='GL_BALANCE', export_path: str=None):
    scope = df_agg[df_agg['CONTRACT_SOURCE_SYSTEM']==system]
    ts = scope.groupby('END_OF_MONTH_DATE')[metric].sum().reset_index()
    plt.figure()
    plt.plot(ts['END_OF_MONTH_DATE'], ts[metric])
    plt.title(f'Trend â€” {metric} â€” {system}')
    plt.xlabel('Month'); plt.ylabel(metric); plt.tight_layout()
    if export_path: plt.savefig(export_path, dpi=150)
    plt.show()


raw = load_data_from_folder(DATA_FOLDER)
if raw.empty:
    print('Load some CSVs into DATA_FOLDER and re-run this cell.')
else:
    validate_schema(raw)
    df = normalize_columns(raw)
    agg = aggregate_monthly(df)
    mom = add_mom_columns(agg)
    # mom = add_yoy_columns(mom)  # enable when you have >= 13 months
    agg_path = os.path.join(EXPORT_DIR, 'monthly_aggregates.csv')
    mom_path = os.path.join(EXPORT_DIR, 'monthly_with_mom.csv')
    agg.to_csv(agg_path, index=False); mom.to_csv(mom_path, index=False)
    print('Saved:', agg_path, '\nSaved:', mom_path)
    display(mom.head(10))


if 'agg' in globals() and not agg.empty:
    kpi_totals_plot(agg, export_path=os.path.join(EXPORT_DIR, 'kpi_totals_latest.png'))


if 'mom' in globals() and not mom.empty:
    heatmap_mom_percent(mom, metric='GL_BALANCE', export_path=os.path.join(EXPORT_DIR, 'heatmap_mom_pct_gl.png'))


if 'mom' in globals() and not mom.empty:
    example_system = str(mom['CONTRACT_SOURCE_SYSTEM'].dropna().astype(str).mode().iloc[0]) if not mom['CONTRACT_SOURCE_SYSTEM'].dropna().empty else 'SYSTEM_A'
    waterfall_mom_system(mom, system=example_system, metric='GL_BALANCE', export_path=os.path.join(EXPORT_DIR, f'waterfall_{example_system}_gl.png'))


if 'agg' in globals() and not agg.empty:
    example_system = str(agg['CONTRACT_SOURCE_SYSTEM'].dropna().astype(str).mode().iloc[0]) if not agg['CONTRACT_SOURCE_SYSTEM'].dropna().empty else 'SYSTEM_A'
    line_trend_system_metric(agg, system=example_system, metric='GL_BALANCE', export_path=os.path.join(EXPORT_DIR, f'trend_{example_system}_gl.png'))


"""\
## Next Steps
- Enable YoY metrics (`add_yoy_columns`) when 13+ months available.
- Merge risk/concentration fields for richer slices.
- Account-level deltas and anomaly flags for exceptions review.

"""








Date =
VAR MinDate = DATE(YEAR(MIN(FactMonthly[END_OF_MONTH_DATE]))-1, 1, 1)
VAR MaxDate = DATE(YEAR(MAX(FactMonthly[END_OF_MONTH_DATE]))+1, 12, 31)
RETURN
ADDCOLUMNS(
    CALENDAR(MinDate, MaxDate),
    "Year", YEAR([Date]),
    "Month", FORMAT([Date], "MMM"),
    "MonthNum", MONTH([Date]),
    "YearMonth", FORMAT([Date], "YYYY-MM"),
    "EOM", EOMONTH([Date], 0)
)






-- Base totals
Total GL := SUM(FactMonthly[GL_BALANCE])
Total Source := SUM(FactMonthly[SOURCE_SYSTEM_BALANCE])
Total Available := SUM(FactMonthly[AVAILABLE_BALANCE])
Total Commitment := SUM(FactMonthly[COMMITMENT])
Total Records := SUM(FactMonthly[RECORD_COUNT])  -- if present

-- Prior-month helpers
Prior Month GL :=
CALCULATE([Total GL], DATEADD(Date[Date], -1, MONTH))

Prior Month Source :=
CALCULATE([Total Source], DATEADD(Date[Date], -1, MONTH))

Prior Month Available :=
CALCULATE([Total Available], DATEADD(Date[Date], -1, MONTH))

Prior Month Commitment :=
CALCULATE([Total Commitment], DATEADD(Date[Date], -1, MONTH))

Prior Month Records :=
CALCULATE([Total Records], DATEADD(Date[Date], -1, MONTH))

-- MoM $ and %
GL MoM $ := [Total GL] - [Prior Month GL]
GL MoM % := DIVIDE([GL MoM $], ABS([Prior Month GL]))

Source MoM $ := [Total Source] - [Prior Month Source]
Source MoM % := DIVIDE([Source MoM $], ABS([Prior Month Source]))

Available MoM $ := [Total Available] - [Prior Month Available]
Available MoM % := DIVIDE([Available MoM $], ABS([Prior Month Available]))

Commitment MoM $ := [Total Commitment] - [Prior Month Commitment]
Commitment MoM % := DIVIDE([Commitment MoM $], ABS([Prior Month Commitment]))

Record MoM := [Total Records] - [Prior Month Records]
Record MoM % := DIVIDE([Record MoM], [Prior Month Records])

-- YoY (enable once 13+ months loaded)
GL YoY $ :=
VAR Prior12 = CALCULATE([Total GL], DATEADD(Date[Date], -12, MONTH))
RETURN [Total GL] - Prior12

GL YoY % :=
VAR Prior12 = CALCULATE([Total GL], DATEADD(Date[Date], -12, MONTH))
RETURN DIVIDE([Total GL] - Prior12, ABS(Prior12))





let
    Source             = FactMonthly,
    KeepDate           = Table.SelectColumns(Source, {"END_OF_MONTH_DATE"}),
    RemoveDuplicates   = Table.Distinct(KeepDate),
    Sorted             = Table.Sort(RemoveDuplicates, {{"END_OF_MONTH_DATE", Order.Ascending}}),
    AddYear            = Table.AddColumn(Sorted, "Year", each Date.Year([END_OF_MONTH_DATE]), Int64.Type),
    AddMonthNum        = Table.AddColumn(AddYear, "MonthNum", each Date.Month([END_OF_MONTH_DATE]), Int64.Type),
    AddMonthName       = Table.AddColumn(AddMonthNum, "Month", each Date.ToText([END_OF_MONTH_DATE], "MMM"), type text),
    AddYearMonth       = Table.AddColumn(AddMonthName, "YearMonth", each Date.ToText([END_OF_MONTH_DATE], "yyyy-MM"), type text)
in
    AddYearMonth





Source Î” % Color :=
VAR x = [Source Î” %]
-- Avoid coloring subtotal/total rows and blank cells
RETURN
IF (
    NOT ISINSCOPE ( FactMonthly[CONTRACT_SOURCE_SYSTEM] ) || ISBLANK ( x ),
    BLANK(),
    IF ( x >= 0.05, "#137333",           -- green
        IF ( x <= -0.05, "#C5221F",      -- red
             "#FFFFFF"                   -- neutral white for between -5% and +5%
        )
    )
)





Source Delta % Flag :=
VAR x = [Source Delta %]
RETURN
SWITCH (
    TRUE(),
    ISBLANK(x), BLANK(),
    x >= 0.05,  1,     -- green
    x <= -0.05, -1,    -- red
    0                  -- neutral
)




// =======================
// Phase 4 â€” Records vs $
// =======================

// Base totals
Total Records :=
SUM ( FactMonthly[RECORD_COUNT] )

Total Source :=
SUM ( FactMonthly[SOURCE_SYSTEM_BALANCE] )

// Current / Prior month (context-aware via Date[EOM])
Records (Current Month) :=
VAR cm = MAX ( 'Date'[EOM] )
RETURN
CALCULATE ( [Total Records], KEEPFILTERS ( 'Date'[EOM] = cm ) )

Records (Prior Month) :=
VAR cm = MAX ( 'Date'[EOM] )
VAR pm = EOMONTH ( cm, -1 )
RETURN
CALCULATE ( [Total Records], KEEPFILTERS ( 'Date'[EOM] = pm ) )

// MoM deltas for record counts
Record Delta :=
[Records (Current Month)] - [Records (Prior Month)]

Record Delta % :=
DIVIDE ( [Record Delta], [Records (Prior Month)] )

// Absolute % (web-friendly CF / scatter X-axis)
Record Delta % Abs :=
VAR x = [Record Delta %]
RETURN IF ( ISBLANK ( x ), BLANK (), ABS ( x ) )

// -----------------------
// $ side to compare with
// -----------------------

// If you already have Source (Current/Prior) + Source Delta % from earlier, keep them.
// Included here for completeness:

Source (Current Month) :=
VAR cm = MAX ( 'Date'[EOM] )
RETURN
CALCULATE ( [Total Source], KEEPFILTERS ( 'Date'[EOM] = cm ) )

Source (Prior Month) :=
VAR cm = MAX ( 'Date'[EOM] )
VAR pm = EOMONTH ( cm, -1 )
RETURN
CALCULATE ( [Total Source], KEEPFILTERS ( 'Date'[EOM] = pm ) )

Source Delta $ :=
[Source (Current Month)] - [Source (Prior Month)]

Source Delta % :=
DIVIDE ( [Source Delta $], [Source (Prior Month)] )

// Absolute % (scatter Y-axis, CF)
Source Delta % Abs :=
VAR x = [Source Delta %]
RETURN IF ( ISBLANK ( x ), BLANK (), ABS ( x ) )

// ---------------------------------------
// Quality flags / quick anomaly classifiers
// ---------------------------------------

// Choose tolerance thresholds (you can swap these for a What-If parameter later)
Threshold % Small := 0.02   // 2%  "small"
Threshold % Large := 0.05   // 5%  "large"

// Text label describing the quadrant (great for a legend or table)
Records vs $ Quadrant :=
SWITCH (
    TRUE(),
    ISBLANK ( [Record Delta %] ) || ISBLANK ( [Source Delta %] ), BLANK(),
    [Record Delta % Abs] >= [Threshold % Large] && [Source Delta % Abs] < [Threshold % Small], "Row spike, $ flat",
    [Record Delta % Abs] < [Threshold % Small] && [Source Delta % Abs] >= [Threshold % Large], "$ moved, rows flat",
    [Record Delta % Abs] >= [Threshold % Large] && [Source Delta % Abs] >= [Threshold % Large], "Both moved",
    "Stable"
)

// 3-state flag for easy conditional formatting via Rules in the web editor
Records vs $ Flag :=
SWITCH (
    TRUE(),
    ISBLANK ( [Record Delta %] ) || ISBLANK ( [Source Delta %] ), BLANK(),
    [Record Delta % Abs] >= [Threshold % Large] && [Source Delta % Abs] < [Threshold % Small], -1,   // row spike
    [Record Delta % Abs] < [Threshold % Small] && [Source Delta % Abs] >= [Threshold % Large],  1,   // $ moved
    0
)





// -----------------------------
// Window controls (What-If optional)
// -----------------------------
// If you don't want to create parameters yet, these constants will be used.
Anom Window Months := 12
Anom Z Threshold (Default) := 3.0
Anom Min $ (Default) := 250000

// If you DO add What-If parameters later, replace the defaults:
// Anom Z Threshold := SELECTEDVALUE(AnomZParam[Z], 3.0)
// Anom Min $       := SELECTEDVALUE(AnomMinDollar[Amount], 250000)
// Window Months    := SELECTEDVALUE(AnomWindowParam[Months], 12)

// -----------------------------
// Rolling context for the current filter grain
// (respects BANK_CODE / CONTRACT_SOURCE_SYSTEM / GL_ACCOUNT_CODE in the matrix)
// -----------------------------
Source MoM % Rolling Mean :=
VAR W  = [Anom Window Months]
VAR P  = DATESINPERIOD ( 'Date'[Date], MAX('Date'[Date]), -W, MONTH )
RETURN AVERAGEX ( P, [Source Delta %] )

Source MoM % Rolling StDev :=
VAR W  = [Anom Window Months]
VAR P  = DATESINPERIOD ( 'Date'[Date], MAX('Date'[Date]), -W, MONTH )
RETURN STDEVX.P ( P, [Source Delta %] )

// Z-score of current MoM % vs rolling history
Source MoM % Z :=
VAR mu = [Source MoM % Rolling Mean]
VAR sd = [Source MoM % Rolling StDev]
VAR x  = [Source Delta %]
RETURN IF ( sd = 0 || ISBLANK(sd) || ISBLANK(x), BLANK(), ( x - mu ) / sd )

// Absolute versions for web CF and thresholding
Source MoM % Abs := IF( ISBLANK([Source Delta %]), BLANK(), ABS([Source Delta %]) )
Source MoM % Z Abs := IF( ISBLANK([Source MoM % Z]), BLANK(), ABS([Source MoM % Z]) )

// Thresholds (swap to param measures later if you add them)
Anom Z Threshold := [Anom Z Threshold (Default)]
Anom Min $       := [Anom Min $ (Default)]

// Primary anomaly flag: requires high Z AND meaningful $ impact
Source Anomaly Flag :=
VAR hitZ  = [Source MoM % Z Abs] >= [Anom Z Threshold]
VAR hit$  = ABS ( [Source Delta $] ) >= [Anom Min $]
RETURN 
SWITCH ( TRUE(),
    ISBLANK([Source MoM % Z Abs]) || ISBLANK([Source Delta $]), BLANK(),
    hitZ && hit$, 1,
    0
)

// Severity bucket (nice for legend or conditional formatting)
Source Anomaly Severity :=
VAR z = [Source MoM % Z Abs]
VAR d = ABS([Source Delta $])
RETURN
SWITCH ( TRUE(),
    ISBLANK(z) || ISBLANK(d), BLANK(),
    z >= [Anom Z Threshold] + 1 && d >= [Anom Min $] * 2, "High",
    z >= [Anom Z Threshold]     && d >= [Anom Min $],     "Medium",
    "None"
)

// Convenience counts / KPIs
Anomaly Count :=
CALCULATE ( COUNTROWS ( VALUES ( FactMonthly[GL_ACCOUNT_CODE] ) ), [Source Anomaly Flag] = 1 )

Anomaly Total $ Impact :=
CALCULATE ( SUMX ( VALUES(FactMonthly[GL_ACCOUNT_CODE]), ABS([Source Delta $]) ), [Source Anomaly Flag] = 1 )

// Web-safe color for highlighting (field value or rules)
Source Anomaly Color :=
SWITCH ( [Source Anomaly Severity],
    "High",   "#8B0000",   // dark red
    "Medium", "#C5221F",   // red
    "#FFFFFF"              // white
)