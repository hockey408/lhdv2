R2 (12M, Trend by RC & Model – Aligned) :=
VAR rc  = SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])
VAR mdl = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])  -- leave blank if you don't filter by model
VAR me  = MAX('RC_Code_Model_Base'[month_end])             -- month on the X-axis
VAR st  = EDATE(me, -11)

/* Build y/yhat pairs over the same 12M window and (optionally) same model */
VAR pairs =
    ADDCOLUMNS(
        SUMMARIZE(
            FILTER(
                ALL('RC_Code_Model_Base'),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= me
                && ( ISBLANK(mdl) || 'RC_Code_Model_Base'[Best_Model] = mdl )
            ),
            'RC_Code_Model_Base'[month_end]
        ),
        "y",    CALCULATE( SUM('RC_Code_Model_Base'[bal_num]) ),
        "yhat", CALCULATE( SUM('RC_Code_Model_Base'[Forecast_Selected]) )
    )
VAR t     = FILTER(pairs, NOT ISBLANK([y]) && NOT ISBLANK([yhat]))
VAR n     = COUNTROWS(t)
VAR ybar  = AVERAGEX(t, [y])
VAR sse   = SUMX(t, VAR e = [y] - [yhat] RETURN e * e)
VAR sst   = SUMX(t, VAR d = [y] - ybar   RETURN d * d)
VAR r2raw = IF(n >= 2 && sst > 0, 1 - DIVIDE(sse, sst))
RETURN IF( ISBLANK(r2raw), BLANK(), MAX(0, MIN(1, r2raw)) )


R2 (12M, Latest by RC & Model – Aligned) :=
VAR rc  = SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])
VAR mdl = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
VAR lm  = CALCULATE( MAX('RC_Code_Model_Base'[month_end]), ALL('RC_Code_Model_Base') )
VAR st  = EDATE(lm, -11)

VAR pairs =
    ADDCOLUMNS(
        SUMMARIZE(
            FILTER(
                ALL('RC_Code_Model_Base'),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= lm
                && ( ISBLANK(mdl) || 'RC_Code_Model_Base'[Best_Model] = mdl )
            ),
            'RC_Code_Model_Base'[month_end]
        ),
        "y",    CALCULATE( SUM('RC_Code_Model_Base'[bal_num]) ),
        "yhat", CALCULATE( SUM('RC_Code_Model_Base'[Forecast_Selected]) )
    )
VAR t     = FILTER(pairs, NOT ISBLANK([y]) && NOT ISBLANK([yhat]))
VAR n     = COUNTROWS(t)
VAR ybar  = AVERAGEX(t, [y])
VAR sse   = SUMX(t, VAR e = [y] - [yhat] RETURN e * e)
VAR sst   = SUMX(t, VAR d = [y] - ybar   RETURN d * d)
VAR r2raw = IF(n >= 2 && sst > 0, 1 - DIVIDE(sse, sst))
RETURN IF( ISBLANK(r2raw), BLANK(), MAX(0, MIN(1, r2raw)) )



Avg R2 by Model (12M, Latest) :=
VAR lm =
    CALCULATE( MAX('RC_Code_Model_Base'[month_end]), ALL('RC_Code_Model_Base') )
VAR perRC =
    ADDCOLUMNS(
        VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
        "R2RC", [R2 (12M, Latest by RC & Model – Aligned)],
        "ActLM", CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
                            'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM", CALCULATE( MAX('RC_Code_Model_Base'[Is_Internal_RC]),
                              'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil =
    FILTER(perRC,
        [IsIntLM] = 0 &&
        ABS([ActLM]) >= [Exposure Floor Amount] &&
        NOT ISBLANK([R2RC])
    )
RETURN COALESCE( AVERAGEX(fil, [R2RC]), BLANK() )




R2_By_Model = 
VAR SS_Total =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Actual] ) ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLEXCEPT ( RC_Code_Model_Base, RC_Code_Model_Base[RC_Code], RC_Code_Model_Base[BEST_MODEL] ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [FORECAST_SELECTED] ) ),
        POWER ( [Actual] - [FORECAST_SELECTED], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )



R2 (12M, Trend by RC) :=
VAR rc  = SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])
VAR me  = MAX('RC_Code_Model_Base'[month_end])         -- month on the axis
VAR st  = EDATE(me, -11)

/* optional monitorable checks at the end month */
VAR actME =
    CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
               'RC_Code_Model_Base'[month_end] = me )
VAR isIntME =
    CALCULATE( MAX('RC_Code_Model_Base'[Is_Internal_RC]),
               'RC_Code_Model_Base'[month_end] = me )

/* build y/yhat pairs for this RC over [st..me] */
VAR pairs =
    ADDCOLUMNS(
        SUMMARIZE(
            FILTER(
                ALL('RC_Code_Model_Base'),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= me
            ),
            'RC_Code_Model_Base'[month_end]
        ),
        "y",    CALCULATE(SUM('RC_Code_Model_Base'[bal_num])),
        "yhat", CALCULATE(SUM('RC_Code_Model_Base'[Forecast_Selected]))
    )
VAR t     = FILTER(pairs, NOT ISBLANK([y]) && NOT ISBLANK([yhat]))
VAR n     = COUNTROWS(t)
VAR ybar  = AVERAGEX(t, [y])
VAR sse   = SUMX(t, VAR e = [y] - [yhat] RETURN e*e)
VAR sst   = SUMX(t, VAR d = [y] - ybar   RETURN d*d)
VAR r2raw = IF(n >= 2 && sst > 0, 1 - DIVIDE(sse, sst))

/* apply optional monitorable rules; then clamp to [0,1] */
RETURN
IF(
    /* comment out this IF if you don't want the monitorable gate */
    isIntME = 1 || ABS(actME) < [Exposure Floor Amount],
    BLANK(),
    IF( ISBLANK(r2raw), BLANK(), MAX(0, MIN(1, r2raw)) )
)



R2 (Rolling 12M, Latest) :=
VAR rc  = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lm  = CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR st  = EDATE ( lm, -11 )
/* Build month pairs for this RC: y (Actual) & yhat (Forecast) */
VAR pairs =
    ADDCOLUMNS (
        SUMMARIZE (
            FILTER (
                ALL ( 'RC_Code_Model_Base' ),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                    && 'RC_Code_Model_Base'[month_end] >= st
                    && 'RC_Code_Model_Base'[month_end] <= lm
            ),
            'RC_Code_Model_Base'[month_end]
        ),
        "y",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
        "yhat", CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
    )
/* Keep only months where both y and yhat exist */
VAR t     = FILTER ( pairs, NOT ISBLANK ( [y] ) && NOT ISBLANK ( [yhat] ) )
VAR n     = COUNTROWS ( t )
VAR ybar  = AVERAGEX ( t, [y] )
VAR sse   = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
VAR sst   = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
VAR r2raw = IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ), BLANK () )
RETURN
/* Clamp to [0,1] for reporting */
IF ( ISBLANK ( r2raw ), BLANK (), MAX ( 0, MIN ( 1, r2raw ) ) )


Avg R2 (Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
/* Evaluate each RC at latest month; keep monitorable ones only */
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",     [R2 (Rolling 12M, Latest)],
        "ActLM",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                                'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM",  CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                                'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil =
    FILTER ( perRC,
        [IsIntLM] = 0
        && ABS ( [ActLM] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN
COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



R2 (Rolling 12M, Trend) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )       -- current axis month
VAR st = EDATE ( me, -11 )
/* Build per-RC 12M R² ending at [me] */
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActME",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "IsIntME", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "R2RC",
            VAR pairs =
                ADDCOLUMNS (
                    SUMMARIZE (
                        FILTER (
                            ALL ( 'RC_Code_Model_Base' ),
                            'RC_Code_Model_Base'[RC_DESCRIPTION]
                                = EARLIER ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
                            && 'RC_Code_Model_Base'[month_end] >= st
                            && 'RC_Code_Model_Base'[month_end] <= me
                        ),
                        'RC_Code_Model_Base'[month_end]
                    ),
                    "y",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
                    "yhat", CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
                )
            VAR t     = FILTER ( pairs, NOT ISBLANK ( [y] ) && NOT ISBLANK ( [yhat] ) )
            VAR n     = COUNTROWS ( t )
            VAR ybar  = AVERAGEX ( t, [y] )
            VAR sse   = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
            VAR sst   = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
            VAR r2raw = IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ) )
            RETURN IF ( ISBLANK ( r2raw ), BLANK (), MAX ( 0, MIN ( 1, r2raw ) ) )
    )
VAR fil =
    FILTER ( perRC,
        [IsIntME] = 0
        && ABS ( [ActME] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



R2 (Rolling 12M, Latest) :=
VAR rc  = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lm  = CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR st  = EDATE ( lm, -11 )
VAR t =
    SUMMARIZE (
        FILTER (
            ALL ( 'RC_Code_Model_Base' ),
            'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= lm
        ),
        'RC_Code_Model_Base'[month_end],
        "y",     CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
        "yhat",  CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
    )
VAR n   = COUNTROWS ( t )
VAR ybar= AVERAGEX ( t, [y] )
VAR sse = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
VAR sst = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ), BLANK () )


Avg R2 (Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",     [R2 (Rolling 12M, Latest)],
        "ActLM",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                                'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM",  CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                                'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil =
    FILTER ( t,
        [IsIntLM] = 0
        && ABS ( [ActLM] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



R2 (Rolling 12M, Trend) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )       -- current point on axis
VAR st = EDATE ( me, -11 )
-- Build per-RC 12M R2 ending at [me]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActME",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "IsIntME", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "R2RC",
            VAR series =
                SUMMARIZE (
                    FILTER (
                        ALL ( 'RC_Code_Model_Base' ),
                        'RC_Code_Model_Base'[RC_DESCRIPTION] = EARLIER ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
                          && 'RC_Code_Model_Base'[month_end] >= st
                          && 'RC_Code_Model_Base'[month_end] <= me
                    ),
                    'RC_Code_Model_Base'[month_end],
                    "y",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
                    "yhat", CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
                )
            VAR n    = COUNTROWS ( series )
            VAR ybar = AVERAGEX ( series, [y] )
            VAR sse  = SUMX ( series, VAR e = [y] - [yhat] RETURN e * e )
            VAR sst  = SUMX ( series, VAR d = [y] - ybar  RETURN d * d )
            RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ) )
    )
VAR fil =
    FILTER ( perRC,
        [IsIntME] = 0
        && ABS ( [ActME] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



Avg R2 (Exposure-Weighted, Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",    [R2 (Rolling 12M, Latest)],
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil = FILTER ( t, [IsIntLM] = 0 && ABS ( [ActLM] ) >= [Exposure Floor Amount] && NOT ISBLANK ( [R2RC] ) )
VAR num = SUMX ( fil, [R2RC] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den, BLANK () )






R2 (Rolling 12M, Latest) :=
VAR rc  = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lm  = CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR st  = EDATE ( lm, -11 )
VAR t =
    SUMMARIZE (
        FILTER (
            ALL ( 'RC_Code_Model_Base' ),
            'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= lm
        ),
        'RC_Code_Model_Base'[month_end],
        "y",     CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
        "yhat",  CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
    )
VAR n   = COUNTROWS ( t )
VAR ybar= AVERAGEX ( t, [y] )
VAR sse = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
VAR sst = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ), BLANK () )






R2 (Rolling 12M, Latest) :=
VAR rc  = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lm  = CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR st  = EDATE ( lm, -11 )
VAR t =
    SUMMARIZE (
        FILTER (
            ALL ( 'RC_Code_Model_Base' ),
            'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= lm
        ),
        'RC_Code_Model_Base'[month_end],
        "y",     CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
        "yhat",  CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
    )
VAR n   = COUNTROWS ( t )
VAR ybar= AVERAGEX ( t, [y] )
VAR sse = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
VAR sst = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ), BLANK () )


Avg R2 (Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",     [R2 (Rolling 12M, Latest)],
        "ActLM",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                                'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM",  CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                                'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil =
    FILTER ( t,
        [IsIntLM] = 0
        && ABS ( [ActLM] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



R2 (Rolling 12M, Trend) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )       -- current point on axis
VAR st = EDATE ( me, -11 )
-- Build per-RC 12M R2 ending at [me]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActME",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "IsIntME", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "R2RC",
            VAR series =
                SUMMARIZE (
                    FILTER (
                        ALL ( 'RC_Code_Model_Base' ),
                        'RC_Code_Model_Base'[RC_DESCRIPTION] = EARLIER ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
                          && 'RC_Code_Model_Base'[month_end] >= st
                          && 'RC_Code_Model_Base'[month_end] <= me
                    ),
                    'RC_Code_Model_Base'[month_end],
                    "y",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
                    "yhat", CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
                )
            VAR n    = COUNTROWS ( series )
            VAR ybar = AVERAGEX ( series, [y] )
            VAR sse  = SUMX ( series, VAR e = [y] - [yhat] RETURN e * e )
            VAR sst  = SUMX ( series, VAR d = [y] - ybar  RETURN d * d )
            RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ) )
    )
VAR fil =
    FILTER ( perRC,
        [IsIntME] = 0
        && ABS ( [ActME] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



Avg R2 (Exposure-Weighted, Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",    [R2 (Rolling 12M, Latest)],
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil = FILTER ( t, [IsIntLM] = 0 && ABS ( [ActLM] ) >= [Exposure Floor Amount] && NOT ISBLANK ( [R2RC] ) )
VAR num = SUMX ( fil, [R2RC] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den, BLANK () )






R2 (Rolling 12M, Latest) :=
VAR rc  = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lm  = CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR st  = EDATE ( lm, -11 )
VAR t =
    SUMMARIZE (
        FILTER (
            ALL ( 'RC_Code_Model_Base' ),
            'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
                && 'RC_Code_Model_Base'[month_end] >= st
                && 'RC_Code_Model_Base'[month_end] <= lm
        ),
        'RC_Code_Model_Base'[month_end],
        "y",     CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
        "yhat",  CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
    )
VAR n   = COUNTROWS ( t )
VAR ybar= AVERAGEX ( t, [y] )
VAR sse = SUMX ( t, VAR e = [y] - [yhat] RETURN e * e )
VAR sst = SUMX ( t, VAR d = [y] - ybar  RETURN d * d )
RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ), BLANK () )


Avg R2 (Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",     [R2 (Rolling 12M, Latest)],
        "ActLM",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                                'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM",  CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                                'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil =
    FILTER ( t,
        [IsIntLM] = 0
        && ABS ( [ActLM] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



R2 (Rolling 12M, Trend) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )       -- current point on axis
VAR st = EDATE ( me, -11 )
-- Build per-RC 12M R2 ending at [me]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActME",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "IsIntME", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = me ),
        "R2RC",
            VAR series =
                SUMMARIZE (
                    FILTER (
                        ALL ( 'RC_Code_Model_Base' ),
                        'RC_Code_Model_Base'[RC_DESCRIPTION] = EARLIER ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
                          && 'RC_Code_Model_Base'[month_end] >= st
                          && 'RC_Code_Model_Base'[month_end] <= me
                    ),
                    'RC_Code_Model_Base'[month_end],
                    "y",    CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ) ),
                    "yhat", CALCULATE ( SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ) )
                )
            VAR n    = COUNTROWS ( series )
            VAR ybar = AVERAGEX ( series, [y] )
            VAR sse  = SUMX ( series, VAR e = [y] - [yhat] RETURN e * e )
            VAR sst  = SUMX ( series, VAR d = [y] - ybar  RETURN d * d )
            RETURN IF ( n >= 2 && sst > 0, 1 - DIVIDE ( sse, sst ) )
    )
VAR fil =
    FILTER ( perRC,
        [IsIntME] = 0
        && ABS ( [ActME] ) >= [Exposure Floor Amount]
        && NOT ISBLANK ( [R2RC] )
    )
RETURN COALESCE ( AVERAGEX ( fil, [R2RC] ), BLANK () )



Avg R2 (Exposure-Weighted, Latest) :=
VAR lm =
    CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2RC",    [R2 (Rolling 12M, Latest)],
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               'RC_Code_Model_Base'[month_end] = lm ),
        "IsIntLM", CALCULATE ( MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
                               'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil = FILTER ( t, [IsIntLM] = 0 && ABS ( [ActLM] ) >= [Exposure Floor Amount] && NOT ISBLANK ( [R2RC] ) )
VAR num = SUMX ( fil, [R2RC] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den, BLANK () )





-- Uses only columns; applies your monitorable logic inline
Severity (Weighted, At Month) :=
VAR sev  = AVERAGE( 'RC_Code_Model_Base'[Severity_0_100] )
VAR act  = SUM( 'RC_Code_Model_Base'[bal_num] )
VAR isInternal =
    MAX( 'RC_Code_Model_Base'[Is_Internal_RC] )   -- 0/1 calculated column
VAR passesFloor = IF( ABS(act) >= [Exposure Floor Amount], TRUE(), FALSE() )
VAR w =
    IF( ABS(act) <= 1,
        0.10,
        MIN( 1, MAX( 0.10, LOG10( ABS(act) ) / 6 ) )
    )
RETURN
IF( isInternal = 0 && passesFloor && NOT ISBLANK(sev), sev * w )

Severity % Change (MoM) :=
VAR currMonth =
    MAX( 'RC_Code_Model_Base'[month_end] )
VAR currSev :=
    CALCULATE(
        [Severity (Weighted, At Month)],
        'RC_Code_Model_Base'[month_end] = currMonth
    )
VAR prevMonth :=
    CALCULATE(
        MAX( 'RC_Code_Model_Base'[month_end] ),
        FILTER(
            ALL( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[month_end] < currMonth
        )
    )
VAR prevSev :=
    CALCULATE(
        [Severity (Weighted, At Month)],
        TREATAS( { prevMonth }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN
DIVIDE( currSev - prevSev, prevSev, 0 )







Severity % Change (MoM) :=
VAR currMonth =
    MAX ( 'RC_Code_Model_Base'[month_end] )
VAR prevMonth =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[month_end] ),
        FILTER (
            ALL ( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[month_end] < currMonth
        )
    )
VAR currSev =
    CALCULATE (
        [Severity (Weighted, Latest)],
        'RC_Code_Model_Base'[month_end] = currMonth
    )
VAR prevSev =
    CALCULATE (
        [Severity (Weighted, Latest)],
        'RC_Code_Model_Base'[month_end] = prevMonth
    )
RETURN
DIVIDE ( currSev - prevSev, prevSev, 0 )


Severity % Change (3M Rolling) :=
VAR currMonth = MAX ( 'RC_Code_Model_Base'[month_end] )
VAR prev3Month =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[month_end] ),
        FILTER (
            ALL ( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[month_end] < EDATE ( currMonth, -3 )
        )
    )
VAR currSev =
    CALCULATE ( [Severity (Weighted, Latest)], 'RC_Code_Model_Base'[month_end] = currMonth )
VAR prevSev =
    CALCULATE ( [Severity (Weighted, Latest)], 'RC_Code_Model_Base'[month_end] = prev3Month )
RETURN DIVIDE ( currSev - prevSev, prevSev, 0 )





CASE WHEN ps.max_abs_resid > 0 AND LN(1.0 + ps.max_abs_resid) > 0
     THEN LN(1.0 + x.AbsResid) / LN(1.0 + ps.max_abs_resid)
     ELSE 0 END
CASE WHEN ps.max_mom_abs > 0 AND LN(1.0 + ps.max_mom_abs) > 0
     THEN LN(1.0 + x.MoM_Abs)  / LN(1.0 + ps.max_mom_abs)
     ELSE 0 END




CASE
  WHEN (s.Actual < 0 OR s.prev_bal < 0
        OR (s.prev_bal IS NOT NULL AND s.prev_bal <> 0 AND (s.Actual * s.prev_bal) < 0))
  THEN 'Offsets / negative balance'




WITH
/* ==================== 0) Base ==================== */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* ==================== 1) Index & metadata ==================== */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2)/3)::INT AS qnum
  FROM idx i
),

/* ==================== 2) Windows ==================== */
last12 AS (SELECT * FROM idx_tm WHERE t >= tmax - 11),
last36 AS (SELECT * FROM idx_tm WHERE t >= tmax - 35),

/* ==================== 3) Regression params ==================== */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* ==================== 4) Regression fits ==================== */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36)
            - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* ==================== 5) Moving averages (single pass) ==================== */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.*
  FROM ma_all m
  JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.*
  FROM ma_all m
  JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* ==================== 6) Window metrics & best model ==================== */
mean12 AS (SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE),
mean36 AS (SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12      USING (RC_CODE)
    LEFT JOIN sst36 s36      USING (RC_CODE)
    LEFT JOIN agg_reg12 ar12 USING (RC_CODE)
    LEFT JOIN agg_reg36 ar36 USING (RC_CODE)
    LEFT JOIN agg_ma6_12 am6 USING (RC_CODE)
    LEFT JOIN agg_ma12_36 am12 USING (RC_CODE)
),

best_model AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN COALESCE(m.rmse_reg12, 9e99) <= LEAST(COALESCE(m.rmse_reg36, 9e99), COALESCE(m.rmse_ma6, 9e99), COALESCE(m.rmse_ma12, 9e99)) THEN 'REG12'
      WHEN COALESCE(m.rmse_reg36, 9e99) <= LEAST(COALESCE(m.rmse_ma6, 9e99), COALESCE(m.rmse_ma12, 9e99)) THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6,  9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model
  FROM metrics m
),

/* ==================== 7) Spike-aware seasonality ==================== */
mom_base AS (
  SELECT
    t.*,
    (t.bal_num - COALESCE(t.prev_bal,0))::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL OR ABS(t.prev_bal) < 1.0 THEN (t.bal_num - COALESCE(t.prev_bal,0))
      ELSE (t.bal_num - COALESCE(t.prev_bal,0)) / t.prev_bal
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT RC_CODE, AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.*,
    CASE
      WHEN ABS(b.mom_pct) >= 0.40 OR (ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs) THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT RC_CODE, qnum,
         AVG(CASE WHEN is_spike = 0 THEN bal_num END)::FLOAT8 AS avg_q_nospike,
         COUNT(*) AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT RC_CODE,
         AVG(CASE WHEN is_spike = 0 THEN bal_num END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE, q.qnum,
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE q.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q q
  LEFT JOIN seasonal_all a USING (RC_CODE)
),
seasonal_final AS (
  SELECT
    RC_CODE, qnum,
    LEAST(1.15, GREATEST(0.85, lift_raw))::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(n_q,0)/8.0)::FLOAT8       AS hist_weight
  FROM seasonal_lifts
),
seasonal_ready AS (
  SELECT
    f.RC_CODE, f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0))::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* ==================== 8) Forecasts (with seasonal adj) ==================== */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36', fc_reg36 FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6',   fc_ma6   FROM ma6_last12  WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12',  fc_ma12  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),
fits_seasonal AS (
  SELECT
    u.*,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s USING (RC_CODE, qnum)
),

/* ==================== 9) Residuals & Z ==================== */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t USING (RC_CODE, month_end)
),
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,
    ABS(x.bal_num - COALESCE(x.prev_bal,0))::FLOAT8 AS mom_abs,
    CASE
      WHEN ABS(COALESCE(x.prev_bal,0)) < 1.0 THEN ABS(x.bal_num - COALESCE(x.prev_bal,0))
      ELSE ABS(x.bal_num - COALESCE(x.prev_bal,0)) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(ABS(x.bal_num - COALESCE(x.prev_bal,0))) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(ABS(x.bal_num - COALESCE(x.prev_bal,0))) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs
  FROM union_with_prev x
),
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs
  FROM union_enriched e
),

/* ==================== 10) Portfolio scales & best model rows ==================== */
port_scales AS (
  SELECT
    MAX(abs_resid) AS max_abs_resid,
    MAX(mom_abs)   AS max_mom_abs
  FROM union_with_z
),
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    z.resid              AS Resid,
    z.abs_resid          AS AbsResid,
    z.mom_abs            AS MoM_Abs,
    z.mom_pct_abs        AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos
  FROM union_with_z z
  JOIN best_model bm USING (RC_CODE)
  WHERE z.model = bm.Best_Model
),

/* ==================== 11) Peer z, persistence & recency ==================== */
peer_month AS (
  SELECT
    f.month_end,
    AVG(f.MoM_Abs)::FLOAT8         AS peer_mom_mean,
    STDDEV_SAMP(f.MoM_Abs)::FLOAT8 AS peer_mom_sd,
    MAX(f.Actual)::FLOAT8          AS max_actual_month
  FROM final f
  GROUP BY f.month_end
),
peer_join AS (
  SELECT
    f.*,
    p.peer_mom_mean,
    p.peer_mom_sd,
    p.max_actual_month,
    CASE
      WHEN p.peer_mom_sd IS NULL OR p.peer_mom_sd = 0 THEN 0
      ELSE (f.MoM_Abs - p.peer_mom_mean) / p.peer_mom_sd
    END::FLOAT8 AS Z_Peer
  FROM final f
  LEFT JOIN peer_month p USING (month_end)
),
persist AS (
  SELECT
    j.*,
    SUM(CASE WHEN (ABS(j.Z_Resid) >= 2.5 OR ABS(j.Z_Peer) >= 2.0) THEN 1 ELSE 0 END)
      OVER (PARTITION BY j.RC_CODE ORDER BY j.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS flagged_3m_count,
    LEAST(
      1.0,
      SUM(CASE WHEN (ABS(j.Z_Resid) >= 2.5 OR ABS(j.Z_Peer) >= 2.0) THEN 1 ELSE 0 END)
        OVER (PARTITION BY j.RC_CODE ORDER BY j.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) / 3.0
    )::FLOAT8 AS persistence_score
  FROM peer_join j
),
latest_month AS ( SELECT MAX(month_end) AS max_me FROM final ),
persist_with_recency AS (
  SELECT
    p.*,
    CASE WHEN p.month_end = lm.max_me THEN 1 ELSE 0 END AS is_latest
  FROM persist p
  CROSS JOIN latest_month lm
),

/* ==================== 12) Severity v4 (bandless) ==================== */
severity_v4 AS (
  SELECT
    x.*,

    /* Log-scaled dollar magnitudes (stable normalization) */
    CASE
      WHEN ps.max_abs_resid IS NULL OR ps.max_abs_resid <= 0 THEN 0
      ELSE LN(1.0 + x.AbsResid) / LN(1.0 + ps.max_abs_resid)
    END::FLOAT8 AS AbsResid_LogScaled,

    CASE
      WHEN ps.max_mom_abs IS NULL OR ps.max_mom_abs <= 0 THEN 0
      ELSE LN(1.0 + x.MoM_Abs) / LN(1.0 + ps.max_mom_abs)
    END::FLOAT8 AS MoM_Abs_LogScaled,

    /* Exposure scale within month */
    CASE
      WHEN x.max_actual_month IS NULL OR x.max_actual_month = 0 THEN 0
      ELSE x.Actual / x.max_actual_month
    END::FLOAT8 AS Exposure_Scale,

    /* Composite raw severity (weights sum to 1.0) */
    (
      0.50 * ABS(x.Z_Resid)
    + 0.25 * ABS(COALESCE(x.Z_Peer,0))
    + 0.08 * CASE WHEN ps.max_abs_resid > 0 THEN LN(1.0 + x.AbsResid) / LN(1.0 + ps.max_abs_resid) ELSE 0 END
    + 0.05 * CASE WHEN ps.max_mom_abs  > 0 THEN LN(1.0 + x.MoM_Abs)  / LN(1.0 + ps.max_mom_abs)  ELSE 0 END
    + 0.05 * COALESCE(x.Exposure_Scale,0)
    + 0.05 * COALESCE(x.persistence_score,0)
    + 0.02 * x.is_latest
    )::FLOAT8 AS Severity_Raw_v4

  FROM persist_with_recency x
  CROSS JOIN port_scales ps
),

/* ==================== 13) Explainability labels ==================== */
explain AS (
  SELECT
    s.*,

    /* contribution components (mirrors weights above) */
    (0.50 * ABS(s.Z_Resid))                              AS contrib_resid,
    (0.25 * ABS(COALESCE(s.Z_Peer,0)))                   AS contrib_peer,
    (0.08 * s.AbsResid_LogScaled
    + 0.05 * s.MoM_Abs_LogScaled
    + 0.05 * COALESCE(s.Exposure_Scale,0))               AS contrib_dollar,
    (0.05 * COALESCE(s.persistence_score,0))             AS contrib_persist,
    (0.02 * s.is_latest)                                 AS contrib_recency,

    /* direction of surprise */
    CASE WHEN s.Resid > 0 THEN 'Upward surprise'
         WHEN s.Resid < 0 THEN 'Downward surprise'
         ELSE 'On forecast'
    END AS Direction,

    /* structural indicators */
    CASE WHEN (s.prev_bal IS NULL OR s.prev_bal = 0) AND s.Actual > 0 THEN 1 ELSE 0 END AS new_to_active,
    CASE WHEN s.prev_bal > 0 AND s.Actual = 0 THEN 1 ELSE 0 END AS active_to_zero,
    CASE WHEN s.prev_bal IS NOT NULL AND s.prev_bal <> 0 AND (s.Actual * s.prev_bal) < 0 THEN 1 ELSE 0 END AS sign_flip,
    CASE WHEN s.MoM_Pct_Abs >= 1.0 THEN 1 ELSE 0 END AS extreme_pct,
    CASE WHEN s.Actual < 0 OR (s.prev_bal < 0) THEN 1 ELSE 0 END AS negative_balance_flag,

    /* top driver label */
    CASE
      WHEN (0.50*ABS(s.Z_Resid)) >= GREATEST(
             (0.25*ABS(COALESCE(s.Z_Peer,0))),
             (0.08*s.AbsResid_LogScaled + 0.05*s.MoM_Abs_LogScaled + 0.05*COALESCE(s.Exposure_Scale,0)),
             (0.05*COALESCE(s.persistence_score,0)),
             (0.02*s.is_latest)
           ) THEN 'Model miss (Z_Resid)'
      WHEN (0.25*ABS(COALESCE(s.Z_Peer,0))) >= GREATEST(
             (0.08*s.AbsResid_LogScaled + 0.05*s.MoM_Abs_LogScaled + 0.05*COALESCE(s.Exposure_Scale,0)),
             (0.05*COALESCE(s.persistence_score,0)),
             (0.02*s.is_latest)
           ) THEN 'Peer shift (Z_Peer)'
      WHEN (0.08*s.AbsResid_LogScaled + 0.05*s.MoM_Abs_LogScaled + 0.05*COALESCE(s.Exposure_Scale,0)) >= GREATEST(
             (0.05*COALESCE(s.persistence_score,0)),
             (0.02*s.is_latest)
           ) THEN 'Large $ / Exposure'
      WHEN (0.05*COALESCE(s.persistence_score,0)) >= (0.02*s.is_latest)
           THEN 'Persistent (≥2 of last 3)'
      ELSE 'Recency (latest month)'
    END AS Top_Driver,

    /* cause / indicator tag (human-friendly) */
    CASE
      WHEN (s.Actual < 0 OR s.prev_bal < 0 OR s.sign_flip = 1) THEN 'Offsets / negative balance'
      WHEN s.extreme_pct = 1 THEN 'Reclassification candidate (≥100% MoM)'
      WHEN (s.prev_bal IS NULL OR s.prev_bal = 0) AND s.Actual > 0 THEN 'New activity'
      WHEN s.prev_bal > 0 AND s.Actual = 0 THEN 'Run-off / closure'
      WHEN ABS(COALESCE(s.Z_Peer,0)) >= 2.0 AND ABS(s.Z_Resid) < 1.5 THEN 'Portfolio-wide (peer) shift'
      WHEN ABS(s.Z_Resid) >= 2.5 AND ABS(COALESCE(s.Z_Peer,0)) < 1.5 THEN 'Idiosyncratic model miss'
      WHEN s.persistence_score >= 0.67 THEN 'Persistent anomaly'
      WHEN (s.AbsResid_LogScaled >= 0.7 OR s.Exposure_Scale >= 0.8) THEN 'Large $ impact'
      ELSE 'Mixed / moderate signals'
    END AS Cause_Primary

  FROM severity_v4 s
)

/* ==================== Final SELECT ==================== */
SELECT
  e.RC_CODE,
  e.RC_DESCRIPTION,
  e.month_end,
  e.Best_Model,
  e.prev_bal,
  e.Forecast_Selected,
  e.Actual,
  e.Resid,
  e.AbsResid,
  e.MoM_Abs,
  e.MoM_Pct_Abs,
  e.Z_Resid,
  e.Z_Peer,
  e.flagged_3m_count,
  e.persistence_score,
  e.is_latest,

  /* explainability */
  e.Direction,
  e.Top_Driver,
  e.Cause_Primary,
  e.new_to_active,
  e.active_to_zero,
  e.sign_flip,
  e.extreme_pct,
  e.negative_balance_flag,

  /* normalized $ & exposure */
  e.AbsResid_LogScaled,
  e.MoM_Abs_LogScaled,
  e.Exposure_Scale,

  /* (optional) legacy v1 severity to compare */
  ( 0.25 * ( e.AbsResid / NULLIF(ps.max_abs_resid,0) )
  + 0.65 * ABS(e.Z_Resid)
  + 0.07 * ABS(e.Z_MoM_Abs)
  + 0.03 * ( e.MoM_Abs / NULLIF(ps.max_mom_abs,0) )
  )::FLOAT8 AS Severity_Raw_v1,

  /* recommended v4 */
  e.Severity_Raw_v4,
  ROUND( 100.0 * (1.0 - EXP(- e.Severity_Raw_v4)), 0 )::INTEGER AS Severity_0_100_v4

FROM explain e
CROSS JOIN port_scales ps
ORDER BY e.RC_CODE, e.month_end;






WITH
cfg AS (
  SELECT
    25000000::FLOAT8 AS per_kde_min_exposure,   -- Show KDEs ≥ $25MM
    100000::FLOAT8   AS per_account_min_ssb     -- Ignore tiny accounts (<$100k)
),

-- Target month: latest month end
target AS (
  SELECT MAX(END_OF_MONTH_DATE) AS eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),

-- Current month accounts with positive SSB
measures AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, target tg
  WHERE t.END_OF_MONTH_DATE = tg.eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Bring rows for current month (filter small accounts early)
base AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY            = t.ACCOUNT_KEY
  JOIN target tg ON tg.eom = t.END_OF_MONTH_DATE
  JOIN cfg ON 1=1
  WHERE t.SOURCE_SYSTEM_BALANCE >= cfg.per_account_min_ssb
),

-- Map accounts to previous month for comparison
prev_map AS (
  SELECT
    b.CONTRACT_SOURCE_SYSTEM,
    b.ACCOUNT_KEY,
    b.END_OF_MONTH_DATE,
    LAG(b.END_OF_MONTH_DATE) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM, b.ACCOUNT_KEY
      ORDER BY b.END_OF_MONTH_DATE
    ) AS prev_eom
  FROM (
    SELECT DISTINCT CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY, END_OF_MONTH_DATE
    FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
  ) b
),

-- Previous month rows
base_prev AS (
  SELECT p.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME p
  JOIN prev_map mp
    ON mp.prev_eom IS NOT NULL
   AND mp.prev_eom = p.END_OF_MONTH_DATE
   AND mp.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND mp.ACCOUNT_KEY = p.ACCOUNT_KEY
  JOIN target tg ON 1=1
  WHERE mp.END_OF_MONTH_DATE = tg.eom
),

/* ===== CHANGE EVENTS ===== */
kde_changes AS (
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE,
         ''::VARCHAR(1) AS KDE,
         0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE ~8–12 UNION ALL SELECT lines from generator here,
         comparing base (alias b) vs base_prev (alias p) >>> */
),

-- Aggregate to KDE totals
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
)

SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  exposure_dollars
FROM kde_monthly
JOIN cfg ON 1=1
WHERE exposure_dollars >= cfg.per_kde_min_exposure
ORDER BY exposure_dollars DESC, KDE
LIMIT 50;





WITH cols AS (
  SELECT
    c.column_name,
    ROW_NUMBER() OVER (ORDER BY UPPER(c.column_name)) AS rn
  FROM INFORMATION_SCHEMA.COLUMNS c
  /* Anchor so NPS doesn't treat this as a system-only window query */
  CROSS JOIN (SELECT 1 FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME LIMIT 1) a
  WHERE UPPER(c.table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    -- (Optional) tighten schema if needed:
    -- AND UPPER(c.table_schema) = 'CIDPR'
    -- Exclude key/utility columns used elsewhere
    AND UPPER(c.column_name) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- Exclude common audit/noise fields (edit as needed)
    AND UPPER(c.column_name) NOT LIKE '%_TS'
    AND UPPER(c.column_name) NOT LIKE '%_DT'
    AND UPPER(c.column_name) NOT LIKE 'CREATED_%'
    AND UPPER(c.column_name) NOT LIKE 'UPDATED_%'
    AND UPPER(c.column_name) NOT LIKE '%_USER'
    AND UPPER(c.column_name) NOT LIKE '%USER_ID%'
    AND UPPER(c.column_name) NOT LIKE '%HASH%'
    AND UPPER(c.column_name) NOT LIKE '%CHECKSUM%'
    AND UPPER(c.column_name) NOT LIKE '%BATCH%'
    AND UPPER(c.column_name) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM cols
  WHERE rn BETWEEN 1 AND 12   -- <<< adjust per run (e.g., 13-24, 25-36, …)
)
SELECT
  /* Paste these lines into the scaffold's kde_changes CTE */
  'UNION ALL SELECT b.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, b.SOURCE_SYSTEM_BALANCE AS CURR_SSB
     FROM base b
     JOIN base_prev p
       ON p.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
      AND p.ACCOUNT_KEY            = b.ACCOUNT_KEY
    WHERE TRIM(COALESCE(b."'||column_name||'"::VARCHAR(4000), ''~NULL~'')) <>
          TRIM(COALESCE(p."'||column_name||'"::VARCHAR(4000), ''~NULL~''))'
  AS sql_line
FROM batch
ORDER BY rn;





WITH
cfg AS (
  SELECT
    25000000::FLOAT8 AS per_kde_min_exposure,   -- show KDEs ≥ $25MM
    100000::FLOAT8   AS per_account_min_ssb     -- ignore tiny accounts (<$100k)
),

-- pick the month to analyze: latest month-end
target AS (
  SELECT MAX(END_OF_MONTH_DATE) AS eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),

-- positive SSB population for that month
measures AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, target tg
  WHERE t.END_OF_MONTH_DATE = tg.eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- bring rows for the target month (filter small accounts early)
base AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY            = t.ACCOUNT_KEY
  JOIN target tg ON tg.eom = t.END_OF_MONTH_DATE
  JOIN cfg ON 1=1
  WHERE t.SOURCE_SYSTEM_BALANCE >= cfg.per_account_min_ssb
),

-- map to the previous month for the same acct/system
prev_map AS (
  SELECT
    b.CONTRACT_SOURCE_SYSTEM, b.ACCOUNT_KEY, b.END_OF_MONTH_DATE,
    LAG(b.END_OF_MONTH_DATE) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM, b.ACCOUNT_KEY
      ORDER BY b.END_OF_MONTH_DATE
    ) AS prev_eom
  FROM (
    SELECT DISTINCT CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY, END_OF_MONTH_DATE
    FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
  ) b
),

-- previous-month rows (only those that exist for these accounts)
base_prev AS (
  SELECT p.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME p
  JOIN prev_map mp
    ON mp.prev_eom IS NOT NULL
   AND mp.prev_eom = p.END_OF_MONTH_DATE
   AND mp.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND mp.ACCOUNT_KEY = p.ACCOUNT_KEY
  JOIN target tg ON 1=1
  WHERE mp.END_OF_MONTH_DATE = tg.eom
),

/* ===== CHANGE EVENTS (paste a small batch of generated lines) ===== */
/* generator lines compare base (curr) vs base_prev (prev) */
kde_changes AS (
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE, ''::VARCHAR(1) AS KDE, 0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE ~8–12 UNION ALL SELECT lines from the generator here,
         each using base (alias b) and base_prev (alias p) like:

     UNION ALL SELECT b.END_OF_MONTH_DATE, 'COLUMN_X' AS KDE, b.SOURCE_SYSTEM_BALANCE AS CURR_SSB
     FROM base b
     JOIN base_prev p
       ON p.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
      AND p.ACCOUNT_KEY            = b.ACCOUNT_KEY
     WHERE TRIM(COALESCE(b."COLUMN_X"::VARCHAR(4000), '~NULL~')) <>
           TRIM(COALESCE(p."COLUMN_X"::VARCHAR(4000), '~NULL~'))

     ... repeat for the small batch of columns ...
  >>> */
),

-- roll up to KDE totals for the target month
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
)

SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  exposure_dollars
FROM kde_monthly
JOIN cfg ON 1=1
WHERE exposure_dollars >= cfg.per_kde_min_exposure
ORDER BY exposure_dollars DESC, KDE
FETCH FIRST 50 ROWS ONLY;






WITH
cfg AS (
  SELECT
    25000000::FLOAT8 AS per_kde_min_exposure,  -- Show KDEs with ≥ $25MM exposure
    100000::FLOAT8   AS per_account_min_ssb    -- Ignore tiny accounts (<$100k)
),

-- Find last two month-ends
bounds AS (
  SELECT
    MAX(END_OF_MONTH_DATE) AS curr_eom,
    (SELECT MAX(END_OF_MONTH_DATE)
       FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
      WHERE END_OF_MONTH_DATE <
           (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME)) AS prev_eom
),

-- Current month accounts with positive SSB
measures_c AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, bounds b
  WHERE t.END_OF_MONTH_DATE = b.curr_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Previous month accounts with positive SSB
measures_p AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, bounds b
  WHERE t.END_OF_MONTH_DATE = b.prev_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Bring in full rows for each month
base_c AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures_c m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY = t.ACCOUNT_KEY
  JOIN bounds b ON t.END_OF_MONTH_DATE = b.curr_eom
  JOIN cfg ON 1=1
  WHERE t.SOURCE_SYSTEM_BALANCE >= cfg.per_account_min_ssb
),
base_p AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures_p m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY = t.ACCOUNT_KEY
  JOIN bounds b ON t.END_OF_MONTH_DATE = b.prev_eom
),

/* ==== CHANGE EVENTS: paste generated lines here ==== */
kde_changes AS (
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE,
         ''::VARCHAR(1) AS KDE,
         0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE UNION ALL SELECT LINES FROM GENERATOR HERE >>> */
),

-- Aggregate by KDE for current month
kde_monthly_curr AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),

-- Repeat for previous month (swap base_c and base_p in the pasted lines!)
kde_changes_prev AS (
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE,
         ''::VARCHAR(1) AS KDE,
         0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE THE SAME LINES, BUT REPLACE base_c → base_p AND base_p → base_c >>> */
),
kde_monthly_prev AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes_prev
  GROUP BY 1,2
),

-- Join current vs previous for MoM deltas
final AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    c.change_count,
    c.exposure_dollars,
    p.change_count AS prev_change_count,
    p.exposure_dollars AS prev_exposure_dollars,
    (c.change_count - p.change_count) AS mom_change_count_delta,
    CASE WHEN p.change_count > 0
         THEN (c.change_count - p.change_count) / p.change_count::FLOAT8 END AS mom_change_count_pct,
    (c.exposure_dollars - p.exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN p.exposure_dollars <> 0
         THEN (c.exposure_dollars - p.exposure_dollars) / p.exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM kde_monthly_curr c
  LEFT JOIN kde_monthly_prev p
    ON p.KDE = c.KDE
)

-- Filter to large-$ KDEs, order by biggest impact first
SELECT *
FROM final
JOIN cfg ON 1=1
WHERE exposure_dollars >= cfg.per_kde_min_exposure
ORDER BY exposure_dollars DESC, KDE
FETCH FIRST 50 ROWS ONLY;





WITH cols AS (
  SELECT
    c.column_name,
    ROW_NUMBER() OVER (ORDER BY UPPER(c.column_name)) AS rn
  FROM INFORMATION_SCHEMA.COLUMNS c
  /* anchor so it's not a system-only query */
  CROSS JOIN (SELECT 1 FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME LIMIT 1) a
  WHERE UPPER(c.table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    -- exclude keys/utility used elsewhere
    AND UPPER(c.column_name) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- prune audit/noisy columns (tune as needed)
    AND UPPER(c.column_name) NOT LIKE '%_TS'
    AND UPPER(c.column_name) NOT LIKE '%_DT'
    AND UPPER(c.column_name) NOT LIKE 'CREATED_%'
    AND UPPER(c.column_name) NOT LIKE 'UPDATED_%'
    AND UPPER(c.column_name) NOT LIKE '%_USER'
    AND UPPER(c.column_name) NOT LIKE '%USER_ID%'
    AND UPPER(c.column_name) NOT LIKE '%HASH%'
    AND UPPER(c.column_name) NOT LIKE '%CHECKSUM%'
    AND UPPER(c.column_name) NOT LIKE '%BATCH%'
    AND UPPER(c.column_name) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM cols
  WHERE rn BETWEEN 1 AND 20   -- <<< adjust this per run: 1-20, 21-40, 41-60, ...
)
SELECT
  'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
   FROM base_c c
   JOIN base_p p
     ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
    AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
   WHERE TRIM(COALESCE(c."'||column_name||'"::VARCHAR(4000), ''~NULL~'')) <>
         TRIM(COALESCE(p."'||column_name||'"::VARCHAR(4000), ''~NULL~''))'
  AS sql_line
FROM batch
ORDER BY rn;





WITH cols AS (
  SELECT
    sc.attname        AS column_name,
    ROW_NUMBER() OVER (ORDER BY UPPER(sc.attname)) AS rn
  FROM _V_SYS_COLUMNS sc
  /* anchor to a user object so NPS doesn't treat this as system-only */
  CROSS JOIN (SELECT 1 FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME LIMIT 1) a
  WHERE UPPER(sc.objname) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    -- exclude keys/utility
    AND UPPER(sc.attname) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- skim obvious audit/noise (tune as needed)
    AND UPPER(sc.attname) NOT LIKE '%_TS'
    AND UPPER(sc.attname) NOT LIKE '%_DT'
    AND UPPER(sc.attname) NOT LIKE 'CREATED_%'
    AND UPPER(sc.attname) NOT LIKE 'UPDATED_%'
    AND UPPER(sc.attname) NOT LIKE '%_USER'
    AND UPPER(sc.attname) NOT LIKE '%USER_ID%'
    AND UPPER(sc.attname) NOT LIKE '%HASH%'
    AND UPPER(sc.attname) NOT LIKE '%CHECKSUM%'
    AND UPPER(sc.attname) NOT LIKE '%BATCH%'
    AND UPPER(sc.attname) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM cols
  WHERE rn BETWEEN 1 AND 25   -- <<< adjust per run: 1–25, 26–50, 51–75, ...
)
SELECT
  'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
   FROM base_c c
   JOIN base_p p
     ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
    AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
   WHERE TRIM(COALESCE(c."'||column_name||'"::VARCHAR(4000), ''~NULL~'')) <>
         TRIM(COALESCE(p."'||column_name||'"::VARCHAR(4000), ''~NULL~''))'
  AS sql_line
FROM batch
ORDER BY rn;





WITH sel AS (
  SELECT
    c.column_name,
    c.data_type,
    ROW_NUMBER() OVER (ORDER BY UPPER(c.column_name)) AS rn
  FROM INFORMATION_SCHEMA.COLUMNS c
  /* Anchor: cross-join a single row from a user object to avoid "system-only" window agg error */
  CROSS JOIN (
    SELECT 1 AS anchor
    FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
    LIMIT 1
  ) a
  WHERE UPPER(c.table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    AND UPPER(c.column_name) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- prune noisy/audit columns; adjust as needed
    AND UPPER(c.column_name) NOT LIKE '%_TS'
    AND UPPER(c.column_name) NOT LIKE '%_DT'
    AND UPPER(c.column_name) NOT LIKE 'CREATED_%'
    AND UPPER(c.column_name) NOT LIKE 'UPDATED_%'
    AND UPPER(c.column_name) NOT LIKE '%_USER'
    AND UPPER(c.column_name) NOT LIKE '%USER_ID%'
    AND UPPER(c.column_name) NOT LIKE '%HASH%'
    AND UPPER(c.column_name) NOT LIKE '%CHECKSUM%'
    AND UPPER(c.column_name) NOT LIKE '%BATCH%'
    AND UPPER(c.column_name) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM sel
  WHERE rn BETWEEN 1 AND 25   -- <<< change this range each run (e.g., 26-50, 51-75, …)
)
SELECT
  CASE
    WHEN POSITION('CHAR' IN UPPER(data_type))>0 OR POSITION('VARCHAR' IN UPPER(data_type))>0
         OR POSITION('NCHAR' IN UPPER(data_type))>0 OR POSITION('NVARCHAR' IN UPPER(data_type))>0
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    WHEN UPPER(data_type) LIKE '%DATE%' OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    ELSE
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
  END AS sql_line
FROM batch
ORDER BY rn;







=PY("
import numpy as np
import pandas as pd
from math import isfinite
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing
    _HAS_SM = True
except Exception:
    _HAS_SM = False

# =========================
# CONFIG
# =========================
SEASONAL_PERIODS = 12       # monthly data with yearly pattern
FORECAST_HORIZON = 1        # 1 = next month; you can change to 3, 6, etc.
W_Z, W_PCT, W_IMP = 0.5, 0.3, 0.2   # Severity weights (z, pct, $impact)
Z80, Z95 = 1.2816, 1.9599

# =========================
# INPUT
# =========================
df = args[0].copy()

# Standardize column names
df.columns = [c.strip().upper() for c in df.columns]
req = {'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
miss = req - set(df.columns)
if miss:
    raise ValueError(f'Missing required columns: {miss}')

# Types + basic clean
df['END_OF_MONTH_DATE'] = pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE'] = pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df = df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df = (df
      .groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'], as_index=False)['SOURCE_SYSTEM_BALANCE']
      .sum()
      .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))

# =========================
# HELPERS
# =========================
def robust_std(resid):
    if len(resid) == 0: 
        return np.nan
    med = np.median(resid)
    mad = np.median(np.abs(resid - med))
    return 1.4826*mad if mad>0 else (np.std(resid) if len(resid)>1 else np.nan)

def seasonal_naive_forecast(series, h=1, sp=SEASONAL_PERIODS):
    # Fallback if statsmodels isn't available or data is short:
    # yhat_t+h = y_(t+h-sp) (seasonal naive)
    out = []
    n = len(series)
    for _ in range(h):
        if n - sp >= 0:
            out.append(series.iloc[n - sp])
        else:
            out.append(series.iloc[-1])
    return pd.Series(out, index=range(h))

def fit_and_forecast(y, h=1, sp=SEASONAL_PERIODS):
    y = y.astype(float)
    model_name = 'Fallback-SeasonalNaive'
    fitted_vals = pd.Series(index=y.index, dtype=float)

    if _HAS_SM:
        # Try ETS(A,A,A) if long enough; then ETS(A,A,N); else SES
        if len(y) >= 2*sp:
            try:
                m = ExponentialSmoothing(y, trend='add', seasonal='add', seasonal_periods=sp, initialization_method='estimated')
                fit = m.fit(optimized=True)
                model_name = 'ETS(A,A,A)'
            except Exception:
                fit = None
        else:
            fit = None

        if fit is None and len(y) >= 6:
            try:
                m = ExponentialSmoothing(y, trend='add', seasonal=None, initialization_method='estimated')
                fit = m.fit(optimized=True)
                model_name = 'ETS(A,A,N)'
            except Exception:
                fit = None

        if fit is None:
            try:
                m = ExponentialSmoothing(y, trend=None, seasonal=None, initialization_method='estimated')
                fit = m.fit(optimized=True)
                model_name = 'SES'
            except Exception:
                fit = None

        if fit is not None:
            fitted_vals = pd.Series(fit.fittedvalues, index=y.index)
            fcast = fit.forecast(h)
            return model_name, fitted_vals, pd.Series(fcast.values, index=range(h))

    # Fallback: seasonal naive
    fcast = seasonal_naive_forecast(pd.Series(y.values), h=h, sp=sp)
    # Pseudo fitted for residuals (shift by sp if possible)
    if len(y) > sp:
        fitted_vals.iloc[sp:] = y.values[:-sp]
        fitted_vals.iloc[:sp] = y.values[0]
    else:
        fitted_vals[:] = y.values.mean()
    return model_name, fitted_vals, fcast

# =========================
# MAIN
# =========================
rows = []
for system, g in df.groupby('CONTRACT_SOURCE_SYSTEM', sort=False):
    g = g.sort_values('END_OF_MONTH_DATE')
    y = g['SOURCE_SYSTEM_BALANCE']

    model_name, fitted_vals, fcast = fit_and_forecast(y, h=FORECAST_HORIZON, sp=SEASONAL_PERIODS)

    resid = (y.values - np.nan_to_num(fitted_vals.values, nan=np.nan)).astype(float)
    resid = resid[~np.isnan(resid)]
    sigma = robust_std(resid)

    last_date = g['END_OF_MONTH_DATE'].iloc[-1]
    last_actual = float(y.iloc[-1])

    # Build horizon rows (usually h=1; supports h>1)
    for step in range(len(fcast)):
        f = float(fcast.iloc[step])
        # Next period date(s): month-end stepping
        next_period = last_date + pd.offsets.MonthEnd(step+1)

        # Simple normal-approx PI using residual sigma
        if sigma is not None and isfinite(sigma):
            lo80, hi80 = f - Z80*sigma, f + Z80*sigma
            lo95, hi95 = f - Z95*sigma, f + Z95*sigma
        else:
            lo80 = hi80 = lo95 = hi95 = np.nan

        # Diagnostics vs last actual (useful for step=0)
        dev_abs = last_actual - f
        dev_pct = (dev_abs / f) if f != 0 else np.nan
        zscore = (dev_abs / sigma) if (sigma is not None and isfinite(sigma) and sigma>0) else np.nan

        # Impact scaling by system median
        med_lvl = float(np.median(y)) if len(y)>0 else 1.0
        imp_term = min((abs(dev_abs) / (med_lvl*0.1)) if med_lvl>0 else 0.0, 1.0)  # 10% of median cap
        z_term   = min(abs(zscore)/3.0, 1.0) if pd.notna(zscore) else 0.0         # cap ~3σ
        pct_term = min(abs(dev_pct)/0.1, 1.0) if pd.notna(dev_pct) else 0.0       # cap at ±10%

        severity = 100.0*(W_Z*z_term + W_PCT*pct_term + W_IMP*imp_term)

        flag95 = (pd.notna(last_actual) and pd.notna(lo95) and (last_actual < lo95 or last_actual > hi95))

        rows.append({
            'CONTRACT_SOURCE_SYSTEM': system,
            'MODEL': model_name,
            'LAST_PERIOD': last_date,
            'NEXT_PERIOD': next_period,
            'STEP_AHEAD': step+1,
            'ACTUAL_LAST': last_actual,
            'FORECAST': f,
            'PI80_LO': lo80, 'PI80_HI': hi80,
            'PI95_LO': lo95, 'PI95_HI': hi95,
            'DEV_ABS_vs_LAST': dev_abs,
            'DEV_PCT_vs_LAST': dev_pct,
            'Z_SCORE_vs_LAST': zscore,
            'SEVERITY_0_100': severity,
            'OUTSIDE_95_BAND_vs_LAST': bool(flag95)
        })

result = pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'], ascending=[True, False])

return result
", tblSSB[#All])






-- Pull ~30 months (24+ buffer) ending at the latest END_OF_MONTH_DATE in the table
WITH latest AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
    SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom
    FROM latest
),
base AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SOURCE_SYSTEM_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
      -- Optional filters you might want:
      -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
)
SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    SUM(SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
FROM base
GROUP BY 1,2
ORDER BY 1,2;





-- === RC_CODE monthly trend + MoM variance + anomaly flags (last 12 months) ===
WITH base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)                   AS EOM,
        RC_CODE,
        RV_DESCRIPTION,
        SUM(GL_BALANCE)                                   AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE), -12)
    GROUP BY 1,2,3
),
calc AS (
    SELECT
        EOM,
        RC_CODE,
        RV_DESCRIPTION,
        GL_BALANCE,
        LAG(GL_BALANCE) OVER (PARTITION BY RC_CODE ORDER BY EOM)             AS PREV_GL_BALANCE,
        (GL_BALANCE - LAG(GL_BALANCE) OVER (PARTITION BY RC_CODE ORDER BY EOM)) AS MOM_ABS_CHANGE,
        CASE
            WHEN LAG(GL_BALANCE) OVER (PARTITION BY RC_CODE ORDER BY EOM) = 0 THEN NULL
            ELSE (GL_BALANCE - LAG(GL_BALANCE) OVER (PARTITION BY RC_CODE ORDER BY EOM))
                 / NULLIF(LAG(GL_BALANCE) OVER (PARTITION BY RC_CODE ORDER BY EOM),0)
        END                                                                  AS MOM_PCT_CHANGE,
        -- rolling stats over the *prior* 12 months (exclude current row)
        AVG(GL_BALANCE) OVER (
            PARTITION BY RC_CODE
            ORDER BY EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        )                                                                    AS ROLL_MEAN_12_EXCL,
        STDDEV_SAMP(GL_BALANCE) OVER (
            PARTITION BY RC_CODE
            ORDER BY EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        )                                                                    AS ROLL_STD_12_EXCL
    FROM base
)
SELECT
    EOM AS END_OF_MONTH_DATE,
    RC_CODE,
    RV_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    CASE
        WHEN ROLL_STD_12_EXCL IS NULL OR ROLL_STD_12_EXCL = 0 THEN NULL
        ELSE (GL_BALANCE - ROLL_MEAN_12_EXCL) / ROLL_STD_12_EXCL
    END AS Z_SCORE_12_EXCL,
    CASE
        WHEN (ROLL_STD_12_EXCL IS NOT NULL AND ROLL_STD_12_EXCL > 0
              AND ABS((GL_BALANCE - ROLL_MEAN_12_EXCL) / ROLL_STD_12_EXCL) >= 2.0)
          OR (COALESCE(ABS(MOM_PCT_CHANGE),0) >= 0.25 AND COALESCE(ABS(MOM_ABS_CHANGE),0) >= 100000)
        THEN 1 ELSE 0
    END AS IS_ANOMALY
FROM calc
ORDER BY END_OF_MONTH_DATE, RC_CODE;




/* ============================================================================================
   Non-Accrual Project — ONE OUTPUT (Tall Table) — NETEZZA (SAFE NUMERIC CASTS)
   Output columns:
     Dataset (VARCHAR), MonthEnd (DATE), Dim1 (VARCHAR), Dim2 (VARCHAR),
     Metric (VARCHAR), Value (NUMERIC)
   Use Dataset to filter each Power BI visual to its slice.
   ============================================================================================ */

WITH Base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)                           AS MonthEnd,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,
    CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2))              AS Balance,
    UPPER(TRIM(CAST(NON_ACCRUAL_FLAG AS VARCHAR(10))))        AS NA_Flag,
    /* SAFE NUMERIC PARSE: only cast PD_GRADE if it looks numeric */
    CASE
      WHEN PD_GRADE IS NULL THEN NULL
      WHEN REGEXP_LIKE(TRIM(CAST(PD_GRADE AS VARCHAR(50))), '^[+-]?[0-9]+(\.[0-9]+)?$')
        THEN CAST(TRIM(CAST(PD_GRADE AS VARCHAR(50))) AS NUMERIC(18,6))
      WHEN UPPER(TRIM(CAST(PD_GRADE AS VARCHAR(50)))) IN ('NULL','N/A','NA','INF','-INF','NAN')
        THEN NULL
      ELSE NULL
    END AS PD_GRADE_NUM
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND SOURCE_SYSTEM_BALANCE > 0
),
All_Enterprise_Summary AS (  -- for % calculations
  SELECT MonthEnd, SUM(Balance) AS EntBalance
  FROM Base
  GROUP BY MonthEnd
),
NonAccrual AS (
  SELECT *
  FROM Base
  WHERE NA_Flag IN ('1','Y','YES','TRUE','T')
),
LatestMonth AS (
  SELECT MAX(MonthEnd) AS MonthEnd FROM Base
),

/* ===================== TAB 1 – KPIs (Latest Month, Non-Accrual) ===================== */
Tab1_KPIs AS (
  -- Total Balance
  SELECT 'Tab1_KPI_Latest' AS Dataset, lm.MonthEnd AS MonthEnd,
         'NonAccrual' AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'TotalBalance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd

  UNION ALL

  -- Account Count
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', CAST(NULL AS VARCHAR(100)), 'AccountCount',
         CAST(COUNT(DISTINCT n.ACCOUNT_IDENTIFIER) AS NUMERIC(38,2))
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd

  UNION ALL

  -- % of Enterprise
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', CAST(NULL AS VARCHAR(100)), 'PctOfEnterprise',
         (SUM(n.Balance) / NULLIF(e.EntBalance, 0)) * 100.0
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  JOIN All_Enterprise_Summary e ON e.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd, e.EntBalance

  UNION ALL

  -- Weighted Avg PD_Grade (non-accrual)
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', CAST(NULL AS VARCHAR(100)), 'WeightedAvg_PD_Grade',
         SUM(n.Balance * n.PD_GRADE_NUM) / NULLIF(SUM(n.Balance), 0)
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  WHERE n.PD_GRADE_NUM IS NOT NULL
  GROUP BY lm.MonthEnd
),

/* ===================== TAB 3 – Composition (Stacks) ===================== */
Tab3_GLStack_All AS (
  -- Enterprise ALL by GL level (trend)
  SELECT 'Tab3_GL_Stack_All' AS Dataset, b.MonthEnd AS MonthEnd,
         b.GL_ACCOUNT_HIER_LEVEL_4 AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Balance' AS Metric,
         SUM(b.Balance) AS Value
  FROM Base b
  GROUP BY b.MonthEnd, b.GL_ACCOUNT_HIER_LEVEL_4
),
Tab3_GLStack_NA AS (
  -- Non-Accrual ONLY by GL level (trend)
  SELECT 'Tab3_GL_Stack_NA' AS Dataset, n.MonthEnd AS MonthEnd,
         n.GL_ACCOUNT_HIER_LEVEL_4 AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Balance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.GL_ACCOUNT_HIER_LEVEL_4
),

/* ===================== TAB 6 – Adds / Removals / Persisting Delta (Non-Accrual) ===================== */
Months AS (
  SELECT DISTINCT MonthEnd FROM NonAccrual
),
MonthPairs AS (
  SELECT m.MonthEnd AS CurrMonth, ADD_MONTHS(m.MonthEnd, -1) AS PrevMonth
  FROM Months m
),
CurrVsPrev AS (  -- adds + persisting
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),
PrevNotCurr AS (  -- removals
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),
Tab6_Wide AS (  -- month-level sums
  SELECT
    CurrMonth AS MonthEnd,
    SUM(CASE WHEN PrevBal IS NULL THEN CurrBal ELSE 0 END)                         AS Adds,
    SUM(CASE WHEN PrevBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)         AS PersistingDelta,
    CAST(0 AS NUMERIC(38,2))                                                       AS Removals
  FROM CurrVsPrev
  GROUP BY CurrMonth

  UNION ALL

  SELECT
    CurrMonth AS MonthEnd,
    CAST(0 AS NUMERIC(38,2))                                                       AS Adds,
    CAST(0 AS NUMERIC(38,2))                                                       AS PersistingDelta,
    SUM(-PrevBal)                                                                  AS Removals
  FROM PrevNotCurr
  GROUP BY CurrMonth
),
Tab6_Collapsed AS (
  SELECT
    MonthEnd,
    SUM(Adds)             AS Adds,
    SUM(PersistingDelta)  AS PersistingDelta,
    SUM(Removals)         AS Removals
  FROM Tab6_Wide
  GROUP BY MonthEnd
),
Tab6_Long AS (
  SELECT 'Tab6_AddsRemovalsDelta' AS Dataset, MonthEnd, 'Adds' AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2,
         'AmountSigned' AS Metric, Adds AS Value
  FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Removals', CAST(NULL AS VARCHAR(100)), 'AmountSigned', Removals
  FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Persisting Delta', CAST(NULL AS VARCHAR(100)), 'AmountSigned', PersistingDelta
  FROM Tab6_Collapsed
),

/* ===================== TAB 7 – Non-Accrual Drilldown ===================== */
Tab7_BySystem AS (
  -- Trend by system
  SELECT 'Tab7_NA_BySystem' AS Dataset, n.MonthEnd AS MonthEnd,
         n.CONTRACT_SOURCE_SYSTEM AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Balance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.CONTRACT_SOURCE_SYSTEM
),
Tab7_PD_Trend AS (
  -- Weighted Avg PD_Grade trend (Non-Accrual)
  SELECT 'Tab7_PD_WtAvg_Trend' AS Dataset, n.MonthEnd AS MonthEnd,
         CAST(NULL AS VARCHAR(100)) AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'WeightedAvg_PD_Grade' AS Metric,
         SUM(n.Balance * n.PD_GRADE_NUM) / NULLIF(SUM(n.Balance),0) AS Value
  FROM NonAccrual n
  WHERE n.PD_GRADE_NUM IS NOT NULL
  GROUP BY n.MonthEnd
),
Tab7_LatestDetail AS (
  -- Latest-month account detail (for a table)
  SELECT 'Tab7_Latest_Detail' AS Dataset, lm.MonthEnd AS MonthEnd,
         n.ACCOUNT_IDENTIFIER AS Dim1, n.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Account_Balance' AS Metric, SUM(n.Balance) AS Value
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
Tab2_AddsRemovals_BySystem AS (
  -- Adds / Removals by system (month-level)
  SELECT 'Tab2_AddsRemovals_BySystem' AS Dataset, a.CurrMonth AS MonthEnd,
         a.CONTRACT_SOURCE_SYSTEM AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Adds' AS Metric,
         SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value
  FROM CurrVsPrev a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT 'Tab2_AddsRemovals_BySystem', r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM, CAST(NULL AS VARCHAR(100)), 'Removals',
         SUM(-r.PrevBal)
  FROM PrevNotCurr r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_TopN AS (
  SELECT a.CurrMonth AS MonthEnd,
         a.ACCOUNT_IDENTIFIER AS AccountId,
         a.CONTRACT_SOURCE_SYSTEM AS SystemName,
         SUM(a.CurrBal - a.PrevBal) AS Delta
  FROM CurrVsPrev a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT MonthEnd, AccountId, SystemName, Delta,
         ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT 'Tab2_PersistingMovers' AS Dataset, MonthEnd,
         AccountId AS Dim1, SystemName AS Dim2, 'DeltaSigned' AS Metric, Delta AS Value
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),
Tab2_AddsDetail AS (
  SELECT 'Tab2_AddsDetail' AS Dataset, a.CurrMonth AS MonthEnd,
         a.ACCOUNT_IDENTIFIER AS Dim1, a.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Add_Balance' AS Metric, SUM(a.CurrBal) AS Value
  FROM CurrVsPrev a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT 'Tab2_RemovalsDetail' AS Dataset, r.CurrMonth AS MonthEnd,
         r.ACCOUNT_IDENTIFIER AS Dim1, r.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Removal_Balance' AS Metric, SUM(r.PrevBal) AS Value
  FROM PrevNotCurr r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */
Tab4_PD_Buckets AS (
  SELECT n.MonthEnd AS MonthEnd,
         CASE
           WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
           WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
           WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
           WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
           ELSE 'PD 9+'
         END AS PDBand,
         n.Balance AS Balance,
         n.ACCOUNT_IDENTIFIER AS AccountId,
         n.CONTRACT_SOURCE_SYSTEM AS SystemName
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT 'Tab4_PD_Distribution' AS Dataset, MonthEnd,
         PDBand AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Balance' AS Metric, SUM(Balance) AS Value
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),
Tab4_TopAccounts AS (
  SELECT n.MonthEnd AS MonthEnd,
         n.ACCOUNT_IDENTIFIER AS AccountId,
         n.CONTRACT_SOURCE_SYSTEM AS SystemName,
         SUM(n.Balance) AS Bal,
         ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10_Accounts AS (
  SELECT 'Tab4_Top10_Accounts' AS Dataset, MonthEnd,
         AccountId AS Dim1, SystemName AS Dim2, 'Balance' AS Metric, Bal AS Value
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),
Tab4_Top5Conc_Base AS (
  SELECT n.MonthEnd AS MonthEnd, SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT t.MonthEnd AS MonthEnd, SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT n.MonthEnd AS MonthEnd,
           n.ACCOUNT_IDENTIFIER AS AccountId,
           SUM(n.Balance) AS Bal,
           ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5_Concentration AS (
  SELECT 'Tab4_Top5_Concentration' AS Dataset, c.MonthEnd AS MonthEnd,
         'Top5Pct' AS Dim1, CAST(NULL AS VARCHAR(100)) AS Dim2, 'Percent' AS Metric,
         (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value
  FROM Tab4_Top5Conc_Base c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
)

/* ===================== FINAL UNION: one tall table ===================== */
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab1_KPIs
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab3_GLStack_All
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab3_GLStack_NA
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab6_Long
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_BySystem
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_PD_Trend
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_LatestDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_AddsRemovals_BySystem
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_PersistingMovers_Long
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_AddsDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_RemovalsDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_PD_Distribution
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_Top10_Accounts
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_Top5_Concentration
ORDER BY Dataset, MonthEnd, Dim1, Metric;





/* ============================================================================================
   Non-Accrual Project — ONE OUTPUT (Tall Table) — NETEZZA
   Output columns:
     Dataset (VARCHAR), MonthEnd (DATE), Dim1 (VARCHAR), Dim2 (VARCHAR),
     Metric (VARCHAR), Value (NUMERIC)
   Use Dataset to filter each Power BI visual to its slice.
   ============================================================================================ */

WITH Base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)                           AS MonthEnd,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,
    CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2))              AS Balance,
    UPPER(TRIM(CAST(NON_ACCRUAL_FLAG AS VARCHAR(10))))        AS NA_Flag,
    CAST(NULLIF(TRIM(CAST(PD_GRADE AS VARCHAR(50))), '') AS NUMERIC(18,6)) AS PD_GRADE_NUM
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND SOURCE_SYSTEM_BALANCE > 0
),
All_Enterprise_Summary AS (  -- for % calculations
  SELECT MonthEnd, SUM(Balance) AS EntBalance
  FROM Base
  GROUP BY MonthEnd
),
NonAccrual AS (
  SELECT *
  FROM Base
  WHERE NA_Flag IN ('1','Y','YES','TRUE','T')
),
LatestMonth AS (
  SELECT MAX(MonthEnd) AS MonthEnd FROM Base
),

/* ===================== TAB 1 – KPIs (Latest Month, Non-Accrual) ===================== */
Tab1_KPIs AS (
  -- Total Balance
  SELECT 'Tab1_KPI_Latest' AS Dataset, lm.MonthEnd AS MonthEnd,
         'NonAccrual' AS Dim1, NULL AS Dim2, 'TotalBalance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd

  UNION ALL

  -- Account Count
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', NULL, 'AccountCount',
         COUNT(DISTINCT n.ACCOUNT_IDENTIFIER)
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd

  UNION ALL

  -- % of Enterprise
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', NULL, 'PctOfEnterprise',
         (SUM(n.Balance) / NULLIF(e.EntBalance, 0)) * 100.0
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  JOIN All_Enterprise_Summary e ON e.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd, e.EntBalance

  UNION ALL

  -- Weighted Avg PD_Grade (non-accrual)
  SELECT 'Tab1_KPI_Latest', lm.MonthEnd,
         'NonAccrual', NULL, 'WeightedAvg_PD_Grade',
         SUM(n.Balance * n.PD_GRADE_NUM) / NULLIF(SUM(n.Balance), 0)
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  WHERE n.PD_GRADE_NUM IS NOT NULL
  GROUP BY lm.MonthEnd
),

/* ===================== TAB 3 – Composition (Stacks) ===================== */
Tab3_GLStack_All AS (
  -- Enterprise ALL by GL level (trend)
  SELECT 'Tab3_GL_Stack_All' AS Dataset, b.MonthEnd AS MonthEnd,
         b.GL_ACCOUNT_HIER_LEVEL_4 AS Dim1, NULL AS Dim2, 'Balance' AS Metric,
         SUM(b.Balance) AS Value
  FROM Base b
  GROUP BY b.MonthEnd, b.GL_ACCOUNT_HIER_LEVEL_4
),
Tab3_GLStack_NA AS (
  -- Non-Accrual ONLY by GL level (trend)
  SELECT 'Tab3_GL_Stack_NA' AS Dataset, n.MonthEnd AS MonthEnd,
         n.GL_ACCOUNT_HIER_LEVEL_4 AS Dim1, NULL AS Dim2, 'Balance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.GL_ACCOUNT_HIER_LEVEL_4
),

/* ===================== TAB 6 – Adds / Removals / Persisting Delta (Non-Accrual) ===================== */
Months AS (
  SELECT DISTINCT MonthEnd FROM NonAccrual
),
MonthPairs AS (
  SELECT m.MonthEnd AS CurrMonth, ADD_MONTHS(m.MonthEnd, -1) AS PrevMonth
  FROM Months m
),
CurrVsPrev AS (  -- adds + persisting
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),
PrevNotCurr AS (  -- removals
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),
Tab6_Wide AS (  -- month-level sums
  SELECT
    CurrMonth AS MonthEnd,
    SUM(CASE WHEN PrevBal IS NULL THEN CurrBal ELSE 0 END)                         AS Adds,
    SUM(CASE WHEN PrevBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)         AS PersistingDelta,
    CAST(0 AS NUMERIC(38,2))                                                       AS Removals
  FROM CurrVsPrev
  GROUP BY CurrMonth

  UNION ALL

  SELECT
    CurrMonth AS MonthEnd,
    CAST(0 AS NUMERIC(38,2))                                                       AS Adds,
    CAST(0 AS NUMERIC(38,2))                                                       AS PersistingDelta,
    SUM(-PrevBal)                                                                  AS Removals
  FROM PrevNotCurr
  GROUP BY CurrMonth
),
Tab6_Collapsed AS (
  SELECT
    MonthEnd,
    SUM(Adds)             AS Adds,
    SUM(PersistingDelta)  AS PersistingDelta,
    SUM(Removals)         AS Removals
  FROM Tab6_Wide
  GROUP BY MonthEnd
),
Tab6_Long AS (
  SELECT 'Tab6_AddsRemovalsDelta' AS Dataset, MonthEnd, 'Adds' AS Dim1, NULL AS Dim2,
         'AmountSigned' AS Metric, Adds AS Value
  FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Removals', NULL, 'AmountSigned', Removals
  FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Persisting Delta', NULL, 'AmountSigned', PersistingDelta
  FROM Tab6_Collapsed
),

/* ===================== TAB 7 – Non-Accrual Drilldown ===================== */
Tab7_BySystem AS (
  -- Trend by system
  SELECT 'Tab7_NA_BySystem' AS Dataset, n.MonthEnd AS MonthEnd,
         n.CONTRACT_SOURCE_SYSTEM AS Dim1, NULL AS Dim2, 'Balance' AS Metric,
         SUM(n.Balance) AS Value
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.CONTRACT_SOURCE_SYSTEM
),
Tab7_PD_Trend AS (
  -- Weighted Avg PD_Grade trend (Non-Accrual)
  SELECT 'Tab7_PD_WtAvg_Trend' AS Dataset, n.MonthEnd AS MonthEnd,
         NULL AS Dim1, NULL AS Dim2, 'WeightedAvg_PD_Grade' AS Metric,
         SUM(n.Balance * n.PD_GRADE_NUM) / NULLIF(SUM(n.Balance),0) AS Value
  FROM NonAccrual n
  WHERE n.PD_GRADE_NUM IS NOT NULL
  GROUP BY n.MonthEnd
),
Tab7_LatestDetail AS (
  -- Latest-month account detail (for a table)
  SELECT 'Tab7_Latest_Detail' AS Dataset, lm.MonthEnd AS MonthEnd,
         n.ACCOUNT_IDENTIFIER AS Dim1, n.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Account_Balance' AS Metric, SUM(n.Balance) AS Value
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  GROUP BY lm.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
Tab2_AddsRemovals_BySystem AS (
  -- Adds / Removals by system (month-level)
  SELECT 'Tab2_AddsRemovals_BySystem' AS Dataset, a.CurrMonth AS MonthEnd,
         a.CONTRACT_SOURCE_SYSTEM AS Dim1, NULL AS Dim2, 'Adds' AS Metric,
         SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value
  FROM CurrVsPrev a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT 'Tab2_AddsRemovals_BySystem', r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM, NULL, 'Removals',
         SUM(-r.PrevBal)
  FROM PrevNotCurr r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_TopN AS (
  SELECT a.CurrMonth AS MonthEnd,
         a.ACCOUNT_IDENTIFIER AS AccountId,
         a.CONTRACT_SOURCE_SYSTEM AS SystemName,
         SUM(a.CurrBal - a.PrevBal) AS Delta
  FROM CurrVsPrev a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT MonthEnd, AccountId, SystemName, Delta,
         ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT 'Tab2_PersistingMovers' AS Dataset, MonthEnd,
         AccountId AS Dim1, SystemName AS Dim2, 'DeltaSigned' AS Metric, Delta AS Value
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),
Tab2_AddsDetail AS (
  SELECT 'Tab2_AddsDetail' AS Dataset, a.CurrMonth AS MonthEnd,
         a.ACCOUNT_IDENTIFIER AS Dim1, a.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Add_Balance' AS Metric, SUM(a.CurrBal) AS Value
  FROM CurrVsPrev a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT 'Tab2_RemovalsDetail' AS Dataset, r.CurrMonth AS MonthEnd,
         r.ACCOUNT_IDENTIFIER AS Dim1, r.CONTRACT_SOURCE_SYSTEM AS Dim2,
         'Removal_Balance' AS Metric, SUM(r.PrevBal) AS Value  -- positive; flip sign in PBI if desired
  FROM PrevNotCurr r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */
Tab4_PD_Buckets AS (
  SELECT n.MonthEnd AS MonthEnd,
         CASE
           WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
           WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
           WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
           WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
           ELSE 'PD 9+'
         END AS PDBand,
         n.Balance AS Balance,
         n.ACCOUNT_IDENTIFIER AS AccountId,
         n.CONTRACT_SOURCE_SYSTEM AS SystemName
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT 'Tab4_PD_Distribution' AS Dataset, MonthEnd,
         PDBand AS Dim1, NULL AS Dim2, 'Balance' AS Metric, SUM(Balance) AS Value
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),
Tab4_TopAccounts AS (
  SELECT n.MonthEnd AS MonthEnd,
         n.ACCOUNT_IDENTIFIER AS AccountId,
         n.CONTRACT_SOURCE_SYSTEM AS SystemName,
         SUM(n.Balance) AS Bal,
         ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10_Accounts AS (
  SELECT 'Tab4_Top10_Accounts' AS Dataset, MonthEnd,
         AccountId AS Dim1, SystemName AS Dim2, 'Balance' AS Metric, Bal AS Value
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),
Tab4_Top5Conc_Base AS (
  SELECT n.MonthEnd AS MonthEnd, SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT t.MonthEnd AS MonthEnd, SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT n.MonthEnd AS MonthEnd,
           n.ACCOUNT_IDENTIFIER AS AccountId,
           SUM(n.Balance) AS Bal,
           ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5_Concentration AS (
  SELECT 'Tab4_Top5_Concentration' AS Dataset, c.MonthEnd AS MonthEnd,
         'Top5Pct' AS Dim1, NULL AS Dim2, 'Percent' AS Metric,
         (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value
  FROM Tab4_Top5Conc_Base c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
)

/* ===================== FINAL UNION: one tall table ===================== */
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab1_KPIs
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab3_GLStack_All
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab3_GLStack_NA
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab6_Long
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_BySystem
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_PD_Trend
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_LatestDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_AddsRemovals_BySystem
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_PersistingMovers_Long
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_AddsDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab2_RemovalsDetail
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_PD_Distribution
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_Top10_Accounts
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab4_Top5_Concentration
ORDER BY Dataset, MonthEnd, Dim1, Metric;

/* ===================== OPTIONAL: TAB 5 – Anomaly Detection (UNCOMMENT IF AVAILABLE) =====================

-- Replace <YOUR_ANOMALY_TABLE>, EventDate, Severity, SystemName as needed, then
-- add these two UNIONs to the final UNION block.

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE) AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName
  FROM <YOUR_ANOMALY_TABLE>
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1,
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_Anomaly_Trend AS (
  SELECT 'Tab5_Anomaly_Trend' AS Dataset, MonthEnd,
         Sev AS Dim1, NULL AS Dim2, 'Count' AS Metric, Cnt AS Value
  FROM AnomalyByMonth
),
Tab5_Anomaly_Table AS (
  SELECT 'Tab5_Anomaly_Table' AS Dataset,
         ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
         CAST(EventDate AS VARCHAR(30)) AS Dim1,
         Severity AS Dim2,
         'Count' AS Metric, 1 AS Value
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)
)

-- Then append:
-- UNION ALL SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab5_Anomaly_Trend
-- UNION ALL SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab5_Anomaly_Table

============================================================================================== */






-- ONE-QUERY MULTI-DATASET OUTPUT (NETEZZA)
-- Produces a tall table with a Dataset label so Power BI can filter per visual.

WITH Base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS MonthEnd,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,
    CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2)) AS Balance,
    UPPER(TRIM(CAST(NON_ACCRUAL_FLAG AS VARCHAR(10)))) AS NA_Flag,
    CAST(PD_GRADE AS NUMERIC(18,6)) AS PD_GRADE_NUM
  FROM V_DPRT_CREDIT_INSTRUMENTS
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND SOURCE_SYSTEM_BALANCE > 0
),
NonAccrual AS (
  SELECT *
  FROM Base
  WHERE NA_Flag IN ('1','Y','YES','TRUE','T')
),

-- ===================== TAB 3: Portfolio Composition (stacked by GL level) =====================
Tab3_GLStack AS (
  SELECT
    'Tab3_GL_Stack'::VARCHAR(40)         AS Dataset,
    MonthEnd,
    GL_ACCOUNT_HIER_LEVEL_4              AS Dim1,     -- use as Legend in stacked column
    NULL::VARCHAR(100)                   AS Dim2,     -- placeholder
    'Balance'::VARCHAR(40)               AS Metric,
    SUM(Balance)                         AS Value
  FROM Base
  GROUP BY MonthEnd, GL_ACCOUNT_HIER_LEVEL_4
),

-- ===================== TAB 6: Adds / Removals / Persisting (NON-ACCRUAL) =====================
Months AS (
  SELECT DISTINCT MonthEnd FROM NonAccrual
),
MonthPairs AS (
  SELECT m.MonthEnd AS CurrMonth, ADD_MONTHS(m.MonthEnd, -1) AS PrevMonth
  FROM Months m
),
CurrVsPrev AS (               -- adds + persisting
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),
PrevNotCurr AS (              -- removals
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),
Tab6_Wide AS (                -- month-level sums
  SELECT
    CurrMonth AS MonthEnd,
    SUM(CASE WHEN PrevBal IS NULL THEN CurrBal ELSE 0 END)                         AS Adds,
    SUM(CASE WHEN PrevBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)         AS PersistingDelta,
    CAST(0 AS NUMERIC(38,2))                                                       AS Removals
  FROM CurrVsPrev
  GROUP BY CurrMonth

  UNION ALL

  SELECT
    CurrMonth AS MonthEnd,
    CAST(0 AS NUMERIC(38,2))                                                       AS Adds,
    CAST(0 AS NUMERIC(38,2))                                                       AS PersistingDelta,
    SUM(-PrevBal)                                                                  AS Removals
  FROM PrevNotCurr
  GROUP BY CurrMonth
),
Tab6_Collapsed AS (
  SELECT
    MonthEnd,
    SUM(Adds)             AS Adds,
    SUM(PersistingDelta)  AS PersistingDelta,
    SUM(Removals)         AS Removals
  FROM Tab6_Wide
  GROUP BY MonthEnd
),
Tab6_Long AS (
  SELECT 'Tab6_AddsRemovalsDelta'::VARCHAR(40) AS Dataset,
         MonthEnd,
         'Adds'::VARCHAR(100)                  AS Dim1,
         NULL::VARCHAR(100)                    AS Dim2,
         'AmountSigned'::VARCHAR(40)           AS Metric,
         Adds                                  AS Value
  FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Removals', NULL, 'AmountSigned', Removals FROM Tab6_Collapsed
  UNION ALL
  SELECT 'Tab6_AddsRemovalsDelta', MonthEnd, 'Persisting Delta', NULL, 'AmountSigned', PersistingDelta FROM Tab6_Collapsed
),

-- ===================== TAB 7: Weighted Avg PD_Grade (NON-ACCRUAL) — latest month only =========
LatestMonth AS (
  SELECT MAX(MonthEnd) AS MonthEnd FROM NonAccrual
),
Tab7_PD_Latest AS (
  SELECT
    'Tab7_PD_WtAvg_Latest'::VARCHAR(40)  AS Dataset,
    lm.MonthEnd                           AS MonthEnd,
    NULL::VARCHAR(100)                    AS Dim1,
    NULL::VARCHAR(100)                    AS Dim2,
    'WeightedAvg_PD_Grade'::VARCHAR(40)   AS Metric,
    SUM(n.Balance * n.PD_GRADE_NUM) / NULLIF(SUM(n.Balance), 0) AS Value
  FROM NonAccrual n
  JOIN LatestMonth lm ON n.MonthEnd = lm.MonthEnd
  WHERE n.PD_GRADE_NUM IS NOT NULL
  GROUP BY lm.MonthEnd
)

-- ===================== FINAL UNION OF ALL DATASETS =====================
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab3_GLStack
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab6_Long
UNION ALL
SELECT Dataset, MonthEnd, Dim1, Dim2, Metric, Value FROM Tab7_PD_Latest
ORDER BY Dataset, MonthEnd, Dim1;







-- Tab 3: Portfolio Composition — Stacked Column (Balance by GL Level) — NETEZZA
SELECT
    CAST(END_OF_MONTH_DATE AS DATE)            AS MonthEnd,
    GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2))) AS TotalBalance
FROM V_DPRT_CREDIT_INSTRUMENTS
WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
  AND SOURCE_SYSTEM_BALANCE > 0
GROUP BY
    CAST(END_OF_MONTH_DATE AS DATE),
    GL_ACCOUNT_HIER_LEVEL_4
ORDER BY
    MonthEnd,
    CASE WHEN GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' THEN 1 ELSE 2 END;






-- Weighted Avg PD_Grade (enterprise, NON-ACCRUAL ONLY) for the latest month — NETEZZA

WITH LatestMonth AS (
    SELECT MAX(CAST(END_OF_MONTH_DATE AS DATE)) AS MonthEnd
    FROM V_DPRT_CREDIT_INSTRUMENTS
    WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND SOURCE_SYSTEM_BALANCE > 0
),
Scoped AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE) AS MonthEnd,
        CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2)) AS Balance,
        CAST(PD_GRADE AS NUMERIC(18,6)) AS PD_GRADE_NUM
    FROM V_DPRT_CREDIT_INSTRUMENTS
    WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND SOURCE_SYSTEM_BALANCE > 0
      AND UPPER(TRIM(CAST(NON_ACCRUAL_FLAG AS VARCHAR(10)))) IN ('1','Y','YES','TRUE','T')
      AND PD_GRADE IS NOT NULL
)
SELECT
    lm.MonthEnd,
    SUM(s.Balance * s.PD_GRADE_NUM) / NULLIF(SUM(s.Balance), 0) AS WeightedAvg_PD_Grade
FROM Scoped s
JOIN LatestMonth lm
  ON s.MonthEnd = lm.MonthEnd
GROUP BY lm.MonthEnd;






-- Weighted Avg PD_Grade (enterprise, NON-ACCRUAL ONLY) for latest month — NETEZZA

WITH LatestMonth AS (
    SELECT MAX(CAST(END_OF_MONTH_DATE AS DATE)) AS MonthEnd
    FROM V_DPRT_CREDIT_INSTRUMENTS
    WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND SOURCE_SYSTEM_BALANCE > 0
),
Scoped AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE) AS MonthEnd,
        CAST(SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2)) AS Balance,
        CAST(PD_GRADE AS NUMERIC(18,6)) AS PD_GRADE_NUM
    FROM V_DPRT_CREDIT_INSTRUMENTS
    WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND SOURCE_SYSTEM_BALANCE > 0
      AND UPPER(TRIM(CAST(NON_ACCRUAL_FLAG AS VARCHAR(10)))) IN ('1','Y','YES','TRUE','T')
      AND PD_GRADE IS NOT NULL
)
SELECT
    s.MonthEnd,
    SUM(s.Balance * s.PD_GRADE_NUM) / NULLIF(SUM(s.Balance), 0) AS WeightedAvg_PD_Grade
FROM Scoped s
JOIN LatestMonth lm
  ON s.MonthEnd = lm.MonthEnd;






-- Tab 6: Trend & History — Adds / Removals / Persisting Delta (NON-ACCRUAL ONLY) — NETEZZA

WITH SnapshotsRaw AS (
    SELECT
        CAST(s.END_OF_MONTH_DATE AS DATE) AS MonthEnd,
        s.ACCOUNT_IDENTIFIER,
        s.CONTRACT_SOURCE_SYSTEM,
        CAST(s.SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2)) AS SOURCE_SYSTEM_BALANCE,
        CASE
            WHEN UPPER(TRIM(CAST(s.NON_ACCRUAL_FLAG AS VARCHAR(10)))) IN ('1','Y','YES','TRUE','T') THEN 1
            ELSE 0
        END AS IsNonAccrual
    FROM V_DPRT_CREDIT_INSTRUMENTS s
    WHERE s.GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND CAST(s.END_OF_MONTH_DATE AS DATE) <= DATE '2025-08-31'
      AND s.SOURCE_SYSTEM_BALANCE > 0
),
-- One row per MonthEnd × Account × System within NON-ACCRUAL population
Snapshots AS (
    SELECT
        MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        SUM(SOURCE_SYSTEM_BALANCE) AS Balance
    FROM SnapshotsRaw
    WHERE IsNonAccrual = 1
    GROUP BY MonthEnd, ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
),
Months AS (
    SELECT DISTINCT MonthEnd FROM Snapshots
),
MonthPairs AS (
    SELECT
        m.MonthEnd AS CurrMonth,
        ADD_MONTHS(m.MonthEnd, -1) AS PrevMonth
    FROM Months m
),

-- Pass 1: Current vs Prev (drives Adds + Persisting)
CurrVsPrev AS (
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        c.ACCOUNT_IDENTIFIER,
        c.CONTRACT_SOURCE_SYSTEM,
        c.Balance AS CurrBal,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    JOIN Snapshots c
      ON c.MonthEnd = mp.CurrMonth
    LEFT JOIN Snapshots p
      ON p.MonthEnd = mp.PrevMonth
     AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
     AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

-- Pass 2: Prev not in Curr (drives Removals)
PrevNotCurr AS (
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        p.ACCOUNT_IDENTIFIER,
        p.CONTRACT_SOURCE_SYSTEM,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    JOIN Snapshots p
      ON p.MonthEnd = mp.PrevMonth
    LEFT JOIN Snapshots c
      ON c.MonthEnd = mp.CurrMonth
     AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
     AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
    WHERE c.ACCOUNT_IDENTIFIER IS NULL
),

ComponentsWide AS (
    -- From CurrVsPrev: Adds (prev missing), Persisting (both sides)
    SELECT
        CurrMonth AS MonthEnd,
        SUM(CASE WHEN PrevBal IS NULL THEN CurrBal ELSE 0 END)                  AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)  AS PersistingDelta,
        CAST(0 AS NUMERIC(38,2))                                                AS Removals
    FROM CurrVsPrev
    GROUP BY CurrMonth

    UNION ALL

    -- From PrevNotCurr: Removals (curr missing; record as negative)
    SELECT
        CurrMonth AS MonthEnd,
        CAST(0 AS NUMERIC(38,2))                                                AS Adds,
        CAST(0 AS NUMERIC(38,2))                                                AS PersistingDelta,
        SUM(-PrevBal)                                                           AS Removals
    FROM PrevNotCurr
    GROUP BY CurrMonth
),

Collapsed AS (
    SELECT
        MonthEnd,
        SUM(Adds)            AS Adds,
        SUM(Removals)        AS Removals,
        SUM(PersistingDelta) AS PersistingDelta
    FROM ComponentsWide
    GROUP BY MonthEnd
),

ComponentsLong AS (
    SELECT MonthEnd, 'Adds'             AS Component, Adds            AS AmountSigned, ABS(Adds)            AS AmountAbsolute FROM Collapsed
    UNION ALL
    SELECT MonthEnd, 'Removals'         AS Component, Removals        AS AmountSigned, ABS(Removals)        AS AmountAbsolute FROM Collapsed
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta' AS Component, PersistingDelta AS AmountSigned, ABS(PersistingDelta) AS AmountAbsolute FROM Collapsed
)

SELECT
    MonthEnd,
    Component,
    AmountSigned,     -- Use for algebraic stacking (sums to MoM net change within non-accruals)
    AmountAbsolute    -- Use if you prefer all-positive stacking
FROM ComponentsLong
ORDER BY
    MonthEnd,
    CASE Component WHEN 'Adds' THEN 1 WHEN 'Removals' THEN 2 WHEN 'Persisting Delta' THEN 3 ELSE 4 END;





-- Tab 6: Trend & History — Adds / Removals / Persisting Delta (NON-ACCRUAL ONLY) — NETEZZA
-- Latest cap: 2025-08-31

WITH SnapshotsRaw AS (
    SELECT
        CAST(s.END_OF_MONTH_DATE AS DATE) AS MonthEnd,
        s.ACCOUNT_IDENTIFIER,
        s.CONTRACT_SOURCE_SYSTEM,
        CAST(s.SOURCE_SYSTEM_BALANCE AS NUMERIC(38,2)) AS SOURCE_SYSTEM_BALANCE,
        CASE
            WHEN UPPER(TRIM(CHAR(s.NON_ACCRUAL_FLAG))) IN ('1','Y','YES','TRUE','T') THEN 1 ELSE 0
        END AS IsNonAccrual
    FROM V_DPRT_CREDIT_INSTRUMENTS s
    WHERE s.GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND CAST(s.END_OF_MONTH_DATE AS DATE) <= DATE '2025-08-31'
      AND s.SOURCE_SYSTEM_BALANCE > 0
),
Snapshots AS (
    -- One row per MonthEnd × Account × System within NON-ACCRUAL population
    SELECT
        MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        SUM(SOURCE_SYSTEM_BALANCE) AS Balance
    FROM SnapshotsRaw
    WHERE IsNonAccrual = 1
    GROUP BY MonthEnd, ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
),
Months AS (
    SELECT DISTINCT MonthEnd FROM Snapshots
),
MonthPairs AS (
    -- CurrMonth with its PrevMonth (since MonthEnd is already month-end, just subtract 1 month)
    SELECT
        m.MonthEnd AS CurrMonth,
        ADD_MONTHS(m.MonthEnd, -1) AS PrevMonth
    FROM Months m
),

-- Pass 1: Current vs Prev (drives Adds + Persisting)
CurrVsPrev AS (
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        c.ACCOUNT_IDENTIFIER,
        c.CONTRACT_SOURCE_SYSTEM,
        c.Balance AS CurrBal,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    JOIN Snapshots c
      ON c.MonthEnd = mp.CurrMonth
    LEFT JOIN Snapshots p
      ON p.MonthEnd = mp.PrevMonth
     AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
     AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

-- Pass 2: Prev not in Curr (drives Removals)
PrevNotCurr AS (
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        p.ACCOUNT_IDENTIFIER,
        p.CONTRACT_SOURCE_SYSTEM,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    JOIN Snapshots p
      ON p.MonthEnd = mp.PrevMonth
    LEFT JOIN Snapshots c
      ON c.MonthEnd = mp.CurrMonth
     AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
     AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
    WHERE c.ACCOUNT_IDENTIFIER IS NULL
),

ComponentsWide AS (
    SELECT
        CurrMonth AS MonthEnd,
        SUM(CASE WHEN PrevBal IS NULL THEN CurrBal ELSE 0 END)                         AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)         AS PersistingDelta,
        0::NUMERIC(38,2)                                                                AS Removals
    FROM CurrVsPrev
    GROUP BY CurrMonth

    UNION ALL

    SELECT
        CurrMonth AS MonthEnd,
        0::NUMERIC(38,2)                                                                AS Adds,
        0::NUMERIC(38,2)                                                                AS PersistingDelta,
        SUM(-PrevBal)                                                                   AS Removals
    FROM PrevNotCurr
    GROUP BY CurrMonth
),
-- Collapse any duplicate MonthEnd from UNION ALL above
Collapsed AS (
    SELECT
        MonthEnd,
        SUM(Adds)             AS Adds,
        SUM(Removals)         AS Removals,
        SUM(PersistingDelta)  AS PersistingDelta
    FROM ComponentsWide
    GROUP BY MonthEnd
),

ComponentsLong AS (
    SELECT MonthEnd, 'Adds' AS Component, Adds AS AmountSigned, ABS(Adds) AS AmountAbsolute FROM Collapsed
    UNION ALL
    SELECT MonthEnd, 'Removals', Removals, ABS(Removals) FROM Collapsed
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta', PersistingDelta, ABS(PersistingDelta) FROM Collapsed
)
SELECT
    MonthEnd,
    Component,
    AmountSigned,
    AmountAbsolute
FROM ComponentsLong
ORDER BY
    MonthEnd,
    CASE Component WHEN 'Adds' THEN 1 WHEN 'Removals' THEN 2 WHEN 'Persisting Delta' THEN 3 ELSE 4 END;





/*
Tab 6: Trend & History — Adds / Removals / Persisting Delta (NON-ACCRUAL ONLY)
Source: dbo.V_DPRT_CREDIT_INSTRUMENTS

Uses:
- SOURCE_SYSTEM_BALANCE (only > 0)
- END_OF_MONTH_DATE as the month-end
- Filters GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
- Only NON_ACCRUAL_FLAG = 1/Y/TRUE

Produces: Adds, Removals, PersistingDelta for a stacked area chart.
*/

DECLARE @MaxMonthEnd DATE = '2025-08-31';

WITH SnapshotsRaw AS (
    SELECT
        CAST(s.END_OF_MONTH_DATE AS date) AS MonthEnd,
        s.ACCOUNT_IDENTIFIER,
        s.CONTRACT_SOURCE_SYSTEM,
        CAST(s.SOURCE_SYSTEM_BALANCE AS DECIMAL(38,2)) AS SOURCE_SYSTEM_BALANCE,
        CASE
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS INT) = 1 THEN 1
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS BIT) = 1 THEN 1
            WHEN UPPER(CONVERT(NVARCHAR(10), s.NON_ACCRUAL_FLAG)) IN ('Y','YES','TRUE') THEN 1
            ELSE 0
        END AS IsNonAccrual
    FROM dbo.V_DPRT_CREDIT_INSTRUMENTS s
    WHERE s.GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND CAST(s.END_OF_MONTH_DATE AS date) <= @MaxMonthEnd
      AND s.SOURCE_SYSTEM_BALANCE > 0
),
Snapshots AS (
    SELECT
        MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        SUM(SOURCE_SYSTEM_BALANCE) AS Balance
    FROM SnapshotsRaw
    WHERE IsNonAccrual = 1
    GROUP BY MonthEnd, ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
),
MonthPairs AS (
    SELECT DISTINCT
        m.MonthEnd AS CurrMonth,
        EOMONTH(DATEADD(MONTH, -1, m.MonthEnd)) AS PrevMonth
    FROM Snapshots m
),
Paired AS (
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
        COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
        c.Balance AS CurrBal,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    LEFT JOIN Snapshots c
        ON c.MonthEnd = mp.CurrMonth
    FULL OUTER JOIN Snapshots p
        ON p.MonthEnd = mp.PrevMonth
       AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
       AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),
ComponentsWide AS (
    SELECT
        CurrMonth AS MonthEnd,
        SUM(CASE WHEN PrevBal IS NULL AND CurrBal IS NOT NULL THEN CurrBal ELSE 0 END) AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NULL THEN -PrevBal ELSE 0 END) AS Removals,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END) AS PersistingDelta
    FROM Paired
    WHERE CurrMonth IS NOT NULL
    GROUP BY CurrMonth
),
ComponentsLong AS (
    SELECT MonthEnd, 'Adds' AS Component, Adds AS AmountSigned, ABS(Adds) AS AmountAbsolute FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Removals', Removals, ABS(Removals) FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta', PersistingDelta, ABS(PersistingDelta) FROM ComponentsWide
)
SELECT
    MonthEnd,
    Component,
    AmountSigned,
    AmountAbsolute
FROM ComponentsLong
ORDER BY
    MonthEnd,
    CASE Component WHEN 'Adds' THEN 1 WHEN 'Removals' THEN 2 WHEN 'Persisting Delta' THEN 3 ELSE 4 END;





/*
Tab 6: Trend & History — Adds / Removals / Persisting Delta (NON-ACCRUAL ONLY)
Source: dbo.V_DPRT_CREDIT_INSTRUMENTS

- Adds:        Curr-only non-accruals (sum of SOURCE_SYSTEM_BALANCE, positive)
- Removals:    Prev-only non-accruals (negative sum of SOURCE_SYSTEM_BALANCE)
- Persisting:  Accounts in both months; amount = CurrBal - PrevBal

All three components sum to the net MoM change within the NON-ACCRUAL population.
*/

DECLARE @MaxMonthEnd DATE = '2025-08-31';

WITH SnapshotsRaw AS (
    SELECT
        CAST(s.END_OF_MONTH_DATE AS date) AS MonthEnd,       -- already month-end
        s.ACCOUNT_IDENTIFIER,
        s.CONTRACT_SOURCE_SYSTEM,
        CAST(s.SOURCE_SYSTEM_BALANCE AS DECIMAL(38,2)) AS SOURCE_SYSTEM_BALANCE,
        CASE
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS INT) = 1 THEN 1
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS BIT) = 1 THEN 1
            WHEN UPPER(CONVERT(NVARCHAR(10), s.NON_ACCRUAL_FLAG)) IN ('Y','YES','TRUE') THEN 1
            ELSE 0
        END AS IsNonAccrual
    FROM dbo.V_DPRT_CREDIT_INSTRUMENTS s
    WHERE s.GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
      AND CAST(s.END_OF_MONTH_DATE AS date) <= @MaxMonthEnd
      AND s.SOURCE_SYSTEM_BALANCE > 0
),
-- Reduce to one row per MonthEnd × Account × System within NON-ACCRUAL population
Snapshots AS (
    SELECT
        MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        SUM(SOURCE_SYSTEM_BALANCE) AS Balance
    FROM SnapshotsRaw
    WHERE IsNonAccrual = 1
    GROUP BY MonthEnd, ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
),
Months AS (
    SELECT DISTINCT MonthEnd FROM Snapshots
),
MonthPairs AS (
    SELECT
        m.MonthEnd AS CurrMonth,
        EOMONTH(DATEADD(MONTH, -1, m.MonthEnd)) AS PrevMonth
    FROM Months m
),
Paired AS (
    -- Capture adds (curr only), removals (prev only), and persisting (both)
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER)        AS ACCOUNT_IDENTIFIER,
        COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
        c.Balance AS CurrBal,
        p.Balance AS PrevBal
    FROM MonthPairs mp
    LEFT JOIN Snapshots c
        ON c.MonthEnd = mp.CurrMonth
    FULL OUTER JOIN Snapshots p
        ON p.MonthEnd = mp.PrevMonth
       AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
       AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),
ComponentsWide AS (
    SELECT
        CurrMonth AS MonthEnd,
        -- Uncomment next line to break series by system (and add to GROUP BY)
        -- CONTRACT_SOURCE_SYSTEM,

        SUM(CASE WHEN PrevBal IS NULL AND CurrBal IS NOT NULL THEN CurrBal ELSE 0 END)                         AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NULL THEN -PrevBal ELSE 0 END)                         AS Removals,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)          AS PersistingDelta
    FROM Paired
    WHERE CurrMonth IS NOT NULL
    GROUP BY CurrMonth
    -- , CONTRACT_SOURCE_SYSTEM
),
ComponentsLong AS (
    SELECT MonthEnd, 'Adds' AS Component, Adds AS AmountSigned, ABS(Adds) AS AmountAbsolute FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Removals', Removals, ABS(Removals) FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta', PersistingDelta, ABS(PersistingDelta) FROM ComponentsWide
)
SELECT
    MonthEnd,
    Component,
    AmountSigned,     -- Use for algebraic stacking (sums to MoM net change)
    AmountAbsolute    -- Use if you prefer all-positive stacking
FROM ComponentsLong
ORDER BY
    MonthEnd,
    CASE Component WHEN 'Adds' THEN 1 WHEN 'Removals' THEN 2 WHEN 'Persisting Delta' THEN 3 ELSE 4 END;







/*
Tab 6: Trend & History — Adds / Removals / Persisting Delta (NON-ACCRUAL ONLY)
Source: dbo.V_DPRT_CREDIT_INSTRUMENTS

Definitions:
- Adds:        Curr-only non-accruals (balance counted positive)
- Removals:    Prev-only non-accruals (balance counted NEGATIVE)
- Persisting:  Non-accrual in both months; amount = CurrBal - PrevBal

All three sum to the net MoM change within the NON-ACCRUAL population.

Assumptions/Filters:
- GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
- Latest month-end available = '2025-08-31'
- If date is already month-end, EOMONTH() is harmless.
*/

DECLARE @MaxMonthEnd DATE = '2025-08-31';
-- Optional: limit the window (comment out to use all history up to @MaxMonthEnd)
-- DECLARE @StartMonth DATE = '2024-01-01';

WITH SnapshotsRaw AS (
    SELECT
        EOMONTH(CAST(s.LOAD_DATE AS date)) AS MonthEnd,
        s.ACCOUNT_IDENTIFIER,
        s.CONTRACT_SOURCE_SYSTEM,
        CAST(s.GL_BALANCE AS DECIMAL(38,2)) AS GL_BALANCE,
        CASE
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS INT) = 1 THEN 1
            WHEN TRY_CAST(s.NON_ACCRUAL_FLAG AS BIT) = 1 THEN 1
            WHEN UPPER(CONVERT(NVARCHAR(10), s.NON_ACCRUAL_FLAG)) IN ('Y','YES','TRUE') THEN 1
            ELSE 0
        END AS IsNonAccrual
    FROM dbo.V_DPRT_CREDIT_INSTRUMENTS s
    WHERE s.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      AND EOMONTH(CAST(s.LOAD_DATE AS date)) <= @MaxMonthEnd
      -- AND EOMONTH(CAST(s.LOAD_DATE AS date)) >= @StartMonth  -- (optional)
),
-- Reduce to one row per MonthEnd × Account × System within NON-ACCRUAL population
Snapshots AS (
    SELECT
        MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        SUM(GL_BALANCE) AS GL_BALANCE
    FROM SnapshotsRaw
    WHERE IsNonAccrual = 1
    GROUP BY MonthEnd, ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
),
Months AS (
    SELECT DISTINCT MonthEnd FROM Snapshots
),
MonthPairs AS (
    SELECT
        m.MonthEnd AS CurrMonth,
        EOMONTH(DATEADD(MONTH, -1, m.MonthEnd)) AS PrevMonth
    FROM Months m
),
Paired AS (
    -- FULL OUTER JOIN prev vs curr to capture adds/removals/persisting
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
        COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
        c.GL_BALANCE AS CurrBal,
        p.GL_BALANCE AS PrevBal
    FROM MonthPairs mp
    LEFT JOIN Snapshots c
        ON c.MonthEnd = mp.CurrMonth
    FULL OUTER JOIN Snapshots p
        ON p.MonthEnd = mp.PrevMonth
       AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
       AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),
ComponentsWide AS (
    SELECT
        CurrMonth AS MonthEnd,
        -- Uncomment next line to break the series out by system (and add to GROUP BY)
        -- CONTRACT_SOURCE_SYSTEM,

        SUM(CASE WHEN PrevBal IS NULL AND CurrBal IS NOT NULL THEN CurrBal ELSE 0 END)                         AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NULL THEN -PrevBal ELSE 0 END)                         AS Removals,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)          AS PersistingDelta
    FROM Paired
    WHERE CurrMonth IS NOT NULL
    GROUP BY CurrMonth
    -- , CONTRACT_SOURCE_SYSTEM
),
ComponentsLong AS (
    SELECT MonthEnd, 'Adds' AS Component, Adds AS AmountSigned, ABS(Adds) AS AmountAbsolute FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Removals', Removals, ABS(Removals) FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta', PersistingDelta, ABS(PersistingDelta) FROM ComponentsWide
)
SELECT
    MonthEnd,
    Component,
    AmountSigned,    -- Use for algebraic stacking (sums to MoM net change within non-accruals)
    AmountAbsolute   -- Use if you prefer all-positive stacking
FROM ComponentsLong
ORDER BY
    MonthEnd,
    CASE Component WHEN 'Adds' THEN 1 WHEN 'Removals' THEN 2 WHEN 'Persisting Delta' THEN 3 ELSE 4 END;





/*
Tab 6: Trend & History — Stacked Area: Adds, Removals, Persisting Delta
- Adds: balance of accounts that appear this month but not last month
- Removals: negative balance of accounts that were in last month but not this month
- Persisting Delta: change for accounts present in both months
All three components sum to the net month-over-month change.

PARAMS to adjust:
  @StartMonth / @EndMonth   -- inclusive bounds for trend window
  Table: dbo.MonthlyPortfolio   -- replace with your table/view
  Filters: GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' (keep / adjust)
           CONTRACT_SOURCE_SYSTEM filter (optional)
*/

DECLARE @StartMonth DATE = '2024-01-01';
DECLARE @EndMonth   DATE = '2025-09-30';
DECLARE @SystemFilter NVARCHAR(100) = NULL; -- e.g. 'ACBS' or NULL for all

WITH Snapshots AS (
    SELECT
        EOMONTH(CAST(AsOfDate AS date))        AS MonthEnd,
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        CAST(GL_BALANCE AS DECIMAL(38,2))      AS GL_BALANCE
    FROM dbo.MonthlyPortfolio   -- TODO: replace with your table/view name
    WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      AND EOMONTH(CAST(AsOfDate AS date)) BETWEEN @StartMonth AND @EndMonth
      AND (@SystemFilter IS NULL OR CONTRACT_SOURCE_SYSTEM = @SystemFilter)
),
Months AS (
    SELECT DISTINCT MonthEnd
    FROM Snapshots
),
MonthPairs AS (
    -- Pair each month with its previous month (only where we have data for the current month)
    SELECT
        m.MonthEnd                 AS CurrMonth,
        EOMONTH(DATEADD(MONTH,-1,m.MonthEnd)) AS PrevMonth
    FROM Months m
),
PairedSnapshots AS (
    -- FULL OUTER JOIN to capture adds (only curr), removals (only prev), and persisting (both)
    SELECT
        mp.CurrMonth,
        mp.PrevMonth,
        COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
        COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
        c.GL_BALANCE AS CurrBal,
        p.GL_BALANCE AS PrevBal
    FROM MonthPairs mp
    LEFT JOIN Snapshots c
        ON c.MonthEnd = mp.CurrMonth
    FULL OUTER JOIN Snapshots p
        ON p.MonthEnd = mp.PrevMonth
       AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
       AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),
ComponentsWide AS (
    SELECT
        CurrMonth AS MonthEnd,
        -- Signed components that sum to total MoM change
        SUM(CASE WHEN PrevBal IS NULL AND CurrBal IS NOT NULL THEN CurrBal ELSE 0 END)                          AS Adds,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NULL THEN -PrevBal ELSE 0 END)                          AS Removals,
        SUM(CASE WHEN PrevBal IS NOT NULL AND CurrBal IS NOT NULL THEN (CurrBal - PrevBal) ELSE 0 END)           AS PersistingDelta
    FROM PairedSnapshots
    -- Only months where we have a "current" (CurrMonth) snapshot are meaningful for the chart
    WHERE CurrMonth IS NOT NULL
    GROUP BY CurrMonth
),
-- Long form (tidy) for Power BI stacked area chart
ComponentsLong AS (
    SELECT MonthEnd, 'Adds' AS Component, Adds AS AmountSigned, ABS(Adds) AS AmountAbsolute FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Removals', Removals, ABS(Removals) FROM ComponentsWide
    UNION ALL
    SELECT MonthEnd, 'Persisting Delta', PersistingDelta, ABS(PersistingDelta) FROM ComponentsWide
)
SELECT
    MonthEnd,
    Component,
    AmountSigned,     -- use this if you want components to algebraically sum to MoM net change
    AmountAbsolute    -- use this if you want all-positive stacking for area charts
FROM ComponentsLong
ORDER BY MonthEnd, CASE Component
    WHEN 'Adds' THEN 1
    WHEN 'Removals' THEN 2
    WHEN 'Persisting Delta' THEN 3
    ELSE 4 END;







WITH params AS (
  SELECT DATE '2025-08-31' AS curr_eom, 24 AS months_back
),
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS eom,
      Account_Identifier,
      MAX(COALESCE(Days_Past_Due,0))  AS dpd,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2
)
SELECT
  eom,
  AVG(dpd)::NUMERIC                                    AS avg_dpd_accounts,
  (SUM(dpd * bal) / NULLIF(SUM(bal),0))::NUMERIC       AS wavg_dpd_balance,
  SUM(bal)::NUMERIC                                    AS total_balance,
  COUNT(DISTINCT Account_Identifier)::INT              AS account_count
FROM pop
GROUP BY eom
ORDER BY eom;





WITH params AS (
  SELECT DATE '2025-08-31' AS curr_eom, 24 AS months_back
),
raw AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS eom,
      Account_Identifier,
      MAX(UPPER(TRIM(PD_GRADE)))          AS pd_raw,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2
),
pd_clean AS (
  SELECT
    eom, Account_Identifier, bal, pd_raw,
    TRANSLATE(pd_raw,'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz _-()/\[]{}|=+*,','') AS pd_digits_only
  FROM raw
),
pd_mapped AS (
  SELECT
    eom, Account_Identifier, bal,
    CASE
      WHEN LENGTH(TRANSLATE(pd_digits_only,'0123456789.','')) = 0 AND pd_digits_only <> '' THEN CAST(pd_digits_only AS NUMERIC)
      WHEN pd_raw='A' THEN 1 WHEN pd_raw='B' THEN 2 WHEN pd_raw='C' THEN 3 WHEN pd_raw='D' THEN 4
      WHEN pd_raw='E' THEN 5 WHEN pd_raw='F' THEN 6 WHEN pd_raw='G' THEN 7 WHEN pd_raw='H' THEN 8
      ELSE NULL
    END::NUMERIC AS pd_num
  FROM pd_clean
)
SELECT
  eom,
  AVG(pd_num)::NUMERIC                                      AS avg_pd_accounts,
  (SUM(pd_num * bal) / NULLIF(SUM(bal),0))::NUMERIC         AS wavg_pd_balance,
  SUM(bal)::NUMERIC                                         AS total_balance,
  COUNT(DISTINCT Account_Identifier)::INT                   AS account_count
FROM pd_mapped
GROUP BY eom
ORDER BY eom;













/* === PD_GRADE over time (avg & weighted) — REGEX-FREE for Netezza === */
WITH params AS (
  SELECT
    DATE '2025-08-31' AS curr_eom,
    24                AS months_back
),

/* 1) Base: one row per account per month */
raw AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)     AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      /* keep raw PD and balance */
      MAX(UPPER(TRIM(PD_GRADE)))          AS pd_raw,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3,4
),

/* 2) Clean PD: try numeric by stripping letters/spaces/punct; else map letters A..H */
pd_clean AS (
  SELECT
    r.eom,
    r.Bank_Code,
    r.Contract_Source_System,
    r.Account_Identifier,
    r.bal,
    r.pd_raw,
    /* remove letters and common separators to isolate digits/decimal */
    TRANSLATE(
      r.pd_raw,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz _-()/\[]{}|=+*,',
      ''
    ) AS pd_digits_only
  FROM raw r
),

/* 3) Safe numeric mapping without regex or risky casts */
pd_mapped AS (
  SELECT
    p.eom,
    p.Bank_Code,
    p.Contract_Source_System,
    p.Account_Identifier,
    p.bal,
    /* If pd_digits_only contains only digits/dot, cast it; else try letter mapping; else NULL */
    CASE
      WHEN LENGTH(TRANSLATE(p.pd_digits_only, '0123456789.', '')) = 0
           AND p.pd_digits_only <> ''  -- non-empty after stripping
        THEN CAST(p.pd_digits_only AS NUMERIC)
      WHEN p.pd_raw = 'A' THEN 1
      WHEN p.pd_raw = 'B' THEN 2
      WHEN p.pd_raw = 'C' THEN 3
      WHEN p.pd_raw = 'D' THEN 4
      WHEN p.pd_raw = 'E' THEN 5
      WHEN p.pd_raw = 'F' THEN 6
      WHEN p.pd_raw = 'G' THEN 7
      WHEN p.pd_raw = 'H' THEN 8
      ELSE NULL
    END::NUMERIC AS pd_num
  FROM pd_clean p
)

/* 4) Output monthly metrics (use as line chart source) */
SELECT
  m.eom,
  m.Bank_Code,
  m.Contract_Source_System,
  AVG(m.pd_num)::NUMERIC                                   AS avg_pd_accounts,   -- simple average across accounts
  (SUM(m.pd_num * m.bal) / NULLIF(SUM(m.bal),0))::NUMERIC  AS wavg_pd_balance,   -- balance-weighted average
  SUM(m.bal)::NUMERIC                                      AS total_balance,
  COUNT(DISTINCT m.Account_Identifier)::INT                AS account_count
FROM pd_mapped m
GROUP BY m.eom, m.Bank_Code, m.Contract_Source_System
ORDER BY m.eom, m.Bank_Code, m.Contract_Source_System;







/* === DPD over time === */
WITH params AS (
  SELECT
    DATE '2025-08-31' AS curr_eom,       -- set current EOM
    24                AS months_back     -- pull this many months including curr
),
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)    AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(COALESCE(Days_Past_Due,0))     AS days_past_due,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3,4
)
/* Portfolio + (optionally) Bank/System */
SELECT
  p.eom,
  p.Bank_Code,
  p.Contract_Source_System,
  AVG(p.days_past_due)::NUMERIC                    AS avg_dpd_accounts,        -- simple avg across accounts
  (SUM(p.days_past_due * p.bal) / NULLIF(SUM(p.bal),0))::NUMERIC AS wavg_dpd_balance, -- balance-weighted
  SUM(p.bal)::NUMERIC                              AS total_balance,
  COUNT(DISTINCT p.Account_Identifier)::INT        AS account_count
FROM pop p
GROUP BY p.eom, p.Bank_Code, p.Contract_Source_System
ORDER BY p.eom, p.Bank_Code, p.Contract_Source_System;





/* === PD_GRADE over time (avg & weighted) === */
WITH params AS (
  SELECT
    DATE '2025-08-31' AS curr_eom,
    24                AS months_back
),
raw AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)    AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(UPPER(TRIM(PD_GRADE)))         AS pd_raw,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3,4
),
/* Try to coerce PD_GRADE to numeric */
pd_mapped AS (
  SELECT
    r.eom,
    r.Bank_Code,
    r.Contract_Source_System,
    r.Account_Identifier,
    r.bal,
    /* 1) direct numeric */
    CASE
      WHEN r.pd_raw ~ '^[0-9]+(\.[0-9]+)?$'
        THEN CAST(r.pd_raw AS NUMERIC)
      /* 2) extract digits from things like 'PD3', 'GRADE-4' */
      WHEN REGEXP_REPLACE(r.pd_raw, '[^0-9\.]', '') ~ '^[0-9]+(\.[0-9]+)?$'
        THEN CAST(REGEXP_REPLACE(r.pd_raw, '[^0-9\.]', '') AS NUMERIC)
      /* 3) letter fallback (tweak mapping if your scale differs) */
      WHEN r.pd_raw IN ('A') THEN 1
      WHEN r.pd_raw IN ('B') THEN 2
      WHEN r.pd_raw IN ('C') THEN 3
      WHEN r.pd_raw IN ('D') THEN 4
      WHEN r.pd_raw IN ('E') THEN 5
      WHEN r.pd_raw IN ('F') THEN 6
      WHEN r.pd_raw IN ('G') THEN 7
      WHEN r.pd_raw IN ('H') THEN 8
      ELSE NULL
    END::NUMERIC AS pd_num
  FROM raw r
)
/* Portfolio + (optionally) Bank/System */
SELECT
  p.eom,
  p.Bank_Code,
  p.Contract_Source_System,
  AVG(p.pd_num)::NUMERIC                                         AS avg_pd_accounts,          -- simple avg across accts
  (SUM(p.pd_num * p.bal) / NULLIF(SUM(p.bal),0))::NUMERIC        AS wavg_pd_balance,          -- balance-weighted
  SUM(p.bal)::NUMERIC                                            AS total_balance,
  COUNT(DISTINCT p.Account_Identifier)::INT                      AS account_count,
  COUNT(*)::INT                                                  AS rows_used_for_avg         -- helps spot NULL mapping cases
FROM pd_mapped p
GROUP BY p.eom, p.Bank_Code, p.Contract_Source_System
ORDER BY p.eom, p.Bank_Code, p.Contract_Source_System;








/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-08-31' AS curr_eom,              -- set current EOM
    NULL::VARCHAR(50)  AS bank_code_filter,     -- optional: e.g. '123'; NULL = all
    NULL::VARCHAR(100) AS system_filter         -- optional: e.g. 'ACBS'; NULL = all
),

/* ===== Base at account level (current EOM, NA only) ===== */
curr_accts AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)         AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                       AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC     AS Curr_Bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND ( (SELECT bank_code_filter  FROM params) IS NULL
          OR Bank_Code = (SELECT bank_code_filter  FROM params) )
    AND ( (SELECT system_filter FROM params) IS NULL
          OR Contract_Source_System = (SELECT system_filter FROM params) )
  GROUP BY 1,2,3,4
),

/* ===== Per-system ranking & totals ===== */
ranked_sys AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    Account_Identifier,
    Account_Name,
    Curr_Bal,
    ROW_NUMBER() OVER (
      PARTITION BY Bank_Code, Contract_Source_System
      ORDER BY Curr_Bal DESC NULLS LAST, Account_Identifier
    ) AS rnk_sys,
    SUM(Curr_Bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System
    ) AS sys_total
  FROM curr_accts
),

concentration_sys AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    SUM(CASE WHEN rnk_sys <= 5 THEN Curr_Bal ELSE 0 END)::NUMERIC AS top5_bal,
    MAX(sys_total)::NUMERIC AS sys_total
  FROM ranked_sys
  GROUP BY 1,2
),

/* ===== Portfolio-wide ranking & totals (across all accounts) ===== */
ranked_portfolio AS (
  SELECT
    Account_Identifier,
    Account_Name,
    Curr_Bal,
    ROW_NUMBER() OVER (
      ORDER BY Curr_Bal DESC NULLS LAST, Account_Identifier
    ) AS rnk_all,
    SUM(Curr_Bal) OVER () AS portfolio_total
  FROM curr_accts
),

concentration_portfolio AS (
  SELECT
    SUM(CASE WHEN rnk_all <= 5 THEN Curr_Bal ELSE 0 END)::NUMERIC AS top5_bal_portfolio,
    MAX(portfolio_total)::NUMERIC AS portfolio_total
  FROM ranked_portfolio
)

/* ===================== FINAL OUTPUT ===================== */
-- A) Portfolio (single row)
SELECT
  'PORTFOLIO_TOP5_SHARE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params)       AS eom,
  NULL::VARCHAR(50)                   AS Bank_Code,
  NULL::VARCHAR(100)                  AS Contract_Source_System,
  p.top5_bal_portfolio                AS top5_balance,
  p.portfolio_total                   AS total_balance,
  CASE WHEN p.portfolio_total = 0 THEN NULL
       ELSE p.top5_bal_portfolio / NULLIF(p.portfolio_total,0) END AS top5_share_pct
FROM concentration_portfolio p

UNION ALL

-- B) By Bank × System (one row per system)
SELECT
  'SYSTEM_TOP5_SHARE'::VARCHAR(30)    AS section,
  (SELECT curr_eom FROM params)       AS eom,
  s.Bank_Code,
  s.Contract_Source_System,
  s.top5_bal                          AS top5_balance,
  s.sys_total                         AS total_balance,
  CASE WHEN s.sys_total = 0 THEN NULL
       ELSE s.top5_bal / NULLIF(s.sys_total,0) END AS top5_share_pct
FROM concentration_sys s

ORDER BY section, Bank_Code, Contract_Source_System;








/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,         -- << set current EOM
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom,
    25::INT                           AS top_n_persist,    -- only for persisting movers (set NULL to return all)
    0::NUMERIC                        AS min_size,         -- min $ for Adds/Removals (filter noise)
    0::NUMERIC                        AS min_abs_delta,    -- min |$| for persisting movers
    NULL::VARCHAR(50)                 AS bank_code,        -- optional filter; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system  -- optional filter; NULL = all
),

/* ===================== BASE POPULATION (one row per acct/month) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)       AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                     AS Account_Name,
      /* Drop if not in your table */
      MAX(PD_GRADE)                         AS PD_GRADE,
      MAX(COALESCE(Days_Past_Due,0))        AS Days_Past_Due,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))    AS Non_Accrual_Flag,
      SUM(Source_System_Balance)::NUMERIC   AS Source_System_Balance
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA (aggregated) ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    MAX(PD_GRADE)     AS PD_GRADE,
    MAX(Days_Past_Due) AS Days_Past_Due,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    MAX(PD_GRADE)     AS PD_GRADE,
    MAX(Days_Past_Due) AS Days_Past_Due,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== CLASSIFY MOM STATUS ===================== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    COALESCE(c.PD_GRADE,              p.PD_GRADE)               AS PD_GRADE,
    COALESCE(c.Days_Past_Due,         p.Days_Past_Due)          AS Days_Past_Due,
    p.Prev_Bal,
    c.Curr_Bal,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR COALESCE(c.Bank_Code,p.Bank_Code) = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR COALESCE(c.Contract_Source_System,p.Contract_Source_System) = (SELECT contract_source_system FROM params) )
),

/* ===================== DATASETS ===================== */
/* All Adds (no Top-N) */
adds_all AS (
  SELECT
    m.Bank_Code,
    m.Contract_Source_System,
    m.Account_Identifier,
    m.Account_Name,
    m.PD_GRADE,
    m.Days_Past_Due,
    m.Prev_Bal,
    m.Curr_Bal,
    COALESCE(m.Curr_Bal,0) AS size_metric
  FROM mom m
  WHERE m.NA_Transition = 'ADD'
    AND COALESCE(m.Curr_Bal,0) >= (SELECT min_size FROM params)
),

/* All Removals (no Top-N) */
rem_all AS (
  SELECT
    m.Bank_Code,
    m.Contract_Source_System,
    m.Account_Identifier,
    m.Account_Name,
    m.PD_GRADE,
    m.Days_Past_Due,
    m.Prev_Bal,
    m.Curr_Bal,
    COALESCE(m.Prev_Bal,0) AS size_metric
  FROM mom m
  WHERE m.NA_Transition = 'REMOVAL'
    AND COALESCE(m.Prev_Bal,0) >= (SELECT min_size FROM params)
),

/* Persisting Movers (keep optional Top-N by |delta|) */
persist_ranked AS (
  SELECT
    c.Bank_Code,
    c.Contract_Source_System,
    c.Account_Identifier,
    COALESCE(c.Account_Name, p.Account_Name) AS Account_Name,
    COALESCE(c.PD_GRADE, p.PD_GRADE)         AS PD_GRADE,
    COALESCE(c.Days_Past_Due, p.Days_Past_Due) AS Days_Past_Due,
    p.Prev_Bal,
    c.Curr_Bal,
    (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) AS delta,
    ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) AS size_metric,
    CASE WHEN (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) >= 0 THEN 'UP' ELSE 'DOWN' END AS direction,
    ROW_NUMBER() OVER (
      PARTITION BY c.Bank_Code, c.Contract_Source_System
      ORDER BY ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) DESC NULLS LAST, c.Account_Identifier
    ) AS rnk_sys
  FROM curr_agg c
  INNER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  WHERE ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) >= (SELECT min_abs_delta FROM params)
)

/* ===================== FINAL OUTPUT (3 sections) ===================== */
-- ADDS TABLE (all)
SELECT
  'ADDS_TABLE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  a.Bank_Code,
  a.Contract_Source_System,
  a.Account_Identifier,
  a.Account_Name,
  a.PD_GRADE,
  a.Days_Past_Due,
  a.Prev_Bal,
  a.Curr_Bal,
  NULL::NUMERIC AS delta,
  NULL::VARCHAR(5) AS direction,
  a.size_metric,
  NULL::INT AS rnk_sys
FROM adds_all a

UNION ALL

-- REMOVALS TABLE (all)
SELECT
  'REMOVALS_TABLE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  r.Bank_Code,
  r.Contract_Source_System,
  r.Account_Identifier,
  r.Account_Name,
  r.PD_GRADE,
  r.Days_Past_Due,
  r.Prev_Bal,
  r.Curr_Bal,
  NULL::NUMERIC AS delta,
  NULL::VARCHAR(5) AS direction,
  r.size_metric,
  NULL::INT AS rnk_sys
FROM rem_all r

UNION ALL

-- PERSISTING MOVERS (Top-N optional; send all by setting top_n_persist = NULL)
SELECT
  'PERSISTING_MOVERS'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  p.Bank_Code,
  p.Contract_Source_System,
  p.Account_Identifier,
  p.Account_Name,
  p.PD_GRADE,
  p.Days_Past_Due,
  p.Prev_Bal,
  p.Curr_Bal,
  p.delta,
  p.direction,
  p.size_metric,
  p.rnk_sys
FROM persist_ranked p
WHERE (SELECT top_n_persist FROM params) IS NULL
   OR p.rnk_sys <= (SELECT top_n_persist FROM params)

ORDER BY
  1,            -- section
  3, 4,         -- Bank, System
  12 DESC NULLS LAST,  -- direction not used for Adds/Removals; keeps movers UP before DOWN when using delta as value
  13 DESC NULLS LAST;  -- size_metric







/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,         -- << set current EOM
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom,
    25::INT                           AS top_n,            -- Top N per Bank×System for each section
    0::NUMERIC                        AS min_size,         -- min $ for Adds/Removals
    0::NUMERIC                        AS min_abs_delta,    -- min |$| for persisting movers
    NULL::VARCHAR(50)                 AS bank_code,        -- optional filter; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system  -- optional filter; NULL = all
),

/* ===================== BASE POPULATION (one row per acct/month) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)       AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                     AS Account_Name,
      -- Keep PD_GRADE / DPD if present; drop these lines if not in your table
      MAX(PD_GRADE)                         AS PD_GRADE,
      MAX(COALESCE(Days_Past_Due,0))        AS Days_Past_Due,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))    AS Non_Accrual_Flag,
      SUM(Source_System_Balance)::NUMERIC   AS Source_System_Balance
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA (aggregated) ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    MAX(PD_GRADE)     AS PD_GRADE,
    MAX(Days_Past_Due) AS Days_Past_Due,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    MAX(PD_GRADE)     AS PD_GRADE,
    MAX(Days_Past_Due) AS Days_Past_Due,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== CLASSIFY MOM STATUS ===================== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    COALESCE(c.PD_GRADE,              p.PD_GRADE)               AS PD_GRADE,
    COALESCE(c.Days_Past_Due,         p.Days_Past_Due)          AS Days_Past_Due,
    p.Prev_Bal,
    c.Curr_Bal,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR COALESCE(c.Bank_Code,p.Bank_Code) = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR COALESCE(c.Contract_Source_System,p.Contract_Source_System) = (SELECT contract_source_system FROM params) )
),

/* ===================== RANKINGS ===================== */
adds_ranked AS (
  SELECT
    m.*,
    COALESCE(m.Curr_Bal,0) AS size_metric,
    ROW_NUMBER() OVER (
      PARTITION BY m.Bank_Code, m.Contract_Source_System
      ORDER BY COALESCE(m.Curr_Bal,0) DESC NULLS LAST, m.Account_Identifier
    ) AS rnk_sys
  FROM mom m
  WHERE m.NA_Transition = 'ADD'
    AND COALESCE(m.Curr_Bal,0) >= (SELECT min_size FROM params)
),
rem_ranked AS (
  SELECT
    m.*,
    COALESCE(m.Prev_Bal,0) AS size_metric,
    ROW_NUMBER() OVER (
      PARTITION BY m.Bank_Code, m.Contract_Source_System
      ORDER BY COALESCE(m.Prev_Bal,0) DESC NULLS LAST, m.Account_Identifier
    ) AS rnk_sys
  FROM mom m
  WHERE m.NA_Transition = 'REMOVAL'
    AND COALESCE(m.Prev_Bal,0) >= (SELECT min_size FROM params)
),
persist_ranked AS (
  SELECT
    c.Bank_Code,
    c.Contract_Source_System,
    c.Account_Identifier,
    COALESCE(c.Account_Name, p.Account_Name) AS Account_Name,
    COALESCE(c.PD_GRADE, p.PD_GRADE)         AS PD_GRADE,
    COALESCE(c.Days_Past_Due, p.Days_Past_Due) AS Days_Past_Due,
    p.Prev_Bal,
    c.Curr_Bal,
    (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) AS delta,
    ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) AS size_metric,
    CASE WHEN (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) >= 0 THEN 'UP' ELSE 'DOWN' END AS direction,
    ROW_NUMBER() OVER (
      PARTITION BY c.Bank_Code, c.Contract_Source_System
      ORDER BY ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) DESC NULLS LAST, c.Account_Identifier
    ) AS rnk_sys
  FROM curr_agg c
  INNER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  WHERE ABS(COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) >= (SELECT min_abs_delta FROM params)
)

/* ===================== FINAL OUTPUT (3 sections) ===================== */
-- ADDS TABLE
SELECT
  'ADDS_TABLE'::VARCHAR(30) AS section,          -- col 1
  (SELECT curr_eom FROM params) AS eom,          -- col 2
  a.Bank_Code,                                    -- col 3
  a.Contract_Source_System,                       -- col 4
  a.Account_Identifier,                           -- col 5
  a.Account_Name,                                 -- col 6
  a.PD_GRADE,                                     -- col 7
  a.Days_Past_Due,                                -- col 8
  a.Prev_Bal,                                     -- col 9
  a.Curr_Bal,                                     -- col10
  NULL::NUMERIC AS delta,                         -- col11 (not used for adds)
  NULL::VARCHAR(5) AS direction,                  -- col12
  a.size_metric,                                  -- col13 (Curr_Bal)
  a.rnk_sys                                       -- col14
FROM adds_ranked a
WHERE a.rnk_sys <= (SELECT top_n FROM params)

UNION ALL

-- REMOVALS TABLE
SELECT
  'REMOVALS_TABLE'::VARCHAR(30) AS section,       -- col 1
  (SELECT curr_eom FROM params) AS eom,          -- col 2
  r.Bank_Code,                                    -- col 3
  r.Contract_Source_System,                       -- col 4
  r.Account_Identifier,                           -- col 5
  r.Account_Name,                                 -- col 6
  r.PD_GRADE,                                     -- col 7
  r.Days_Past_Due,                                -- col 8
  r.Prev_Bal,                                     -- col 9
  r.Curr_Bal,                                     -- col10
  NULL::NUMERIC AS delta,                         -- col11 (not used for removals)
  NULL::VARCHAR(5) AS direction,                  -- col12
  r.size_metric,                                  -- col13 (Prev_Bal)
  r.rnk_sys                                       -- col14
FROM rem_ranked r
WHERE r.rnk_sys <= (SELECT top_n FROM params)

UNION ALL

-- PERSISTING MOVERS (bar chart: plot size_metric or delta by Account_Name)
SELECT
  'PERSISTING_MOVERS'::VARCHAR(30) AS section,    -- col 1
  (SELECT curr_eom FROM params) AS eom,          -- col 2
  p.Bank_Code,                                    -- col 3
  p.Contract_Source_System,                       -- col 4
  p.Account_Identifier,                           -- col 5
  p.Account_Name,                                 -- col 6
  p.PD_GRADE,                                     -- col 7
  p.Days_Past_Due,                                -- col 8
  p.Prev_Bal,                                     -- col 9
  p.Curr_Bal,                                     -- col10
  p.delta,                                        -- col11
  p.direction,                                    -- col12 ('UP'/'DOWN')
  p.size_metric,                                  -- col13 (ABS(delta))
  p.rnk_sys                                       -- col14
FROM persist_ranked p
WHERE p.rnk_sys <= (SELECT top_n FROM params)

ORDER BY
  1,  -- section
  3, 4,  -- Bank_Code, Contract_Source_System
  14; -- rnk_sys







WITH params AS (
  SELECT
    DATE '2025-08-31' AS curr_eom
),
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(COALESCE(Days_Past_Due,0)) AS days_past_due,
      SUM(Source_System_Balance)::NUMERIC AS bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
  GROUP BY 1,2,3,4
)
SELECT
  SUM(days_past_due * bal) / NULLIF(SUM(bal),0) AS weighted_avg_dpd,
  SUM(bal) AS total_balance,
  COUNT(DISTINCT Account_Identifier) AS account_count
FROM pop;





/* ===== Params ===== */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom
),

/* ===== Base pop (aggregate to one row per acct per month) ===== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)            AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                          AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC        AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))         AS Non_Accrual_Flag,
      MAX(GL_ACCOUNT_HIER_LEVEL_4)               AS GL_L4
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

curr AS (
  SELECT Bank_Code, Contract_Source_System, Account_Identifier,
         MAX(Account_Name) AS Account_Name,
         SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev AS (
  SELECT Bank_Code, Contract_Source_System, Account_Identifier,
         MAX(Account_Name) AS Account_Name,
         SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===== Classify MoM status from the same base ===== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System_curr,
    p.Contract_Source_System                                      AS Contract_Source_System_prev,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr c
  FULL OUTER JOIN prev p
    ON  c.Account_Identifier = p.Account_Identifier
    AND c.Bank_Code          = p.Bank_Code
)

/* ===== 1) Portfolio-level tie-out (use correct basis) ===== */
SELECT
  'PORTFOLIO_TOTALS' AS section,
  SUM(CASE WHEN NA_Transition='ADD'     THEN COALESCE(Curr_Bal,0) ELSE 0 END)::NUMERIC  AS adds_curr_basis,
  SUM(CASE WHEN NA_Transition='REMOVAL' THEN COALESCE(Prev_Bal,0) ELSE 0 END)::NUMERIC  AS removals_prev_basis,
  SUM(CASE WHEN NA_Transition='PERSIST' THEN COALESCE(Curr_Bal,0) - COALESCE(Prev_Bal,0) ELSE 0 END)::NUMERIC AS persisting_delta,
  /* Bridge check: Prev + Adds - Removals + PersistingΔ = Curr */
  SUM(COALESCE(Prev_Bal,0))::NUMERIC     AS prev_total_na,
  SUM(COALESCE(Curr_Bal,0))::NUMERIC     AS curr_total_na,
  (SUM(COALESCE(Prev_Bal,0))
   + SUM(CASE WHEN NA_Transition='ADD'     THEN COALESCE(Curr_Bal,0) ELSE 0 END)
   - SUM(CASE WHEN NA_Transition='REMOVAL' THEN COALESCE(Prev_Bal,0) ELSE 0 END)
   + SUM(CASE WHEN NA_Transition='PERSIST' THEN COALESCE(Curr_Bal,0) - COALESCE(Prev_Bal,0) ELSE 0 END)
  )::NUMERIC AS bridge_check
FROM mom

UNION ALL

/* ===== 2) Diagnostics: system switchers (cause per-system mismatches) ===== */
SELECT
  'SYSTEM_SWITCHERS' AS section,
  NULL, NULL, NULL,
  NULL, NULL,
  COUNT(*)::NUMERIC AS switcher_count
FROM mom
WHERE NA_Transition IN ('ADD','REMOVAL')
  AND Contract_Source_System_curr IS DISTINCT FROM Contract_Source_System_prev

UNION ALL

/* ===== 3) Diagnostics: basis mismatch view (what each side is summing) ===== */
SELECT
  'BASIS_SUMS' AS section,
  SUM(CASE WHEN NA_Transition='ADD'     THEN COALESCE(Prev_Bal,0) ELSE 0 END)::NUMERIC  AS adds_prev_basis_should_be_zero,
  SUM(CASE WHEN NA_Transition='ADD'     THEN COALESCE(Curr_Bal,0) ELSE 0 END)::NUMERIC  AS adds_curr_basis,
  SUM(CASE WHEN NA_Transition='REMOVAL' THEN COALESCE(Curr_Bal,0) ELSE 0 END)::NUMERIC  AS removals_curr_basis_should_be_zero,
  SUM(CASE WHEN NA_Transition='REMOVAL' THEN COALESCE(Prev_Bal,0) ELSE 0 END)::NUMERIC  AS removals_prev_basis
FROM mom;





/* === Portfolio MoM % Change (single row) === */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,      -- set current EOM here
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom
),
base AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    SUM(Source_System_Balance)::NUMERIC AS total_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date IN (
      (SELECT curr_eom FROM params),
      (SELECT prev_eom FROM params)
    )
  GROUP BY CAST(End_of_Month_Date AS DATE)
)
SELECT
  (SELECT curr_eom FROM params) AS eom_curr,
  (SELECT prev_eom FROM params) AS eom_prev,
  MAX(CASE WHEN eom = (SELECT curr_eom FROM params) THEN total_bal END)::NUMERIC AS curr_total,
  MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END)::NUMERIC AS prev_total,
  (MAX(CASE WHEN eom = (SELECT curr_eom FROM params) THEN total_bal END)
   - MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END))::NUMERIC AS delta,
  CASE 
    WHEN MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END) = 0 
         OR MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END) IS NULL
    THEN NULL
    ELSE (MAX(CASE WHEN eom = (SELECT curr_eom FROM params) THEN total_bal END)
         - MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END))
         / NULLIF(MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END),0)
  END AS pct_change
FROM base;




/* === Portfolio MoM % Change (single row) === */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,      -- set current EOM here
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom
),
base AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    SUM(Source_System_Balance)::NUMERIC AS total_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date IN (
      (SELECT curr_eom FROM params),
      (SELECT prev_eom FROM params)
    )
  GROUP BY CAST(End_of_Month_Date AS DATE)
),
totals AS (
  SELECT
    MAX(CASE WHEN eom = (SELECT curr_eom FROM params) THEN total_bal END)::NUMERIC AS curr_total,
    MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END)::NUMERIC AS prev_total
  FROM base
)
SELECT
  (SELECT curr_eom FROM params) AS eom_curr,
  (SELECT prev_eom FROM params) AS eom_prev,
  curr_total,
  prev_total,
  (curr_total - prev_total)                              AS delta,
  CASE WHEN prev_total IS NULL OR prev_total = 0
       THEN NULL
       ELSE (curr_total - prev_total) / NULLIF(prev_total,0)
  END                                                     AS pct_change;





/* === Portfolio MoM % Change (single row) === */
WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,      -- set current EOM here
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom
),
base AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    SUM(Source_System_Balance)::NUMERIC AS total_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date IN (
      (SELECT curr_eom FROM params),
      (SELECT prev_eom FROM params)
    )
),
totals AS (
  SELECT
    MAX(CASE WHEN eom = (SELECT curr_eom FROM params) THEN total_bal END)::NUMERIC AS curr_total,
    MAX(CASE WHEN eom = (SELECT prev_eom FROM params) THEN total_bal END)::NUMERIC AS prev_total
  FROM base
)
SELECT
  (SELECT curr_eom FROM params) AS eom_curr,
  (SELECT prev_eom FROM params) AS eom_prev,
  curr_total,
  prev_total,
  (curr_total - prev_total)                              AS delta,
  CASE WHEN prev_total IS NULL OR prev_total = 0
       THEN NULL
       ELSE (curr_total - prev_total) / NULLIF(prev_total,0)
  END                                                     AS pct_change
FROM totals;






/* ===================== FINAL UNION (aligned columns) ===================== */
SELECT
  'FLAG_COUNTS_BY_MONTH'::VARCHAR(40) AS section,   -- col 1
  c.eom,                                            -- col 2
  NULL::VARCHAR(50)   AS Bank_Code,                 -- col 3
  NULL::VARCHAR(100)  AS Contract_Source_System,    -- col 4
  NULL::NUMERIC       AS curr_sys_balance,          -- col 5
  NULL::NUMERIC       AS prev_sys_balance,          -- col 6
  NULL::NUMERIC       AS mean_12_prior,             -- col 7
  NULL::NUMERIC       AS std_12_prior,              -- col 8
  NULL::NUMERIC       AS sys_z_score,               -- col 9
  NULL::NUMERIC       AS sys_pct_change,            -- col10
  NULL::INTEGER       AS flag_sys_z,                -- col11
  NULL::INTEGER       AS flag_sys_pct,              -- col12
  NULL::VARCHAR(10)   AS severity,                  -- col13
  c.systems_total,                                  -- col14
  c.critical_cnt,                                   -- col15
  c.warning_cnt,                                    -- col16
  c.ok_cnt                                          -- col17
FROM counts c

UNION ALL

SELECT
  'FLAGGED_SYSTEMS_HISTORY'::VARCHAR(40) AS section, -- col 1
  l.eom,                                            -- col 2
  l.Bank_Code,                                      -- col 3
  l.Contract_Source_System,                         -- col 4
  l.curr_sys_balance,                               -- col 5
  l.prev_sys_balance,                               -- col 6
  l.mean_12_prior,                                  -- col 7
  l.std_12_prior,                                   -- col 8
  l.sys_z_score,                                    -- col 9
  l.sys_pct_change,                                 -- col10
  l.flag_sys_z,                                     -- col11
  l.flag_sys_pct,                                   -- col12
  l.severity,                                       -- col13
  NULL::INT  AS systems_total,                      -- col14
  NULL::INT  AS critical_cnt,                       -- col15
  NULL::INT  AS warning_cnt,                        -- col16
  NULL::INT  AS ok_cnt                              -- col17
FROM labeled l

/* Order strictly by output columns (no expressions) */
ORDER BY
  1,          -- section
  2,          -- eom
  13 DESC NULLS LAST,  -- severity (puts Critical/Warning above OK within history rows; NULLs for counts)
  9  DESC NULLS LAST,  -- sys_z_score
  10 DESC NULLS LAST,  -- sys_pct_change
  3, 4;                -- Bank_Code, Contract_Source_System





/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'   AS curr_eom,     -- << set anchor EOM
    24                  AS months_back,  -- how many months to pull (curr + prior N-1)
    2.5::NUMERIC        AS z_threshold,  -- z-score flag threshold
    0.15::NUMERIC       AS warn_pct,     -- 15% = Warning threshold
    0.25::NUMERIC       AS crit_pct,     -- 25% = Critical threshold
    NULL::VARCHAR(50)   AS bank_code,    -- optional filter; NULL = all
    NULL::VARCHAR(100)  AS contract_source_system  -- optional filter; NULL = all
),

/* ===================== SYSTEM-LEVEL MONTHLY BALANCES ===================== */
sys_monthly AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    Bank_Code,
    Contract_Source_System,
    SUM(Source_System_Balance)::NUMERIC AS sys_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
    AND ( (SELECT bank_code FROM params) IS NULL
          OR Bank_Code = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR Contract_Source_System = (SELECT contract_source_system FROM params) )
  GROUP BY 1,2,3
),

/* ===================== ROLLING METRICS (exclude current row from stats) ===================== */
sys_calc AS (
  SELECT
    s.*,
    LAG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
    ) AS prev_sys_bal,

    AVG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS mean_12_prior,

    STDDEV_SAMP(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS std_12_prior
  FROM sys_monthly s
),

/* ===================== SCORES & FLAGS PER MONTH ===================== */
scored AS (
  SELECT
    c.eom,
    c.Bank_Code,
    c.Contract_Source_System,
    c.sys_bal           AS curr_sys_balance,
    c.prev_sys_bal      AS prev_sys_balance,
    c.mean_12_prior,
    c.std_12_prior,

    CASE
      WHEN c.std_12_prior IS NULL OR c.std_12_prior = 0 THEN NULL
      ELSE (c.sys_bal - c.mean_12_prior) / c.std_12_prior
    END AS sys_z_score,

    CASE
      WHEN c.prev_sys_bal IS NULL OR c.prev_sys_bal = 0 THEN NULL
      ELSE (c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)
    END AS sys_pct_change,

    /* flag columns */
    CASE 
      WHEN (c.std_12_prior IS NOT NULL AND c.std_12_prior <> 0)
       AND ABS((c.sys_bal - c.mean_12_prior) / c.std_12_prior) >= (SELECT z_threshold FROM params)
      THEN 1 ELSE 0 END AS flag_sys_z,

    CASE 
      WHEN c.prev_sys_bal IS NOT NULL AND c.prev_sys_bal <> 0
       AND ABS((c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)) >= (SELECT crit_pct FROM params)
      THEN 2  -- Critical
      WHEN c.prev_sys_bal IS NOT NULL AND c.prev_sys_bal <> 0
       AND ABS((c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)) >= (SELECT warn_pct FROM params)
      THEN 1  -- Warning
      ELSE 0
    END AS flag_sys_pct
  FROM sys_calc c
),

labeled AS (
  SELECT
    s.*,
    CASE
      WHEN s.flag_sys_z = 1
        OR s.flag_sys_pct = 2
      THEN 'Critical'
      WHEN s.flag_sys_pct = 1
      THEN 'Warning'
      ELSE 'OK'
    END AS severity
  FROM scored s
),

/* monthly counts */
counts AS (
  SELECT
    eom,
    COUNT(*)::INT                                           AS systems_total,
    SUM(CASE WHEN severity = 'Critical' THEN 1 ELSE 0 END)::INT AS critical_cnt,
    SUM(CASE WHEN severity = 'Warning'  THEN 1 ELSE 0 END)::INT AS warning_cnt,
    SUM(CASE WHEN severity = 'OK'       THEN 1 ELSE 0 END)::INT AS ok_cnt
  FROM labeled
  GROUP BY eom
)

/* ===================== FINAL UNION (aligned columns) ===================== */
SELECT
  'FLAG_COUNTS_BY_MONTH'::VARCHAR(40) AS section,
  c.eom,
  /* detail columns not applicable here → NULLs */
  NULL::VARCHAR(50)   AS Bank_Code,
  NULL::VARCHAR(100)  AS Contract_Source_System,
  NULL::NUMERIC       AS curr_sys_balance,
  NULL::NUMERIC       AS prev_sys_balance,
  NULL::NUMERIC       AS mean_12_prior,
  NULL::NUMERIC       AS std_12_prior,
  NULL::NUMERIC       AS sys_z_score,
  NULL::NUMERIC       AS sys_pct_change,
  NULL::INTEGER       AS flag_sys_z,
  NULL::INTEGER       AS flag_sys_pct,
  NULL::VARCHAR(10)   AS severity,
  /* counts populated */
  c.systems_total,
  c.critical_cnt,
  c.warning_cnt,
  c.ok_cnt
FROM counts c

UNION ALL

SELECT
  'FLAGGED_SYSTEMS_HISTORY'::VARCHAR(40) AS section,
  l.eom,
  l.Bank_Code,
  l.Contract_Source_System,
  l.curr_sys_balance,
  l.prev_sys_balance,
  l.mean_12_prior,
  l.std_12_prior,
  l.sys_z_score,
  l.sys_pct_change,
  l.flag_sys_z,
  l.flag_sys_pct,
  l.severity,
  /* counts not applicable here → NULLs */
  NULL::INT  AS systems_total,
  NULL::INT  AS critical_cnt,
  NULL::INT  AS warning_cnt,
  NULL::INT  AS ok_cnt
FROM labeled l

ORDER BY
  section,
  eom,
  CASE section
    WHEN 'FLAGGED_SYSTEMS_HISTORY' THEN 
      CASE severity WHEN 'Critical' THEN 0 WHEN 'Warning' THEN 1 ELSE 2 END
    ELSE 0
  END,
  ABS(COALESCE(sys_z_score,0)) DESC,
  ABS(COALESCE(sys_pct_change,0)) DESC,
  Bank_Code,
  Contract_Source_System;





/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'   AS curr_eom,     -- << set anchor EOM (e.g., use 2025-08-31 when you switch)
    24                  AS months_back,  -- how many months to pull (curr + prior N-1)
    2.5::NUMERIC        AS z_threshold,  -- z-score flag threshold
    0.15::NUMERIC       AS warn_pct,     -- 15% = Warning threshold
    0.25::NUMERIC       AS crit_pct,     -- 25% = Critical threshold
    NULL::VARCHAR(50)   AS bank_code,    -- optional: filter to one BANK_CODE; NULL = all
    NULL::VARCHAR(100)  AS contract_source_system  -- optional: filter to one system; NULL = all
),

/* ===================== SYSTEM-LEVEL MONTHLY BALANCES ===================== */
sys_monthly AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    Bank_Code,
    Contract_Source_System,
    SUM(Source_System_Balance)::NUMERIC AS sys_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
    AND ( (SELECT bank_code FROM params) IS NULL
          OR Bank_Code = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR Contract_Source_System = (SELECT contract_source_system FROM params) )
  GROUP BY 1,2,3
),

/* ===================== ROLLING METRICS (exclude current row from stats) ===================== */
sys_calc AS (
  SELECT
    s.*,
    LAG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
    ) AS prev_sys_bal,

    AVG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS mean_12_prior,

    STDDEV_SAMP(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS std_12_prior
  FROM sys_monthly s
),

/* ===================== SCORES & FLAGS PER MONTH ===================== */
scored AS (
  SELECT
    c.eom,
    c.Bank_Code,
    c.Contract_Source_System,
    c.sys_bal           AS curr_sys_balance,
    c.prev_sys_bal      AS prev_sys_balance,
    c.mean_12_prior,
    c.std_12_prior,

    CASE
      WHEN c.std_12_prior IS NULL OR c.std_12_prior = 0 THEN NULL
      ELSE (c.sys_bal - c.mean_12_prior) / c.std_12_prior
    END AS sys_z_score,

    CASE
      WHEN c.prev_sys_bal IS NULL OR c.prev_sys_bal = 0 THEN NULL
      ELSE (c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)
    END AS sys_pct_change,

    /* flag columns */
    CASE 
      WHEN (c.std_12_prior IS NOT NULL AND c.std_12_prior <> 0)
       AND ABS((c.sys_bal - c.mean_12_prior) / c.std_12_prior) >= (SELECT z_threshold FROM params)
      THEN 1 ELSE 0 END AS flag_sys_z,

    CASE 
      WHEN c.prev_sys_bal IS NOT NULL AND c.prev_sys_bal <> 0
       AND ABS((c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)) >= (SELECT crit_pct FROM params)
      THEN 2  -- Critical
      WHEN c.prev_sys_bal IS NOT NULL AND c.prev_sys_bal <> 0
       AND ABS((c.sys_bal - c.prev_sys_bal) / NULLIF(c.prev_sys_bal,0)) >= (SELECT warn_pct FROM params)
      THEN 1  -- Warning
      ELSE 0
    END AS flag_sys_pct
  FROM sys_calc c
),

labeled AS (
  SELECT
    s.*,
    CASE
      WHEN s.flag_sys_z = 1
        OR s.flag_sys_pct = 2
      THEN 'Critical'
      WHEN s.flag_sys_pct = 1
      THEN 'Warning'
      ELSE 'OK'
    END AS severity
  FROM scored s
)

/* ===================== FINAL OUTPUTS ===================== */

-- 1) Monthly counts of flags (Critical / Warning / OK)
SELECT
  'FLAG_COUNTS_BY_MONTH'::VARCHAR(40) AS section,
  eom,
  COUNT(*)::INT                                           AS systems_total,
  SUM(CASE WHEN severity = 'Critical' THEN 1 ELSE 0 END)::INT AS critical_cnt,
  SUM(CASE WHEN severity = 'Warning'  THEN 1 ELSE 0 END)::INT AS warning_cnt,
  SUM(CASE WHEN severity = 'OK'       THEN 1 ELSE 0 END)::INT AS ok_cnt
FROM labeled
GROUP BY eom
ORDER BY eom

UNION ALL

-- 2) Flagged systems history with metrics & severity
SELECT
  'FLAGGED_SYSTEMS_HISTORY'::VARCHAR(40) AS section,
  eom,
  Bank_Code,
  Contract_Source_System,
  curr_sys_balance,
  prev_sys_balance,
  mean_12_prior,
  std_12_prior,
  sys_z_score,
  sys_pct_change,
  flag_sys_z,
  flag_sys_pct,
  severity
FROM labeled
-- keep all rows; filter to only Critical/Warning in Power BI if desired
ORDER BY eom, 
         CASE severity WHEN 'Critical' THEN 0 WHEN 'Warning' THEN 1 ELSE 2 END,
         ABS(COALESCE(sys_z_score,0)) DESC,
         ABS(COALESCE(sys_pct_change,0)) DESC,
         Bank_Code, Contract_Source_System;





/* =============== PARAMETERS =============== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,   -- << set current EOM here
    'Y'::CHAR(1)                      AS na_only     -- 'Y' to keep Non-Accruals only; 'N' for all
),

/* =============== Base (one row per account @ EOM) =============== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)                  AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                                AS Account_Name,
      /* If PD_GRADE exists here; if not, drop it. */
      MAX(PD_GRADE)                                    AS PD_GRADE,
      MAX(GL_ACCOUNT_HIER_LEVEL_4)                     AS GL_L4,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))              AS Non_Accrual_Flag,
      /* If your DPD column name differs, change DAYS_PAST_DUE below */
      MAX(COALESCE(DAYS_PAST_DUE,0))                   AS days_past_due,
      SUM(Source_System_Balance)::NUMERIC              AS Source_System_Balance
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND (
          (SELECT na_only FROM params) = 'N'
          OR UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
        )
  GROUP BY 1,2,3,4
),

/* =============== DPD bucketization =============== */
bucketed AS (
  SELECT
    p.eom,
    p.Bank_Code,
    p.Contract_Source_System,
    p.Account_Identifier,
    p.Account_Name,
    p.PD_GRADE,
    p.GL_L4,
    p.Non_Accrual_Flag,
    p.days_past_due,
    CASE
      WHEN p.days_past_due IS NULL OR p.days_past_due <= 0 THEN 'Zero Days'
      WHEN p.days_past_due BETWEEN 1   AND 30  THEN '1-30 Days'
      WHEN p.days_past_due BETWEEN 31  AND 90  THEN '31-90 Days'
      WHEN p.days_past_due BETWEEN 91  AND 179 THEN '91-180 Days'
      ELSE '180+ Days'
    END AS dpd_bucket,
    p.Source_System_Balance
  FROM pop p
),

/* =============== Summary by System × DPD bucket =============== */
sys_summary AS (
  SELECT
    b.Bank_Code,
    b.Contract_Source_System,
    b.dpd_bucket,
    SUM(b.Source_System_Balance)::NUMERIC AS bucket_balance,
    COUNT(*)::INT                         AS bucket_accounts,
    SUM(SUM(b.Source_System_Balance)) OVER (
      PARTITION BY b.Bank_Code, b.Contract_Source_System
    ) AS sys_total_balance
  FROM bucketed b
  GROUP BY 1,2,3
)

/* =============== FINAL OUTPUTS (2 sections) =============== */
-- 1) Account-level detail (for drill/slicing)
SELECT
  'DPD_DETAIL'::VARCHAR(20)           AS section,
  eom,
  Bank_Code,
  Contract_Source_System,
  Account_Identifier,
  Account_Name,
  PD_GRADE,
  GL_L4,
  Non_Accrual_Flag,
  days_past_due,
  dpd_bucket,
  Source_System_Balance              AS metric_value,
  NULL::NUMERIC                      AS metric_pct,
  NULL::INT                          AS account_count
FROM bucketed

UNION ALL

-- 2) System-level summary by DPD bucket
SELECT
  'DPD_SUMMARY'::VARCHAR(20)          AS section,
  (SELECT curr_eom FROM params)       AS eom,
  Bank_Code,
  Contract_Source_System,
  NULL::VARCHAR(200)                  AS Account_Identifier,
  NULL::VARCHAR(200)                  AS Account_Name,
  NULL::VARCHAR(50)                   AS PD_GRADE,
  NULL::VARCHAR(100)                  AS GL_L4,
  NULL::VARCHAR(2)                    AS Non_Accrual_Flag,
  NULL::INTEGER                       AS days_past_due,
  dpd_bucket,
  bucket_balance                      AS metric_value,
  CASE WHEN sys_total_balance = 0 THEN NULL
       ELSE bucket_balance / NULLIF(sys_total_balance,0) END AS metric_pct,
  bucket_accounts                     AS account_count
FROM sys_summary
ORDER BY section, Bank_Code, Contract_Source_System,
         CASE dpd_bucket
           WHEN 'Zero Days' THEN 0
           WHEN '1-30 Days' THEN 1
           WHEN '31-90 Days' THEN 2
           WHEN '91-180 Days' THEN 3
           WHEN '180+ Days' THEN 4
           ELSE 9 END;







/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,          -- << set current EOM here
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom,
    100::INT                          AS top_n,             -- rows per Bank×System×Status (for rnk_sys)
    0::NUMERIC                        AS min_size,          -- minimum size_metric to include
    NULL::VARCHAR(50)                 AS bank_code,         -- e.g., '123'; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system  -- e.g., 'ACBS'; NULL = all
),

/* ===================== BASE POPULATION (filters applied) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)            AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                          AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC        AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))         AS Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA AGGREGATES ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== SYSTEM TOTALS (for % of system) ===================== */
sys_curr_tot AS (
  SELECT Bank_Code, Contract_Source_System,
         SUM(Curr_Bal)::NUMERIC AS sys_curr_total
  FROM curr_agg
  GROUP BY 1,2
),
sys_prev_tot AS (
  SELECT Bank_Code, Contract_Source_System,
         SUM(Prev_Bal)::NUMERIC AS sys_prev_total
  FROM prev_agg
  GROUP BY 1,2
),

/* ===================== Adds / Removals identification ===================== */
adds_removals AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE NULL
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR COALESCE(c.Bank_Code,p.Bank_Code) = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR COALESCE(c.Contract_Source_System,p.Contract_Source_System) = (SELECT contract_source_system FROM params) )
),

/* ===================== Size metric + % of system ===================== */
scored AS (
  SELECT
    ar.Bank_Code,
    ar.Contract_Source_System,
    ar.NA_Transition,                               -- 'ADD' or 'REMOVAL'
    ar.Account_Identifier,
    ar.Account_Name,
    ar.Prev_Bal,
    ar.curr_Bal,
    CASE
      WHEN ar.NA_Transition = 'REMOVAL' THEN COALESCE(ar.Prev_Bal,0)
      WHEN ar.NA_Transition = 'ADD'     THEN COALESCE(ar.Curr_Bal,0)
      ELSE 0
    END AS size_metric,
    ct.sys_curr_total,
    pt.sys_prev_total,
    CASE
      WHEN ar.NA_Transition = 'REMOVAL'
        THEN CASE WHEN pt.sys_prev_total = 0 OR pt.sys_prev_total IS NULL THEN NULL
                  ELSE COALESCE(ar.Prev_Bal,0) / NULLIF(pt.sys_prev_total,0) END
      WHEN ar.NA_Transition = 'ADD'
        THEN CASE WHEN ct.sys_curr_total = 0 OR ct.sys_curr_total IS NULL THEN NULL
                  ELSE COALESCE(ar.Curr_Bal,0) / NULLIF(ct.sys_curr_total,0) END
      ELSE NULL
    END AS pct_of_system
  FROM adds_removals ar
  LEFT JOIN sys_curr_tot ct
    ON ct.Bank_Code = ar.Bank_Code
   AND ct.Contract_Source_System = ar.Contract_Source_System
  LEFT JOIN sys_prev_tot pt
    ON pt.Bank_Code = ar.Bank_Code
   AND pt.Contract_Source_System = ar.Contract_Source_System
  WHERE ar.NA_Transition IN ('ADD','REMOVAL')
    AND (
          (ar.NA_Transition = 'ADD'     AND COALESCE(ar.Curr_Bal,0) >= (SELECT min_size FROM params)) OR
          (ar.NA_Transition = 'REMOVAL' AND COALESCE(ar.Prev_Bal,0) >= (SELECT min_size FROM params))
        )
),

/* ===================== Rankings (per system and overall) ===================== */
ranked AS (
  SELECT
    s.*,
    ROW_NUMBER() OVER (
      PARTITION BY s.Bank_Code, s.Contract_Source_System, s.NA_Transition
      ORDER BY s.size_metric DESC NULLS LAST, s.Account_Identifier
    ) AS rnk_sys,
    ROW_NUMBER() OVER (
      PARTITION BY s.NA_Transition
      ORDER BY s.size_metric DESC NULLS LAST, s.Account_Identifier
    ) AS rnk_all
  FROM scored s
)

/* ===================== FINAL OUTPUT ===================== */
SELECT
  r.Bank_Code,
  r.Contract_Source_System,
  r.NA_Transition,                 -- 'ADD' or 'REMOVAL'
  r.Account_Identifier,
  r.Account_Name,
  r.Prev_Bal,
  r.Curr_Bal,
  r.size_metric,                   -- current for ADD, prior for REMOVAL
  r.pct_of_system,                 -- share of system total (appropriate base per status)
  r.rnk_sys,                       -- rank within Bank×System×Status
  r.rnk_all                        -- rank across enterprise by Status
FROM ranked r
WHERE r.rnk_sys <= (SELECT top_n FROM params)
ORDER BY
  CASE r.NA_Transition WHEN 'ADD' THEN 0 ELSE 1 END,
  r.Bank_Code,
  r.Contract_Source_System,
  r.rnk_sys,
  r.size_metric DESC NULLS LAST,
  r.Account_Identifier;






/* ============= PARAMETERS: set the month ============= */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,   -- << set current EOM here
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom
),

/* ============= Base pop with filters (aggregate to 1 row per acct/month) ============= */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)             AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                           AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC         AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))          AS Non_Accrual_Flag,
      /* If PD_GRADE exists in your table, keep it; else drop the next line */
      MAX(PD_GRADE)                               AS PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ============= Current / Prior NA slices ============= */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    COALESCE(MAX(PD_GRADE),'UNKNOWN') AS PD_GRADE,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    COALESCE(MAX(PD_GRADE),'UNKNOWN') AS PD_GRADE,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ============= MoM status per account (ADD / REMOVAL / PERSIST) ============= */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    COALESCE(c.PD_GRADE,              p.PD_GRADE)               AS PD_GRADE,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
),

/* ============= 1) PD mix of current NA (Adds + Persist) ============= */
na_pd AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    PD_GRADE,
    SUM(CASE WHEN NA_Transition IN ('ADD','PERSIST') THEN COALESCE(Curr_Bal,0) ELSE 0 END)::NUMERIC AS pd_eom_bal
  FROM mom
  GROUP BY 1,2,3
),
na_pd_with_share AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    PD_GRADE,
    pd_eom_bal,
    SUM(pd_eom_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System) AS sys_eom_total,
    CASE
      WHEN SUM(pd_eom_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System) = 0 THEN NULL
      ELSE pd_eom_bal / NULLIF(SUM(pd_eom_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System),0)
    END AS pd_share_of_eom
  FROM na_pd
),

/* ============= 2) PD mix of ADDs (new NA this month) ============= */
adds_pd AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    PD_GRADE,
    SUM(CASE WHEN NA_Transition='ADD' THEN COALESCE(Curr_Bal,0) ELSE 0 END)::NUMERIC AS adds_bal
  FROM mom
  GROUP BY 1,2,3
),
adds_pd_with_share AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    PD_GRADE,
    adds_bal,
    SUM(adds_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System) AS sys_adds_total,
    CASE
      WHEN SUM(adds_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System) = 0 THEN NULL
      ELSE adds_bal / NULLIF(SUM(adds_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System),0)
    END AS adds_pd_share
  FROM adds_pd
),

/* ============= 3) Concentration of current NA (Top-1/5/10 share) ============= */
curr_accounts AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier, Account_Name, PD_GRADE, Curr_Bal
  FROM curr_agg
),
ranked_curr AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier, Account_Name, PD_GRADE, Curr_Bal,
    ROW_NUMBER() OVER (
      PARTITION BY Bank_Code, Contract_Source_System
      ORDER BY Curr_Bal DESC NULLS LAST, Account_Identifier
    ) AS rnk,
    SUM(Curr_Bal) OVER (PARTITION BY Bank_Code, Contract_Source_System) AS sys_total
  FROM curr_accounts
),
concentration AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    /* sums for top N */
    SUM(CASE WHEN rnk = 1  THEN Curr_Bal ELSE 0 END)::NUMERIC AS top1_bal,
    SUM(CASE WHEN rnk <= 5 THEN Curr_Bal ELSE 0 END)::NUMERIC AS top5_bal,
    SUM(CASE WHEN rnk <= 10 THEN Curr_Bal ELSE 0 END)::NUMERIC AS top10_bal,
    MAX(sys_total)::NUMERIC AS sys_total
  FROM ranked_curr
  GROUP BY 1,2
)

/* ============= FINAL OUTPUT: 3 sections ============= */
-- 1) PD mix of current NA (Adds + Persist)
SELECT
  'NA_PD_MIX_EOM'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  PD_GRADE,
  pd_eom_bal        AS metric_value,
  pd_share_of_eom   AS metric_pct
FROM na_pd_with_share

UNION ALL
-- 2) PD mix of Adds
SELECT
  'ADDS_PD_MIX'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  PD_GRADE,
  adds_bal        AS metric_value,
  adds_pd_share   AS metric_pct
FROM adds_pd_with_share

UNION ALL
-- 3) Concentration (Top 1 / Top 5 / Top 10 share)
SELECT
  'CONCENTRATION'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  'ALL_PD'::VARCHAR(100)       AS PD_GRADE,  -- placeholder; not used for this section
  sys_total                    AS metric_value,
  NULL                         AS metric_pct
FROM concentration

UNION ALL
SELECT
  'CONCENTRATION_TOP1_SHARE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  'ALL_PD'::VARCHAR(100)       AS PD_GRADE,
  CASE WHEN sys_total = 0 THEN NULL ELSE top1_bal  / NULLIF(sys_total,0) END AS metric_value,
  NULL AS metric_pct
FROM concentration

UNION ALL
SELECT
  'CONCENTRATION_TOP5_SHARE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  'ALL_PD'::VARCHAR(100)       AS PD_GRADE,
  CASE WHEN sys_total = 0 THEN NULL ELSE top5_bal  / NULLIF(sys_total,0) END AS metric_value,
  NULL AS metric_pct
FROM concentration

UNION ALL
SELECT
  'CONCENTRATION_TOP10_SHARE'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params) AS eom,
  Bank_Code,
  Contract_Source_System,
  'ALL_PD'::VARCHAR(100)       AS PD_GRADE,
  CASE WHEN sys_total = 0 THEN NULL ELSE top10_bal / NULLIF(sys_total,0) END AS metric_value,
  NULL AS metric_pct
FROM concentration

ORDER BY section, Bank_Code, Contract_Source_System, PD_GRADE;





let
  Src = Merge1,

  // Keep only columns needed for sums (speeds everything up)
  Keep = Table.SelectColumns(Src, {"Old_SOURCE_SYSTEM_BALANCE","New_SOURCE_SYSTEM_BALANCE"}),

  // Robust numeric conversion without changing table types
  OldList = List.Transform(Table.Column(Keep, "Old_SOURCE_SYSTEM_BALANCE"), each try Number.From(_) otherwise 0),
  NewList = List.Transform(Table.Column(Keep, "New_SOURCE_SYSTEM_BALANCE"), each try Number.From(_) otherwise 0),

  OldSum = List.Sum(OldList),
  NewSum = List.Sum(NewList),
  RecalcVar = NewSum - OldSum,

  Out = #table({"Old_Sum","New_Sum","Recalc_Variance_(New-Old)"}, {{OldSum, NewSum, RecalcVar}})
in
  Out





/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,         -- << set current EOM here
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom,
    100::INT                          AS top_n,            -- max rows to return
    0::NUMERIC                        AS min_abs_delta,    -- minimum absolute $ move
    NULL::VARCHAR(50)                 AS bank_code,        -- e.g., '123'; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system -- e.g., 'ACBS'; NULL = all
),

/* ===================== BASE POPULATION (filters applied) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE)            AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name)                          AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC        AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag)))         AS Non_Accrual_Flag,
      MAX(GL_ACCOUNT_HIER_LEVEL_4)               AS GL_L4,
      /* If PD_GRADE exists in this table, keep the MAX; if not, remove the next line */
      MAX(PD_GRADE)                              AS PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA AGGREGATES ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal,
    /* passthrough dims */
    MAX(GL_L4) AS GL_L4,
    MAX(PD_GRADE) AS PD_GRADE
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal,
    /* passthrough dims */
    MAX(GL_L4) AS GL_L4,
    MAX(PD_GRADE) AS PD_GRADE
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== PERSISTING ONLY (inner join) ===================== */
persist AS (
  SELECT
    c.Bank_Code,
    c.Contract_Source_System,
    c.Account_Identifier,
    COALESCE(c.Account_Name, p.Account_Name) AS Account_Name,
    /* balances */
    p.Prev_Bal,
    c.Curr_Bal,
    /* delta & % change */
    (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) AS delta,
    CASE
      WHEN COALESCE(p.Prev_Bal,0) = 0 THEN NULL
      ELSE (COALESCE(c.Curr_Bal,0) - COALESCE(p.Prev_Bal,0)) / NULLIF(p.Prev_Bal,0)
    END AS pct_change,
    /* dims */
    COALESCE(c.GL_L4, p.GL_L4) AS GL_L4,
    COALESCE(c.PD_GRADE, p.PD_GRADE) AS PD_GRADE
  FROM curr_agg c
  INNER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
  /* optional scope filters from params */
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR c.Bank_Code = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR c.Contract_Source_System = (SELECT contract_source_system FROM params) )
),

/* ===================== RANK BIGGEST MOVERS (by |delta|) ===================== */
ranked AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    Account_Identifier,
    Account_Name,
    GL_L4,
    PD_GRADE,
    Prev_Bal,
    Curr_Bal,
    delta,
    ABS(delta) AS delta_abs,
    pct_change,
    /* rank within each (Bank, System) by absolute delta */
    ROW_NUMBER() OVER (
      PARTITION BY Bank_Code, Contract_Source_System
      ORDER BY ABS(delta) DESC NULLS LAST, Account_Identifier
    ) AS rnk_abs,
    /* separate directional ranks if you want top ups / top downs */
    ROW_NUMBER() OVER (
      PARTITION BY Bank_Code, Contract_Source_System
      ORDER BY CASE WHEN delta IS NULL THEN -1e99 ELSE delta END DESC, Account_Identifier
    ) AS rnk_up,
    ROW_NUMBER() OVER (
      PARTITION BY Bank_Code, Contract_Source_System
      ORDER BY CASE WHEN delta IS NULL THEN  1e99 ELSE delta END ASC, Account_Identifier
    ) AS rnk_down
  FROM persist
  WHERE ABS(COALESCE(delta,0)) >= (SELECT min_abs_delta FROM params)
)

/* ===================== 1) TOP MOVERS OUTPUT ===================== */
SELECT
  'PERSISTING_TOP_MOVERS'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params)        AS eom,
  r.Bank_Code,
  r.Contract_Source_System,
  r.Account_Identifier,
  r.Account_Name,
  r.GL_L4,
  r.PD_GRADE,
  r.Prev_Bal,
  r.Curr_Bal,
  r.delta,
  r.delta_abs,
  r.pct_change,
  CASE WHEN r.delta >= 0 THEN 'UP' ELSE 'DOWN' END AS direction
FROM ranked r
WHERE r.rnk_abs <= (SELECT top_n FROM params)
ORDER BY
  r.Bank_Code, r.Contract_Source_System,
  r.delta_abs DESC NULLS LAST, r.Account_Identifier;

/* ===================== 2) TIE-OUT SUMMARY (matches Waterfall Persisting Δ) ===================== */
SELECT
  'PERSISTING_DELTA_SUMMARY'::VARCHAR(30) AS section,
  (SELECT curr_eom FROM params)           AS eom,
  Bank_Code,
  Contract_Source_System,
  SUM(delta)::NUMERIC AS persisting_delta_sum,
  SUM(Prev_Bal)::NUMERIC AS total_prev_persist_bal,
  SUM(Curr_Bal)::NUMERIC AS total_curr_persist_bal,
  (SUM(Curr_Bal) - SUM(Prev_Bal))::NUMERIC AS check_delta
FROM persist
GROUP BY 2,3,4
ORDER BY Bank_Code, Contract_Source_System;






let
  Src = Merge1,

  // Force types & null-safe numbers
  Typed = Table.TransformColumnTypes(
            Src,
            {
              {"Old_SOURCE_SYSTEM_BALANCE", type number},
              {"New_SOURCE_SYSTEM_BALANCE", type number},
              {"Variance", type number}
            },
            "en-US"
          ),
  Safe = Table.TransformColumns(
           Typed,
           {
             {"Old_SOURCE_SYSTEM_BALANCE", each if _ = null then 0 else _, type number},
             {"New_SOURCE_SYSTEM_BALANCE", each if _ = null then 0 else _, type number},
             {"Variance", each if _ = null then 0 else _, type number}
           }
         ),

  // Totals from the row-level columns
  OldSum   = List.Sum( Safe[Old_SOURCE_SYSTEM_BALANCE] ),
  NewSum   = List.Sum( Safe[New_SOURCE_SYSTEM_BALANCE] ),
  VarSum   = List.Sum( Safe[Variance] ),
  RecalcVar = NewSum - OldSum,

  // Counts & distincts for diagnostics
  RowCount = Table.RowCount(Safe),
  DistAcct = List.Count(List.Distinct(Safe[ACCOUNT_IDENTIFIER])),

  // Compare the two ways of computing variance
  Diff_Check = VarSum - RecalcVar,

  // Output one neat row
  Out = #table(
          {"Old_Sum","New_Sum","Sum_of_Variance_Column","Recalc_Variance_(New-Old)","Difference_(SumVariance - Recalc)","Rows","Distinct_Accounts"},
          {{OldSum, NewSum, VarSum, RecalcVar, Diff_Check, RowCount, DistAcct}}
        )
in
  Out






let
  Source = Merge1,

  // Ensure numeric types & null-safe math
  Typed = Table.TransformColumnTypes(
           Source,
           {
             {"Old_SOURCE_SYSTEM_BALANCE", type number},
             {"New_SOURCE_SYSTEM_BALANCE", type number},
             {"Variance", type number}
           },
           "en-US"
         ),
  Safe = Table.TransformColumns(
           Typed,
           {
             {"Old_SOURCE_SYSTEM_BALANCE", each if _ = null then 0 else _, type number},
             {"New_SOURCE_SYSTEM_BALANCE", each if _ = null then 0 else _, type number},
             {"Variance", each if _ = null then 0 else _, type number}
           }
         ),

  // Add a helper for change type (in case you want counts)
  WithChangeType = Table.AddColumn(
                     Safe, "Change_Type",
                     each
                       if [Old_SOURCE_SYSTEM_BALANCE] <> 0 and [New_SOURCE_SYSTEM_BALANCE] = 0 then "Dropped"
                       else if [Old_SOURCE_SYSTEM_BALANCE] = 0 and [New_SOURCE_SYSTEM_BALANCE] <> 0 then "Added"
                       else "Balance Change",
                     type text
                   ),

  // Aggregate strictly by ACCOUNT_IDENTIFIER
  Grouped = Table.Group(
    WithChangeType,
    {"ACCOUNT_IDENTIFIER"},
    {
      {"Old_Total", each List.Sum([Old_SOURCE_SYSTEM_BALANCE]), type number},
      {"New_Total", each List.Sum([New_SOURCE_SYSTEM_BALANCE]), type number},
      {"Variance_Total", each List.Sum([Variance]), type number},

      // optional context (multi-row accounts handled via distinct concatenation)
      {"Systems", each Text.Combine(List.Distinct(List.Transform(Table.Column(_, "CONTRACT_SOURCE_SYSTEM"), each Text.From(_))), ", "), type text},
      {"Bank_Codes", each Text.Combine(List.Distinct(List.Transform(Table.Column(_, "BANK_CODE"), each Text.From(_))), ", "), type text},
      {"Non_Accrual_Flags", each Text.Combine(List.Distinct(List.Transform(Table.Column(_, "NON_ACCRUAL_FLAG"), each Text.From(_))), ", "), type text},
      {"Account_Names", each Text.Combine(List.Distinct(List.Transform(Table.Column(_, "ACCOUNT_NAME"), each Text.From(_))), " | "), type text},

      // quick diagnostics
      {"Added_Count", each Table.RowCount(Table.SelectRows(_, each [Change_Type] = "Added")), Int64.Type},
      {"Dropped_Count", each Table.RowCount(Table.SelectRows(_, each [Change_Type] = "Dropped")), Int64.Type},
      {"BalanceChange_Count", each Table.RowCount(Table.SelectRows(_, each [Change_Type] = "Balance Change")), Int64.Type}
    }
  ),

  // Keep only non-zero variances (adjust/remove this filter if you want all)
  NonZero = Table.SelectRows(Grouped, each [Variance_Total] <> 0),

  // Add AbsVariance for sorting
  WithAbs = Table.AddColumn(NonZero, "AbsVariance", each Number.Abs([Variance_Total]), type number),

  // Nice column order
  Reordered = Table.ReorderColumns(
                WithAbs,
                {
                  "ACCOUNT_IDENTIFIER", "Old_Total", "New_Total", "Variance_Total", "AbsVariance",
                  "Systems", "Bank_Codes", "Non_Accrual_Flags", "Account_Names",
                  "Added_Count", "Dropped_Count", "BalanceChange_Count"
                }
              ),

  // Sort by biggest dollar impact
  Sorted = Table.Sort(Reordered, {{"AbsVariance", Order.Descending}})
in
  Sorted






BANK_CODE
ACCOUNT_NAME
CONTRACT_SOURCE_SYSTEM
CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
STATUS_CODE_DESCRIPTION
INSTRUMENT_TYPE
GL_ACCOUNT_HIER_LEVEL_4
Old_SOURCE_SYSTEM_BALANCE
GL_BALANCE
AVAILABLE_BALANCE
BORROWER_RISK_RATING
PD_GRADE
DAYS_PAST_DUE
NON_ACCRUAL_FLAG
DAYS_PAST_DUE_BUCKET
BALANCE_BUCKET
ACCOUNT_ID_CLEAN
New_ACCOUNT_IDENTIFIER
New_SOURCE_SYSTEM_BALANCE
Variance







/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom,
    50::INT                           AS top_n,            -- rows per (Bank,System,Status)
    0::NUMERIC                        AS min_size,         -- minimum size_metric to include
    NULL::VARCHAR(50)                 AS bank_code,        -- e.g. '123'; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system  -- e.g. 'ACBS'; NULL = all
),

/* ===================== BASE POPULATION (filters applied) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name) AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag))) AS Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA AGGREGATES ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== MOM STATUS ===================== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
),

/* ===================== SIZE METRIC + SYSTEM TOTALS ===================== */
scored AS (
  SELECT
    m.Bank_Code,
    m.Contract_Source_System,
    m.Account_Identifier,
    m.Account_Name,
    m.NA_Transition,
    m.Prev_Bal,
    m.Curr_Bal,
    CASE
      WHEN m.NA_Transition = 'REMOVAL' THEN COALESCE(m.Prev_Bal,0)
      ELSE COALESCE(m.Curr_Bal,0)
    END AS size_metric,
    /* system totals used for % of system */
    SUM(CASE WHEN m.NA_Transition IN ('ADD','PERSIST') THEN COALESCE(m.Curr_Bal,0) ELSE 0 END)
      OVER (PARTITION BY m.Bank_Code, m.Contract_Source_System) AS sys_curr_total,
    SUM(CASE WHEN m.NA_Transition IN ('PERSIST','REMOVAL') THEN COALESCE(m.Prev_Bal,0) ELSE 0 END)
      OVER (PARTITION BY m.Bank_Code, m.Contract_Source_System) AS sys_prev_total
  FROM mom m
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR m.Bank_Code = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR m.Contract_Source_System = (SELECT contract_source_system FROM params) )
),

/* ===================== RANK PER (Bank,System,Status) ===================== */
ranked AS (
  SELECT
    s.*,
    CASE
      WHEN s.NA_Transition = 'REMOVAL' AND COALESCE(s.sys_prev_total,0) > 0
        THEN s.size_metric / NULLIF(s.sys_prev_total,0)
      WHEN COALESCE(s.sys_curr_total,0) > 0
        THEN s.size_metric / NULLIF(s.sys_curr_total,0)
      ELSE NULL
    END AS pct_of_system,
    ROW_NUMBER() OVER (
      PARTITION BY s.Bank_Code, s.Contract_Source_System, s.NA_Transition
      ORDER BY s.size_metric DESC NULLS LAST, s.Account_Identifier
    ) AS rnk
  FROM scored s
  WHERE s.size_metric >= (SELECT min_size FROM params)
)

/* ===================== FINAL OUTPUT ===================== */
SELECT
  r.Bank_Code,
  r.Contract_Source_System,
  r.NA_Transition,                     -- 'ADD' | 'REMOVAL' | 'PERSIST'
  r.Account_Identifier,
  r.Account_Name,
  r.Prev_Bal,
  r.Curr_Bal,
  r.size_metric,                       -- ranking metric (curr for ADD/PERSIST, prev for REMOVAL)
  r.pct_of_system                      -- share of system total (curr share for ADD/PERSIST, prev share for REMOVAL)
FROM ranked r
WHERE r.rnk <= (SELECT top_n FROM params)
  AND r.NA_Transition IN ('ADD','REMOVAL','PERSIST')
ORDER BY
  r.Bank_Code,
  r.Contract_Source_System,
  CASE r.NA_Transition WHEN 'ADD' THEN 0 WHEN 'REMOVAL' THEN 1 WHEN 'PERSIST' THEN 2 ELSE 3 END,
  r.size_metric DESC NULLS LAST,
  r.Account_Identifier;





/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,         -- << set current EOM
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom,
    50::INT                           AS top_n,            -- rows per (Bank,System,Status)
    0::NUMERIC                        AS min_size,         -- minimum size_metric to include
    NULL::VARCHAR(50)                 AS bank_code,        -- e.g. '123'; NULL = all
    NULL::VARCHAR(100)                AS contract_source_system  -- e.g. 'ACBS'; NULL = all
),

/* ===================== BASE POPULATION (filters applied) ===================== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS eom,
      Bank_Code,
      Contract_Source_System,
      Account_Identifier,
      MAX(Account_Name) AS Account_Name,
      SUM(Source_System_Balance)::NUMERIC AS Source_System_Balance,
      MAX(UPPER(TRIM(Non_Accrual_Flag))) AS Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
  GROUP BY 1,2,3,4
),

/* ===================== CURRENT / PRIOR NA AGGREGATES ===================== */
curr_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE eom = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code, Contract_Source_System, Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE eom = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
  GROUP BY 1,2,3
),

/* ===================== MOM STATUS ===================== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
),

/* ===================== SIZE METRIC + SYSTEM TOTALS ===================== */
scored AS (
  SELECT
    m.Bank_Code,
    m.Contract_Source_System,
    m.Account_Identifier,
    m.Account_Name,
    m.NA_Transition,
    m.Prev_Bal,
    m.Curr_Bal,
    CASE
      WHEN m.NA_Transition = 'REMOVAL' THEN COALESCE(m.Prev_Bal,0)
      ELSE COALESCE(m.Curr_Bal,0)
    END AS size_metric,
    /* system totals used for % of system */
    SUM(CASE WHEN m.NA_Transition IN ('ADD','PERSIST') THEN COALESCE(m.Curr_Bal,0) ELSE 0 END)
      OVER (PARTITION BY m.Bank_Code, m.Contract_Source_System) AS sys_curr_total,
    SUM(CASE WHEN m.NA_Transition IN ('PERSIST','REMOVAL') THEN COALESCE(m.Prev_Bal,0) ELSE 0 END)
      OVER (PARTITION BY m.Bank_Code, m.Contract_Source_System) AS sys_prev_total
  FROM mom m
  /* optional system filter(s) driven by params */
  WHERE ( (SELECT bank_code FROM params) IS NULL
          OR m.Bank_Code = (SELECT bank_code FROM params) )
    AND ( (SELECT contract_source_system FROM params) IS NULL
          OR m.Contract_Source_System = (SELECT contract_source_system FROM params) )
),

/* ===================== RANK PER (Bank,System,Status) ===================== */
ranked AS (
  SELECT
    s.*,
    CASE
      WHEN s.NA_Transition = 'REMOVAL' AND COALESCE(s.sys_prev_total,0) > 0
        THEN s.size_metric / NULLIF(s.sys_prev_total,0)
      WHEN COALESCE(s.sys_curr_total,0) > 0
        THEN s.size_metric / NULLIF(s.sys_curr_total,0)
      ELSE NULL
    END AS pct_of_system,
    ROW_NUMBER() OVER (
      PARTITION BY s.Bank_Code, s.Contract_Source_System, s.NA_Transition
      ORDER BY s.size_metric DESC NULLS LAST, s.Account_Identifier
    ) AS rnk
  FROM scored s
  WHERE s.size_metric >= (SELECT min_size FROM params)
)

/* ===================== FINAL OUTPUT ===================== */
SELECT
  Bank_Code,
  Contract_Source_System,
  NA_Transition,                     -- 'ADD' | 'REMOVAL' | 'PERSIST'
  Account_Identifier,
  Account_Name,
  Prev_Bal,
  Curr_Bal,
  size_metric,                       -- ranking metric (curr for ADD/PERSIST, prev for REMOVAL)
  pct_of_system                      -- share of system total (curr share for ADD/PERSIST, prev share for REMOVAL)
FROM ranked r
CROSS JOIN params p
WHERE r.rnk <= p.top_n
ORDER BY
  Bank_Code,
  Contract_Source_System,
  CASE NA_Transition WHEN 'ADD' THEN 0 WHEN 'REMOVAL' THEN 1 WHEN 'PERSIST' THEN 2 ELSE 3 END,
  size_metric DESC NULLS LAST,
  Account_Identifier;








/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'   AS curr_eom,     -- << set current EOM here
    13                  AS months_back,  -- current + 12 prior
    2.5::NUMERIC        AS z_threshold,  -- threshold for z-score flag
    0.15::NUMERIC       AS warn_pct,     -- 15% = Warning threshold
    0.25::NUMERIC       AS crit_pct      -- 25% = Critical threshold
),

/* ===================== SYSTEM-LEVEL MONTHLY BALANCES ===================== */
sys_monthly AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    Bank_Code,
    Contract_Source_System,
    SUM(Source_System_Balance)::NUMERIC AS sys_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3
),

/* ===================== ROLLING METRICS ===================== */
sys_metrics AS (
  SELECT
    s.*,
    LAG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
    ) AS prev_sys_bal,

    AVG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS mean_12_prior,

    STDDEV_SAMP(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS std_12_prior
  FROM sys_monthly s
),

/* ===================== CALCULATIONS (Z, % CHANGE) ===================== */
sys_calc AS (
  SELECT
    m.*,
    CASE
      WHEN m.std_12_prior IS NULL OR m.std_12_prior = 0 THEN NULL
      ELSE (m.sys_bal - m.mean_12_prior) / m.std_12_prior
    END AS sys_z_score,

    CASE
      WHEN m.prev_sys_bal IS NULL OR m.prev_sys_bal = 0 THEN NULL
      ELSE (m.sys_bal - m.prev_sys_bal) / NULLIF(m.prev_sys_bal,0)
    END AS sys_pct_change
  FROM sys_metrics m
)

/* ===================== FINAL OUTPUTS ===================== */

/* ---- 1) CURRENT MONTH ANOMALY INBOX ---- */
SELECT
  'SYSTEM_ANOMALY_INBOX'::VARCHAR(30) AS section,
  a.eom,
  a.Bank_Code,
  a.Contract_Source_System,
  a.sys_bal           AS curr_sys_balance,
  a.prev_sys_bal      AS prev_sys_balance,
  a.mean_12_prior,
  a.std_12_prior,
  a.sys_z_score,
  a.sys_pct_change,

  /* flag rules */
  CASE 
    WHEN a.sys_z_score IS NOT NULL 
     AND ABS(a.sys_z_score) >= (SELECT z_threshold FROM params)
    THEN 1 ELSE 0 END AS flag_sys_z,

  CASE 
    WHEN a.sys_pct_change IS NOT NULL
     AND ABS(a.sys_pct_change) >= (SELECT crit_pct FROM params)
    THEN 2  -- Critical
    WHEN a.sys_pct_change IS NOT NULL
     AND ABS(a.sys_pct_change) >= (SELECT warn_pct FROM params)
    THEN 1  -- Warning
    ELSE 0
  END AS flag_sys_pct,

  /* severity: Critical > Warning > OK */
  CASE
    WHEN (a.sys_z_score IS NOT NULL AND ABS(a.sys_z_score) >= (SELECT z_threshold FROM params))
      OR (a.sys_pct_change IS NOT NULL AND ABS(a.sys_pct_change) >= (SELECT crit_pct FROM params))
    THEN 'Critical'
    WHEN (a.sys_pct_change IS NOT NULL AND ABS(a.sys_pct_change) >= (SELECT warn_pct FROM params))
    THEN 'Warning'
    ELSE 'OK'
  END AS severity

FROM sys_calc a
WHERE a.eom = (SELECT curr_eom FROM params)
ORDER BY severity DESC, ABS(COALESCE(sys_z_score,0)) DESC, ABS(COALESCE(sys_pct_change,0)) DESC;

/* ---- 2) 13-MONTH TREND ---- */
SELECT
  'SYSTEM_TREND'::VARCHAR(30) AS section,
  t.eom,
  t.Bank_Code,
  t.Contract_Source_System,
  t.sys_bal           AS curr_sys_balance,
  t.prev_sys_bal,
  t.mean_12_prior,
  t.std_12_prior,
  t.sys_z_score,
  t.sys_pct_change
FROM sys_calc t
ORDER BY Bank_Code, Contract_Source_System, eom;






/* ===================== PARAMETERS ===================== */
WITH params AS (
  SELECT
    DATE '2025-07-31'   AS curr_eom,     -- << set current EOM here
    13                  AS months_back,  -- current + 12 prior
    2.5::NUMERIC        AS z_threshold,  -- threshold for z-score flag
    0.15::NUMERIC       AS warn_pct,     -- 15% = Warning threshold
    0.25::NUMERIC       AS crit_pct      -- 25% = Critical threshold
),

/* ===================== SYSTEM-LEVEL MONTHLY BALANCES ===================== */
sys_monthly AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    Bank_Code,
    Contract_Source_System,
    SUM(Source_System_Balance)::NUMERIC AS sys_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3
),

/* ===================== ROLLING METRICS ===================== */
sys_metrics AS (
  SELECT
    s.*,
    LAG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
    ) AS prev_sys_bal,

    AVG(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS mean_12_prior,

    STDDEV_SAMP(sys_bal) OVER (
      PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS std_12_prior
  FROM sys_monthly s
),

/* ===================== ANOMALY CALCULATIONS ===================== */
sys_anomalies AS (
  SELECT
    m.eom,
    m.Bank_Code,
    m.Contract_Source_System,
    m.sys_bal           AS curr_sys_balance,
    m.prev_sys_bal      AS prev_sys_balance,
    m.mean_12_prior,
    m.std_12_prior,

    /* z-score */
    CASE
      WHEN m.std_12_prior IS NULL OR m.std_12_prior = 0 THEN NULL
      ELSE (m.sys_bal - m.mean_12_prior) / m.std_12_prior
    END AS sys_z_score,

    /* % change */
    CASE
      WHEN m.prev_sys_bal IS NULL OR m.prev_sys_bal = 0 THEN NULL
      ELSE (m.sys_bal - m.prev_sys_bal) / NULLIF(m.prev_sys_bal,0)
    END AS sys_pct_change
  FROM sys_metrics m
)

/* ===================== FINAL OUTPUT: FLAGS + SEVERITY ===================== */
SELECT
  a.eom,
  a.Bank_Code,
  a.Contract_Source_System,
  a.curr_sys_balance,
  a.prev_sys_balance,
  a.mean_12_prior,
  a.std_12_prior,
  a.sys_z_score,
  a.sys_pct_change,

  /* flag rules */
  CASE 
    WHEN a.sys_z_score IS NOT NULL 
     AND ABS(a.sys_z_score) >= (SELECT z_threshold FROM params)
    THEN 1 ELSE 0 END AS flag_sys_z,

  CASE 
    WHEN a.sys_pct_change IS NOT NULL
     AND ABS(a.sys_pct_change) >= (SELECT crit_pct FROM params)
    THEN 2  -- Critical
    WHEN a.sys_pct_change IS NOT NULL
     AND ABS(a.sys_pct_change) >= (SELECT warn_pct FROM params)
    THEN 1  -- Warning
    ELSE 0
  END AS flag_sys_pct,

  /* severity: Critical > Warning > None */
  CASE
    WHEN (a.sys_z_score IS NOT NULL AND ABS(a.sys_z_score) >= (SELECT z_threshold FROM params))
      OR (a.sys_pct_change IS NOT NULL AND ABS(a.sys_pct_change) >= (SELECT crit_pct FROM params))
    THEN 'Critical'
    WHEN (a.sys_pct_change IS NOT NULL AND ABS(a.sys_pct_change) >= (SELECT warn_pct FROM params))
    THEN 'Warning'
    ELSE 'OK'
  END AS severity

FROM sys_anomalies a
WHERE a.eom = (SELECT curr_eom FROM params)
ORDER BY severity DESC, ABS(COALESCE(sys_z_score,0)) DESC, ABS(COALESCE(sys_pct_change,0)) DESC;






/* ====== PARAMETERS ====== */
WITH params AS (
  SELECT
    DATE '2025-07-31'   AS curr_eom,     -- set reporting month
    13                  AS months_back,  -- current + 12 prior
    2.5::NUMERIC        AS z_threshold,
    0.20::NUMERIC       AS pct_threshold
),

/* ====== NA totals by system, monthly (filters applied) ====== */
sys_monthly AS (
  SELECT
    CAST(End_of_Month_Date AS DATE) AS eom,
    Bank_Code,
    Contract_Source_System,
    SUM(Source_System_Balance)::NUMERIC AS sys_bal
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
    AND End_of_Month_Date BETWEEN
        ADD_MONTHS((SELECT curr_eom FROM params), -(SELECT months_back FROM params) + 1)
        AND (SELECT curr_eom FROM params)
  GROUP BY 1,2,3
),

/* ====== Add prior, rolling mean/std (exclude current row) ====== */
sys_metrics AS (
  SELECT
    s.*,
    LAG(sys_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom) AS prev_sys_bal,
    AVG(sys_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
                       ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS mean_12_prior,
    STDDEV_SAMP(sys_bal) OVER (PARTITION BY Bank_Code, Contract_Source_System ORDER BY eom
                               ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_12_prior
  FROM sys_monthly s
),

/* ====== Current-month anomaly flags (tiny result set) ====== */
sys_anomalies AS (
  SELECT
    m.eom,
    m.Bank_Code,
    m.Contract_Source_System,
    m.sys_bal           AS curr_sys_balance,
    m.prev_sys_bal      AS prev_sys_balance,
    m.mean_12_prior,
    m.std_12_prior,
    CASE WHEN m.std_12_prior IS NULL OR m.std_12_prior = 0 THEN NULL
         ELSE (m.sys_bal - m.mean_12_prior) / m.std_12_prior END AS sys_z_score,
    CASE WHEN m.prev_sys_bal IS NULL OR m.prev_sys_bal = 0 THEN NULL
         ELSE (m.sys_bal - m.prev_sys_bal) / NULLIF(m.prev_sys_bal,0) END AS sys_pct_change,
    /* flags */
    CASE WHEN (CASE WHEN m.std_12_prior = 0 THEN NULL
                    ELSE (m.sys_bal - m.mean_12_prior) / m.std_12_prior END)
              IS NOT NULL
          AND ABS((m.sys_bal - m.mean_12_prior) / m.std_12_prior) >= (SELECT z_threshold FROM params)
         THEN 1 ELSE 0 END AS flag_sys_z,
    CASE WHEN (CASE WHEN m.prev_sys_bal = 0 THEN NULL
                    ELSE (m.sys_bal - m.prev_sys_bal) / NULLIF(m.prev_sys_bal,0) END)
              IS NOT NULL
          AND ABS((m.sys_bal - m.prev_sys_bal) / NULLIF(m.prev_sys_bal,0)) >= (SELECT pct_threshold FROM params)
         THEN 1 ELSE 0 END AS flag_sys_pct
  FROM sys_metrics m
  WHERE m.eom = (SELECT curr_eom FROM params)
)
SELECT *
FROM sys_anomalies
ORDER BY
  (CASE WHEN flag_sys_z  = 1 THEN ABS(sys_z_score)    ELSE 0 END) DESC,
  (CASE WHEN flag_sys_pct= 1 THEN ABS(sys_pct_change) ELSE 0 END) DESC,
  Bank_Code, Contract_Source_System;






/* ====== PARAMETERS: set your reporting month ====== */
WITH params AS (
  SELECT
    DATE '2025-07-31'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-07-31', -1) AS prev_eom
),

/* ====== Base population with your filters ====== */
pop AS (
  SELECT
      CAST(End_of_Month_Date AS DATE) AS End_of_Month_Date,
      Account_Identifier,
      Account_Name,
      Bank_Code,
      Contract_Source_System,
      Source_System_Balance,
      Non_Accrual_Flag,
      GL_ACCOUNT_HIER_LEVEL_4
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),

/* ====== Aggregate to 1 row per account per month to avoid dupes ====== */
curr_agg AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Curr_Bal
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
  GROUP BY 1,2,3
),
prev_agg AS (
  SELECT
    Bank_Code,
    Contract_Source_System,
    Account_Identifier,
    MAX(Account_Name) AS Account_Name,
    SUM(Source_System_Balance)::NUMERIC AS Prev_Bal
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND UPPER(TRIM(Non_Accrual_Flag)) = 'Y'
  GROUP BY 1,2,3
),

/* ====== MoM status per account (Add / Removal / Persist) ====== */
mom AS (
  SELECT
    COALESCE(c.Bank_Code,             p.Bank_Code)              AS Bank_Code,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.Account_Identifier,    p.Account_Identifier)     AS Account_Identifier,
    COALESCE(c.Account_Name,          p.Account_Name)           AS Account_Name,
    CASE
      WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'ADD'
      WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'REMOVAL'
      ELSE 'PERSIST'
    END AS NA_Transition,
    p.Prev_Bal,
    c.Curr_Bal
  FROM curr_agg c
  FULL OUTER JOIN prev_agg p
    ON  c.Account_Identifier     = p.Account_Identifier
    AND c.Bank_Code              = p.Bank_Code
    AND c.Contract_Source_System = p.Contract_Source_System
),

/* ====== Roll up to the five-step bridge per bank/system ====== */
wf AS (
  SELECT
    Bank_Code,
    Contract_Source_System,

    /* 1) Start = prior NA (persist.prev + removal.prev) */
    SUM(CASE WHEN NA_Transition IN ('PERSIST','REMOVAL')
             THEN COALESCE(Prev_Bal,0) ELSE 0 END) AS start_balance,

    /* 2) Adds = current $ of new NA */
    SUM(CASE WHEN NA_Transition = 'ADD'
             THEN COALESCE(Curr_Bal,0) ELSE 0 END) AS adds,

    /* 3) Removals = negative prior $ of exits */
    -SUM(CASE WHEN NA_Transition = 'REMOVAL'
              THEN COALESCE(Prev_Bal,0) ELSE 0 END) AS removals,

    /* 4) Persisting Δ = (persist.curr - persist.prev) */
    SUM(CASE WHEN NA_Transition = 'PERSIST'
             THEN COALESCE(Curr_Bal,0) - COALESCE(Prev_Bal,0) ELSE 0 END) AS persisting_delta,

    /* 5) End = current NA (adds.curr + persist.curr) */
    SUM(CASE WHEN NA_Transition IN ('ADD','PERSIST')
             THEN COALESCE(Curr_Bal,0) ELSE 0 END) AS end_balance
  FROM mom
  GROUP BY 1,2
)

/* ====== Final long-form output for Power BI Waterfall ====== */
SELECT
  Bank_Code,
  Contract_Source_System,
  1 AS metric_order,
  'start_balance'::VARCHAR(30) AS metric_name,
  start_balance::NUMERIC       AS metric_value
FROM wf
UNION ALL
SELECT Bank_Code, Contract_Source_System, 2, 'adds',            adds            FROM wf
UNION ALL
SELECT Bank_Code, Contract_Source_System, 3, 'removals',        removals        FROM wf
UNION ALL
SELECT Bank_Code, Contract_Source_System, 4, 'persisting_delta', persisting_delta FROM wf
UNION ALL
SELECT Bank_Code, Contract_Source_System, 5, 'end_balance',     end_balance     FROM wf
ORDER BY Bank_Code, Contract_Source_System, metric_order;





WITH params AS (
  SELECT
    DATE '2025-08-31'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-08-31', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Identifier,
      Account_Name,
      Bank_Code,
      Contract_Source_System,
      Source_System_Balance,
      Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 in ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
),
prev AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
)
SELECT
  COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
  COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
  COALESCE(c.Bank_Code,          p.Bank_Code)          AS Bank_Code,
  COALESCE(c.Contract_Source_System, p.Contract_Source_System) AS Contract_Source_System,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Removed (Resolved/Out)'
    ELSE 'Persisting'
  END AS NA_Status_Change,
  p.Source_System_Balance AS Prev_Bal,
  c.Source_System_Balance AS Curr_Bal,
  /* use a numeric sort key instead of ordering by the alias */
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 0
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1
    WHEN c.Account_Identifier IS NOT NULL AND p.Account_Identifier IS NOT NULL THEN 2
    ELSE 3
  END AS Sort_Order
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
ORDER BY
  Sort_Order,
  Bank_Code,
  Account_Identifier;







-- =========================================================
-- Set your schema and month-end ONCE
-- =========================================================
-- Replace with your schema (e.g., CIDPR.DATAHUB)
SET SCHEMA 'YOUR_SCHEMA';

-- Pick the reporting month-end:
-- (Change each run; keep YYYY-MM-DD format)
-- =========================================================
-- Safety: drop old params if left around
DROP TABLE IF EXISTS WRK_PARAMS;

CREATE TABLE WRK_PARAMS AS
SELECT DATE '2025-08-31' AS asof_eom;

-- =========================================================
-- 1) Current / Prior snapshots (NA only)
--    Use safe numeric cast for GL_BALANCE to handle 'N'/'NULL'
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_CUR;
CREATE TABLE WRK_NA_CUR AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  /* safe cast in case of text noise */
  CASE
    WHEN t.GL_BALANCE ~ '^[0-9\.\-]+$' THEN t.GL_BALANCE::NUMERIC
    ELSE NULL
  END AS GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = p.asof_eom
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

DROP TABLE IF EXISTS WRK_NA_PREV;
CREATE TABLE WRK_NA_PREV AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  CASE
    WHEN t.GL_BALANCE ~ '^[0-9\.\-]+$' THEN t.GL_BALANCE::NUMERIC
    ELSE NULL
  END AS GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

GENERATE STATISTICS ON WRK_NA_CUR;
GENERATE STATISTICS ON WRK_NA_PREV;

-- Quick counts (optional)
SELECT 'CUR' src, COUNT(*) cnt FROM WRK_NA_CUR
UNION ALL SELECT 'PREV', COUNT(*) FROM WRK_NA_PREV;

-- =========================================================
-- 2) Sets: ADDS / REMOVALS / PERSIST (NOT EXISTS / JOIN)
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_ADDS;
CREATE TABLE WRK_NA_ADDS AS
SELECT c.*
FROM WRK_NA_CUR c
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_PREV p WHERE p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_REMOVALS;
CREATE TABLE WRK_NA_REMOVALS AS
SELECT p.*
FROM WRK_NA_PREV p
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_CUR c WHERE c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_PERSIST;
CREATE TABLE WRK_NA_PERSIST AS
SELECT
  c.eom,
  c.BANK_CODE,
  c.CONTRACT_SOURCE_SYSTEM,
  c.GL_ACCOUNT_HIER_LEVEL_4,
  c.ACCOUNT_IDENTIFIER,
  c.FACILITY_ID,
  c.GL_BALANCE AS cur_balance,
  p.GL_BALANCE AS prev_balance,
  c.INDUSTRY_CODE,
  c.PD_GRADE
FROM WRK_NA_CUR  c
JOIN WRK_NA_PREV p
  ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER;

GENERATE STATISTICS ON WRK_NA_ADDS;
GENERATE STATISTICS ON WRK_NA_REMOVALS;
GENERATE STATISTICS ON WRK_NA_PERSIST;

-- =========================================================
-- 3) Pre-aggregate once (no correlated subselects)
-- =========================================================
DROP TABLE IF EXISTS WRK_AGG_CUR;
CREATE TABLE WRK_AGG_CUR AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS na_eom_balance,
       COUNT(*)        AS na_eom_count
FROM WRK_NA_CUR
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_ADDS;
CREATE TABLE WRK_AGG_ADDS AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS adds_balance,
       COUNT(*)        AS adds_count
FROM WRK_NA_ADDS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
CREATE TABLE WRK_AGG_REMOVALS AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS removals_balance,
       COUNT(*)        AS removals_count
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_PERSIST;
CREATE TABLE WRK_AGG_PERSIST AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(cur_balance) AS persist_balance,
       COUNT(*)         AS persist_count
FROM WRK_NA_PERSIST
GROUP BY 1,2,3;

GENERATE STATISTICS ON WRK_AGG_CUR;
GENERATE STATISTICS ON WRK_AGG_ADDS;
GENERATE STATISTICS ON WRK_AGG_REMOVALS;
GENERATE STATISTICS ON WRK_AGG_PERSIST;

-- =========================================================
-- 4) Unified keyset, KPI table
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_KEYS;
CREATE TABLE WRK_NA_KEYS AS
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_CUR
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PREV
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PERSIST;

GENERATE STATISTICS ON WRK_NA_KEYS;

DROP TABLE IF EXISTS WRK_NA_KPI;
CREATE TABLE WRK_NA_KPI AS
SELECT
  k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.na_eom_balance,  0)::NUMERIC AS na_eom_balance,
  COALESCE(c.na_eom_count,    0)::NUMERIC AS na_eom_count,
  COALESCE(a.adds_balance,    0)::NUMERIC AS adds_balance,
  COALESCE(a.adds_count,      0)::NUMERIC AS adds_count,
  COALESCE(r.removals_balance,0)::NUMERIC AS removals_balance,
  COALESCE(r.removals_count,  0)::NUMERIC AS removals_count,
  COALESCE(p.persist_balance, 0)::NUMERIC AS persist_balance,
  COALESCE(p.persist_count,   0)::NUMERIC AS persist_count
FROM WRK_NA_KEYS k
LEFT JOIN WRK_AGG_CUR      c USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_ADDS     a USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_REMOVALS r USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_PERSIST  p USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4);

GENERATE STATISTICS ON WRK_NA_KPI;

-- =========================================================
-- 5) Waterfall & Adds composition (long format)
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_WATERFALL;
CREATE TABLE WRK_NA_WATERFALL AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT 'WATERFALL'::VARCHAR(20) AS section,
       (SELECT asof_eom FROM prm) AS eom,
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'start_balance'::VARCHAR(50) AS metric_name,
       SUM(GL_BALANCE)::NUMERIC AS metric_value,
       NULL::VARCHAR(100) AS extra_dim1,
       NULL::VARCHAR(100) AS extra_dim2
FROM WRK_NA_PREV
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'adds', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'removals', -SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'end_balance', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_CUR
GROUP BY 1,2,3,4,5;

GENERATE STATISTICS ON WRK_NA_WATERFALL;

DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
CREATE TABLE WRK_NA_ADDS_COMP AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT
  'ADDS_COMPOSITION'::VARCHAR(20) AS section,
  (SELECT asof_eom FROM prm)      AS eom,
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_balance'::VARCHAR(50)     AS metric_name,
  SUM(GL_BALANCE)::NUMERIC        AS metric_value,
  COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
  COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9

UNION ALL
SELECT
  'ADDS_COMPOSITION', (SELECT asof_eom FROM prm),
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_count',
  COUNT(*)::NUMERIC,
  COALESCE(INDUSTRY_CODE,'(unknown)'),
  COALESCE(PD_GRADE,'(unknown)')
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9;

GENERATE STATISTICS ON WRK_NA_ADDS_COMP;

-- =========================================================
-- 6) Peek outputs (query these in this or later sessions)
-- =========================================================
SELECT * FROM WRK_NA_KPI        ORDER BY na_eom_balance DESC NULLS LAST LIMIT 200;
SELECT * FROM WRK_NA_WATERFALL  ORDER BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name;
SELECT * FROM WRK_NA_ADDS_COMP  ORDER BY metric_value DESC NULLS LAST LIMIT 200;

-- =========================================================
-- 7) CLEANUP (optional)
--    Comment out this whole block if you want to keep tables
-- =========================================================
-- DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
-- DROP TABLE IF EXISTS WRK_NA_WATERFALL;
-- DROP TABLE IF EXISTS WRK_NA_KPI;
-- DROP TABLE IF EXISTS WRK_NA_KEYS;
-- DROP TABLE IF EXISTS WRK_AGG_PERSIST;
-- DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
-- DROP TABLE IF EXISTS WRK_AGG_ADDS;
-- DROP TABLE IF EXISTS WRK_AGG_CUR;
-- DROP TABLE IF EXISTS WRK_NA_PERSIST;
-- DROP TABLE IF EXISTS WRK_NA_REMOVALS;
-- DROP TABLE IF EXISTS WRK_NA_ADDS;
-- DROP TABLE IF EXISTS WRK_NA_PREV;
-- DROP TABLE IF EXISTS WRK_NA_CUR;
-- DROP TABLE IF EXISTS WRK_PARAMS;






-- 1) Drop if exists (safe if it never existed)
DROP TABLE IF EXISTS WRK_DEMO_TEMP;

-- 2) Create a tiny temp table
CREATE TEMP TABLE WRK_DEMO_TEMP (id INTEGER, note VARCHAR(20));

-- 3) Insert one row
INSERT INTO WRK_DEMO_TEMP VALUES (1, 'hello');

-- 4) Read it back
SELECT * FROM WRK_DEMO_TEMP;

-- 5) Confirm it exists in session temp catalog
SELECT objname, objtype
FROM _v_tempobjects
WHERE UPPER(objname) = 'WRK_DEMO_TEMP';






-- ========= PARAM =========
-- Set your month-end once here
CREATE TEMP TABLE WRK_PARAMS AS
SELECT DATE '2025-08-31' AS asof_eom;

-- ========= CURRENT / PRIOR NA SLICES (ONLY NEEDED COLS) =========
DROP TABLE IF EXISTS WRK_NA_CUR;
CREATE TEMP TABLE WRK_NA_CUR
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  -- If GL_BALANCE might have non-numeric values, use the safe cast below instead:
  -- CAST(NULLIF(t.GL_BALANCE,'N') AS NUMERIC) AS GL_BALANCE,
  t.GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = p.asof_eom
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

DROP TABLE IF EXISTS WRK_NA_PREV;
CREATE TEMP TABLE WRK_NA_PREV
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  -- CAST(NULLIF(t.GL_BALANCE,'N') AS NUMERIC) AS GL_BALANCE,
  t.GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

GENERATE STATISTICS ON WRK_NA_CUR;
GENERATE STATISTICS ON WRK_NA_PREV;

-- ========= SETS: ADDS / REMOVALS / PERSIST =========
DROP TABLE IF EXISTS WRK_NA_ADDS;
CREATE TEMP TABLE WRK_NA_ADDS
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT c.*
FROM WRK_NA_CUR c
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_PREV p
  WHERE p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_REMOVALS;
CREATE TEMP TABLE WRK_NA_REMOVALS
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT p.*
FROM WRK_NA_PREV p
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_CUR c
  WHERE c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_PERSIST;
CREATE TEMP TABLE WRK_NA_PERSIST
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  c.eom,
  c.BANK_CODE,
  c.CONTRACT_SOURCE_SYSTEM,
  c.GL_ACCOUNT_HIER_LEVEL_4,
  c.ACCOUNT_IDENTIFIER,
  c.FACILITY_ID,
  c.GL_BALANCE  AS cur_balance,
  p.GL_BALANCE  AS prev_balance,
  c.INDUSTRY_CODE,
  c.PD_GRADE
FROM WRK_NA_CUR  c
JOIN WRK_NA_PREV p
  ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER;

GENERATE STATISTICS ON WRK_NA_ADDS;
GENERATE STATISTICS ON WRK_NA_REMOVALS;
GENERATE STATISTICS ON WRK_NA_PERSIST;

-- ========= KEYSET (ALL SEGMENTS THAT APPEAR IN EITHER MONTH) =========
DROP TABLE IF EXISTS WRK_NA_KEYS;
CREATE TEMP TABLE WRK_NA_KEYS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_CUR
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PREV
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PERSIST;

GENERATE STATISTICS ON WRK_NA_KEYS;

-- ========= PRE-AGGREGATE ONCE (NO CORRELATED SUBSELECTS) =========
DROP TABLE IF EXISTS WRK_AGG_CUR;
CREATE TEMP TABLE WRK_AGG_CUR
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS na_eom_balance,
       COUNT(*)        AS na_eom_count
FROM WRK_NA_CUR
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_ADDS;
CREATE TEMP TABLE WRK_AGG_ADDS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS adds_balance,
       COUNT(*)        AS adds_count
FROM WRK_NA_ADDS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
CREATE TEMP TABLE WRK_AGG_REMOVALS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS removals_balance,
       COUNT(*)        AS removals_count
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_PERSIST;
CREATE TEMP TABLE WRK_AGG_PERSIST
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(cur_balance) AS persist_balance,
       COUNT(*)         AS persist_count
FROM WRK_NA_PERSIST
GROUP BY 1,2,3;

GENERATE STATISTICS ON WRK_AGG_CUR;
GENERATE STATISTICS ON WRK_AGG_ADDS;
GENERATE STATISTICS ON WRK_AGG_REMOVALS;
GENERATE STATISTICS ON WRK_AGG_PERSIST;

-- ========= KPI (JOIN PRE-AGGS TO KEYSET) =========
DROP TABLE IF EXISTS WRK_NA_KPI;
CREATE TEMP TABLE WRK_NA_KPI
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT
  k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.na_eom_balance,  0)::NUMERIC AS na_eom_balance,
  COALESCE(c.na_eom_count,    0)::NUMERIC AS na_eom_count,
  COALESCE(a.adds_balance,    0)::NUMERIC AS adds_balance,
  COALESCE(a.adds_count,      0)::NUMERIC AS adds_count,
  COALESCE(r.removals_balance,0)::NUMERIC AS removals_balance,
  COALESCE(r.removals_count,  0)::NUMERIC AS removals_count,
  COALESCE(p.persist_balance, 0)::NUMERIC AS persist_balance,
  COALESCE(p.persist_count,   0)::NUMERIC AS persist_count
FROM WRK_NA_KEYS k
LEFT JOIN WRK_AGG_CUR      c USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_ADDS     a USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_REMOVALS r USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_PERSIST  p USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4);

GENERATE STATISTICS ON WRK_NA_KPI;

-- ========= WATERFALL =========
DROP TABLE IF EXISTS WRK_NA_WATERFALL;
CREATE TEMP TABLE WRK_NA_WATERFALL
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT 'WATERFALL'::VARCHAR(20) AS section,
       (SELECT asof_eom FROM prm) AS eom,
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'start_balance'::VARCHAR(50) AS metric_name,
       SUM(GL_BALANCE)::NUMERIC AS metric_value,
       NULL::VARCHAR(100) AS extra_dim1,
       NULL::VARCHAR(100) AS extra_dim2
FROM WRK_NA_PREV
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'adds', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'removals', -SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'end_balance', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_CUR
GROUP BY 1,2,3,4,5;

GENERATE STATISTICS ON WRK_NA_WATERFALL;

-- ========= ADDS COMPOSITION =========
DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
CREATE TEMP TABLE WRK_NA_ADDS_COMP
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT
  'ADDS_COMPOSITION'::VARCHAR(20) AS section,
  (SELECT asof_eom FROM prm)      AS eom,
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_balance'::VARCHAR(50)     AS metric_name,
  SUM(GL_BALANCE)::NUMERIC        AS metric_value,
  COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
  COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9

UNION ALL
SELECT
  'ADDS_COMPOSITION', (SELECT asof_eom FROM prm),
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_count',
  COUNT(*)::NUMERIC,
  COALESCE(INDUSTRY_CODE,'(unknown)'),
  COALESCE(PD_GRADE,'(unknown)')
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9;

GENERATE STATISTICS ON WRK_NA_ADDS_COMP;

-- ========= OPTIONAL: QUICK PEEK =========
SELECT * FROM WRK_NA_KPI        ORDER BY na_eom_balance DESC NULLS LAST LIMIT 200;
SELECT * FROM WRK_NA_WATERFALL  ORDER BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name;
SELECT * FROM WRK_NA_ADDS_COMP  ORDER BY metric_value DESC NULLS LAST LIMIT 200;







WITH params AS (
  SELECT DATE '2025-08-31' AS asof_eom
),

/* 1) Current & prior month NA slices */
cur AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = p.asof_eom
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),
prev AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),

/* 2) Sets via joins on ACCOUNT_IDENTIFIER */
adds AS (         /* in cur, not in prev */
  SELECT c.*
  FROM cur c
  LEFT JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
  WHERE p.ACCOUNT_IDENTIFIER IS NULL
),
removals AS (     /* in prev, not in cur */
  SELECT p.*
  FROM prev p
  LEFT JOIN cur c
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
),
persist AS (      /* in both */
  SELECT
    c.eom,
    c.BANK_CODE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.ACCOUNT_IDENTIFIER,
    c.FACILITY_ID,
    c.GL_BALANCE  AS cur_balance,
    p.GL_BALANCE  AS prev_balance,
    c.INDUSTRY_CODE,
    c.PD_GRADE
  FROM cur c
  INNER JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
),

/* 3) KPI rollups (by BANK/SYSTEM/GL_L4) */
kpi AS (
  SELECT
    COALESCE(x.BANK_CODE, y.BANK_CODE, z.BANK_CODE) AS BANK_CODE,
    COALESCE(x.CONTRACT_SOURCE_SYSTEM, y.CONTRACT_SOURCE_SYSTEM, z.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4, y.GL_ACCOUNT_HIER_LEVEL_4, z.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,

    /* EOM NA */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_balance,
    COALESCE( (SELECT COUNT(*) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_count,

    /* Adds */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_balance,
    COALESCE( (SELECT COUNT(*) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_count,

    /* Removals (use prev dollars) */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_balance,
    COALESCE( (SELECT COUNT(*) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_count,

    /* Persist (use current dollars) */
    COALESCE( (SELECT SUM(cur_balance) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_balance,
    COALESCE( (SELECT COUNT(*) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_count

  FROM (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM cur) x
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM prev) y
    ON y.BANK_CODE=x.BANK_CODE AND y.CONTRACT_SOURCE_SYSTEM=x.CONTRACT_SOURCE_SYSTEM AND y.GL_ACCOUNT_HIER_LEVEL_4=x.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM persist) z
    ON z.BANK_CODE = COALESCE(x.BANK_CODE,y.BANK_CODE)
   AND z.CONTRACT_SOURCE_SYSTEM = COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM)
   AND z.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 4) Waterfall rows */
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    SUM(GL_BALANCE)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM prev
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds', SUM(GL_BALANCE), NULL, NULL
  FROM adds
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals', -SUM(GL_BALANCE), NULL, NULL
  FROM removals
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'end_balance', SUM(GL_BALANCE), NULL, NULL
  FROM cur
  GROUP BY 1,2,3,4,5
),

/* 5) Adds composition (Industry / PD_GRADE) — FIXED GROUP BY */
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,              -- 1
    (SELECT asof_eom FROM params)   AS eom,                  -- 2
    BANK_CODE,                                                -- 3
    CONTRACT_SOURCE_SYSTEM,                                   -- 4
    GL_ACCOUNT_HIER_LEVEL_4,                                  -- 5
    'adds_balance'::VARCHAR(50)     AS metric_name,           -- 6
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,          -- 7 (aggregate)
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,        -- 8
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2         -- 9
  FROM adds
  GROUP BY 1,2,3,4,5,8,9

  UNION ALL

  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count',
    COUNT(*)::NUMERIC,
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,8,9
),

/* 6) KPI long rows */
kpi_long AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    na_eom_balance::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', na_eom_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count::NUMERIC, NULL, NULL FROM kpi
)

/* === FINAL OUTPUT === */
SELECT * FROM kpi_long
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM adds_comp_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 20000;





-- ====== 5) Adds composition (Industry / PD_GRADE) — FIXED GROUP BY ======
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,            -- 1
    (SELECT asof_eom FROM params)   AS eom,                -- 2
    BANK_CODE,                                              -- 3
    CONTRACT_SOURCE_SYSTEM,                                 -- 4
    GL_ACCOUNT_HIER_LEVEL_4,                                -- 5
    'adds_balance'::VARCHAR(50)     AS metric_name,         -- 6
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,        -- 7 (aggregate)
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,      -- 8
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2       -- 9
  FROM adds
  GROUP BY 1,2,3,4,5,8,9   -- ✅ exclude column 7 (aggregate)

  UNION ALL

  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count',
    COUNT(*)::NUMERIC,                                     -- aggregate
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,8,9   -- ✅ exclude the COUNT(*) column
)





-- ====== PARAMETERS ======
WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom
),

-- ====== 1) Current & prior month NA slices (only needed columns) ======
cur AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = p.asof_eom
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),
prev AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),

-- ====== 2) Sets: ADDS, REMOVALS, PERSISTING (set joins, no windows) ======
adds AS (         -- in cur, not in prev
  SELECT c.*
  FROM cur c
  LEFT JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
  WHERE p.ACCOUNT_IDENTIFIER IS NULL
),
removals AS (     -- in prev, not in cur
  SELECT p.*
  FROM prev p
  LEFT JOIN cur c
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
),
persist AS (      -- in both
  SELECT
    c.eom,
    c.BANK_CODE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.ACCOUNT_IDENTIFIER,
    c.FACILITY_ID,
    c.GL_BALANCE      AS cur_balance,
    p.GL_BALANCE      AS prev_balance,
    c.INDUSTRY_CODE,
    c.PD_GRADE
  FROM cur c
  INNER JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
),

-- ====== 3) KPI rollups (by BANK/SYSTEM/GL_L4) ======
kpi AS (
  SELECT
    COALESCE(x.BANK_CODE, y.BANK_CODE, z.BANK_CODE) AS BANK_CODE,
    COALESCE(x.CONTRACT_SOURCE_SYSTEM, y.CONTRACT_SOURCE_SYSTEM, z.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4, y.GL_ACCOUNT_HIER_LEVEL_4, z.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,

    -- EOM NA balance/count (from cur)
    COALESCE( (SELECT SUM(GL_BALANCE) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_balance,
    COALESCE( (SELECT COUNT(*) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_count,

    -- Adds $/count
    COALESCE( (SELECT SUM(GL_BALANCE) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_balance,
    COALESCE( (SELECT COUNT(*) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_count,

    -- Removals $/count (use prev_balance dollars)
    COALESCE( (SELECT SUM(GL_BALANCE) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_balance,
    COALESCE( (SELECT COUNT(*) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_count,

    -- Persisting $/count (use current balances for $)
    COALESCE( (SELECT SUM(cur_balance) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_balance,
    COALESCE( (SELECT COUNT(*) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_count

  FROM (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM cur) x
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM prev) y
    ON y.BANK_CODE=x.BANK_CODE AND y.CONTRACT_SOURCE_SYSTEM=x.CONTRACT_SOURCE_SYSTEM AND y.GL_ACCOUNT_HIER_LEVEL_4=x.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM persist) z
    ON z.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE)
   AND z.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM)
   AND z.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4)
),

-- ====== 4) Waterfall rows (per key) without joining giant sets ======
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    SUM(GL_BALANCE)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM prev
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds', SUM(GL_BALANCE), NULL, NULL
  FROM adds
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals', -SUM(GL_BALANCE), NULL, NULL    -- negative for removals
  FROM removals
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'end_balance', SUM(GL_BALANCE), NULL, NULL
  FROM cur
  GROUP BY 1,2,3,4,5
),

-- ====== 5) Adds composition (Industry / PD_GRADE) ======
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params)   AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50)     AS metric_name,
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
  FROM adds
  GROUP BY 1,2,3,4,5,7,8

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', COUNT(*)::NUMERIC,
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,7,8
),

-- ====== 6) KPI long rows (so you can reuse visuals easily) ======
kpi_long AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    na_eom_balance::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', na_eom_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count::NUMERIC, NULL, NULL FROM kpi
)

-- ====== FINAL OUTPUT (long format) ======
SELECT * FROM kpi_long
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM adds_comp_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 20000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag Y/N -> 1/0, use GL_BALANCE, include FACILITY_ID */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.ACCOUNT_IDENTIFIER,
      t.FACILITY_ID,
      t.GL_BALANCE,
      CASE
        WHEN UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional
      t.PD_GRADE           -- replaced Risk_Rating
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per account */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_na_flag,
    LAG(b.GL_BALANCE)        OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_balance
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    ACCOUNT_IDENTIFIER, FACILITY_ID,
    GL_BALANCE, prev_balance,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, PD_GRADE,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) using GL_BALANCE */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='ADD'     THEN 1           ELSE 0 END)  AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN 1           ELSE 0 END)  AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN GL_BALANCE   ELSE 0 END) AS persist_balance,
    SUM(CASE WHEN na_transition='PERSIST' THEN 1           ELSE 0 END)  AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS na_eom_balance,
    COUNT(*)        AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) using GL_BALANCE */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS prev_na_balance
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS curr_na_balance
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na2 AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.ACCOUNT_IDENTIFIER ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na2 l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.ACCOUNT_IDENTIFIER ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.ACCOUNT_IDENTIFIER, s.FACILITY_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.PD_GRADE,
    MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) )::INT AS months_since_entry,
    s.GL_BALANCE
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & PD_GRADE) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.PD_GRADE,'(unknown)')      AS PD_GRADE,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN c.na_transition='ADD' THEN 1           ELSE 0 END)    AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50) AS metric_name,
    adds_balance::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    PD_GRADE      AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, PD_GRADE
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag to 1/0, use GL_BALANCE, include FACILITY_ID */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.ACCOUNT_IDENTIFIER,
      t.FACILITY_ID,
      t.GL_BALANCE,
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional, keep if available
      t.PD_GRADE           -- replaced Risk_Rating
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per account */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_na_flag,
    LAG(b.GL_BALANCE)        OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_balance
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    ACCOUNT_IDENTIFIER, FACILITY_ID,
    GL_BALANCE, prev_balance,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, PD_GRADE,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) using GL_BALANCE */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    COUNT(CASE WHEN na_transition='ADD'     THEN 1 END)                  AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance,
    COUNT(CASE WHEN na_transition='REMOVAL' THEN 1 END)                  AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN GL_BALANCE   ELSE 0 END) AS persist_balance,
    COUNT(CASE WHEN na_transition='PERSIST' THEN 1 END)                  AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS na_eom_balance,
    COUNT(*)        AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) using GL_BALANCE */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS prev_na_balance
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS curr_na_balance
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) using ACCOUNT_IDENTIFIER, GL_BALANCE carried for optional weighting */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.ACCOUNT_IDENTIFIER ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.ACCOUNT_IDENTIFIER ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.ACCOUNT_IDENTIFIER, s.FACILITY_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.PD_GRADE,
    MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) )::INT AS months_since_entry,
    s.GL_BALANCE
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & PD_GRADE) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.PD_GRADE,'(unknown)')      AS PD_GRADE,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.GL_BALANCE   ELSE 0 END) AS adds_balance,
    COUNT(CASE WHEN c.na_transition='ADD' THEN 1 END)                    AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50) AS metric_name,
    adds_balance::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    PD_GRADE      AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, PD_GRADE
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;








WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag to 1/0 */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.LOAN_ID,
      t.EXPOSURE_AMOUNT,
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional, keep if available
      t.RISK_RATING        -- optional, keep if available
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per loan */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.LOAN_ID ORDER BY b.eom) AS prev_na_flag,
    LAG(b.EXPOSURE_AMOUNT)  OVER (PARTITION BY b.LOAN_ID ORDER BY b.eom) AS prev_exposure
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    LOAN_ID, EXPOSURE_AMOUNT, prev_exposure,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, RISK_RATING,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN EXPOSURE_AMOUNT  ELSE 0 END) AS adds_exposure,
    COUNT(CASE WHEN na_transition='ADD'     THEN 1 END)                      AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_exposure  ELSE 0 END)   AS removals_exposure,
    COUNT(CASE WHEN na_transition='REMOVAL' THEN 1 END)                      AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN EXPOSURE_AMOUNT ELSE 0 END)  AS persist_exposure,
    COUNT(CASE WHEN na_transition='PERSIST' THEN 1 END)                      AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS na_eom_exposure,
    COUNT(*)             AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_exposure'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_exposure,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_exposure', adds_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_exposure', removals_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_exposure', persist_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS prev_na_exposure
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS curr_na_exposure
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN EXPOSURE_AMOUNT ELSE 0 END) AS adds_exposure,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_exposure  ELSE 0 END) AS removals_exposure
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_exposure,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.LOAN_ID ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.LOAN_ID ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.LOAN_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.RISK_RATING,
    MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id))) )::INT AS months_since_entry,
    s.EXPOSURE_AMOUNT
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & Risk) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.RISK_RATING,'(unknown)')   AS RISK_RATING,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.EXPOSURE_AMOUNT ELSE 0 END) AS adds_exposure,
    COUNT(CASE WHEN c.na_transition='ADD' THEN 1 END)                       AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_exposure'::VARCHAR(50) AS metric_name,
    adds_exposure::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    RISK_RATING  AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, RISK_RATING
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,
    17 AS lookback_months   -- prior 17 + current = 18 months total
),
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.LOAN_ID,
      t.EXPOSURE_AMOUNT,
      /* Map Non-Accrual to 1/0 if your source uses Y/N or text */
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,
      t.RISK_RATING
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months)
                                AND p.asof_eom
)
SELECT *
FROM base
ORDER BY eom DESC
LIMIT 100;





-- Anchor at the latest month-end you want in the dashboard
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    17 AS lookback_months  -- prior 17 + current = 18 months
),

/* Base: keep only fields we need */
base AS (
  SELECT
    t.END_OF_MONTH_DATE::DATE AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.LOAN_ID,
    t.EXPOSURE_AMOUNT,                     -- or your preferred balance
    t.NON_ACCRUAL_FLAG,                    -- 1/0 (adjust if Y/N or text)
    t.INDUSTRY_CODE,                       -- optional
    t.RISK_RATING                          -- optional
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
)




, lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (
      PARTITION BY b.LOAN_ID
      ORDER BY b.eom
    ) AS prev_na_flag,

    LAG(b.EXPOSURE_AMOUNT) OVER (
      PARTITION BY b.LOAN_ID
      ORDER BY b.eom
    ) AS prev_exposure
  FROM base b
),

/* Classify each loan each month */
classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    LOAN_ID, EXPOSURE_AMOUNT, prev_exposure,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, RISK_RATING,

    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
)





-- Set the anchor month (latest month-end you want to analyze)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    12                      AS lookback_months,  -- prior 12 + current = 13 months
    2.5::FLOAT              AS z_threshold,
    0.10::FLOAT             AS pct_threshold,    -- 10% MoM % change threshold
    10000000::NUMERIC       AS abs_threshold     -- $10M absolute MoM change threshold
),

/* 1) Pre-aggregate to month × dims to reduce volume */
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE) AS measure_val           -- swap this line to analyze other measures
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
  GROUP BY 1,2,3,4
),

/* 2) Compute prior-month and delta (single window usage) */
calc1 AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      measure_val                                                AS curr_val,
      LAG(measure_val) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                          AS prev_val,
      (measure_val - LAG(measure_val) OVER (
         PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                        AS delta
  FROM base
),

/* 3) Add % change (uses prev_val computed above; still no nesting) */
calc2 AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      curr_val,
      prev_val,
      delta,
      CASE
        WHEN prev_val IS NULL OR prev_val = 0 THEN NULL
        ELSE delta / prev_val
      END AS pct_change
  FROM calc1
),

/* 4) Rolling stats over delta (now delta is a simple column, so no nested window funcs) */
roll AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      curr_val,
      prev_val,
      delta,
      pct_change,
      AVG(delta)       OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS avg_delta_12,
      STDDEV_SAMP(delta) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS sd_delta_12
  FROM calc2
),

/* 5) Latest month only + z-score */
scored AS (
  SELECT
      r.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM roll r
  JOIN params p ON r.eom = p.asof_eom
)

/* 6) Flag, rank, and return anomalies */
SELECT
    eom,
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,
    prev_val,
    curr_val,
    delta,
    pct_change,
    avg_delta_12,
    sd_delta_12,
    z_score,

    CASE WHEN z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS flag_z,
    CASE WHEN ABS(delta)      >= p.abs_threshold                        THEN 1 ELSE 0 END AS flag_abs,
    CASE WHEN ABS(pct_change) >= p.pct_threshold                         THEN 1 ELSE 0 END AS flag_pct,

    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
      (z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold)
   OR (ABS(delta)      >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
LIMIT 100;





-- Set the anchor month you want to analyze (latest month-end available)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    12                      AS lookback_months,     -- prior 12 + current = 13 months total
    2.5::FLOAT              AS z_threshold,         -- z-score flag threshold
    0.10::FLOAT             AS pct_threshold,       -- 10% MoM % change threshold
    10000000::NUMERIC       AS abs_threshold        -- $10M absolute MoM change threshold
),

/* 1) Pre-aggregate to reduce volume (month × dims) */
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.REVISED_BANK,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE) AS measure_val
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
  GROUP BY 1,2,3,4
),

/* 2) Compute prior month, MoM Δ and %Δ, plus rolling stats on Δ over prior 12 months */
calc AS (
  SELECT
      eom,
      REVISED_BANK,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      measure_val                                                   AS curr_val,
      LAG(measure_val) OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                             AS prev_val,

      (measure_val - LAG(measure_val) OVER (
         PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                           AS delta,

      CASE
        WHEN LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) IS NULL
             OR LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) = 0
        THEN NULL
        ELSE (measure_val - LAG(measure_val) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ))
             / NULLIF(LAG(measure_val) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ), 0)
      END                                                           AS pct_change,

      AVG( (measure_val - LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
           )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                             AS avg_delta_12,

      STDDEV_SAMP( (measure_val - LAG(measure_val) OVER (
                      PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                      ORDER BY eom
                    )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                             AS sd_delta_12
  FROM base
),

/* 3) Compute z-score (for latest month only) */
scored AS (
  SELECT
      c.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM calc c
  JOIN params p ON 1=1
  WHERE c.eom = p.asof_eom
)

/* 4) Flag and rank anomalies for leadership */
SELECT
    eom,
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    prev_val,
    curr_val,
    delta,
    pct_change,
    avg_delta_12,
    sd_delta_12,
    z_score,

    /* Flags */
    CASE WHEN z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS flag_z,
    CASE WHEN ABS(delta)      >= p.abs_threshold                        THEN 1 ELSE 0 END AS flag_abs,
    CASE WHEN ABS(pct_change) >= p.pct_threshold                         THEN 1 ELSE 0 END AS flag_pct,

    /* Composite ranking: materiality first, then z, then % */
    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
      (z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold)
   OR (ABS(delta)      >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
LIMIT 100;





-- Set the anchor month (last month-end you want to analyze)
-- Example: '2025-08-31'
WITH params AS (
    SELECT DATE '2025-08-31'::DATE AS asof_eom
),

-- 1) Pull current and prior month balances, aggregated by dimensions
base AS (
    SELECT
        t.END_OF_MONTH_DATE::DATE AS eom,
        t.REVISED_BANK,
        t.CONTRACT_SOURCE_SYSTEM,
        t.GL_ACCOUNT_HIER_LEVEL_4,
        SUM(t.GL_BALANCE)           AS gl_balance,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS source_system_balance,
        SUM(t.COMMITMENT_BALANCE)    AS commitment_balance,
        SUM(t.EXPOSURE_AMOUNT)       AS exposure_amount,
        SUM(t.AVAILABLE_BALANCE)     AS available_balance
    FROM V_DPRT_CREDIT_INSTRUMENTS t
    JOIN params p ON 1=1
    WHERE t.END_OF_MONTH_DATE IN (p.asof_eom, ADD_MONTHS(p.asof_eom,-1))
    GROUP BY 1,2,3,4
),

-- 2) Pivot to align current and prior month
paired AS (
    SELECT
        REVISED_BANK,
        CONTRACT_SOURCE_SYSTEM,
        GL_ACCOUNT_HIER_LEVEL_4,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN gl_balance END) AS curr_gl_balance,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN gl_balance END) AS prev_gl_balance,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN source_system_balance END) AS curr_source_bal,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN source_system_balance END) AS prev_source_bal,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN commitment_balance END) AS curr_commit,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN commitment_balance END) AS prev_commit,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN exposure_amount END) AS curr_exposure,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN exposure_amount END) AS prev_exposure,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN available_balance END) AS curr_available,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN available_balance END) AS prev_available
    FROM base b
    JOIN params p ON 1=1
    GROUP BY 1,2,3
)

-- 3) Calculate variance
SELECT
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    curr_gl_balance, prev_gl_balance,
    (curr_gl_balance - prev_gl_balance) AS gl_delta,
    CASE WHEN prev_gl_balance = 0 OR prev_gl_balance IS NULL
         THEN NULL
         ELSE (curr_gl_balance - prev_gl_balance) / prev_gl_balance
    END AS gl_pct_change,

    curr_source_bal, prev_source_bal,
    (curr_source_bal - prev_source_bal) AS source_delta,

    curr_commit, prev_commit,
    (curr_commit - prev_commit) AS commit_delta,

    curr_exposure, prev_exposure,
    (curr_exposure - prev_exposure) AS exposure_delta,

    curr_available, prev_available,
    (curr_available - prev_available) AS available_delta

FROM paired
ORDER BY ABS(curr_gl_balance - prev_gl_balance) DESC NULLS LAST
FETCH FIRST 50 ROWS ONLY;







WITH detail AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SUM(GL_BALANCE) AS DETAIL_GL_BALANCE
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE END_OF_MONTH_DATE = DATE '2025-08-31'
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM
),
credit AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SUM(GL_BALANCE) AS CREDIT_GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE END_OF_MONTH_DATE = DATE '2025-08-31'
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM
)
SELECT
    COALESCE(d.END_OF_MONTH_DATE, c.END_OF_MONTH_DATE) AS END_OF_MONTH_DATE,
    COALESCE(d.CONTRACT_SOURCE_SYSTEM, c.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(d.DETAIL_GL_BALANCE, 0) AS DETAIL_GL_BALANCE,
    COALESCE(c.CREDIT_GL_BALANCE, 0) AS CREDIT_GL_BALANCE,
    COALESCE(d.DETAIL_GL_BALANCE, 0) - COALESCE(c.CREDIT_GL_BALANCE, 0) AS BALANCE_DIFFERENCE
FROM detail d
FULL OUTER JOIN credit c
  ON d.END_OF_MONTH_DATE = c.END_OF_MONTH_DATE
 AND d.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
ORDER BY CONTRACT_SOURCE_SYSTEM;






-- ====== PARAMETERS: edit these ======
-- Anchor date = last month you want included (month-end date)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,    -- last month-end to include
    12                                    AS lookback_months,  -- rolling window length
    2.5                                   AS z_threshold,      -- flag threshold for |z|
    0.10                                  AS pct_threshold,    -- 10% MoM threshold
    10000000::NUMERIC                     AS abs_threshold     -- $10M absolute change
),

-- 1) Limit to the last (lookback_months + 1) months and pre-aggregate
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                AS eom,
      t.REVISED_BANK,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE)                        AS gl_balance
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN
        ADD_MONTHS(p.asof_eom, -(p.lookback_months))  -- include prior 12 months
        AND p.asof_eom
  GROUP BY 1,2,3,4
),

-- 2) Compute prior-month, Δ, %Δ, and rolling stats on Δ
calc AS (
  SELECT
      eom,
      REVISED_BANK,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      gl_balance                                           AS curr_bal,
      LAG(gl_balance) OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                    AS prev_bal,

      /* MoM absolute change */
      (gl_balance - LAG(gl_balance) OVER (
         PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                  AS delta,

      /* MoM percent change (guard divide-by-zero) */
      CASE
        WHEN LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) = 0
          OR LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) IS NULL
        THEN NULL
        ELSE (gl_balance - LAG(gl_balance) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ))
             / NULLIF(LAG(gl_balance) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ), 0)
      END                                                  AS pct_change,

      /* Rolling stats of delta over prior N months (exclude current row) */
      AVG( (gl_balance - LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
           )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                    AS avg_delta_12,

      STDDEV_SAMP( (gl_balance - LAG(gl_balance) OVER (
                      PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                      ORDER BY eom
                    )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                    AS sd_delta_12
  FROM base
),

-- 3) Z-score and flags (current month only)
scored AS (
  SELECT
      c.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM calc c
  JOIN params p ON 1=1
  WHERE c.eom = p.asof_eom                -- only show flags for latest month
)

-- 4) Rank anomalies and filter to interesting rows
SELECT
    eom,
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    prev_bal,
    curr_bal,
    delta,
    pct_change,
    z_score,

    /* Flags for prioritization */
    CASE WHEN ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS z_flag,
    CASE WHEN ABS(delta)  >= p.abs_threshold THEN 1 ELSE 0 END AS abs_flag,
    CASE WHEN ABS(pct_change) >= p.pct_threshold THEN 1 ELSE 0 END AS pct_flag,

    /* Composite rank: materiality first, then z-score */
    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
  /* Show rows that trip at least one meaningful flag */
  (ABS(z_score) >= p.z_threshold)
   OR (ABS(delta) >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
;





# Python in Excel — Robust Top-25 review (range/table passed via =PY(...))
# Call example: =PY(Sheet1!A1:Q50000)   <-- include the header row in the range!

import pandas as pd
import numpy as np

# -------------------- ingest from args[0] --------------------
if len(args) == 0:
    raise RuntimeError("No input range passed. Use a formula like =PY(Sheet1!A1:Q50000) that includes the header row.")

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# If columns aren't strings (e.g., 0..N), assume first row contains headers and promote it
if not all(isinstance(c, str) for c in df.columns):
    first = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = first

# Trim header whitespace
df.columns = df.columns.astype(str).str.strip()

# -------------------- Phase 2 core metrics (recompute if missing) --------------------
# Tunables
MIN_HISTORY           = 6
STD_FLOOR_ABS         = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005  # 0.5%

# Ensure numerics if present
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# (Re)compute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# (Re)compute Z with stdev floor if missing / all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    df["Z_Prev12"] = np.nan

# Convenience columns
df["Abs_MoM"]    = df["MoM_Diff"].abs()
df["Pct_Points"] = (df["MoM_Pct"].abs() * 100.0)
df["Abs_Z"]      = df["Z_Prev12"].abs()

# -------------------- Flags + Why --------------------
Z_FLAG_STRICT = 3.0
Z_FLAG_WARN   = 2.0
AMT_FLAG      = 250000
PCT_FLAG      = 0.25  # 25%

df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# -------------------- Severity score + Top-N --------------------
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
df["SeverityScore"] = (
    W_Z   * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

TOP_N = 25
review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# Build tidy output
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# add common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]




import pandas as pd
import numpy as np

TABLE_NAME = "tblPrecomputed"   # <-- no [#All]
TOP_N = 25

# thresholds / weights
MIN_HISTORY           = 6
STD_FLOOR_ABS         = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005
W_Z, W_AMT, W_PCT     = 100.0, 10.0, 1.0
Z_FLAG_STRICT, Z_FLAG_WARN = 3.0, 2.0
AMT_FLAG, PCT_FLAG    = 250000, 0.25

df = xl(TABLE_NAME, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

# numeric
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# recompute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)
if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# recompute Z with floor if missing/all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean, stdev = df["Mean_Prev12"].astype(float), df["StDev_Prev12"].astype(float)
    cnt, curr   = df["Cnt_Prev12"].astype(float), df["SecUnfunded_Curr"].astype(float)
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    df["Z_Prev12"] = np.nan

# convenience + flags
df["Abs_MoM"]    = df["MoM_Diff"].abs()
df["Pct_Points"] = df["MoM_Pct"].abs() * 100.0
df["Abs_Z"]      = df["Z_Prev12"].abs()

df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# severity + top N
df["SeverityScore"] = (
    W_Z * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]





# === Python in Excel: Phase 2 Core Metrics + Flags + Top 25 ===
# Call in a Python cell with no args; it pulls the table via xl()
# Example: =PY()

import pandas as pd
import numpy as np

# -------------------- CONFIG --------------------
TABLE_REF = "tblPrecomputed[#All]"   # change if needed, e.g., "Sheet1!A1:K5000"
TOP_N = 25

# Phase 2 (core metrics) params
MIN_HISTORY           = 6          # min prior months to trust stats
STD_FLOOR_ABS         = 250.0      # absolute stdev floor in $
STD_FLOOR_PCT_OF_MEAN = 0.005      # 0.5% of trailing mean

# Severity weights
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0

# Flag thresholds
Z_FLAG_STRICT = 3.0    # ≥3σ
Z_FLAG_WARN   = 2.0    # ≥2σ
AMT_FLAG      = 250000 # $ MoM
PCT_FLAG      = 0.25   # 25% MoM (0.25 = 25%)

# -------------------- LOAD --------------------
df = xl(TABLE_REF, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

# Validate required columns; some will be recomputed if missing
expected_any = {
    "CreditLineNumber","LoadDate_Curr","SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
}
missing_now = [c for c in expected_any if c not in df.columns]
# it's OK if MoM_* or Z_Prev12 are missing; we'll compute them below

# -------------------- PHASE 2: CORE METRICS --------------------
# 1) Numeric types
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# 2) (Re)compute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# 3) (Re)compute Z with stdev floor if missing or all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    # If we can't compute Z and it's not present, create it so downstream works
    df["Z_Prev12"] = np.nan

# 4) Convenience columns
df["Abs_MoM"]     = df["MoM_Diff"].abs()
df["Pct_Points"]  = (df["MoM_Pct"].abs() * 100.0)
df["Abs_Z"]       = df["Z_Prev12"].abs()

# -------------------- FLAGS + WHY --------------------
df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# -------------------- SEVERITY SCORE + TOP N --------------------
df["SeverityScore"] = (
    W_Z   * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()

review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# -------------------- OUTPUT --------------------
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# Append common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]




import numpy as np

# --- 0) Parameters (tune as you like) ---
MIN_HISTORY          = 6       # need this many prior months to trust stats
STD_FLOOR_ABS        = 250.0   # absolute stdev floor in $
STD_FLOOR_PCT_OF_MEAN= 0.005   # 0.5% of trailing mean

# --- 1) Ensure numeric types for all stat columns ---
num_cols_expected = [
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
for c in num_cols_expected:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# --- 2) (Re)compute MoM if missing (or keep what’s there) ---
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# --- 3) (Re)compute Z with stdev floor if missing or untrusted ---
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)

# --- 4) Convenience analysis columns ---
df["Abs_MoM"]       = df["MoM_Diff"].abs()
df["Pct_Points"]    = (df["MoM_Pct"].abs() * 100.0)  # %-points
df["Abs_Z"]         = df["Z_Prev12"].abs()

# --- 5) Useful flags for review/explanations ---
df["Flag_Z_3plus"]        = (df["Abs_Z"] >= 3.0).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= 2.0) & (df["Abs_Z"] < 3.0)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= 250000).astype(int)   # tweak threshold
df["Flag_BigPercent"]     = (df["Pct_Points"] >= 25).astype(int)    # 25%-points
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)








import pandas as pd
import numpy as np

# ====== CONFIG ======
TABLE_REF = "tblPrecomputed[#All]"  # change if needed (e.g., "Sheet1!A1:K5000")
TOP_N = 25

# thresholds
Z_FLAG_STRICT = 3.0      # severe outlier
Z_FLAG_WARN   = 2.0      # notable outlier
AMT_FLAG      = 250000   # $ change threshold for "Big $" flag
PCT_FLAG      = 0.25     # 25% MoM threshold for "Big %"
# severity weights
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0

# ====== LOAD & CLEAN ======
df = xl(TABLE_REF, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(f"Missing columns: {missing}\nFound: {sorted(df.columns.tolist())}")

for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# ====== FLAGS ======
abs_z   = df["Z_Prev12"].abs()
abs_amt = df["MoM_Diff"].abs()
abs_pct = df["MoM_Pct"].abs()

df["Flag_Z_3plus"]        = (abs_z >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((abs_z >= Z_FLAG_WARN) & (abs_z < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (abs_amt >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (abs_pct >= PCT_FLAG).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

# human-readable reason
def reason(row):
    r = []
    if row["Flag_Z_3plus"]:       r.append("High Z (≥3σ)")
    elif row["Flag_Z_2plus"]:     r.append("Notable Z (≥2σ)")
    if row["Flag_BigDollar"]:     r.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if row["Flag_BigPercent"]:    r.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if row["Flag_ZeroToNonZero"]: r.append("0 → non-0")
    if row["Flag_NonZeroToZero"]: r.append("non-0 → 0")
    return "; ".join(r) if r else "Severity mix"
df["Why"] = df.apply(reason, axis=1)

# ====== SEVERITY SCORE & RANK ======
df["SeverityScore"] = (
    W_Z   * abs_z.fillna(0) +
    W_AMT * np.log10(abs_amt.fillna(0) + 1.0) +
    W_PCT * (abs_pct.fillna(0) * 100.0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()

review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# ====== OUTPUT (Top 25 with flags & reasons) ======
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# include common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns:
        cols.append(extra)

review[cols]





df = xl("tblPrecomputed[#All]", headers=True).copy()
df.columns = df.columns.astype(str).str.strip()




import numpy as np

# Ensure numeric
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# Robust Z (median & MAD over prev 12 months, optional)
# Needs historical data → skip if you only have 1 row/line
df["RobustZ"] = np.nan  # placeholder for now





import pandas as pd
import numpy as np

# 1) Pull your table into a DataFrame.
#    Change the table name if yours is different.
#    headers=True tells Python that the first row contains headers.
df = xl("tblPrecomputed[#All]", headers=True).copy()

# 2) Light sanity check
df.columns = df.columns.astype(str).str.strip()
print("Rows x Cols:", df.shape)
print("First 10 cols:", df.columns.tolist()[:10])

# 3) Expect the precomputed SQL columns (one row per credit line)
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        f"Missing columns: {missing}\n"
        f"Found: {sorted(df.columns.tolist())}\n"
        "Check your header row and table name."
    )

# 4) Fast severity score + Top 25
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct
out = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(25).copy()

out.insert(0, "SeverityRank", np.arange(1, len(out)+1))
out[[
    "SeverityRank","SeverityScore","CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]]






import pandas as pd
df = args[0]
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()
df.head()







import pandas as pd

df = args[0]  # take the first argument passed in (your range or table)
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()

print("Shape:", df.shape)
print("First 5 columns:", df.columns.tolist()[:5])
df.head(5)






# Robust Top-25 review from precomputed SQL result
# Call this cell with a range/table that INCLUDES the header row, e.g.:
#   =PY(tblPrecomputed[#All])    or    =PY(Sheet1!A1:K5000)

import pandas as pd
import numpy as np
import re

TOP_N = 25
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0  # severity weights

# ---------- ingest ----------
if len(args) == 0:
    raise RuntimeError(
        "No input provided. Call like: =PY(tblPrecomputed[#All]) or =PY(Sheet1!A1:K5000) (headers included)."
    )

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# If columns aren't strings (e.g., 0..N), assume first row contains headers and promote it
if not all(isinstance(c, str) for c in df.columns):
    first = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = first

# Normalize headers: strip, lower, replace spaces/dots/dashes with underscores, squeeze repeats
def norm(s):
    s = str(s).strip().lower()
    s = re.sub(r"[ \t\-.]+", "_", s)
    s = re.sub(r"_+", "_", s)
    return s.strip("_")

df.columns = [norm(c) for c in df.columns]

# Build a lookup from normalized name -> original column name
norm_to_orig = {norm(c): c for c in df.columns}  # after norm, norm(c)==c; we’ll keep for clarity

# Required canonical columns and acceptable aliases (normalized)
aliases = {
    "loaddate_curr": {"loaddate_curr","loaddate","load_date_curr","loaddate_current","load_date"},
    "creditlinenumber": {"creditlinenumber","credit_line_number","cln","line_number"},
    "secunfunded_curr": {"secunfunded_curr","secunfunded","sec_unfunded_curr","secured_unfunded_curr"},
    "prev_secunfunded": {"prev_secunfunded","prev_sec_unfunded","previous_secunfunded","secunfunded_prev"},
    "mom_diff": {"mom_diff","mom$","delta","change","mom_change"},
    "mom_pct": {"mom_pct","mom%","pct_change","percent_change","mom_percent"},
    "mean_prev12": {"mean_prev12","avg_prev12","mean_12","rolling_mean_12"},
    "stdev_prev12": {"stdev_prev12","std_prev12","stddev_prev12","rolling_std_12","stdev"},
    "cnt_prev12": {"cnt_prev12","count_prev12","n_prev12","count_12"},
    "z_prev12": {"z_prev12","zscore","z_score_prev12","z"},
}

# Resolve each canonical column by checking aliases against normalized df columns
resolved = {}
missing = []
for canon, opts in aliases.items():
    found = None
    for opt in opts:
        if opt in df.columns:
            found = opt
            break
    if found:
        resolved[canon] = found
    else:
        missing.append(canon)

# If many are missing, show diagnostics to help fix the input
if missing:
    # Show what we do have (first 20 normalized headers)
    have = ", ".join(list(df.columns)[:20])
    raise ValueError(
        "Some expected columns were not found.\n"
        f"Missing (canonical names): {missing}\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and the header row is included.\n"
        f"Detected (normalized) headers: {have}\n"
        "Tip: If your headers look different, rename them in Excel to the expected names."
    )

# For convenience, get original names (they're equal to normalized now, but left here for clarity)
c = resolved  # shorthand

# Make numerics numeric
num_cols = [c["secunfunded_curr"], c["prev_secunfunded"], c["mom_diff"], c["mom_pct"],
            c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"]]
for col in num_cols:
    df[col] = pd.to_numeric(df[col], errors="coerce")

# Severity score (simple & fast)
abs_z   = df[c["z_prev12"]].abs().fillna(0.0)
abs_amt = df[c["mom_diff"]].abs().fillna(0.0)
abs_pct = (df[c["mom_pct"]].abs() * 100.0).fillna(0.0)

df["severity_score"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct

# Sort & take Top N
order = ["severity_score", c["z_prev12"], c["mom_diff"], c["mom_pct"], c["creditlinenumber"]]
out = df.sort_values(order, ascending=[False, False, False, False, True]).head(TOP_N).copy()
out.insert(0, "severity_rank", np.arange(1, len(out)+1))

# Build tidy output (include common metadata if present)
cols = [
    "severity_rank","severity_score",
    c["creditlinenumber"], c["loaddate_curr"],
    c["secunfunded_curr"], c["prev_secunfunded"],
    c["mom_diff"], c["mom_pct"],
    c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"],
]
# Try to add nice-to-have metadata if columns exist with common names
for extra in ["cif","clientname","applid","formulaline","revolvingflag","line_status",
              "netlineamount","netutilized","netdisbursed","netborrowingbase","business_unit"]:
    if extra in df.columns:
        cols.append(extra)

# Drop any that aren't present (shouldn't be necessary but safe)
cols = [col for col in cols if col in out.columns]

# Return to Excel
out[cols]






# --- DIAGNOSTIC: just tell me what you passed in ---
import pandas as pd

if len(args) == 0:
    raise RuntimeError("No input given. Call like: =PY(<cell>, Sheet1!A1:Q50000) or =PY(<cell>, MyTable[#All])")

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# Try to detect if the FIRST ROW contains your headers; if so, promote it.
first_row = df.iloc[0].astype(str).str.strip().tolist()
expected_any = {"CreditLineNumber","LoadDate_Curr","SecUnfunded_Curr"}  # from precompute SQL
headers_look_ok = len(set(first_row) & expected_any) > 0

if headers_look_ok and "CreditLineNumber" not in df.columns:
    df.columns = [str(x).strip() for x in first_row]
    df = df.iloc[1:].reset_index(drop=True)

# Always strip column whitespace
df.columns = df.columns.astype(str).str.strip()

print("Shape (rows, cols):", df.shape)
print("First 12 column names:", df.columns.tolist()[:12])

# Show the first 5 rows so we can see if headers are correct
df.head(5)







# Python in Excel — Range-Passed Review (fast, no name lookup)
# Call pattern:
#   =PY(<this_cell>, Sheet1!A1:Q50000)
#   =PY(<this_cell>, tblPrecomputed[#All])

import numpy as np
import pandas as pd

# ---------- CONFIG ----------
TOP_N = 25                 # rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold (still ranked by score)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0   # severity weights

# ---------- INPUT ----------
if len(args) == 0:
    raise RuntimeError(
        "No input range provided. In the formula bar, pass a range or table, e.g.:\n"
        "  =PY(<this_cell>, Sheet1!A1:Q50000)\n"
        "  =PY(<this_cell>, tblPrecomputed[#All])"
    )

df = args[0].copy()
if not isinstance(df, pd.DataFrame):
    # If Excel passed a numpy array, convert to DataFrame
    df = pd.DataFrame(df)

# Normalize headers (first row must be headers in the passed range/table)
df.columns = df.columns.astype(str).str.strip()

# ---------- REQUIRED COLUMNS (from the precompute SQL) ----------
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        "Missing required columns: %s\n"
        "Found columns: %s\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and included the header row in the range."
        % (missing, sorted(df.columns.tolist()))
    )

# ---------- TYPES ----------
num_cols = ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
            "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]
for c in num_cols:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# ---------- SEVERITY SCORE (very light) ----------
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = (
    W_Z * abs_z +
    W_AMT * np.log10(abs_amt + 1.0) +
    W_PCT * abs_pct
)

# Optional: force-include Z outliers (|Z| >= threshold)
mask_z = abs_z >= Z_THRESHOLD

# Final ranking
order_cols = ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"]
review = df.sort_values(order_cols, ascending=[False, False, False, False, True]).copy()

# If you want to *only* include Z-outliers + top-N by SeverityScore, uncomment below:
# review = review[mask_z].copy() if mask_z.any() else review

# Keep top N
review = review.head(TOP_N).reset_index(drop=True)

# Build clean output
cols = [
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "SeverityScore"
]
# Only include those that exist (in case extra columns came through)
cols = [c for c in cols if c in review.columns]

# Add a 1-based rank
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# Return to Excel
review[["SeverityRank"] + cols]





# Minimal check that Python can see your table and how big it is.
TABLE_NAME = "tblPrecomputed"  # <- change if your table has a different name

df = xl(TABLE_NAME)
print("Rows x Cols:", df.shape)
df.columns = df.columns.str.strip()
print("Sample cols:", df.columns.tolist()[:12])
df.head(3)



# ==============================
# Clean Review Builder (fast)
# Works with *precomputed* SQL output per line (latest month)
# ==============================

import re
import numpy as np
import pandas as pd

# ---- Set this to your Excel Table / Named Range ----
TABLE_NAME = "tblPrecomputed"   # <-- change to your actual table name

# ---- Tunable parameters ----
TOP_N = 50                 # number of rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold
DOLLAR_ALWAYS_INCLUDE = None  # e.g., 250000 to always include very large $ moves

# Severity weights
W_Z   = 100.0    # per 1.0 of |Z|
W_AMT = 10.0     # per log10(|$|+1)
W_PCT = 1.0      # per percentage point (100 * |MoM_Pct|)

# Z stdev floor (Fix A) used if we need to recompute Z
MIN_HISTORY = 6
STD_FLOOR_ABS = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005  # 0.5% of mean

# ---- Load data from Excel ----
df = xl(TABLE_NAME)

# Normalize column names: strip spaces
df.columns = df.columns.str.strip()

# Helper: pick a column by preferred name, falling back to suffixed variants (e.g., "Z_Prev12.1")
def pick(colname: str) -> str | None:
    if colname in df.columns:
        return colname
    # exact suffix like .1 or .2
    matches = [c for c in df.columns if re.fullmatch(fr"{re.escape(colname)}(\.\d+)?", str(c))]
    return matches[0] if matches else None

# Map required columns (accept a couple of common variants)
col_LoadDate   = pick("LoadDate_Curr") or pick("LoadDate")
col_CLN        = pick("CreditLineNumber")
col_SecCurr    = pick("SecUnfunded_Curr") or pick("SecUnfunded")
col_SecPrev    = pick("Prev_SecUnfunded")
col_Mean       = pick("Mean_Prev12")
col_StDev      = pick("StDev_Prev12")
col_Cnt        = pick("Cnt_Prev12")
col_MoMdiff    = pick("MoM_Diff")
col_MoMpct     = pick("MoM_Pct")
col_Z          = pick("Z_Prev12")

required = {
    "CreditLineNumber": col_CLN,
    "LoadDate (Curr or generic)": col_LoadDate,
    "SecUnfunded (Curr or generic)": col_SecCurr,
}
missing_core = [k for k,v in required.items() if v is None]
if missing_core:
    raise ValueError(
        "Your table is missing core columns needed for ranking.\n"
        f"Missing: {missing_core}\n"
        f"Columns found: {sorted(df.columns.tolist())}"
    )

# Ensure numeric types for calculations
for c in [col_SecCurr, col_SecPrev, col_Mean, col_StDev, col_Cnt, col_MoMdiff, col_MoMpct, col_Z]:
    if c and c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Compute MoM fields if they’re missing but we have current/prev
if col_MoMdiff is None and col_SecPrev:
    df["MoM_Diff"] = (df[col_SecCurr] - df[col_SecPrev]).round(2)
    col_MoMdiff = "MoM_Diff"

if col_MoMpct is None and col_SecPrev:
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df[col_SecPrev].fillna(0) == 0,
            np.nan,
            (df[col_SecCurr] - df[col_SecPrev]) / np.abs(df[col_SecPrev])
        )
    col_MoMpct = "MoM_Pct"

# Recompute Z if missing and inputs exist (uses same stdev floor logic you asked for)
if col_Z is None and all(x is not None for x in [col_Mean, col_StDev, col_Cnt]):
    mean = df[col_Mean].astype(float)
    stdev = df[col_StDev].astype(float)
    cnt = df[col_Cnt].astype(float)
    curr = df[col_SecCurr].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
    col_Z = "Z_Prev12"

# Build severity components (handle nulls)
df["AbsZ"]          = df[col_Z].abs() if col_Z else 0.0
df["AbsAmt"]        = df[col_MoMdiff].abs() if col_MoMdiff else 0.0
df["AbsPctPoints"]  = (df[col_MoMpct].abs() * 100.0).fillna(0) if col_MoMpct else 0.0

# Composite SeverityScore
df["SeverityScore"] = (
    W_Z   * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1.0) +
    W_PCT * df["AbsPctPoints"]
)

# Candidate filters (fast)
mask_z   = (df["AbsZ"].notna()) & (df["AbsZ"] >= Z_THRESHOLD) if col_Z else False
mask_top = df["AbsAmt"].rank(method="first", ascending=False) <= TOP_N if col_MoMdiff else False
mask_big = (df["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE) if DOLLAR_ALWAYS_INCLUDE is not None else False

# If none of the masks exist (e.g., missing MoM), just sort everything and take TOP_N
if (isinstance(mask_z, bool) and isinstance(mask_top, bool) and isinstance(mask_big, bool)):
    review = df.copy()
else:
    review = df[ mask_z | mask_top | mask_big ].copy()
    if review.empty:
        # Fallback: take top-N by SeverityScore
        review = df.copy()

# Final ordering & rank
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints", col_CLN],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)

# Build clean output with whatever columns are available
cols_keep = [
    "SeverityRank","SeverityScore",
    col_LoadDate, col_CLN,
    "AbsAmt","AbsPctPoints","AbsZ",
]
# Add common fields if present
for c in [
    col_SecPrev, col_SecCurr, col_MoMdiff, col_MoMpct,
    col_Mean, col_StDev, col_Cnt, col_Z,
    "CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
    "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "BUSINESS_UNIT"
]:
    if c and c in review.columns and c not in cols_keep:
        cols_keep.append(c)

# Make nicer header names (optional)
rename_map = {
    col_LoadDate: "LoadDate",
    col_CLN: "CreditLineNumber",
    col_SecCurr: "SecUnfunded_Curr",
    col_SecPrev: "Prev_SecUnfunded",
    col_MoMdiff: "MoM_Diff",
    col_MoMpct:  "MoM_Pct",
    col_Mean:    "Mean_Prev12",
    col_StDev:   "StDev_Prev12",
    col_Cnt:     "Cnt_Prev12",
    col_Z:       "Z_Prev12",
}
review_out = review[cols_keep].rename(columns={k:v for k,v in rename_map.items() if k})

# Return only the top N rows to Excel (fast)
review_out.head(TOP_N)







df = xl("tblPrecomputed")  # the result of the SQL above
df["AbsZ"] = df["Z_Prev12"].abs()
df["AbsAmt"] = df["MoM_Diff"].abs()
df["AbsPctPoints"] = (df["MoM_Pct"].abs() * 100).fillna(0)

# Simple severity score (same weights as before)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
df["SeverityScore"] = (
    W_Z * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1) +
    W_PCT * df["AbsPctPoints"]
)

review = df.sort_values(
    ["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)
review.head(50)  # return top 50 only




/*==============================================================
  Portfolio Variance Precompute (hand-off to Python/Excel)
  - Population from CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
  - SecUnfunded from CALCULATED_UNFUNDED
  - Current EOM = last day of previous month
  - Output: ONE row per CreditLineNumber (latest ≤ @CurrEOM) with:
      Prev_SecUnfunded, Mean_Prev12, StDev_Prev12 (prev-12 only),
      Z_Prev12 (with stdev floor), MoM_Diff, MoM_Pct,
      and requested CLM metadata/amounts
==============================================================*/

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13; -- current + prior 12
-- Current EOM without EOMONTH(): last day of previous month
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

-- Z-score floor (Fix A)
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean
DECLARE @MinHistory          int           = 6;       -- min months in prev window to compute Z

;WITH base AS (
    /* Pull last 13 months for BUS00 population from CLM, join SecUnfunded from CU */
    SELECT
        cl.LoadDate,
        cl.CreditLineNumber,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BUSINESS_UNIT,
        cl.RevolvingFlag,
        cl.Line_Status,

        CAST(cl.NetLineAmount    AS decimal(38,2)) AS NetLineAmount,
        CAST(cl.NetUtilized      AS decimal(38,2)) AS NetUtilized,
        CAST(cl.NetDisbursed     AS decimal(38,2)) AS NetDisbursed,
        CAST(cl.NetBorrowingBase AS decimal(38,2)) AS NetBorrowingBase,

        CAST(cu.SecUnfunded      AS decimal(38,2)) AS SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
           ON cu.LoadDate         = cl.LoadDate
          AND cu.CreditLineNumber = cl.CreditLineNumber
    WHERE cl.BUSINESS_UNIT = 'BUS00'
      AND cl.LoadDate >= @StartEOM
      AND cl.LoadDate <= @CurrEOM
),
series AS (
    /* Compute per-line rolling (prev-12) stats and prev month */
    SELECT
        b.*,

        LAG(b.SecUnfunded, 1) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
        ) AS Prev_SecUnfunded,

        /* prev-12 window excludes the current row via ... AND 1 PRECEDING */
        AVG(b.SecUnfunded)   OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Mean_Prev12,

        STDEV(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS StDev_Prev12,

        COUNT(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Cnt_Prev12,

        ROW_NUMBER() OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate DESC
        ) AS rn_desc
    FROM base b
),
calc AS (
    /* Keep latest available month per line; compute MoM, Z with stdev floor */
    SELECT
        s.LoadDate                       AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF,
        s.ClientName,
        s.ApplID,
        s.FormulaLine,
        s.BUSINESS_UNIT,
        s.RevolvingFlag,
        s.Line_Status,

        s.NetLineAmount,
        s.NetUtilized,
        s.NetDisbursed,
        s.NetBorrowingBase,

        s.SecUnfunded                   AS SecUnfunded_Curr,
        s.Prev_SecUnfunded,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(
            CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                 ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
            END AS decimal(38,6)
        ) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4)) AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
        s.Cnt_Prev12,

        /* Z-score with stdev floor (Fix A):
           floor = MAX(@StdFloorAbs, ABS(Mean_Prev12) * @StdFloorPctOfMean).
           If StDev_Prev12 < floor OR insufficient history => Z = NULL.
        */
        CAST(
            CASE
              WHEN s.Cnt_Prev12 < @MinHistory THEN NULL
              WHEN s.StDev_Prev12 IS NULL THEN NULL
              WHEN s.StDev_Prev12 <
                   CASE
                     WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                     ELSE CASE
                            WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                                 THEN @StdFloorAbs
                                 ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                          END
                   END
                   THEN NULL
              ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
            END AS decimal(38,4)
        ) AS Z_Prev12
    FROM series s
    WHERE s.rn_desc = 1
)
SELECT
    c.LoadDate_Curr,
    c.CreditLineNumber,
    c.CIF,
    c.ClientName,
    c.ApplID,
    c.FormulaLine,
    c.BUSINESS_UNIT,
    c.RevolvingFlag,
    c.Line_Status,

    c.NetLineAmount,
    c.NetUtilized,
    c.NetDisbursed,
    c.NetBorrowingBase,

    c.Prev_SecUnfunded,
    c.SecUnfunded_Curr,
    c.MoM_Diff,
    c.MoM_Pct,

    c.Mean_Prev12,
    c.StDev_Prev12,
    c.Cnt_Prev12,
    c.Z_Prev12
FROM calc c
ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber;






# Python in Excel: Portfolio variance & outlier review
# Requirements: your SQL extract is in an Excel Table named "tblCreditLines"

import pandas as pd
import numpy as np
from datetime import date
try:
    # Python in Excel function to pull an Excel Table by name
    df = xl("tblCreditLines")
except NameError:
    # Fallback for testing outside Excel: df must be defined externally
    raise RuntimeError("In Python in Excel, rename your data table to 'tblCreditLines' and re-run this cell.")

# -------------------------
# Tunable parameters
# -------------------------
LOOKBACK = 12                # trailing months (excluding current month)
MIN_HISTORY = 6              # minimum months to compute any Z/Robust Z
Z_THRESHOLD = 2.0            # notable Z
ROBUST_Z_THRESHOLD = 2.5     # optional robust Z threshold for review
TOP_N = 25                   # top N by $ move (abs)
DOLLAR_ALWAYS_INCLUDE = None # e.g., 250000 to always include very large $ moves

# Stdev floor (Fix A)
STD_FLOOR_ABS = 250.0        # absolute $ floor
STD_FLOOR_PCT_OF_MEAN = 0.005 # 0.5% of trailing mean

# SeverityScore weights
W_Z = 100.0                  # weight per 1.0 of |Z|
W_AMT = 10.0                 # weight per log10(|$|+1)
W_PCT = 1.0                  # weight per percentage point (100 * |MoM_Pct|)

# -------------------------
# Prep & sanity checks
# -------------------------
# Ensure expected columns exist
expected_cols = {
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "BusinessUnit","RevolvingFlag","Line_Status","NetLineAmount","NetUtilized",
    "NetDisbursed","NetBorrowingBase","SecUnfunded"
}
missing = sorted(list(expected_cols - set(df.columns)))
if missing:
    raise ValueError(f"Missing columns in Excel table: {missing}")

# Filter to BusinessUnit='BUS00' (population per your requirement)
df = df[df["BusinessUnit"] == "BUS00"].copy()

# Parse dates and sort
df["LoadDate"] = pd.to_datetime(df["LoadDate"]).dt.date
df = df.sort_values(["CreditLineNumber","LoadDate"]).reset_index(drop=True)

# Latest month-end anchor = last day of previous month relative to "today"
today = date.today()
curr_eom = (pd.Timestamp(today).to_period("M") - 1).to_timestamp("M").date()
df = df[df["LoadDate"] <= curr_eom].copy()

# -----------------------------------------
# Per-line rolling stats (exclude current)
# -----------------------------------------
def compute_metrics(g: pd.DataFrame) -> pd.DataFrame:
    g = g.sort_values("LoadDate").copy()
    s = g["SecUnfunded"].astype(float)

    # Prior month
    g["Prev_SecUnfunded"] = s.shift(1)

    # Trailing (prev-12) windows built on the *shifted* series so current is excluded
    prev = s.shift(1)

    roll = prev.rolling(window=LOOKBACK, min_periods=MIN_HISTORY)
    g["Mean_Prev12"] = roll.mean()
    g["StDev_Prev12"] = roll.std(ddof=1)

    # Z with stdev floor
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(g["Mean_Prev12"]) * STD_FLOOR_PCT_OF_MEAN)
    z_num = (s - g["Mean_Prev12"])
    z_den = g["StDev_Prev12"]
    z_ok = (g["StDev_Prev12"].notna()) & (g["StDev_Prev12"] >= eff_floor) & (roll.count() >= MIN_HISTORY)
    g["Z_Prev12"] = np.where(z_ok, z_num / z_den, np.nan)

    # Robust Z: median & MAD on prev-12 (exclude current)
    med_prev12 = roll.median()
    # MAD: median of |prev - median|
    mad_prev12 = (prev - med_prev12).abs().rolling(window=LOOKBACK, min_periods=MIN_HISTORY).median()
    robust_den_ok = (mad_prev12.notna()) & (mad_prev12 > 0) & (roll.count() >= MIN_HISTORY)
    g["RobustZ_Prev12"] = np.where(
        robust_den_ok, 0.6745 * (s - med_prev12) / mad_prev12, np.nan
    )

    # MoM diffs
    g["MoM_Diff"] = (s - g["Prev_SecUnfunded"]).round(2)
    with np.errstate(divide="ignore", invalid="ignore"):
        g["MoM_Pct"] = np.where(
            g["Prev_SecUnfunded"].fillna(0) == 0,
            np.nan,
            (s - g["Prev_SecUnfunded"]) / np.abs(g["Prev_SecUnfunded"])
        )

    return g

df_metrics = df.groupby("CreditLineNumber", group_keys=False).apply(compute_metrics)

# -----------------------------------------
# Latest month per credit line (on/before curr_eom)
# -----------------------------------------
idx_latest = df_metrics.groupby("CreditLineNumber")["LoadDate"].transform("max") == df_metrics["LoadDate"]
latest = df_metrics[idx_latest].copy()

# SeverityScore & Rank
latest["AbsZ"] = latest["Z_Prev12"].abs()
latest["AbsAmt"] = latest["MoM_Diff"].abs()
latest["AbsPctPoints"] = (latest["MoM_Pct"].abs() * 100.0).fillna(0)

latest["SeverityScore"] = (
    W_Z * latest["AbsZ"].fillna(0)
    + W_AMT * np.log10(latest["AbsAmt"].fillna(0) + 1.0)
    + W_PCT * latest["AbsPctPoints"]
)

# Candidate sets: Z outliers, Top-N $ movers, optional dollar threshold
mask_z = (latest["AbsZ"].notna()) & (latest["AbsZ"] >= Z_THRESHOLD)
top_n_idx = latest["AbsAmt"].rank(method="first", ascending=False) <= TOP_N
if DOLLAR_ALWAYS_INCLUDE is not None:
    mask_big = latest["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE
else:
    mask_big = pd.Series(False, index=latest.index)

review = latest[mask_z | top_n_idx | mask_big].copy()

# Rank rows for review
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review) + 1)

# Optional: also include RobustZ thresholding (uncomment if you want it to force include)
# mask_robust = review["RobustZ_Prev12"].abs() >= ROBUST_Z_THRESHOLD
# review.loc[mask_robust & ~mask_z, "SeverityScore"] += 50.0  # small bump for robust-only outliers
# review = review.sort_values(by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
#                             ascending=[False, False, False, False, True]).reset_index(drop=True)
# review["SeverityRank"] = np.arange(1, len(review) + 1)

# Select final columns for Excel
cols_out = [
    "SeverityRank","SeverityScore",
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "RevolvingFlag","Line_Status","NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "Prev_SecUnfunded","SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Z_Prev12","RobustZ_Prev12"
]
review_out = review[cols_out]

# Return the review table back to Excel (spills into the sheet)
review_out



-- Base extract for Python-in-Excel variance analysis
-- Population = CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
-- SecUnfunded pulled from CALCULATED_UNFUNDED

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Latest month-end (works without EOMONTH)
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cl.LoadDate,
    cl.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BUSINESS_UNIT,
    cl.RevolvingFlag,
    cl.Line_Status,

    -- Amounts from CREDIT_LINE_MONTHLY
    CAST(cl.NetLineAmount     AS decimal(38,2)) AS NetLineAmount,
    CAST(cl.NetUtilized       AS decimal(38,2)) AS NetUtilized,
    CAST(cl.NetDisbursed      AS decimal(38,2)) AS NetDisbursed,
    CAST(cl.NetBorrowingBase  AS decimal(38,2)) AS NetBorrowingBase,

    -- Only SecUnfunded from CALCULATED_UNFUNDED
    CAST(cu.SecUnfunded       AS decimal(38,2)) AS SecUnfunded

FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
       ON cu.LoadDate         = cl.LoadDate
      AND cu.CreditLineNumber = cl.CreditLineNumber

WHERE cl.LoadDate >= @StartEOM
  AND cl.LoadDate <= @CurrEOM
  AND cl.BUSINESS_UNIT = 'BUS00'

-- Optional scope refinements (uncomment as needed):
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
--   AND cl.Line_Status IN ('Active','Open')

ORDER BY cl.LoadDate, cl.CreditLineNumber;





-- Base extract for Python-in-Excel variance analysis
-- One row per (LoadDate, CreditLineNumber)

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Compute latest month end (works without EOMONTH)
DECLARE @CurrEOM date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cu.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
       ON cl.LoadDate = cu.LoadDate
      AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate >= @StartEOM
  AND cu.LoadDate <= @CurrEOM
-- Optional scope filters:
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
ORDER BY cu.LoadDate, cu.CreditLineNumber;






/*==============================================================
  Base extract for Python-in-Excel variance analysis
  - SQL Server (CRDLMTUFCALC)
  - Pulls current EOM (as of today) + trailing @LookbackMonths-1 EOMs
  - One row per (LoadDate, CreditLineNumber)
==============================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM         date = EOMONTH(GETDATE(), -1);  -- e.g., today 2025-09-05 -> 2025-08-31
DECLARE @LookbackMonths  int  = 13;  -- current + prior 12 (adjust if you want more history)

;WITH rng AS (
    SELECT
        /* Start at the earliest month we want to include */
        EOMONTH(DATEADD(MONTH, -( @LookbackMonths - 1 ), @CurrEOM)) AS StartEOM,
        @CurrEOM AS EndEOM
),
-- Pull SecUnfunded + join line metadata
raw AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM

    /* Optional: scope filters (uncomment as desired)
       AND cl.ApplID = 'LN'
       AND cl.FormulaLine = 1
       -- AND cl.ClientName IS NOT NULL
       -- AND cu.CreditLineNumber IN ('123456','789012')
    */
),
/* If your source can have duplicates per (LoadDate, CreditLineNumber)
   (e.g., multiple calc runs without RunID scoping), keep a deterministic
   single record. MAX() is a safe choice for balances that should end
   the month at a single figure. Switch to SUM() if your data model
   expects summation across fragments. */
dedup AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        MAX(SecUnfunded) AS SecUnfunded,   -- or SUM(SecUnfunded)
        MAX(CIF)         AS CIF,
        MAX(ClientName)  AS ClientName,
        MAX(ApplID)      AS ApplID,
        MAX(FormulaLine) AS FormulaLine
    FROM raw
    GROUP BY LoadDate, CreditLineNumber
)
SELECT
    LoadDate,
    CreditLineNumber,
    SecUnfunded,      -- numeric, cast already applied
    CIF,
    ClientName,
    ApplID,
    FormulaLine
FROM dedup
ORDER BY LoadDate, CreditLineNumber;








/*=============================================================================
  Portfolio-Wide Review with StDev Floor (Fix A) + SeverityScore/Rank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Rolling Z vs trailing 12 months (excluding current), with stdev floor
  - Returns union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;   -- notable outlier
DECLARE @TopN             int           = 25;       -- top-N abs $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;     -- e.g., 250000 to always include big $ moves

-- Severity weights (tune as you like)
DECLARE @wZ   float = 100.0;   -- per 1.0 of |Z|
DECLARE @wAmt float = 10.0;    -- per log10(|$|+1)
DECLARE @wPct float = 1.0;     -- per percentage point (100×|MoM_Pct|)

-- *** Fix A: StDev floor parameters ***
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        /* -------- Fix A: Z with stdev floor --------
           Effective floor = MAX(@StdFloorAbs, |Mean_Prev12| * @StdFloorPctOfMean)
           If StDev_Prev12 < floor => Z = NULL (unreliable)
        */
        CAST(
          CASE 
            WHEN s.Cnt_Prev12 < 6 THEN NULL  -- require minimum history
            WHEN s.StDev_Prev12 IS NULL THEN NULL
            WHEN s.StDev_Prev12 <
                 CASE 
                   WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                   ELSE
                     CASE 
                       WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                            THEN @StdFloorAbs
                            ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                     END
                 END
              THEN NULL
            ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
          END AS decimal(38,4)
        ) AS Z_Prev12

    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        ABS(ISNULL(rs.Z_Prev12, 0))             AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0) AS LogAmt,
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0       AS AbsPctPoints,

        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0)) AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;









DECLARE @StdFloorAbs       decimal(38,6) = 250.0;   -- absolute stdev floor in $
DECLARE @StdFloorPctOfMean decimal(9,6)  = 0.005;   -- 0.5% of trailing mean




-- Effective floor = max(abs floor, % of mean)
CAST(
  CASE
    WHEN s.Cnt_Prev12 < 6 THEN NULL
    ELSE
      CASE 
        WHEN s.StDev_Prev12 IS NULL THEN NULL
        WHEN s.StDev_Prev12 < 
             CASE 
               WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
               ELSE 
                 CASE 
                   WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                        THEN @StdFloorAbs
                        ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                 END
             END
          THEN NULL
        ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
      END
  END AS decimal(38,4)
) AS Z_Prev12







/*=============================================================================
  Portfolio-Wide Review with SeverityScore + SeverityRank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Compute MoM change + Z vs trailing 12 months (excluding current)
  - Return union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
  - Compute SeverityScore and SeverityRank for the final set
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;  -- notable outlier
DECLARE @TopN             int           = 25;      -- top-N absolute $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;    -- e.g., 250000 to always include big $ moves

-- Severity weights (tune these)
DECLARE @wZ   float = 100.0;  -- impact per 1.0 of |Z|
DECLARE @wAmt float = 10.0;   -- impact per log10(|$|+1)
DECLARE @wPct float = 1.0;    -- impact per percentage point of |MoM_Pct| (i.e., 100 * fraction)

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        CAST(CASE WHEN s.StDev_Prev12 IS NULL OR s.StDev_Prev12=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
             END AS decimal(38,4)) AS Z_Prev12,

        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)=0 AND ISNULL(s.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)<>0 AND ISNULL(s.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        -- Components for scoring
        ABS(ISNULL(rs.Z_Prev12, 0))                    AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)        AS LogAmt,               -- stable scale for $ moves
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0              AS AbsPctPoints,         -- convert fraction to pct points

        -- Final SeverityScore (tunable weights)
        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0))  AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.Flag_ZeroToNonZero,
    s.Flag_NonZeroToZero,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;







/*==========================================================
  Single-CreditLine Variance Analysis (12M history + Z-score)
  - Anchors current EOM to latest month-end relative to today
    (e.g., if today is 2025-09-04 -> current EOM = 2025-08-31)
  - Pulls up to 12 prior EOMs (plus current), handles gaps
  - Computes MoM diffs, trailing-12 mean/stdev (prev-12 only),
    and Z-score vs trailing 12 (statistically sound)
==========================================================*/

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line
DECLARE @LookbackMonths    int        = 12;
DECLARE @NaturalCurrEOM    date       = EOMONTH(GETDATE(), -1);

/* Latest available EOM for this line on/before @NaturalCurrEOM */
DECLARE @Anchor date =
(
  SELECT MAX(cu.LoadDate)
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  WHERE cu.CreditLineNumber = @CreditLineNumber
    AND cu.LoadDate <= @NaturalCurrEOM
);

IF @Anchor IS NULL
BEGIN
    DECLARE @msg nvarchar(200) =
        CONCAT('No data found on or before ',
               CONVERT(varchar(10), @NaturalCurrEOM, 120),
               ' for CreditLine ', @CreditLineNumber, '.');
    RAISERROR(@msg, 16, 1);
    RETURN;
END;

/* =========================
   A) Full 13-row Panel
   ========================= */
;WITH spine AS (
    -- generate current anchor + 12 prior EOMs
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1,
           EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT
        s.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT
        h.LoadDate,
        COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
        h.SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,

        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- trailing statistics over the *previous* 12 months (excludes current)
        AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(b.Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN NULL
              ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base b
ORDER BY b.LoadDate
OPTION (MAXRECURSION 200);

/* =========================
   B) Latest-month Spotlight
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           CIF, ClientName, ApplID, FormulaLine, BankCode,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT TOP (1)
    LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode,
    SecUnfunded, Prev_SecUnfunded,
    CAST(SecUnfunded - ISNULL(Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (SecUnfunded - Prev_SecUnfunded) / NULLIF(ABS(Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,
    CAST(Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
    CAST(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN NULL
              ELSE (SecUnfunded - Mean_Prev12) / StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base
ORDER BY LoadDate DESC
OPTION (MAXRECURSION 200);

/* =========================
   C) Quick Summary (Panel)
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    COUNT(*)                                                       AS Rows_In_Panel,
    SUM(CASE WHEN Prev_SecUnfunded IS NULL THEN 0 ELSE 1 END)      AS Rows_With_Prior,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END) AS Cnt_ZeroToNonZero,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END) AS Cnt_NonZeroToZero,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_2plus,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_3plus
FROM base
OPTION (MAXRECURSION 200);



/* ==========================================================
   Drill-Down Variance Analysis for ONE CreditLine
   - Pulls last 12 EOM snapshots (plus one extra to get MoM)
   - Computes MoM_Diff / MoM_Pct
   - Rolling (prev-12) mean & stdev
   - Z-score per month vs trailing 12 (excludes the month itself)
   - Flags: |Z|≥2 (moderate), |Z|≥3 (severe), zero↔nonzero switches

   Assumed tables (SQL Server):
     CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED   (LoadDate, CreditLineNumber, SecUnfunded)
     CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY   (LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode)

   >>> Set @CreditLineNumber below
========================================================== */

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line here
DECLARE @CurrEOM          date        = EOMONTH(GETDATE(), -1);  -- latest month-end as of "today"
DECLARE @LookbackMonths    int        = 12;             -- trailing window

/* 0) Resolve current/prior month-ends that actually exist for this line */
IF OBJECT_ID('tempdb..#LineEOM') IS NOT NULL DROP TABLE #LineEOM;

;WITH d AS (
    SELECT DISTINCT LoadDate
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
    WHERE CreditLineNumber = @CreditLineNumber
      AND LoadDate <= @CurrEOM
),
ranked AS (
    SELECT LoadDate,
           ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
    FROM d
)
SELECT
    MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM_Available,
    MAX(CASE WHEN rn = @LookbackMonths + 1 THEN LoadDate END) AS OldestNeededEOM
INTO #LineEOM
FROM ranked;

/* 1) Build a month-end spine (dates) for the last @LookbackMonths + 1 months up to the available current EOM */
IF OBJECT_ID('tempdb..#Spine') IS NOT NULL DROP TABLE #Spine;

DECLARE @Anchor date = (SELECT CurrEOM_Available FROM #LineEOM);
IF @Anchor IS NULL
BEGIN
    RAISERROR('No data found on or before %s for CreditLine %s.', 16, 1, CONVERT(varchar(10), @CurrEOM, 120), @CreditLineNumber);
    RETURN;
END

;WITH spine AS (
    SELECT @Anchor AS LoadDate, 0 AS step
    UNION ALL
    SELECT EOMONTH(DATEADD(MONTH, -1, LoadDate)), step + 1
    FROM spine
    WHERE step < @LookbackMonths
)
SELECT LoadDate
INTO #Spine
FROM spine
OPTION (MAXRECURSION 200);

/* 2) Pull SecUnfunded history for that line, aligned to the spine (left join → preserves missing months) */
IF OBJECT_ID('tempdb..#Hist') IS NOT NULL DROP TABLE #Hist;

SELECT
    s.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
INTO #Hist
FROM #Spine s
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    ON cu.LoadDate = s.LoadDate
   AND cu.CreditLineNumber = @CreditLineNumber;

/* 3) Attach some metadata (from CREDIT_LINE_MONTHLY at the same LoadDate, if available) */
IF OBJECT_ID('tempdb..#HistMeta') IS NOT NULL DROP TABLE #HistMeta;

SELECT
    h.LoadDate,
    COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
    h.SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode
INTO #HistMeta
FROM #Hist h
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = h.LoadDate
 AND cl.CreditLineNumber = @CreditLineNumber;

/* 4) Compute MoM diffs and rolling stats; Z-score vs trailing 12 (excluding current) */
IF OBJECT_ID('tempdb..#Stats') IS NOT NULL DROP TABLE #Stats;

;WITH base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,
        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- Rolling (prev-12) mean & stdev; excludes the current month by framing to 1 PRECEDING
        AVG(SecUnfunded)  OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded)OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM #HistMeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded, 0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
        CASE WHEN ISNULL(b.Prev_SecUnfunded, 0.00) = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded), 0.00)
        END AS decimal(38,6)
    ) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(
        CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
        END AS decimal(38,4)
    ) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
INTO #Stats
FROM base b;

/* 5) Final outputs
      A) Full 13-row panel (oldest … latest)
      B) Latest-month spotlight (most recent EOM available)
      C) Quick anomaly summary counts across the panel
*/
-- A) Panel
SELECT *
FROM #Stats
ORDER BY LoadDate;

-- B) Latest-month spotlight
SELECT TOP (1) *
FROM #Stats
ORDER BY LoadDate DESC;

-- C) Summary (counts across panel)
SELECT
    COUNT(*)                                           AS Rows_In_Panel,
    SUM(CASE WHEN MoM_Diff IS NULL THEN 0 ELSE 1 END)  AS Rows_With_Prior,
    SUM(Flag_ZeroToNonZero)                            AS Cnt_ZeroToNonZero,
    SUM(Flag_NonZeroToZero)                            AS Cnt_NonZeroToZero,
    SUM(Flag_Z_2plus)                                  AS Cnt_Z_Abs_2plus,
    SUM(Flag_Z_3plus)                                  AS Cnt_Z_Abs_3plus
FROM #Stats;





/*==========================================================
  MoM SecUnfunded Variance @ CreditLine
  Current month = 08/31/2025
  Prior month   = 07/31/2025
==========================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM date = '2025-08-31';
DECLARE @PrevEOM date = '2025-07-31';

/* Current snapshot */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Curr
INTO #Curr
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @CurrEOM
  AND cl.LoadDate = @CurrEOM;

/* Prior snapshot */
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Prev
INTO #Prev
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @PrevEOM
  AND cl.LoadDate = @PrevEOM;

/* MoM Variance */
SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,
    COALESCE(c.CIF, p.CIF)           AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID, p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine, p.FormulaLine) AS FormulaLine,
    COALESCE(c.BankCode, p.BankCode) AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr,0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev,0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
      CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                 / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
      END AS decimal(38,6)
    ) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber
ORDER BY ABS(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00)) DESC;






/*==========================================================
  MoM SecUnfunded Variance @ CreditLine (no RunID)
  - Auto-detects the latest two LoadDates from CALCULATED_UNFUNDED
  - Joins optional line metadata from CREDIT_LINE_MONTHLY (current/prior)
  - Safe math, zero↔nonzero flags
==========================================================*/

SET NOCOUNT ON;

/* 1) Identify the latest two LoadDates present in CALCULATED_UNFUNDED */
IF OBJECT_ID('tempdb..#EOM') IS NOT NULL DROP TABLE #EOM;
WITH DistinctDates AS (
  SELECT DISTINCT LoadDate
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
),
Ranked AS (
  SELECT LoadDate,
         ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
  FROM DistinctDates
)
SELECT
  MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM,
  MAX(CASE WHEN rn = 2 THEN LoadDate END) AS PrevEOM
INTO #EOM
FROM Ranked
WHERE rn IN (1,2);

-- Optional: quick sanity check
-- SELECT * FROM #EOM;

/* 2) Build current & prior SecUnfunded snapshots */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Curr AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.CurrEOM
), CL_Curr AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT CurrEOM FROM #EOM) d
  WHERE cl.LoadDate = d.CurrEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    c.SecUnfunded AS SecUnfunded_Curr
INTO #Curr
FROM CU_Curr c
LEFT JOIN CL_Curr m
  ON m.LoadDate = c.LoadDate
 AND m.CreditLineNumber = c.CreditLineNumber;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Prev AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.PrevEOM
), CL_Prev AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT PrevEOM FROM #EOM) d
  WHERE cl.LoadDate = d.PrevEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    p.LoadDate,
    p.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    p.SecUnfunded AS SecUnfunded_Prev
INTO #Prev
FROM CU_Prev p
LEFT JOIN CL_Prev m
  ON m.LoadDate = p.LoadDate
 AND m.CreditLineNumber = p.CreditLineNumber;

/* 3) Compute MoM */
IF OBJECT_ID('tempdb..#MoM') IS NOT NULL DROP TABLE #MoM;

DECLARE @CurrEOM date = (SELECT CurrEOM FROM #EOM);
DECLARE @PrevEOM date = (SELECT PrevEOM FROM #EOM);

SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,

    -- Prefer current metadata if present
    COALESCE(c.CIF,        p.CIF)        AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID,     p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine,p.FormulaLine)AS FormulaLine,
    COALESCE(c.BankCode,   p.BankCode)   AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr, 0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev, 0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE
           WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
INTO #MoM
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber;

/* 4) Results */
-- Detailed variances
SELECT *
FROM #MoM
ORDER BY ABS(MoM_Diff) DESC, CreditLineNumber;

-- Quick top movers
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff DESC, CreditLineNumber; -- biggest increases
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff ASC,  CreditLineNumber; -- biggest decreases

-- Optional rollups (uncomment as needed):
-- SELECT BankCode, SUM(SecUnfunded_Prev) AS Prev_, SUM(SecUnfunded_Curr) AS Curr_, SUM(MoM_Diff) AS MoM_Diff
-- FROM #MoM GROUP BY BankCode ORDER BY ABS(SUM(MoM_Diff)) DESC;






-- === Define the two months once ===
DECLARE @PrevDate date = DATEFROMPARTS(2025,7,31);
DECLARE @CurrDate date = DATEFROMPARTS(2025,8,31);

WITH Prev AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @PrevDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
),
Curr AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @CurrDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
)

SELECT
    c.LoadDate,
    c.Cif,
    c.CreditLineNumber,
    c.RevolvingFlag,
    c.FormulaLine,

    p.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    c.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(c.NetBorrowingBase,0)  - ISNULL(p.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    p.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    c.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(c.GrossLineAmount,0)   - ISNULL(p.GrossLineAmount,0)   AS GrossLineAmount_Change,

    p.NetLineAmount     AS PrevMonth_NetLineAmount,
    c.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(c.NetLineAmount,0)     - ISNULL(p.NetLineAmount,0)     AS NetLineAmount_Change,

    p.NetUtilized       AS PrevMonth_NetUtilized,
    c.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(c.NetUtilized,0)       - ISNULL(p.NetUtilized,0)       AS NetUtilized_Change,

    p.SecUnfunded       AS PrevMonth_SecUnfunded,
    c.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(c.SecUnfunded,0)       - ISNULL(p.SecUnfunded,0)       AS SecUnfunded_Change,

    p.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    c.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(c.Recalculated_SecUnfunded,0) - ISNULL(p.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM Curr c
LEFT JOIN Prev p
  ON p.CreditLineNumber = c.CreditLineNumber;





IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- === PREVIOUS MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === CURRENT MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === COMPARE (numeric math only; no FORMAT anywhere) ===
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- show raw values
    pm.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    cm.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(cm.NetBorrowingBase,0)  - ISNULL(pm.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    pm.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    cm.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(cm.GrossLineAmount,0)   - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    pm.NetLineAmount     AS PrevMonth_NetLineAmount,
    cm.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(cm.NetLineAmount,0)     - ISNULL(pm.NetLineAmount,0)     AS NetLineAmount_Change,

    pm.NetUtilized       AS PrevMonth_NetUtilized,
    cm.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(cm.NetUtilized,0)       - ISNULL(pm.NetUtilized,0)       AS NetUtilized_Change,

    pm.SecUnfunded       AS PrevMonth_SecUnfunded,
    cm.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(cm.SecUnfunded,0)       - ISNULL(pm.SecUnfunded,0)       AS SecUnfunded_Change,

    pm.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    cm.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);








IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- PREVIOUS MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- CURRENT MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- COMPARE (math on numerics; optional FORMAT for display)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- optional pretty display of raw values
    FORMAT(pm.NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    ISNULL(cm.NetBorrowingBase,0) - ISNULL(pm.NetBorrowingBase,0) AS NetBorrowingBase_Change,

    FORMAT(pm.GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    ISNULL(cm.GrossLineAmount,0) - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    FORMAT(pm.NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    ISNULL(cm.NetLineAmount,0) - ISNULL(pm.NetLineAmount,0)       AS NetLineAmount_Change,

    FORMAT(pm.NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    ISNULL(cm.NetUtilized,0) - ISNULL(pm.NetUtilized,0)           AS NetUtilized_Change,

    FORMAT(pm.SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    ISNULL(cm.SecUnfunded,0) - ISNULL(pm.SecUnfunded,0)           AS SecUnfunded_Change,

    -- recalculated sec unfunded comparison (numeric)
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);






IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- Previous month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS PrevMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS PrevMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS PrevMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS PrevMonth_NetUtilized, 
    CAST(b.SecUnfunded          AS decimal(19,2)) AS PrevMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS PrevMonth_Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-07-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Current month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS CurrMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS CurrMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS CurrMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS CurrMonth_NetUtilized,
    CAST(b.SecUnfunded          AS decimal(19,2)) AS CurrMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS CurrMonth_Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-08-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Compare (do math on numerics; format at the end if desired)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- Optional pretty display
    FORMAT(pm.PrevMonth_NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.CurrMonth_NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    cm.CurrMonth_NetBorrowingBase - pm.PrevMonth_NetBorrowingBase AS NetBorrowingBase_Change,

    FORMAT(pm.PrevMonth_GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.CurrMonth_GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    cm.CurrMonth_GrossLineAmount - pm.PrevMonth_GrossLineAmount   AS GrossLineAmount_Change,

    FORMAT(pm.PrevMonth_NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.CurrMonth_NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    cm.CurrMonth_NetLineAmount - pm.PrevMonth_NetLineAmount       AS NetLineAmount_Change,

    FORMAT(pm.PrevMonth_NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.CurrMonth_NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    cm.CurrMonth_NetUtilized - pm.PrevMonth_NetUtilized           AS NetUtilized_Change,

    FORMAT(pm.PrevMonth_SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.CurrMonth_SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    cm.CurrMonth_SecUnfunded - pm.PrevMonth_SecUnfunded           AS SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);







IF OBJECT_ID('tempdb..#PrevMonth')   IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth')  IS NOT NULL DROP TABLE #CurrMonth;

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as PrevMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as PrevMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as PrevMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as PrevMonth_NetUtilized_fmtd, 
	format(b.SecUnfunded,'N2') as PrevMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as PrevMonth_Recalculated_SecUnfunded
into #PrevMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '7/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as CurrMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as CurrMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as CurrMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as CurrMonth_NetUtilized_fmtd,
	format(b.SecUnfunded,'N2') as CurrMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as CurrMonth_Recalculated_SecUnfunded
into #CurrMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '8/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select
	cm.LoadDate,
	cm.Cif,
	cm.CreditLineNumber,
	cm.RevolvingFlag,
	cm.FormulaLine,
	pm.PrevMonth_NetBorrowingBase_fmtd,
	cm.CurrMonth_NetBorrowingBase_fmtd,
	(cm.CurrMonth_NetBorrowingBase_fmtd - pm.PrevMonth_NetBorrowingBase_fmtd) as NetBorrowingBase_Change,
	pm.PrevMonth_GrossLineAmount_fmtd,
	cm.CurrMonth_GrossLineAmount_fmtd,
	(cm.CurrMonth_GrossLineAmount_fmtd - pm.PrevMonth_GrossLineAmount_fmtd) as GrossLineAmount_Change,
	pm.PrevMonth_NetLineAmount_fmtd,
	cm.CurrMonth_NetLineAmount_fmtd,
	(cm.CurrMonth_NetLineAmount_fmtd - pm.PrevMonth_NetLineAmount_fmtd) as NetLineAmount_Change,
	pm.PrevMonth_NetUtilized_fmtd,
	cm.CurrMonth_NetUtilized_fmtd,
	(cm.CurrMonth_NetUtilized_fmtd - pm.PrevMonth_NetUtilized_fmtd) as NetUtilized_Change,
	pm.PrevMonth_SecUnfunded_fmtd,
	cm.CurrMonth_SecUnfunded_fmtd,
	(cm.CurrMonth_SecUnfunded_fmtd - pm.PrevMonth_SecUnfunded_fmtd) as SecUnfunded_Change
from #CurrMonth cm
left join #PrevMonth pm
on cm.LoadDate = pm.LoadDate and cm.CreditLineNumber = pm.CreditLineNumber






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;
