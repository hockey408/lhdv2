import pandas as pd
import numpy as np
import requests
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error, accuracy_score





import requests
import pandas as pd

# Example: pull player stats from 2024-25 season
season = "20242025"
url = f"https://statsapi.web.nhl.com/api/v1/teams?expand=team.roster&season={season}"
teams = requests.get(url).json()

players = []
for team in teams["teams"]:
    for player in team["roster"]["roster"]:
        pid = player["person"]["id"]
        stats_url = f"https://statsapi.web.nhl.com/api/v1/people/{pid}/stats?stats=statsSingleSeason&season={season}"
        stats = requests.get(stats_url).json()
        if stats["stats"][0]["splits"]:
            data = stats["stats"][0]["splits"][0]["stat"]
            data["id"] = pid
            data["name"] = player["person"]["fullName"]
            data["team"] = team["name"]
            players.append(data)

df_players = pd.DataFrame(players)
df_players.head()






/* === KDE Change Analysis with Seasonality + Robustness + History ============
   - Netezza-safe: no REGR_*; no POWER(); alias-safe ORDER BY
   - Seasonality: month-of-year additive means from history < latest (no leakage)
   - Robustness: winsorize de-seasonalized training data (pre-latest) at ±3σ
   - Methods: Regression (algebraic moments on de-seasonalized robust series),
              MA(12) on de-seasonalized robust series (exclude current),
              both re-seasonalized for comparison vs actuals
   - Selection: per-KDE method with lower historical RMSE (exposure) pre-latest
   - Output: history window with actuals, prev, forecasts, residuals, z-scores,
             severity, and transparency fields
   ========================================================================== */

WITH
/* Latest month and 24-month base window for modeling */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* ---- HISTORY WINDOW CONTROL (edit to change displayed history length) ---- */
hist_bounds AS (
  /* Last 12 months including latest: start = latest - 11 months */
  SELECT ADD_MONTHS(max_eom, -11) AS hist_start, max_eom AS hist_end
  FROM latest
),

/* Base slice: include every KDE column you might analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION) AS exposure,
    /* add/remove KDE columns you want to analyze downstream */
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional portfolio scope:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to add/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'         AS KDE_NAME, CAST(PD_GRADE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',         CAST(CRE_FLAG         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',    CAST(DAYS_PAST_DUE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',          CAST(RC_CODE          AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',   CAST(REVOLVING_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',   CAST(FDIC_CALL_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE',  CAST(GL_ACCOUNT_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',    CAST(INDUSTRY_CODE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',    CAST(MATURITY_DATE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',              CAST(LTV              AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',       CAST(NAICS_CODE       AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',         CAST(RBC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG', CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* Prior month's KDE value per account × KDE */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Monthly agg per KDE: change volume & change exposure */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Add month-of-year and previous-month actuals */
kde_with_month AS (
  SELECT
    a.*,
    CAST(EXTRACT(MONTH FROM a.END_OF_MONTH_DATE) AS INTEGER) AS mo
  FROM kde_change_agg a
),

/* Seasonality profiles from history strictly before latest (no leakage) */
kde_seasonality AS (
  SELECT
    k.KDE_NAME,
    k.mo,
    AVG(k.change_exposure) AS seas_mean_exp,
    STDDEV(k.change_exposure) AS seas_sd_exp,
    AVG(k.change_acct_cnt) AS seas_mean_cnt,
    STDDEV(k.change_acct_cnt) AS seas_sd_cnt
  FROM kde_with_month k
  JOIN latest l ON k.END_OF_MONTH_DATE < l.max_eom
  GROUP BY k.KDE_NAME, k.mo
),

/* Series with de-seasonalized fields and prev-month actuals */
kde_series AS (
  SELECT
    w.*,
    CAST(ROW_NUMBER() OVER (PARTITION BY w.KDE_NAME ORDER BY w.END_OF_MONTH_DATE)
         AS DOUBLE PRECISION) AS month_num_dp,
    LAG(w.change_acct_cnt) OVER (PARTITION BY w.KDE_NAME ORDER BY w.END_OF_MONTH_DATE) AS prev_change_acct_cnt,
    LAG(w.change_exposure) OVER (PARTITION BY w.KDE_NAME ORDER BY w.END_OF_MONTH_DATE) AS prev_change_exposure,
    s.seas_mean_exp, s.seas_sd_exp, s.seas_mean_cnt, s.seas_sd_cnt,
    /* additive de-seasonalization */
    (w.change_exposure  - COALESCE(s.seas_mean_exp, 0)) AS change_exposure_ds,
    (w.change_acct_cnt  - COALESCE(s.seas_mean_cnt, 0)) AS change_acct_cnt_ds
  FROM kde_with_month w
  LEFT JOIN kde_seasonality s
    ON s.KDE_NAME = w.KDE_NAME AND s.mo = w.mo
),

/* Robustify training history by winsorizing de-seasonalized values (pre-latest only) */
kde_train_stats AS (
  SELECT
    KDE_NAME,
    AVG(change_exposure_ds) AS mu_exp_ds,
    STDDEV(change_exposure_ds) AS sd_exp_ds,
    AVG(change_acct_cnt_ds) AS mu_cnt_ds,
    STDDEV(change_acct_cnt_ds) AS sd_cnt_ds
  FROM kde_series
  JOIN latest l ON kde_series.END_OF_MONTH_DATE < l.max_eom
  GROUP BY KDE_NAME
),
kde_series_robust AS (
  SELECT
    s.*,
    /* cap at ±3σ for training rows only; latest stays uncapped for scoring */
    CASE
      WHEN s.END_OF_MONTH_DATE < (SELECT max_eom FROM latest) AND ts.sd_exp_ds IS NOT NULL THEN
        CASE
          WHEN s.change_exposure_ds >  ts.mu_exp_ds + 3.0 * ts.sd_exp_ds THEN ts.mu_exp_ds + 3.0 * ts.sd_exp_ds
          WHEN s.change_exposure_ds <  ts.mu_exp_ds - 3.0 * ts.sd_exp_ds THEN ts.mu_exp_ds - 3.0 * ts.sd_exp_ds
          ELSE s.change_exposure_ds
        END
      ELSE s.change_exposure_ds
    END AS change_exposure_ds_rb,
    CASE
      WHEN s.END_OF_MONTH_DATE < (SELECT max_eom FROM latest) AND ts.sd_cnt_ds IS NOT NULL THEN
        CASE
          WHEN s.change_acct_cnt_ds >  ts.mu_cnt_ds + 3.0 * ts.sd_cnt_ds THEN ts.mu_cnt_ds + 3.0 * ts.sd_cnt_ds
          WHEN s.change_acct_cnt_ds <  ts.mu_cnt_ds - 3.0 * ts.sd_cnt_ds THEN ts.mu_cnt_ds - 3.0 * ts.sd_cnt_ds
          ELSE s.change_acct_cnt_ds
        END
      ELSE s.change_acct_cnt_ds
    END AS change_acct_cnt_ds_rb
  FROM kde_series s
  LEFT JOIN kde_train_stats ts
    ON ts.KDE_NAME = s.KDE_NAME
),

/* ---------------- Regression path (algebraic moments on de-seasonalized robust) ---------------- */
kde_reg_moments AS (
  SELECT
    KDE_NAME,
    COUNT(*) AS n,
    SUM(month_num_dp) AS sum_x,
    SUM(month_num_dp * month_num_dp) AS sum_x2,
    SUM(CAST(change_exposure_ds_rb AS DOUBLE PRECISION)) AS sum_y_exp,
    SUM(month_num_dp * CAST(change_exposure_ds_rb AS DOUBLE PRECISION)) AS sum_xy_exp,
    SUM(CAST(change_acct_cnt_ds_rb  AS DOUBLE PRECISION)) AS sum_y_cnt,
    SUM(month_num_dp * CAST(change_acct_cnt_ds_rb  AS DOUBLE PRECISION)) AS sum_xy_cnt
  FROM kde_series_robust
  GROUP BY KDE_NAME
),
kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num_dp,
    /* keep raw actuals & seasonal means for re-seasonalization */
    s.change_exposure,
    s.change_acct_cnt,
    s.seas_mean_exp, s.seas_mean_cnt,
    /* solve slope/intercept on de-seasonalized robust series */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp) / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_exp_ds,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_exp - ((m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp) / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n END AS intercept_exp_ds,
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt) / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_cnt_ds,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_cnt - ((m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt) / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n END AS intercept_cnt_ds
  FROM kde_series s
  JOIN kde_reg_moments m ON s.KDE_NAME = m.KDE_NAME
),
kde_reg_fit2 AS (
  SELECT
    f.*,
    /* de-seasonalized predictions */
    (f.intercept_exp_ds + f.slope_exp_ds * f.month_num_dp) AS reg_pred_exp_ds,
    (f.intercept_cnt_ds + f.slope_cnt_ds * f.month_num_dp) AS reg_pred_cnt_ds,
    /* re-seasonalize to compare with raw actuals */
    (f.intercept_exp_ds + f.slope_exp_ds * f.month_num_dp) + COALESCE(f.seas_mean_exp,0) AS reg_pred_exp,
    (f.intercept_cnt_ds + f.slope_cnt_ds * f.month_num_dp) + COALESCE(f.seas_mean_cnt,0) AS reg_pred_cnt,
    /* residuals in raw space */
    (CAST(f.change_exposure AS DOUBLE PRECISION) - ((f.intercept_exp_ds + f.slope_exp_ds * f.month_num_dp) + COALESCE(f.seas_mean_exp,0))) AS reg_resid_exp,
    (CAST(f.change_acct_cnt  AS DOUBLE PRECISION) - ((f.intercept_cnt_ds + f.slope_cnt_ds * f.month_num_dp) + COALESCE(f.seas_mean_cnt,0))) AS reg_resid_cnt
  FROM kde_reg_fit f
),
kde_reg_stats AS (
  SELECT KDE_NAME,
         STDDEV(reg_resid_exp) AS sd_resid_exp,
         STDDEV(reg_resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit2
  GROUP BY KDE_NAME
),
kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.reg_resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.reg_resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit2 f
  JOIN kde_reg_stats s ON f.KDE_NAME = s.KDE_NAME
),

/* ---------------- MA(12) path on de-seasonalized robust (exclude current) ---------------- */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    seas_mean_exp, seas_mean_cnt,
    AVG(change_exposure_ds_rb) OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS ma_exp_ds,
    STDDEV(change_exposure_ds_rb) OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS sd_exp_ds,
    AVG(change_acct_cnt_ds_rb)  OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS ma_cnt_ds,
    STDDEV(change_acct_cnt_ds_rb)  OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS sd_cnt_ds
  FROM kde_series_robust
),
kde_ma_preds AS (
  SELECT
    r.*,
    /* re-seasonalize baselines to raw space */
    (r.ma_exp_ds + COALESCE(r.seas_mean_exp,0)) AS ma_exp,
    (r.ma_cnt_ds + COALESCE(r.seas_mean_cnt,0)) AS ma_cnt
  FROM kde_ma_roll r
),
kde_ma_z AS (
  SELECT
    m.KDE_NAME,
    m.END_OF_MONTH_DATE,
    ((m.change_exposure - m.ma_exp) / NULLIF(m.sd_exp_ds, 0)) AS exp_ma_z,
    ((m.change_acct_cnt - m.ma_cnt) / NULLIF(m.sd_cnt_ds, 0)) AS cnt_ma_z
  FROM kde_ma_preds m
),

/* -------- Model selection (per KDE) by historical RMSE on exposure (pre-latest) -------- */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals already in raw space */
    SQRT(AVG(CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom THEN (rf.reg_resid_exp * rf.reg_resid_exp) END)) AS rmse_reg_exp,
    /* MA residuals vs re-seasonalized baseline */
    SQRT(AVG(CASE WHEN mp.END_OF_MONTH_DATE < l.max_eom THEN (mp.change_exposure - mp.ma_exp) * (mp.change_exposure - mp.ma_exp) END)) AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_preds mp ON mp.KDE_NAME = k.KDE_NAME
  GROUP BY l.max_eom, k.KDE_NAME
),
method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* ===== HISTORY RESULTSET: one row per month per KDE within hist window ===== */
history AS (
  SELECT
    s.END_OF_MONTH_DATE                       AS report_month,
    l.max_eom                                 AS latest_month,
    s.KDE_NAME,
    mc.chosen_method,

    /* actuals & previous */
    s.change_acct_cnt,
    s.prev_change_acct_cnt,
    s.change_exposure,
    s.prev_change_exposure,

    /* forecasts (both methods, re-seasonalized) */
    rf.reg_pred_cnt,
    rf.reg_pred_exp,
    mp.ma_cnt,
    mp.ma_exp,

    /* z-scores */
    rz.cnt_reg_z,
    rz.exp_reg_z,
    mz.cnt_ma_z,
    mz.exp_ma_z,

    /* chosen method: z, forecast, residuals (raw space) */
    CASE WHEN mc.chosen_method = 'REG' THEN rz.cnt_reg_z ELSE mz.cnt_ma_z END AS cnt_z_chosen,
    CASE WHEN mc.chosen_method = 'REG' THEN rz.exp_reg_z ELSE mz.exp_ma_z END AS exp_z_chosen,
    CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_cnt ELSE mp.ma_cnt END AS forecast_change_acct_cnt,
    CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_exp ELSE mp.ma_exp END AS forecast_change_exposure,
    (s.change_acct_cnt - (CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_cnt ELSE mp.ma_cnt END)) AS resid_cnt_chosen,
    (s.change_exposure - (CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_exp ELSE mp.ma_exp END)) AS resid_exp_chosen

  FROM kde_series s
  JOIN latest l             ON 1=1
  JOIN method_choice mc     ON mc.KDE_NAME = s.KDE_NAME
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = s.KDE_NAME AND rf.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_ma_preds mp ON mp.KDE_NAME = s.KDE_NAME AND mp.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_reg_z    rz ON rz.KDE_NAME = s.KDE_NAME AND rz.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_ma_z     mz ON mz.KDE_NAME = s.KDE_NAME AND mz.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  JOIN hist_bounds hb ON s.END_OF_MONTH_DATE BETWEEN hb.hist_start AND hb.hist_end
)

SELECT
  h.report_month,
  h.latest_month,
  h.KDE_NAME,
  h.chosen_method,

  /* actuals & previous */
  h.change_acct_cnt,
  h.prev_change_acct_cnt,
  h.change_exposure,
  h.prev_change_exposure,

  /* forecasts & residuals (chosen method, raw space) */
  h.forecast_change_acct_cnt,
  h.forecast_change_exposure,
  h.resid_cnt_chosen,
  h.resid_exp_chosen,

  /* scores */
  ROUND(h.exp_z_chosen, 2) AS exp_z_chosen,
  ROUND(h.cnt_z_chosen, 2) AS cnt_z_chosen,
  ROUND(0.3 * ABS(h.cnt_z_chosen) + 0.7 * ABS(h.exp_z_chosen), 2) AS severity_score,

  /* transparency (keep if useful) */
  ROUND(h.exp_reg_z, 2) AS exp_z_reg,
  ROUND(h.cnt_reg_z, 2) AS cnt_z_reg,
  ROUND(h.exp_ma_z, 2)  AS exp_z_ma,
  ROUND(h.cnt_ma_z, 2)  AS cnt_z_ma,
  h.reg_pred_cnt, h.reg_pred_exp, h.ma_cnt, h.ma_exp

FROM history h
WHERE (h.exp_z_chosen IS NOT NULL OR h.cnt_z_chosen IS NOT NULL)
ORDER BY
  h.report_month DESC,   /* newest first within the history window */
  (0.3 * ABS(h.cnt_z_chosen) + 0.7 * ABS(h.exp_z_chosen)) DESC,
  ABS(h.exp_z_chosen) DESC,
  ABS(h.cnt_z_chosen) DESC;






/* === KDE Change Analysis: REG (moments) + MA(12) with HISTORY =================
   - Netezza-safe: no REGR_*; no POWER(); alias-safe ORDER BY
   - Method selection per KDE by historical RMSE (exposure) using months < latest
   - Output: history window (default 12 months) with actuals, prev, forecasts,
             residuals, chosen z-scores, severity, and transparency columns
   ============================================================================ */

WITH
/* Latest month and 24-month base window for modeling */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* ---- HISTORY WINDOW CONTROL (edit this to change how much to display) ---- */
hist_bounds AS (
  /* Last 12 months including latest: start = latest - 11 months */
  SELECT ADD_MONTHS(max_eom, -11) AS hist_start, max_eom AS hist_end
  FROM latest
),

/* Base slice: include every KDE column you might analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION) AS exposure,
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
),

/* Manual UNPIVOT: edit this block to add/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'         AS KDE_NAME, CAST(PD_GRADE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',         CAST(CRE_FLAG         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',    CAST(DAYS_PAST_DUE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',          CAST(RC_CODE          AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',   CAST(REVOLVING_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',   CAST(FDIC_CALL_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE',  CAST(GL_ACCOUNT_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',    CAST(INDUSTRY_CODE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',    CAST(MATURITY_DATE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',              CAST(LTV              AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',       CAST(NAICS_CODE       AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',         CAST(RBC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG', CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* Prior month's KDE value per account × KDE */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Monthly agg per KDE: change volume & change exposure */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Series with prev-month actuals and a DP month index */
kde_series AS (
  SELECT
    a.*,
    CAST(ROW_NUMBER() OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE)
         AS DOUBLE PRECISION) AS month_num_dp,
    LAG(a.change_acct_cnt) OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE) AS prev_change_acct_cnt,
    LAG(a.change_exposure) OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE) AS prev_change_exposure
  FROM kde_change_agg a
),

/* -------- REG path (algebraic linear regression) -------- */
kde_reg_moments AS (
  SELECT
    KDE_NAME,
    COUNT(*)                                                       AS n,
    SUM(month_num_dp)                                             AS sum_x,
    SUM(month_num_dp * month_num_dp)                              AS sum_x2,
    SUM(CAST(change_exposure AS DOUBLE PRECISION))                AS sum_y_exp,
    SUM(month_num_dp * CAST(change_exposure AS DOUBLE PRECISION)) AS sum_xy_exp,
    SUM(CAST(change_acct_cnt  AS DOUBLE PRECISION))               AS sum_y_cnt,
    SUM(month_num_dp * CAST(change_acct_cnt  AS DOUBLE PRECISION))AS sum_xy_cnt
  FROM kde_series
  GROUP BY KDE_NAME
),
kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num_dp,
    s.change_exposure,
    s.change_acct_cnt,
    /* slope/intercept for exposure */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp) / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_exp,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_exp - ((m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp) / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n END AS intercept_exp,
    /* slope/intercept for count */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt) / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_cnt,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_cnt - ((m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt) / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n END AS intercept_cnt
  FROM kde_series s
  JOIN kde_reg_moments m ON s.KDE_NAME = m.KDE_NAME
),
kde_reg_fit2 AS (
  SELECT
    f.*,
    (f.intercept_exp + f.slope_exp * f.month_num_dp) AS reg_pred_exp,
    (f.intercept_cnt + f.slope_cnt * f.month_num_dp) AS reg_pred_cnt,
    (CAST(f.change_exposure AS DOUBLE PRECISION) - (f.intercept_exp + f.slope_exp * f.month_num_dp)) AS reg_resid_exp,
    (CAST(f.change_acct_cnt  AS DOUBLE PRECISION) - (f.intercept_cnt + f.slope_cnt * f.month_num_dp)) AS reg_resid_cnt
  FROM kde_reg_fit f
),
kde_reg_stats AS (
  SELECT KDE_NAME,
         STDDEV(reg_resid_exp) AS sd_resid_exp,
         STDDEV(reg_resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit2
  GROUP BY KDE_NAME
),
kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.reg_resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.reg_resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit2 f
  JOIN kde_reg_stats s ON f.KDE_NAME = s.KDE_NAME
),

/* -------- MA(12) path (exclude current) -------- */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    AVG(change_exposure) OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS ma_exp,
    STDDEV(change_exposure) OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS sd_exp,
    AVG(change_acct_cnt)  OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS ma_cnt,
    STDDEV(change_acct_cnt)  OVER (PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS sd_cnt
  FROM kde_series
),
kde_ma_z AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    ((change_exposure - ma_exp) / NULLIF(sd_exp, 0)) AS exp_ma_z,
    ((change_acct_cnt  - ma_cnt) / NULLIF(sd_cnt, 0)) AS cnt_ma_z
  FROM kde_ma_roll
),

/* -------- Model selection (per KDE) by historical RMSE on exposure -------- */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals */
    SQRT(AVG(CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom THEN (rf.reg_resid_exp * rf.reg_resid_exp) END)) AS rmse_reg_exp,
    /* MA residuals = change_exposure - ma_exp */
    SQRT(AVG(CASE WHEN mr.END_OF_MONTH_DATE < l.max_eom THEN (mr.change_exposure - mr.ma_exp)*(mr.change_exposure - mr.ma_exp) END)) AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_roll  mr ON mr.KDE_NAME = k.KDE_NAME
  GROUP BY l.max_eom, k.KDE_NAME
),
method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* ===== HISTORY RESULTSET: one row per month per KDE within hist window ===== */
history AS (
  SELECT
    s.END_OF_MONTH_DATE                       AS report_month,
    l.max_eom                                 AS latest_month,
    s.KDE_NAME,
    mc.chosen_method,

    /* actuals & previous */
    s.change_acct_cnt,
    s.prev_change_acct_cnt,
    s.change_exposure,
    s.prev_change_exposure,

    /* forecasts by method */
    /* regression preds (all months) */
    rf.reg_pred_cnt,
    rf.reg_pred_exp,
    /* MA baselines (all months) */
    mr.ma_cnt,
    mr.ma_exp,

    /* z-scores */
    rz.cnt_reg_z,
    rz.exp_reg_z,
    mz.cnt_ma_z,
    mz.exp_ma_z,

    /* chosen method: z, forecast, residuals */
    CASE WHEN mc.chosen_method = 'REG' THEN rz.cnt_reg_z ELSE mz.cnt_ma_z END AS cnt_z_chosen,
    CASE WHEN mc.chosen_method = 'REG' THEN rz.exp_reg_z ELSE mz.exp_ma_z END AS exp_z_chosen,
    CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_cnt ELSE mr.ma_cnt END AS forecast_change_acct_cnt,
    CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_exp ELSE mr.ma_exp END AS forecast_change_exposure,
    (s.change_acct_cnt - (CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_cnt ELSE mr.ma_cnt END)) AS resid_cnt_chosen,
    (s.change_exposure - (CASE WHEN mc.chosen_method = 'REG' THEN rf.reg_pred_exp ELSE mr.ma_exp END)) AS resid_exp_chosen

  FROM kde_series s
  JOIN latest l           ON 1=1
  JOIN method_choice mc   ON mc.KDE_NAME = s.KDE_NAME
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = s.KDE_NAME AND rf.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_ma_roll  mr ON mr.KDE_NAME = s.KDE_NAME AND mr.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_reg_z    rz ON rz.KDE_NAME = s.KDE_NAME AND rz.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  LEFT JOIN kde_ma_z     mz ON mz.KDE_NAME = s.KDE_NAME AND mz.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
  JOIN hist_bounds hb ON s.END_OF_MONTH_DATE BETWEEN hb.hist_start AND hb.hist_end
)

SELECT
  h.report_month,
  h.latest_month,
  h.KDE_NAME,
  h.chosen_method,

  /* actuals & previous */
  h.change_acct_cnt,
  h.prev_change_acct_cnt,
  h.change_exposure,
  h.prev_change_exposure,

  /* forecasts & residuals (chosen method) */
  h.forecast_change_acct_cnt,
  h.forecast_change_exposure,
  h.resid_cnt_chosen,
  h.resid_exp_chosen,

  /* scores */
  ROUND(h.exp_z_chosen, 2) AS exp_z_chosen,
  ROUND(h.cnt_z_chosen, 2) AS cnt_z_chosen,
  ROUND(0.3 * ABS(h.cnt_z_chosen) + 0.7 * ABS(h.exp_z_chosen), 2) AS severity_score,

  /* transparency (optional) */
  ROUND(h.exp_reg_z, 2) AS exp_z_reg,
  ROUND(h.cnt_reg_z, 2) AS cnt_reg_z,
  ROUND(h.exp_ma_z, 2)  AS exp_z_ma,
  ROUND(h.cnt_ma_z, 2)  AS cnt_z_ma,
  h.reg_pred_cnt, h.reg_pred_exp, h.ma_cnt, h.ma_exp

FROM history h
WHERE (h.exp_z_chosen IS NOT NULL OR h.cnt_z_chosen IS NOT NULL)
ORDER BY
  h.report_month DESC,   /* newest month first */
  (0.3 * ABS(h.cnt_z_chosen) + 0.7 * ABS(h.exp_z_chosen)) DESC,
  ABS(h.exp_z_chosen) DESC,
  ABS(h.cnt_z_chosen) DESC;





/* === KDE Change Analysis with Dual Baselines (REG via moments + MA(12)) ===
   - Netezza-safe: no REGR_*; avoids POWER(); repeats expressions in ORDER BY
   - Model selection per KDE by historical RMSE (exposure), months before latest
   - Latest output: chosen method's severity + both methods’ z-scores
   ======================================================================== */

WITH
/* Latest month and 24-month window */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice: include every KDE column you might analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION) AS exposure,
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional scope:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to add/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'         AS KDE_NAME, CAST(PD_GRADE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',         CAST(CRE_FLAG         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',    CAST(DAYS_PAST_DUE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',          CAST(RC_CODE          AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',   CAST(REVOLVING_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',   CAST(FDIC_CALL_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE',  CAST(GL_ACCOUNT_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',    CAST(INDUSTRY_CODE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',    CAST(MATURITY_DATE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',              CAST(LTV              AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',       CAST(NAICS_CODE       AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',         CAST(RBC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG', CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* Prior month's KDE value per account × KDE */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Monthly agg per KDE: change volume & change exposure */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Index months per KDE for regression & MA */
kde_series AS (
  SELECT
    a.*,
    CAST(ROW_NUMBER() OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE)
         AS DOUBLE PRECISION) AS month_num_dp
  FROM kde_change_agg a
),

/* -------- REG path (algebraic linear regression, no REGR_*) -------- */

/* Moments per KDE for y_exp and y_cnt */
kde_reg_moments AS (
  SELECT
    KDE_NAME,
    COUNT(*)                                                       AS n,
    SUM(month_num_dp)                                             AS sum_x,
    SUM(month_num_dp * month_num_dp)                              AS sum_x2,
    SUM(CAST(change_exposure AS DOUBLE PRECISION))                AS sum_y_exp,
    SUM(month_num_dp * CAST(change_exposure AS DOUBLE PRECISION)) AS sum_xy_exp,
    SUM(CAST(change_acct_cnt  AS DOUBLE PRECISION))               AS sum_y_cnt,
    SUM(month_num_dp * CAST(change_acct_cnt  AS DOUBLE PRECISION))AS sum_xy_cnt
  FROM kde_series
  GROUP BY KDE_NAME
),

/* Slope/intercept, predictions & residuals per row */
kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num_dp,
    s.change_exposure,
    s.change_acct_cnt,

    /* Solve slope/intercept for exposure */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_exp,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_exp
               - ((m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_exp,

    /* Solve slope/intercept for count */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_cnt,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_cnt
               - ((m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_cnt
  FROM kde_series s
  JOIN kde_reg_moments m
    ON s.KDE_NAME = m.KDE_NAME
),

/* Predictions & residuals */
kde_reg_fit2 AS (
  SELECT
    f.*,
    (f.intercept_exp + f.slope_exp * f.month_num_dp) AS pred_exp,
    (f.intercept_cnt + f.slope_cnt * f.month_num_dp) AS pred_cnt,
    (CAST(f.change_exposure AS DOUBLE PRECISION)
       - (f.intercept_exp + f.slope_exp * f.month_num_dp))        AS resid_exp,
    (CAST(f.change_acct_cnt  AS DOUBLE PRECISION)
       - (f.intercept_cnt + f.slope_cnt * f.month_num_dp))        AS resid_cnt
  FROM kde_reg_fit f
),

/* Std dev of regression residuals per KDE (for z-scores) */
kde_reg_stats AS (
  SELECT
    KDE_NAME,
    STDDEV(resid_exp) AS sd_resid_exp,
    STDDEV(resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit2
  GROUP BY KDE_NAME
),

/* Regression z-scores per month */
kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit2 f
  JOIN kde_reg_stats s
    ON f.KDE_NAME = s.KDE_NAME
),

/* -------------------- MA(12) path (exclude current) -------------------- */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    AVG(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_exp,
    STDDEV(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_exp,
    AVG(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_cnt,
    STDDEV(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_cnt
  FROM kde_series
),

kde_ma_z AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    ((change_exposure - ma_exp) / NULLIF(sd_exp, 0)) AS exp_ma_z,
    ((change_acct_cnt - ma_cnt) / NULLIF(sd_cnt, 0)) AS cnt_ma_z
  FROM kde_ma_roll
),

/* --------- Model selection by historical RMSE (exposure) --------- */
/* Compare REG vs MA on months strictly before latest */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals already computed in kde_reg_fit2 */
    SQRT(AVG(CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom
                   THEN (rf.resid_exp * rf.resid_exp) END))              AS rmse_reg_exp,
    /* MA residuals = change_exposure - ma_exp (square via x*x) */
    SQRT(AVG(CASE WHEN mr.END_OF_MONTH_DATE < l.max_eom
                   THEN (mr.change_exposure - mr.ma_exp)
                        * (mr.change_exposure - mr.ma_exp) END))         AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_roll  mr ON mr.KDE_NAME = k.KDE_NAME
  GROUP BY l.max_eom, k.KDE_NAME
),

method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* Latest-month scores from both methods */
latest_scores AS (
  SELECT
    l.max_eom AS latest_month,
    k.KDE_NAME,
    rz.exp_reg_z, rz.cnt_reg_z,
    mz.exp_ma_z,  mz.cnt_ma_z
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_z rz
    ON rz.KDE_NAME = k.KDE_NAME AND rz.END_OF_MONTH_DATE = l.max_eom
  LEFT JOIN kde_ma_z mz
    ON mz.KDE_NAME = k.KDE_NAME AND mz.END_OF_MONTH_DATE = l.max_eom
),

/* Choose method & compute weighted severity */
chosen AS (
  SELECT
    s.latest_month,
    s.KDE_NAME,
    mc.chosen_method,
    /* pick exposure z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.exp_reg_z ELSE s.exp_ma_z END AS exp_z,
    /* pick count z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.cnt_reg_z ELSE s.cnt_ma_z END AS cnt_z,
    /* keep both for transparency */
    s.exp_reg_z, s.cnt_reg_z, s.exp_ma_z, s.cnt_ma_z
  FROM latest_scores s
  JOIN method_choice mc
    ON mc.KDE_NAME = s.KDE_NAME
)

SELECT
  c.latest_month,
  c.KDE_NAME,
  c.chosen_method,
  ROUND(CASE WHEN c.chosen_method = 'REG' THEN c.exp_reg_z ELSE c.exp_ma_z END, 2) AS exp_z_chosen,
  ROUND(CASE WHEN c.chosen_method = 'REG' THEN c.cnt_reg_z ELSE c.cnt_ma_z END, 2) AS cnt_z_chosen,
  ROUND(0.3 * ABS(CASE WHEN c.chosen_method = 'REG' THEN c.cnt_reg_z ELSE c.cnt_ma_z END)
      + 0.7 * ABS(CASE WHEN c.chosen_method = 'REG' THEN c.exp_reg_z ELSE c.exp_ma_z END), 2) AS severity_score,
  /* transparency columns */
  ROUND(c.exp_reg_z, 2) AS exp_z_reg,
  ROUND(c.cnt_reg_z, 2) AS cnt_z_reg,
  ROUND(c.exp_ma_z, 2)  AS exp_z_ma,
  ROUND(c.cnt_ma_z, 2)  AS cnt_z_ma
FROM chosen c
WHERE (c.exp_reg_z IS NOT NULL OR c.exp_ma_z IS NOT NULL)
ORDER BY
  severity_score DESC,
  ABS(CASE WHEN c.chosen_method = 'REG' THEN c.exp_reg_z ELSE c.exp_ma_z END) DESC,
  ABS(CASE WHEN c.chosen_method = 'REG' THEN c.cnt_reg_z ELSE c.cnt_ma_z END) DESC;





/* === KDE Change Analysis with Dual Baselines (REG via moments + MA(12)) ===
   - Netezza-safe: no REGR_*; avoids POWER(); uses x*x for squares
   - Model selection per KDE by historical RMSE (exposure), months before latest
   - Latest output: chosen method's severity + both methods’ z-scores
   ======================================================================== */

WITH
/* Latest month and 24-month window */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice: include every KDE column you might analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION) AS exposure,
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional scope:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to add/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'         AS KDE_NAME, CAST(PD_GRADE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',         CAST(CRE_FLAG         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',    CAST(DAYS_PAST_DUE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',          CAST(RC_CODE          AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',   CAST(REVOLVING_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',   CAST(FDIC_CALL_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE',  CAST(GL_ACCOUNT_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',    CAST(INDUSTRY_CODE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',    CAST(MATURITY_DATE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',              CAST(LTV              AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',       CAST(NAICS_CODE       AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',         CAST(RBC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG', CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* Prior month's KDE value per account × KDE */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Monthly agg per KDE: change volume & change exposure */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Index months per KDE for regression & MA */
kde_series AS (
  SELECT
    a.*,
    CAST(ROW_NUMBER() OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE)
         AS DOUBLE PRECISION) AS month_num_dp
  FROM kde_change_agg a
),

/* -------- REG path (algebraic linear regression, no REGR_*) -------- */

/* Moments per KDE for y_exp and y_cnt */
kde_reg_moments AS (
  SELECT
    KDE_NAME,
    COUNT(*)                                                       AS n,
    SUM(month_num_dp)                                             AS sum_x,
    SUM(month_num_dp * month_num_dp)                              AS sum_x2,
    SUM(CAST(change_exposure AS DOUBLE PRECISION))                AS sum_y_exp,
    SUM(month_num_dp * CAST(change_exposure AS DOUBLE PRECISION)) AS sum_xy_exp,
    SUM(CAST(change_acct_cnt  AS DOUBLE PRECISION))               AS sum_y_cnt,
    SUM(month_num_dp * CAST(change_acct_cnt  AS DOUBLE PRECISION))AS sum_xy_cnt
  FROM kde_series
  GROUP BY KDE_NAME
),

/* Slope/intercept, predictions & residuals per row */
kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num_dp,
    s.change_exposure,
    s.change_acct_cnt,

    /* Solve slope/intercept for exposure */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_exp,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_exp
               - ((m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_exp,

    /* Solve slope/intercept for count */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_cnt,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_cnt
               - ((m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_cnt
  FROM kde_series s
  JOIN kde_reg_moments m
    ON s.KDE_NAME = m.KDE_NAME
),

/* Predictions & residuals */
kde_reg_fit2 AS (
  SELECT
    f.*,
    (f.intercept_exp + f.slope_exp * f.month_num_dp) AS pred_exp,
    (f.intercept_cnt + f.slope_cnt * f.month_num_dp) AS pred_cnt,
    (CAST(f.change_exposure AS DOUBLE PRECISION)
       - (f.intercept_exp + f.slope_exp * f.month_num_dp))        AS resid_exp,
    (CAST(f.change_acct_cnt  AS DOUBLE PRECISION)
       - (f.intercept_cnt + f.slope_cnt * f.month_num_dp))        AS resid_cnt
  FROM kde_reg_fit f
),

/* Std dev of regression residuals per KDE (for z-scores) */
kde_reg_stats AS (
  SELECT
    KDE_NAME,
    STDDEV(resid_exp) AS sd_resid_exp,
    STDDEV(resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit2
  GROUP BY KDE_NAME
),

/* Regression z-scores per month */
kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit2 f
  JOIN kde_reg_stats s
    ON f.KDE_NAME = s.KDE_NAME
),

/* -------------------- MA(12) path (exclude current) -------------------- */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    AVG(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_exp,
    STDDEV(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_exp,
    AVG(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_cnt,
    STDDEV(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_cnt
  FROM kde_series
),

kde_ma_z AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    ((change_exposure - ma_exp) / NULLIF(sd_exp, 0)) AS exp_ma_z,
    ((change_acct_cnt - ma_cnt) / NULLIF(sd_cnt, 0)) AS cnt_ma_z
  FROM kde_ma_roll
),

/* --------- Model selection by historical RMSE (exposure) --------- */
/* Compare REG vs MA on months strictly before latest */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals already computed in kde_reg_fit2 */
    SQRT(AVG(CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom
                   THEN (rf.resid_exp * rf.resid_exp) END))              AS rmse_reg_exp,
    /* MA residuals = change_exposure - ma_exp (square via x*x) */
    SQRT(AVG(CASE WHEN mr.END_OF_MONTH_DATE < l.max_eom
                   THEN (mr.change_exposure - mr.ma_exp)
                        * (mr.change_exposure - mr.ma_exp) END))         AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_roll  mr ON mr.KDE_NAME = k.KDE_NAME
  GROUP BY l.max_eom, k.KDE_NAME
),

method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* Latest-month scores from both methods */
latest_scores AS (
  SELECT
    l.max_eom AS latest_month,
    k.KDE_NAME,
    rz.exp_reg_z, rz.cnt_reg_z,
    mz.exp_ma_z,  mz.cnt_ma_z
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_z rz
    ON rz.KDE_NAME = k.KDE_NAME AND rz.END_OF_MONTH_DATE = l.max_eom
  LEFT JOIN kde_ma_z mz
    ON mz.KDE_NAME = k.KDE_NAME AND mz.END_OF_MONTH_DATE = l.max_eom
),

/* Choose method & compute weighted severity */
chosen AS (
  SELECT
    s.latest_month,
    s.KDE_NAME,
    mc.chosen_method,
    /* pick exposure z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.exp_reg_z ELSE s.exp_ma_z END AS exp_z,
    /* pick count z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.cnt_reg_z ELSE s.cnt_ma_z END AS cnt_z,
    /* keep both for transparency */
    s.exp_reg_z, s.cnt_reg_z, s.exp_ma_z, s.cnt_ma_z
  FROM latest_scores s
  JOIN method_choice mc
    ON mc.KDE_NAME = s.KDE_NAME
)

SELECT
  c.latest_month,
  c.KDE_NAME,
  c.chosen_method,
  ROUND(c.exp_z, 2)  AS exp_z_chosen,
  ROUND(c.cnt_z, 2)  AS cnt_z_chosen,
  ROUND(0.3 * ABS(c.cnt_z) + 0.7 * ABS(c.exp_z), 2) AS severity_score,
  /* transparency columns */
  ROUND(c.exp_reg_z, 2) AS exp_z_reg,
  ROUND(c.cnt_reg_z, 2) AS cnt_z_reg,
  ROUND(c.exp_ma_z, 2)  AS exp_z_ma,
  ROUND(c.cnt_ma_z, 2)  AS cnt_z_ma
FROM chosen c
WHERE (c.exp_z IS NOT NULL OR c.cnt_z IS NOT NULL)
ORDER BY severity_score DESC, ABS(exp_z_chosen) DESC, ABS(cnt_z_chosen) DESC;






/* === KDE Change Analysis with Dual Baselines (REG via moments + MA(12)) ===
   - Netezza-safe: no REGR_* calls; algebraic regression instead
   - Model selection per KDE by historical RMSE (exposure), prior to latest month
   - Latest output: chosen method's severity + both methods' z-scores
   ======================================================================== */

WITH
/* Latest month and 24-month window */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice: include every KDE column you might analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS DOUBLE PRECISION) AS exposure,
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional portfolio scope:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to add/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'         AS KDE_NAME, CAST(PD_GRADE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',         CAST(CRE_FLAG         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',    CAST(DAYS_PAST_DUE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',          CAST(RC_CODE          AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',   CAST(REVOLVING_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',   CAST(FDIC_CALL_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE',  CAST(GL_ACCOUNT_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',    CAST(INDUSTRY_CODE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',    CAST(MATURITY_DATE    AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',              CAST(LTV              AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',       CAST(NAICS_CODE       AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',         CAST(RBC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG', CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* Prior month's KDE value per account × KDE */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Monthly agg per KDE: change volume & change exposure */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Index months per KDE for regression & MA */
kde_series AS (
  SELECT
    a.*,
    CAST(ROW_NUMBER() OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE)
         AS DOUBLE PRECISION) AS month_num_dp
  FROM kde_change_agg a
),

/* -------- REG path (algebraic linear regression, no REGR_*) -------- */

/* Moments per KDE for y_exp and y_cnt */
kde_reg_moments AS (
  SELECT
    KDE_NAME,
    COUNT(*)                                                       AS n,
    SUM(month_num_dp)                                             AS sum_x,
    SUM(month_num_dp * month_num_dp)                              AS sum_x2,
    SUM(CAST(change_exposure AS DOUBLE PRECISION))                AS sum_y_exp,
    SUM(month_num_dp * CAST(change_exposure AS DOUBLE PRECISION)) AS sum_xy_exp,
    SUM(CAST(change_acct_cnt  AS DOUBLE PRECISION))               AS sum_y_cnt,
    SUM(month_num_dp * CAST(change_acct_cnt  AS DOUBLE PRECISION))AS sum_xy_cnt
  FROM kde_series
  GROUP BY KDE_NAME
),

/* Slope/intercept, predictions & residuals per row */
kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num_dp,
    s.change_exposure,
    s.change_acct_cnt,

    /* Solve slope/intercept for exposure */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_exp,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_exp
               - ((m.n * m.sum_xy_exp - m.sum_x * m.sum_y_exp)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_exp,

    /* Solve slope/intercept for count */
    CASE WHEN (m.n * m.sum_x2 - m.sum_x * m.sum_x) = 0 THEN NULL
         ELSE (m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
              / (m.n * m.sum_x2 - m.sum_x * m.sum_x) END AS slope_cnt,
    CASE WHEN m.n = 0 THEN NULL
         ELSE (m.sum_y_cnt
               - ((m.n * m.sum_xy_cnt - m.sum_x * m.sum_y_cnt)
                  / NULLIF((m.n * m.sum_x2 - m.sum_x * m.sum_x),0)) * m.sum_x) / m.n
    END AS intercept_cnt
  FROM kde_series s
  JOIN kde_reg_moments m
    ON s.KDE_NAME = m.KDE_NAME
),

/* Predictions & residuals */
kde_reg_fit2 AS (
  SELECT
    f.*,
    (f.intercept_exp + f.slope_exp * f.month_num_dp) AS pred_exp,
    (f.intercept_cnt + f.slope_cnt * f.month_num_dp) AS pred_cnt,
    (CAST(f.change_exposure AS DOUBLE PRECISION)
       - (f.intercept_exp + f.slope_exp * f.month_num_dp))        AS resid_exp,
    (CAST(f.change_acct_cnt  AS DOUBLE PRECISION)
       - (f.intercept_cnt + f.slope_cnt * f.month_num_dp))        AS resid_cnt
  FROM kde_reg_fit f
),

/* Std dev of regression residuals per KDE (for z-scores) */
kde_reg_stats AS (
  SELECT
    KDE_NAME,
    STDDEV(resid_exp) AS sd_resid_exp,
    STDDEV(resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit2
  GROUP BY KDE_NAME
),

/* Regression z-scores per month */
kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit2 f
  JOIN kde_reg_stats s
    ON f.KDE_NAME = s.KDE_NAME
),

/* -------------------- MA(12) path (exclude current) -------------------- */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    AVG(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_exp,
    STDDEV(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_exp,
    AVG(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_cnt,
    STDDEV(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_cnt
  FROM kde_series
),

kde_ma_z AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    ((change_exposure - ma_exp) / NULLIF(sd_exp, 0)) AS exp_ma_z,
    ((change_acct_cnt - ma_cnt) / NULLIF(sd_cnt, 0)) AS cnt_ma_z
  FROM kde_ma_roll
),

/* --------- Model selection by historical RMSE (exposure) --------- */
/* Compare REG vs MA on months strictly before latest */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals already computed in kde_reg_fit2 */
    SQRT(AVG(CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom
                   THEN (rf.resid_exp * rf.resid_exp) END))         AS rmse_reg_exp,
    /* MA residuals = change_exposure - ma_exp */
    SQRT(AVG(CASE WHEN mr.END_OF_MONTH_DATE < l.max_eom
                   THEN POWER((mr.change_exposure - mr.ma_exp), 2) END)) AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit2 rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_roll  mr ON mr.KDE_NAME = k.KDE_NAME
  GROUP BY l.max_eom, k.KDE_NAME
),

method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* Latest-month scores from both methods */
latest_scores AS (
  SELECT
    l.max_eom AS latest_month,
    k.KDE_NAME,
    rz.exp_reg_z, rz.cnt_reg_z,
    mz.exp_ma_z,  mz.cnt_ma_z
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_z rz
    ON rz.KDE_NAME = k.KDE_NAME AND rz.END_OF_MONTH_DATE = l.max_eom
  LEFT JOIN kde_ma_z mz
    ON mz.KDE_NAME = k.KDE_NAME AND mz.END_OF_MONTH_DATE = l.max_eom
),

/* Choose method & compute weighted severity */
chosen AS (
  SELECT
    s.latest_month,
    s.KDE_NAME,
    mc.chosen_method,
    /* pick exposure z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.exp_reg_z ELSE s.exp_ma_z END AS exp_z,
    /* pick count z */
    CASE WHEN mc.chosen_method = 'REG' THEN s.cnt_reg_z ELSE s.cnt_ma_z END AS cnt_z,
    /* keep both for transparency */
    s.exp_reg_z, s.cnt_reg_z, s.exp_ma_z, s.cnt_ma_z
  FROM latest_scores s
  JOIN method_choice mc
    ON mc.KDE_NAME = s.KDE_NAME
)

SELECT
  c.latest_month,
  c.KDE_NAME,
  c.chosen_method,
  ROUND(c.exp_z, 2)  AS exp_z_chosen,
  ROUND(c.cnt_z, 2)  AS cnt_z_chosen,
  ROUND(0.3 * ABS(c.cnt_z) + 0.7 * ABS(c.exp_z), 2) AS severity_score,
  /* transparency columns */
  ROUND(c.exp_reg_z, 2) AS exp_z_reg,
  ROUND(c.cnt_reg_z, 2) AS cnt_z_reg,
  ROUND(c.exp_ma_z, 2)  AS exp_z_ma,
  ROUND(c.cnt_ma_z, 2)  AS cnt_z_ma
FROM chosen c
WHERE (c.exp_z IS NOT NULL OR c.cnt_z IS NOT NULL)
ORDER BY severity_score DESC, ABS(exp_z_chosen) DESC, ABS(cnt_z_chosen) DESC;






/* === KDE Change Analysis with Dual Baselines (REG + MA) ======================
   - Input: same manual KDE list (UNPIVOT) you already have
   - Methods:
       REG: linear trend vs time (per KDE) using REGR_* functions
       MA : 12-month moving-average & stdev (excludes current month)
   - Model selection: per KDE, pick method with lower historical RMSE on exposure
                      using months strictly BEFORE the latest month
   - Latest output: chosen method's weighted severity + both methods' z-scores
   ============================================================================ */

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* === Base + UNPIVOT (same as yours; edit the KDE list as needed) =========== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS exposure,
    t.PD_GRADE, t.CRE_FLAG, t.DAYS_PAST_DUE, t.RC_CODE, t.REVOLVING_CODE,
    t.FDIC_CALL_CODE, t.GL_ACCOUNT_CODE, t.INDUSTRY_CODE, t.MATURITY_DATE,
    t.LTV, t.NAICS_CODE, t.RBC_CODE, t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
),
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'        AS KDE_NAME, CAST(PD_GRADE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG',        CAST(CRE_FLAG        AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE',   CAST(DAYS_PAST_DUE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE',         CAST(RC_CODE         AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE',  CAST(REVOLVING_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE',  CAST(FDIC_CALL_CODE  AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE', CAST(GL_ACCOUNT_CODE AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE',   CAST(INDUSTRY_CODE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE',   CAST(MATURITY_DATE   AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV',             CAST(LTV             AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE',      CAST(NAICS_CODE      AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE',        CAST(RBC_CODE        AS VARCHAR(255)), exposure FROM base
  UNION ALL SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)), exposure FROM base
),

/* === KDE value changes per account (vs prior month) ======================== */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER ORDER BY u.END_OF_MONTH_DATE) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* === Monthly agg per KDE: change volume & exposure ========================= */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               ) AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               ) AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* === Index months per KDE for regression & MA windows ====================== */
kde_series AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (PARTITION BY a.KDE_NAME ORDER BY a.END_OF_MONTH_DATE) AS month_num
  FROM kde_change_agg a
),

/* === REG: fit per-KDE linear trend on full history ========================= */
kde_regression AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(change_exposure, month_num)     AS slope_exp,
    REGR_INTERCEPT(change_exposure, month_num) AS intercept_exp,
    REGR_COUNT(change_exposure, month_num)     AS n_exp,
    REGR_SLOPE(change_acct_cnt, month_num)     AS slope_cnt,
    REGR_INTERCEPT(change_acct_cnt, month_num) AS intercept_cnt,
    REGR_COUNT(change_acct_cnt, month_num)     AS n_cnt
  FROM kde_series
  GROUP BY KDE_NAME
),

kde_reg_fit AS (
  SELECT
    s.KDE_NAME,
    s.END_OF_MONTH_DATE,
    s.month_num,
    s.change_exposure,
    s.change_acct_cnt,
    (r.intercept_exp + r.slope_exp * s.month_num) AS pred_exp,
    (r.intercept_cnt + r.slope_cnt * s.month_num) AS pred_cnt,
    (s.change_exposure - (r.intercept_exp + r.slope_exp * s.month_num)) AS resid_exp,
    (s.change_acct_cnt - (r.intercept_cnt + r.slope_cnt * s.month_num)) AS resid_cnt
  FROM kde_series s
  JOIN kde_regression r
    ON s.KDE_NAME = r.KDE_NAME
),

/* REG residual stddev per KDE (for z-scores) */
kde_reg_stats AS (
  SELECT
    KDE_NAME,
    STDDEV(resid_exp) AS sd_resid_exp,
    STDDEV(resid_cnt) AS sd_resid_cnt
  FROM kde_reg_fit
  GROUP BY KDE_NAME
),

kde_reg_z AS (
  SELECT
    f.KDE_NAME,
    f.END_OF_MONTH_DATE,
    (f.resid_exp / NULLIF(s.sd_resid_exp, 0)) AS exp_reg_z,
    (f.resid_cnt / NULLIF(s.sd_resid_cnt, 0)) AS cnt_reg_z
  FROM kde_reg_fit f
  JOIN kde_reg_stats s
    ON f.KDE_NAME = s.KDE_NAME
),

/* === MA(12): rolling baseline excluding current month ====================== */
kde_ma_roll AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    change_exposure,
    change_acct_cnt,
    /* baselines computed over the 12 months BEFORE current row */
    AVG(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_exp,
    STDDEV(change_exposure) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_exp,
    AVG(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS ma_cnt,
    STDDEV(change_acct_cnt) OVER (
      PARTITION BY KDE_NAME ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
    ) AS sd_cnt
  FROM kde_series
),

kde_ma_z AS (
  SELECT
    KDE_NAME,
    END_OF_MONTH_DATE,
    ((change_exposure - ma_exp) / NULLIF(sd_exp, 0)) AS exp_ma_z,
    ((change_acct_cnt - ma_cnt) / NULLIF(sd_cnt, 0)) AS cnt_ma_z
  FROM kde_ma_roll
),

/* === Model selection: which method fits exposure better historically? ====== */
/* Compute RMSE on exposure residuals for each method, using months BEFORE latest */
rmse_hist AS (
  SELECT
    l.max_eom,
    k.KDE_NAME,
    /* REG residuals = resid_exp from kde_reg_fit */
    SQRT(AVG( CASE WHEN rf.END_OF_MONTH_DATE < l.max_eom THEN (rf.resid_exp * rf.resid_exp) END )) AS rmse_reg_exp,
    /* MA residuals = change_exposure - ma_exp */
    SQRT(AVG( CASE WHEN mz.END_OF_MONTH_DATE < l.max_eom THEN POWER((mr.change_exposure - mr.ma_exp), 2) END )) AS rmse_ma_exp
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_fit rf ON rf.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_roll mr ON mr.KDE_NAME = k.KDE_NAME
  LEFT JOIN kde_ma_z    mz ON mz.KDE_NAME = k.KDE_NAME AND mz.END_OF_MONTH_DATE = mr.END_OF_MONTH_DATE
  GROUP BY l.max_eom, k.KDE_NAME
),

method_choice AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN rmse_ma_exp IS NULL AND rmse_reg_exp IS NOT NULL THEN 'REG'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NOT NULL THEN 'MA'
      WHEN rmse_reg_exp IS NULL AND rmse_ma_exp IS NULL THEN 'REG'  -- fallback
      WHEN rmse_reg_exp <= rmse_ma_exp THEN 'REG' ELSE 'MA'
    END AS chosen_method
  FROM rmse_hist
),

/* === Latest-month scores from both methods ================================= */
latest_scores AS (
  SELECT
    l.max_eom AS latest_month,
    k.KDE_NAME,
    /* REG z-scores */
    rz.exp_reg_z,
    rz.cnt_reg_z,
    /* MA z-scores */
    mz.exp_ma_z,
    mz.cnt_ma_z
  FROM latest l
  JOIN (SELECT DISTINCT KDE_NAME FROM kde_series) k ON 1=1
  LEFT JOIN kde_reg_z rz
    ON rz.KDE_NAME = k.KDE_NAME AND rz.END_OF_MONTH_DATE = l.max_eom
  LEFT JOIN kde_ma_z mz
    ON mz.KDE_NAME = k.KDE_NAME AND mz.END_OF_MONTH_DATE = l.max_eom
),

/* === Final: pick per-KDE method & compute weighted severity ================= */
chosen AS (
  SELECT
    s.latest_month,
    s.KDE_NAME,
    mc.chosen_method,

    /* choose exposure z by method */
    CASE WHEN mc.chosen_method = 'REG' THEN s.exp_reg_z ELSE s.exp_ma_z END AS exp_z,
    /* choose count z by method */
    CASE WHEN mc.chosen_method = 'REG' THEN s.cnt_reg_z ELSE s.cnt_ma_z END AS cnt_z,

    /* keep both methods for transparency */
    s.exp_reg_z, s.cnt_reg_z, s.exp_ma_z, s.cnt_ma_z
  FROM latest_scores s
  JOIN method_choice mc
    ON mc.KDE_NAME = s.KDE_NAME
)

SELECT
  c.latest_month,
  c.KDE_NAME,
  c.chosen_method,
  ROUND(c.exp_z, 2)                         AS exp_z_chosen,
  ROUND(c.cnt_z, 2)                         AS cnt_z_chosen,
  /* weighted severity on chosen method */
  ROUND( (0.3 * ABS(c.cnt_z) + 0.7 * ABS(c.exp_z)), 2 ) AS severity_score,

  /* transparency fields (optional) */
  ROUND(c.exp_reg_z, 2)                     AS exp_z_reg,
  ROUND(c.cnt_reg_z, 2)                     AS cnt_z_reg,
  ROUND(c.exp_ma_z, 2)                      AS exp_z_ma,
  ROUND(c.cnt_ma_z, 2)                      AS cnt_z_ma
FROM chosen c
/* optional: suppress KDEs with no score (insufficient history) */
WHERE (c.exp_z IS NOT NULL OR c.cnt_z IS NOT NULL)
ORDER BY severity_score DESC, ABS(exp_z_chosen) DESC, ABS(cnt_z_chosen) DESC;






-- Set the month you care about (any date within the month works)
DECLARE @AsOfDate date = '2025-09-30';
DECLARE @CurrEOM  date = EOMONTH(@AsOfDate);
DECLARE @PrevEOM  date = EOMONTH(DATEADD(month, -1, @AsOfDate));

WITH base AS (
    SELECT
        i.LOADDT                           AS MonthEnd,
        i.ACCTNBR,
        i.CIF,
        i.CUST_LINE_NBR,
        i.CLIENT_NM,
        i.NON_ACCR_INT_AMT,
        i.PRNCPL_GROSS_BAL_AMT,
        i.NOTEPRNCPLBALNET,
        i.DERIVED_AMORTIZED_COST_BASIS,
        i.AMORTIZED_COST_BASIS,
        a.TransactionType,
        a.Amount                           AS CO_AMOUNT
    FROM CRDADMPRD.DBO.CDM_INSTRUMENTS_TOPSIDED i
    LEFT JOIN CRDADMPRD.DBO.ALLLActivity_Base a
        ON i.LOADDT = a.CHARGEOFFQTR          -- If CHARGEOFFQTR is text, use TRY_CONVERT(date, a.CHARGEOFFQTR)
       AND i.ACCTNBR = a.DW_NoteNumber
       AND a.TransactionType = 'CHARGE-OFF'   -- keep in JOIN to preserve LEFT JOIN
    WHERE i.LOADDT IN (@CurrEOM, @PrevEOM)
      AND i.CHARGE_OFF_CODE = 'C'
),
-- Top 10 *accounts* in the current month by CO_AMOUNT
top10_curr AS (
    SELECT TOP (10)
        b.ACCTNBR
    FROM base b
    WHERE b.MonthEnd = @CurrEOM
    GROUP BY b.ACCTNBR
    ORDER BY MAX(b.CO_AMOUNT) DESC
),
-- Keep rows for the top-10 accounts for BOTH months
filtered AS (
    SELECT b.*
    FROM base b
    WHERE b.ACCTNBR IN (SELECT ACCTNBR FROM top10_curr)
)
SELECT
    CASE WHEN f.MonthEnd = @CurrEOM THEN 'Current' ELSE 'Previous' END AS Period,
    f.MonthEnd,
    f.ACCTNBR,
    f.CIF,
    f.CUST_LINE_NBR,
    f.CLIENT_NM,
    f.NON_ACCR_INT_AMT,
    f.PRNCPL_GROSS_BAL_AMT,
    f.NOTEPRNCPLBALNET,
    f.DERIVED_AMORTIZED_COST_BASIS,
    f.AMORTIZED_COST_BASIS,
    f.TransactionType,
    f.CO_AMOUNT
FROM filtered f
ORDER BY
    f.ACCTNBR,
    f.MonthEnd DESC,        -- current first, then previous
    f.CO_AMOUNT DESC;       -- helpful when inspecting within a month





WITH base as (
	SELECT i.LOADDT AS MonthEnd, i.ACCTNBR, i.CIF, i.CUST_LINE_NBR, i.CLIENT_NM, i.NON_ACCR_INT_AMT, i.PRNCPL_GROSS_BAL_AMT, i.NOTEPRNCPLBALNET, i.DERIVED_AMORTIZED_COST_BASIS, i.AMORTIZED_COST_BASIS, a.TransactionType, a.Amount AS CO_AMOUNT
	FROM CRDADMPRD.DBO.CDM_INSTRUMENTS_TOPSIDED i
	LEFT JOIN CRDADMPRD.DBO.ALLLActivity_Base a
	ON i.LOADDT = a.CHARGEOFFQTR and i.ACCTNBR = a.DW_NoteNumber
	WHERE i.LOADDT = '9/31/2025'
		AND i.CHARGE_OFF_CODE = 'C'
		AND a.TransactionType = 'CHARGE-OFF'
)
SELECT TOP 10 *
FROM base






/* === KDE Change Analysis (portfolio-level; user-specified KDE list) ===
   - Change volume = # accounts whose KDE value changed vs previous month
   - Change exposure = sum of current-month exposure for those changed accounts
   - Severity = 0.3*|acct_change_z| + 0.7*|exp_change_z|
   - History window: 24 months
   - Platform: Netezza-friendly (no IS DISTINCT FROM)
   ===================================================================== */

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice with all KDE columns you plan to analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS exposure,
    /* <<< list your KDE columns here so they are available below >>> */
    t.PD_GRADE,
    t.CRE_FLAG,
    t.DAYS_PAST_DUE,
    t.RC_CODE,
    t.REVOLVING_CODE,
    t.FDIC_CALL_CODE,
    t.GL_ACCOUNT_CODE,
    t.INDUSTRY_CODE,
    t.MATURITY_DATE,
    t.LTV,
    t.NAICS_CODE,
    t.RBC_CODE,
    t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to include/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'       AS KDE_NAME, CAST(PD_GRADE       AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG'        AS KDE_NAME, CAST(CRE_FLAG        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE'   AS KDE_NAME, CAST(DAYS_PAST_DUE   AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE'         AS KDE_NAME, CAST(RC_CODE         AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE'  AS KDE_NAME, CAST(REVOLVING_CODE  AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE'  AS KDE_NAME, CAST(FDIC_CALL_CODE  AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE' AS KDE_NAME, CAST(GL_ACCOUNT_CODE AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE'   AS KDE_NAME, CAST(INDUSTRY_CODE   AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE'   AS KDE_NAME, CAST(MATURITY_DATE   AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV'             AS KDE_NAME, CAST(LTV             AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE'      AS KDE_NAME, CAST(NAICS_CODE      AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE'        AS KDE_NAME, CAST(RBC_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG' AS KDE_NAME, CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
),

/* Get previous month's KDE value per account × KDE_NAME */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Aggregate: count changed accounts and sum exposure for changed accounts */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Historical stats for monthly change by KDE_NAME */
kde_change_stats AS (
  SELECT
    KDE_NAME,
    AVG(COALESCE(change_acct_cnt,0))    AS avg_cnt,
    STDDEV(COALESCE(change_acct_cnt,0)) AS std_cnt,
    AVG(COALESCE(change_exposure,0))    AS avg_exp,
    STDDEV(COALESCE(change_exposure,0)) AS std_exp,
    COUNT(*)                            AS hist_rows
  FROM kde_change_agg
  GROUP BY KDE_NAME
),

/* Join stats; compute z-scores and fixed severity */
kde_flag AS (
  SELECT
    a.END_OF_MONTH_DATE,
    a.KDE_NAME,
    a.change_acct_cnt,
    a.change_exposure,
    (a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0) AS acct_change_z,
    (a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0) AS exp_change_z,
    0.3 * ABS((a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0))
  + 0.7 * ABS((a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0)) AS severity_score,
    s.hist_rows
  FROM kde_change_agg a
  JOIN kde_change_stats s
    ON a.KDE_NAME = s.KDE_NAME
)

SELECT
  l.max_eom                               AS latest_month,   -- <<< added reference column
  f.KDE_NAME,
  f.change_acct_cnt,
  f.change_exposure,
  ROUND(f.acct_change_z, 2)               AS acct_change_z,
  ROUND(f.exp_change_z, 2)                AS exp_change_z,
  ROUND(f.severity_score, 2)              AS severity_score
FROM kde_flag f
JOIN latest l
  ON f.END_OF_MONTH_DATE = l.max_eom
WHERE f.severity_score IS NOT NULL
  AND f.hist_rows >= 6
ORDER BY f.severity_score DESC, ABS(f.exp_change_z) DESC, ABS(f.acct_change_z) DESC;





/* === KDE Change Analysis (portfolio-level; user-specified KDE list) ===
   - Change volume = # accounts whose KDE value changed vs previous month
   - Change exposure = sum of current-month exposure for those changed accounts
   - Severity = 0.3*|acct_change_z| + 0.7*|exp_change_z|
   - History window: 24 months
   - Platform: Netezza-friendly (no IS DISTINCT FROM)
   ===================================================================== */

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice with all KDE columns you plan to analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS exposure,
    /* <<< list your KDE columns here so they are available below >>> */
    t.PD_GRADE,
    t.CRE_FLAG,
    t.DAYS_PAST_DUE,
    t.RC_CODE,
    t.REVOLVING_CODE,
    t.FDIC_CALL_CODE,
    t.GL_ACCOUNT_CODE,
    t.INDUSTRY_CODE,
    t.MATURITY_DATE,
    t.LTV,
    t.NAICS_CODE,
    t.RBC_CODE,
    t.NON_ACCRUAL_FLAG
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to include/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'      AS KDE_NAME, CAST(PD_GRADE      AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG'       AS KDE_NAME, CAST(CRE_FLAG       AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE'  AS KDE_NAME, CAST(DAYS_PAST_DUE  AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE'        AS KDE_NAME, CAST(RC_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'REVOLVING_CODE'        AS KDE_NAME, CAST(REVOLVING_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'FDIC_CALL_CODE'        AS KDE_NAME, CAST(FDIC_CALL_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'GL_ACCOUNT_CODE'        AS KDE_NAME, CAST(GL_ACCOUNT_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'INDUSTRY_CODE'        AS KDE_NAME, CAST(INDUSTRY_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'MATURITY_DATE'        AS KDE_NAME, CAST(MATURITY_DATE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'LTV'        AS KDE_NAME, CAST(LTV        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base 
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NAICS_CODE'        AS KDE_NAME, CAST(NAICS_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base 
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RBC_CODE'        AS KDE_NAME, CAST(RBC_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base 
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG'        AS KDE_NAME, CAST(NON_ACCRUAL_FLAG        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base 
),

/* Get previous month's KDE value per account × KDE_NAME */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Aggregate: count changed accounts and sum exposure for changed accounts */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Historical stats for monthly change by KDE_NAME */
kde_change_stats AS (
  SELECT
    KDE_NAME,
    AVG(COALESCE(change_acct_cnt,0))    AS avg_cnt,
    STDDEV(COALESCE(change_acct_cnt,0)) AS std_cnt,
    AVG(COALESCE(change_exposure,0))    AS avg_exp,
    STDDEV(COALESCE(change_exposure,0)) AS std_exp,
    COUNT(*)                            AS hist_rows
  FROM kde_change_agg
  GROUP BY KDE_NAME
),

/* Join stats; compute z-scores and fixed severity */
kde_flag AS (
  SELECT
    a.END_OF_MONTH_DATE,
    a.KDE_NAME,
    a.change_acct_cnt,
    a.change_exposure,
    (a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0) AS acct_change_z,
    (a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0) AS exp_change_z,
    0.3 * ABS((a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0))
  + 0.7 * ABS((a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0)) AS severity_score,
    s.hist_rows
  FROM kde_change_agg a
  JOIN kde_change_stats s
    ON a.KDE_NAME = s.KDE_NAME
)

SELECT
  f.KDE_NAME,
  f.change_acct_cnt,
  f.change_exposure,
  ROUND(f.acct_change_z, 2) AS acct_change_z,
  ROUND(f.exp_change_z, 2)  AS exp_change_z,
  ROUND(f.severity_score, 2) AS severity_score
FROM kde_flag f
JOIN latest l
  ON f.END_OF_MONTH_DATE = l.max_eom
WHERE f.severity_score IS NOT NULL
  AND f.hist_rows >= 6
ORDER BY f.severity_score DESC, ABS(f.exp_change_z) DESC, ABS(f.acct_change_z) DESC;







/* === KDE Change Analysis (portfolio-level; user-specified KDE list) ===
   - Change volume = # accounts whose KDE value changed vs previous month
   - Change exposure = sum of current-month exposure for those changed accounts
   - Severity = 0.3*|acct_change_z| + 0.7*|exp_change_z|
   - History window: 24 months
   - Platform: Netezza-friendly (no IS DISTINCT FROM)
   ===================================================================== */

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* Base slice with all KDE columns you plan to analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS exposure,
    /* <<< list your KDE columns here so they are available below >>> */
    t.PD_GRADE,
    t.CRE_FLAG,
    t.DAYS_PAST_DUE,
    t.RC_CODE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* Manual UNPIVOT: edit this block to include/remove KDE columns */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'      AS KDE_NAME, CAST(PD_GRADE      AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG'       AS KDE_NAME, CAST(CRE_FLAG       AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE'  AS KDE_NAME, CAST(DAYS_PAST_DUE  AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE'        AS KDE_NAME, CAST(RC_CODE        AS VARCHAR(255)) AS KDE_VALUE, exposure FROM base
),

/* Get previous month's KDE value per account × KDE_NAME */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* Aggregate: count changed accounts and sum exposure for changed accounts */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN 1 ELSE 0
        END) AS change_acct_cnt,
    SUM(CASE
          WHEN (
                 (KDE_VALUE <> prev_value)
                 OR (KDE_VALUE IS NULL AND prev_value IS NOT NULL)
                 OR (KDE_VALUE IS NOT NULL AND prev_value IS NULL)
               )
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END) AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* Historical stats for monthly change by KDE_NAME */
kde_change_stats AS (
  SELECT
    KDE_NAME,
    AVG(COALESCE(change_acct_cnt,0))    AS avg_cnt,
    STDDEV(COALESCE(change_acct_cnt,0)) AS std_cnt,
    AVG(COALESCE(change_exposure,0))    AS avg_exp,
    STDDEV(COALESCE(change_exposure,0)) AS std_exp,
    COUNT(*)                            AS hist_rows
  FROM kde_change_agg
  GROUP BY KDE_NAME
),

/* Join stats; compute z-scores and fixed severity */
kde_flag AS (
  SELECT
    a.END_OF_MONTH_DATE,
    a.KDE_NAME,
    a.change_acct_cnt,
    a.change_exposure,
    (a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0) AS acct_change_z,
    (a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0) AS exp_change_z,
    0.3 * ABS((a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0))
  + 0.7 * ABS((a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0)) AS severity_score,
    s.hist_rows
  FROM kde_change_agg a
  JOIN kde_change_stats s
    ON a.KDE_NAME = s.KDE_NAME
)

SELECT
  f.KDE_NAME,
  f.change_acct_cnt,
  f.change_exposure,
  ROUND(f.acct_change_z, 2) AS acct_change_z,
  ROUND(f.exp_change_z, 2)  AS exp_change_z,
  ROUND(f.severity_score, 2) AS severity_score
FROM kde_flag f
JOIN latest l
  ON f.END_OF_MONTH_DATE = l.max_eom
WHERE f.severity_score IS NOT NULL
  AND f.hist_rows >= 6
ORDER BY f.severity_score DESC, ABS(f.exp_change_z) DESC, ABS(f.acct_change_z) DESC;





/* === KDE Change Analysis (portfolio-level; user-specified KDE list) =========
   Purpose:
     - For each KDE (column), count how many accounts changed value vs last month
       and sum the exposure of those changing accounts.
     - Compare the latest month’s change vs historical (z-scores) and rank.

   How to use:
     1) Edit the UNION ALL block in `unpivot_kdes` to list your KDE columns.
     2) (Optional) Un-comment portfolio filters (e.g., Total Loans).

   Severity weighting (fixed): 0.3 * |acct_change_z| + 0.7 * |exp_change_z|
   History window: 24 months
   =========================================================================== */

WITH
/* 1) Latest month and historical window */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* 2) Base slice at account granularity with the KDE columns you’ll analyze */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS exposure,
    /* === Include ALL KDE columns you plan to analyze here so they’re available
           later in the UNION ALL block. Examples shown; replace with your fields. === */
    t.PD_GRADE,
    t.CRE_FLAG,
    t.DAYS_PAST_DUE,
    t.RC_CODE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional portfolio scope:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
),

/* 3) UNPIVOT (manually) the chosen KDE columns into (KDE_NAME, KDE_VALUE) rows.
      >>> EDIT THIS BLOCK ONLY: add/remove SELECTs for the KDE columns you want. */
unpivot_kdes AS (
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'PD_GRADE'    AS KDE_NAME, CAST(PD_GRADE    AS VARCHAR(200)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'CRE_FLAG'     AS KDE_NAME, CAST(CRE_FLAG     AS VARCHAR(200)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE'AS KDE_NAME, CAST(DAYS_PAST_DUE AS VARCHAR(200)) AS KDE_VALUE, exposure FROM base
  UNION ALL
  SELECT END_OF_MONTH_DATE, ACCOUNT_IDENTIFIER, 'RC_CODE'      AS KDE_NAME, CAST(RC_CODE      AS VARCHAR(200)) AS KDE_VALUE, exposure FROM base
),

/* 4) For each account × KDE_NAME, detect if KDE_VALUE changed vs previous month */
kde_change AS (
  SELECT
    u.END_OF_MONTH_DATE,
    u.KDE_NAME,
    u.ACCOUNT_IDENTIFIER,
    u.KDE_VALUE,
    LAG(u.KDE_VALUE) OVER (
      PARTITION BY u.KDE_NAME, u.ACCOUNT_IDENTIFIER
      ORDER BY u.END_OF_MONTH_DATE
    ) AS prev_value,
    u.exposure
  FROM unpivot_kdes u
),

/* 5) Flag “changed this month” (treat NULL↔non-NULL as a change) and aggregate */
kde_change_agg AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE_NAME,
    /* change volume = # of accounts with a KDE value change vs prev month */
    SUM(CASE
          WHEN (KDE_VALUE IS DISTINCT FROM prev_value)  -- handles NULL vs non-NULL
               AND prev_value IS NOT NULL               -- require a prior month to compare
          THEN 1 ELSE 0
        END)                                           AS change_acct_cnt,
    /* change exposure = sum of current-month exposure for changed accounts */
    SUM(CASE
          WHEN (KDE_VALUE IS DISTINCT FROM prev_value)
               AND prev_value IS NOT NULL
          THEN exposure ELSE 0
        END)                                           AS change_exposure
  FROM kde_change
  GROUP BY END_OF_MONTH_DATE, KDE_NAME
),

/* 6) Historical stats of monthly change by KDE_NAME (for z-scores) */
kde_change_stats AS (
  SELECT
    KDE_NAME,
    AVG(COALESCE(change_acct_cnt,0))    AS avg_cnt,
    STDDEV(COALESCE(change_acct_cnt,0)) AS std_cnt,
    AVG(COALESCE(change_exposure,0))    AS avg_exp,
    STDDEV(COALESCE(change_exposure,0)) AS std_exp,
    COUNT(*)                            AS hist_rows
  FROM kde_change_agg
  GROUP BY KDE_NAME
),

/* 7) Join stats; compute z-scores and severity */
kde_flag AS (
  SELECT
    a.END_OF_MONTH_DATE,
    a.KDE_NAME,
    a.change_acct_cnt,
    a.change_exposure,
    (a.change_acct_cnt   - s.avg_cnt) / NULLIF(s.std_cnt, 0) AS acct_change_z,
    (a.change_exposure   - s.avg_exp) / NULLIF(s.std_exp, 0) AS exp_change_z,
    /* fixed severity weighting: emphasize exposure */
    0.3 * ABS((a.change_acct_cnt - s.avg_cnt) / NULLIF(s.std_cnt, 0))
  + 0.7 * ABS((a.change_exposure - s.avg_exp) / NULLIF(s.std_exp, 0)) AS severity_score,
    s.hist_rows
  FROM kde_change_agg a
  JOIN kde_change_stats s
    ON a.KDE_NAME = s.KDE_NAME
)

/* 8) Latest-month portfolio-level summary across all chosen KDEs */
SELECT
  f.KDE_NAME,
  f.change_acct_cnt,
  f.change_exposure,
  ROUND(f.acct_change_z, 2) AS acct_change_z,
  ROUND(f.exp_change_z, 2)  AS exp_change_z,
  ROUND(f.severity_score, 2) AS severity_score
FROM kde_flag f
JOIN latest l
  ON f.END_OF_MONTH_DATE = l.max_eom
WHERE f.severity_score IS NOT NULL          -- suppress KDEs with no variance/history
  AND f.hist_rows >= 6                      -- require at least ~6 months of deltas
ORDER BY f.severity_score DESC, ABS(f.exp_change_z) DESC, ABS(f.acct_change_z) DESC;






/* === KDE Portfolio Summary (Latest Month) ===========================
   - Focus: change volume (acct count) & change exposure (dollars)
   - History window: 24 months
   - Severity score (fixed weights): 0.3*|acct_z| + 0.7*|exp_z|
   - Platform: Netezza-friendly SQL (works in many warehouses)
   ================================================================== */

WITH
/* 1) Latest month and historical window */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -24) AS start_eom, max_eom
  FROM latest
),

/* 2) KDE × month aggregation (pre-aggregate to keep it fast) */
kde_base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.KDE,
    COUNT(DISTINCT t.ACCOUNT_IDENTIFIER)        AS acct_cnt,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS exposure
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    /* Optional portfolio filter:
       AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' */
  GROUP BY 1,2
),

/* 3) Month-over-month deltas per KDE */
kde_delta AS (
  SELECT
    k.*,
    (k.acct_cnt - LAG(k.acct_cnt) OVER (PARTITION BY k.KDE ORDER BY k.END_OF_MONTH_DATE))  AS acct_cnt_delta,
    (k.exposure - LAG(k.exposure) OVER (PARTITION BY k.KDE ORDER BY k.END_OF_MONTH_DATE))  AS exposure_delta
  FROM kde_base k
),

/* 4) Historical benchmarks of deltas by KDE */
kde_stats AS (
  SELECT
    d.KDE,
    AVG(COALESCE(d.acct_cnt_delta,0))                 AS avg_acct_change,
    STDDEV(COALESCE(d.acct_cnt_delta,0))              AS std_acct_change,
    AVG(COALESCE(d.exposure_delta,0))                 AS avg_exp_change,
    STDDEV(COALESCE(d.exposure_delta,0))              AS std_exp_change,
    COUNT(*)                                          AS hist_rows
  FROM kde_delta d
  GROUP BY d.KDE
),

/* 5) Join stats; compute Z-scores + fixed-weight severity */
kde_flag AS (
  SELECT
    d.END_OF_MONTH_DATE,
    d.KDE,
    d.acct_cnt_delta,
    d.exposure_delta,

    /* Z-scores vs each KDE's own history (NULL if std=0 or not enough history) */
    (d.acct_cnt_delta - s.avg_acct_change) / NULLIF(s.std_acct_change, 0)  AS acct_change_z,
    (d.exposure_delta - s.avg_exp_change) / NULLIF(s.std_exp_change, 0)    AS exp_change_z,

    /* Fixed-weight severity (emphasize exposure) */
    0.3 * ABS((d.acct_cnt_delta - s.avg_acct_change) / NULLIF(s.std_acct_change, 0))
  + 0.7 * ABS((d.exposure_delta - s.avg_exp_change) / NULLIF(s.std_exp_change, 0)) AS severity_score,

    /* Optional: guardrails to suppress low-history KDEs in the final select */
    s.hist_rows
  FROM kde_delta d
  JOIN kde_stats s
    ON d.KDE = s.KDE
)

SELECT
  f.KDE,
  f.acct_cnt_delta,
  f.exposure_delta,
  ROUND(f.acct_change_z, 2) AS acct_change_z,
  ROUND(f.exp_change_z, 2)  AS exp_change_z,
  ROUND(f.severity_score, 2) AS severity_score
FROM kde_flag f
JOIN latest l
  ON f.END_OF_MONTH_DATE = l.max_eom
/* Optional: only show KDEs with a minimum history size (e.g., >= 6 months of deltas) */
/* WHERE f.hist_rows >= 6 */
ORDER BY f.severity_score DESC, ABS(f.exp_change_z) DESC, ABS(f.acct_change_z) DESC;




/* 10c) Seasonal lifts per RC×Quarter using NON-spike months (revised) */
seasonal_q AS (
  SELECT
    RC_CODE,
    qnum,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT
    RC_CODE,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE,
    q.qnum,
    /* raw lift */
    CASE
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
      ELSE q.avg_q_nospike / a.avg_all_nospike
    END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q   q
  LEFT JOIN seasonal_all a
    ON a.RC_CODE = q.RC_CODE
),

/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes (unchanged) */
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    /* cap to [0.85, 1.15] */
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    /* history-based shrink 0..1 (min points to fully trust ≈ 8) */
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    /* extra damp if recent spikes: halve the effect */
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
)





WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n12,
    SUM(t)::FLOAT8           AS sumx12,
    SUM(bal_num)::FLOAT8     AS sumy12,
    SUM(t*bal_num)::FLOAT8   AS sumxy12,
    SUM(t*t)::FLOAT8         AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n36,
    SUM(t)::FLOAT8           AS sumx36,
    SUM(bal_num)::FLOAT8     AS sumy36,
    SUM(t*bal_num)::FLOAT8   AS sumxy36,
    SUM(t*t)::FLOAT8         AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (arithmetic only) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Best model pick (no aggregates) */
best_model AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model
  FROM metrics m
),

/* 10) --- Robust seasonality: compute spike-aware quarterly lifts --- */

/* 10a) Build MoM (on full series) and spike flags per RC */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT
    RC_CODE,
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  /* spike = big percentage change OR big absolute jump relative to typical */
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
/* 10b) recent spike signal (last 6 months relative to series max month) */
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),

/* 10c) Seasonal lifts per RC×Quarter using NON-spike months */
seasonal_avgs AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    AVG(CASE WHEN f.is_spike = 0 THEN f.bal_num END)::FLOAT8 AS avg_q_nospike,
    AVG(CASE WHEN f.is_spike = 0 THEN f.bal_num END) OVER (PARTITION BY f.RC_CODE)::FLOAT8 AS avg_all_nospike,
    COUNT(CASE WHEN f.is_spike = 0 THEN 1 END) AS n_q
  FROM mom_flag f
  GROUP BY f.RC_CODE, f.qnum
),
seasonal_lifts AS (
  SELECT
    a.RC_CODE,
    a.qnum,
    /* raw lift */
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE a.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    a.n_q
  FROM seasonal_avgs a
),
/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes */
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    /* cap to [0.85, 1.15] */
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    /* history-based shrink 0..1 (min points to fully trust ≈ 8) */
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    /* additional damp if recent spikes: halve the effect */
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts by model (limit rows to each model's window) */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift to forecast */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Add prev_bal & "active last 3 months" flag */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Portfolio-wide scales for severity */
port_scales AS (
  SELECT
    MAX(abs_resid) AS max_abs_resid,
    MAX(mom_abs)   AS max_mom_abs
  FROM union_with_z
),

/* 17) Best model decided earlier; join and return FULL history inside chosen window */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    z.resid              AS Resid,
    z.abs_resid          AS AbsResid,
    z.mom_abs            AS MoM_Abs,
    z.mom_pct_abs        AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos
  FROM union_with_z z
  JOIN best_model bm
    ON bm.RC_CODE = z.RC_CODE
  WHERE z.model = bm.Best_Model
)

SELECT
  f.*,
  /* Severity emphasizing AbsResid and Z_Resid */
  (
    0.45 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )
  + 0.45 * ABS(f.Z_Resid)
  + 0.07 * ABS(f.Z_MoM_Abs)
  + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )
  )::FLOAT8 AS Severity_Raw,

  ROUND(
    100.0 * (1.0 - EXP(
      -(
        0.45 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )
      + 0.45 * ABS(f.Z_Resid)
      + 0.07 * ABS(f.Z_MoM_Abs)
      + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )
      )
    )),
    0
  )::INTEGER AS Severity_0_100
FROM final f
CROSS JOIN port_scales ps
ORDER BY f.RC_CODE, f.month_end;





WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal for MoM later */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped, no windows) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n12,
    SUM(t)::FLOAT8           AS sumx12,
    SUM(bal_num)::FLOAT8     AS sumy12,
    SUM(t*bal_num)::FLOAT8   AS sumxy12,
    SUM(t*t)::FLOAT8         AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n36,
    SUM(t)::FLOAT8           AS sumx36,
    SUM(bal_num)::FLOAT8     AS sumy36,
    SUM(t*bal_num)::FLOAT8   AS sumxy36,
    SUM(t*t)::FLOAT8         AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (no aggregates here; just arithmetic) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Best model pick */
best_pick AS (
  SELECT
    m.RC_CODE,
    CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END AS reg12_elig_rmse,
    CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END AS reg36_elig_rmse,
    m.rmse_ma6, m.rmse_ma12
  FROM metrics m
),
best_model AS (
  SELECT
    b.RC_CODE,
    CASE
      WHEN (CASE WHEN b.reg12_elig_rmse <= b.reg36_elig_rmse THEN b.reg12_elig_rmse ELSE b.reg36_elig_rmse END)
           <
           (CASE
              WHEN b.rmse_ma6  IS NULL THEN b.rmse_ma12
              WHEN b.rmse_ma12 IS NULL THEN b.rmse_ma6
              WHEN b.rmse_ma6 <= b.rmse_ma12 THEN b.rmse_ma6 ELSE b.rmse_ma12
            END)
      THEN CASE WHEN b.reg12_elig_rmse <= b.reg36_elig_rmse THEN 'REG12' ELSE 'REG36' END
      ELSE
           CASE
             WHEN b.rmse_ma6  IS NULL THEN 'MA12'
             WHEN b.rmse_ma12 IS NULL THEN 'MA6'
             WHEN b.rmse_ma6 <= b.rmse_ma12 THEN 'MA6' ELSE 'MA12'
           END
    END AS Best_Model
  FROM best_pick b
),

/* 10) Union all per-row forecasts by model */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 11) Add prev, include-3 flag */
union_with_prev AS (
  SELECT
    u.RC_CODE,
    u.month_end,
    u.RC_DESCRIPTION,
    u.bal_num,
    u.model,
    u.forecast,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_union u
  JOIN idx_tm t
    ON t.RC_CODE = u.RC_CODE AND t.month_end = u.month_end
),

/* 12) Residuals, MoM, per (RC,Model) stats */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 13) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 14) Portfolio-wide scales for dollar emphasis */
port_scales AS (
  SELECT
    MAX(abs_resid) AS max_abs_resid,
    MAX(mom_abs)   AS max_mom_abs
  FROM union_with_z
),

/* 15) Latest month per RC for snapshot */
latest AS (
  SELECT RC_CODE, MAX(month_end) AS latest_me
  FROM idx_tm
  GROUP BY RC_CODE
)

/* === Final snapshot: one row per RC_CODE (latest month), with severity === */
SELECT
  z.RC_CODE,
  z.RC_DESCRIPTION,
  z.month_end                        AS month_end_latest,
  bm.Best_Model,
  z.forecast                         AS Forecast_Selected,
  z.bal_num                          AS Actual_Latest,
  (z.bal_num - z.forecast)::FLOAT8   AS Resid_Latest,
  z.abs_resid                        AS AbsResid,
  z.mom_abs                          AS MoM_Abs,
  z.mom_pct_abs                      AS MoM_Pct_Abs,
  z.Z_Resid,
  z.Z_MoM_Abs,
  z.Z_MoM_Pct,
  CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,

  /* ---- Severity (emphasize AbsResid and Z_Resid) ----
     RawScore = 0.45*(AbsResid scaled by portfolio max) +
                0.45*|Z_Resid| +
                0.07*|Z_MoM_Abs| +
                0.03*(MoM_Abs scaled)
     Then map to 0–100 via 100*(1 - exp(-RawScore)) for a nice saturation.
  */
  (
    0.45 * ( z.abs_resid / NULLIF(ps.max_abs_resid,0) )
  + 0.45 * ABS(z.Z_Resid)
  + 0.07 * ABS(z.Z_MoM_Abs)
  + 0.03 * ( z.mom_abs / NULLIF(ps.max_mom_abs,0) )
  )::FLOAT8 AS Severity_Raw,

  ROUND(
    100.0 * (1.0 - EXP(
      -(
        0.45 * ( z.abs_resid / NULLIF(ps.max_abs_resid,0) )
      + 0.45 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.mom_abs / NULLIF(ps.max_mom_abs,0) )
      )
    )),
    0
  )::INTEGER AS Severity_0_100

FROM union_with_z z
JOIN best_model bm
  ON bm.RC_CODE = z.RC_CODE AND bm.Best_Model = z.model
JOIN latest l
  ON l.RC_CODE = z.RC_CODE AND z.month_end = l.latest_me
CROSS JOIN port_scales ps
ORDER BY z.RC_CODE;





WITH
-- 0) Base
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

-- 1) Index t (window ok)
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),

-- 2) Compute tmax from t (NO window nesting)
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax
  FROM idx i
),

-- 3) Evaluation windows
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* ------------ Regression params (grouped; no windows here) ------------ */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                      AS n12,
    SUM(t)::FLOAT8                AS sumx12,
    SUM(bal_num)::FLOAT8          AS sumy12,
    SUM(t*bal_num)::FLOAT8        AS sumxy12,
    SUM(t*t)::FLOAT8              AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                      AS n36,
    SUM(t)::FLOAT8                AS sumx36,
    SUM(bal_num)::FLOAT8          AS sumy36,
    SUM(t*bal_num)::FLOAT8        AS sumxy36,
    SUM(t*t)::FLOAT8              AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* ------------ Regression fits (evaluate only within their windows) ------------ */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        /* slope12 * t + intercept12 */
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* ------------ Moving averages (window AVG is fine), then restrict to windows ------------ */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.bal_num, i.t, i.tmax,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* ------------ Means and SST per window (grouped, no windows) ------------ */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* ------------ SSE and counts per model/window (grouped, no windows) ------------ */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* ------------ Metrics (pure arithmetic; no aggregates) ------------ */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
)

--  Final selection (no aggregates here)
SELECT
  m.RC_CODE,
  m.r2_reg12,  m.rmse_reg12,
  m.r2_reg36,  m.rmse_reg36,
  m.r2_ma6,    m.rmse_ma6,
  m.r2_ma12,   m.rmse_ma12,

  CASE
    WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5
         AND (m.rmse_reg12 IS NOT NULL)
         AND ( (m.r2_reg36 IS NULL OR m.r2_reg36 < 0.5 OR m.rmse_reg12 <= m.rmse_reg36)
           AND (m.rmse_ma6   IS NULL OR m.rmse_reg12 <= m.rmse_ma6)
           AND (m.rmse_ma12  IS NULL OR m.rmse_reg12 <= m.rmse_ma12) )
      THEN 'REG12'

    WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5
         AND (m.rmse_reg36 IS NOT NULL)
         AND ( (m.r2_reg12 IS NULL OR m.r2_reg12 < 0.5 OR m.rmse_reg36 < m.rmse_reg12)
           AND (m.rmse_ma6   IS NULL OR m.rmse_reg36 <= m.rmse_ma6)
           AND (m.rmse_ma12  IS NULL OR m.rmse_reg36 <= m.rmse_ma12) )
      THEN 'REG36'

    WHEN m.rmse_ma6 IS NOT NULL
         AND ( (m.rmse_ma12 IS NULL OR m.rmse_ma6 <= m.rmse_ma12)
           AND (m.r2_reg12 IS NULL OR m.r2_reg12 < 0.5 OR m.rmse_ma6 < m.rmse_reg12)
           AND (m.r2_reg36 IS NULL OR m.r2_reg36 < 0.5 OR m.rmse_ma6 <= m.rmse_reg36) )
      THEN 'MA6'

    ELSE 'MA12'
  END AS Best_Model
FROM metrics m
ORDER BY m.RC_CODE;





WITH
-- 0) Base (month-end, Total Loans)
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

-- 1) Index and max-t
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
    MAX(ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end))
      OVER (PARTITION BY RC_CODE) AS tmax
  FROM base b
),

-- 2) Window subsets (evaluation sets)
last12 AS ( SELECT * FROM idx WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx WHERE t >= tmax - 35 ),

/* -------------------- Regression-12 -------------------- */
reg12_stats AS (
  SELECT
    l.*,
    -- window sums across last12
    COUNT(*)  OVER (PARTITION BY RC_CODE)                           AS n12,
    SUM(t)::FLOAT8     OVER (PARTITION BY RC_CODE)                  AS sumx12,
    SUM(bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE)                AS sumy12,
    SUM(t*bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE)              AS sumxy12,
    SUM(t*t)::FLOAT8   OVER (PARTITION BY RC_CODE)                  AS sumx2_12
  FROM last12 l
),
reg12_fit AS (
  SELECT
    s.*,
    (s.n12*s.sumx2_12 - s.sumx12*s.sumx12)                          AS den12,
    /* slope/intercept using window sums */
    CASE WHEN s.n12 >= 2 AND (s.n12*s.sumx2_12 - s.sumx12*s.sumx12) <> 0
         THEN ((s.n12*s.sumxy12 - s.sumx12*s.sumy12) / (s.n12*s.sumx2_12 - s.sumx12*s.sumx12))
         ELSE NULL END::FLOAT8 AS slope12,
    CASE WHEN s.n12 >= 1 AND (s.n12*s.sumx2_12 - s.sumx12*s.sumx12) <> 0
         THEN (s.sumy12/s.n12) - (((s.n12*s.sumxy12 - s.sumx12*s.sumy12) / (s.n12*s.sumx2_12 - s.sumx12*s.sumx12)) * (s.sumx12/s.n12))
         ELSE NULL END::FLOAT8 AS intercept12
  FROM reg12_stats s
),
reg12_res AS (
  SELECT
    f.RC_CODE, f.month_end, f.bal_num, f.t,
    /* forecast, residual^2 */
    (CASE WHEN f.slope12 IS NULL THEN NULL ELSE (f.slope12*f.t + f.intercept12) END)::FLOAT8 AS fc_reg12,
    (f.bal_num - (CASE WHEN f.slope12 IS NULL THEN NULL ELSE (f.slope12*f.t + f.intercept12) END))::FLOAT8 AS resid_reg12,
    /* mean and SST over last12 subset */
    AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE)                                  AS mean_y12,
    -- sums over last12 subset
    SUM( ((f.bal_num - (CASE WHEN f.slope12 IS NULL THEN NULL ELSE (f.slope12*f.t + f.intercept12) END))
         * (f.bal_num - (CASE WHEN f.slope12 IS NULL THEN NULL ELSE (f.slope12*f.t + f.intercept12) END))) ) 
         OVER (PARTITION BY f.RC_CODE)                                            AS sse_reg12,
    SUM( (f.bal_num - AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE))
        * (f.bal_num - AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE)) )
         OVER (PARTITION BY f.RC_CODE)                                            AS sst12,
    COUNT(*) OVER (PARTITION BY f.RC_CODE)                                        AS n_reg12,
    ROW_NUMBER() OVER (PARTITION BY f.RC_CODE ORDER BY f.month_end DESC)          AS rn12
  FROM reg12_fit f
),
reg12_metrics AS (
  SELECT
    RC_CODE,
    CASE WHEN sst12 > 0 AND sse_reg12 IS NOT NULL THEN 1.0 - sse_reg12/sst12 ELSE NULL END AS r2_reg12,
    CASE WHEN n_reg12 > 1 AND sse_reg12 IS NOT NULL THEN SQRT(sse_reg12 / n_reg12) ELSE NULL END AS rmse_reg12
  FROM reg12_res
  WHERE rn12 = 1
),

/* -------------------- Regression-36 -------------------- */
reg36_stats AS (
  SELECT
    l.*,
    COUNT(*)  OVER (PARTITION BY RC_CODE)                           AS n36,
    SUM(t)::FLOAT8     OVER (PARTITION BY RC_CODE)                  AS sumx36,
    SUM(bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE)                AS sumy36,
    SUM(t*bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE)              AS sumxy36,
    SUM(t*t)::FLOAT8   OVER (PARTITION BY RC_CODE)                  AS sumx2_36
  FROM last36 l
),
reg36_fit AS (
  SELECT
    s.*,
    (s.n36*s.sumx2_36 - s.sumx36*s.sumx36)                          AS den36,
    CASE WHEN s.n36 >= 2 AND (s.n36*s.sumx2_36 - s.sumx36*s.sumx36) <> 0
         THEN ((s.n36*s.sumxy36 - s.sumx36*s.sumy36) / (s.n36*s.sumx2_36 - s.sumx36*s.sumx36))
         ELSE NULL END::FLOAT8 AS slope36,
    CASE WHEN s.n36 >= 1 AND (s.n36*s.sumx2_36 - s.sumx36*s.sumx36) <> 0
         THEN (s.sumy36/s.n36) - (((s.n36*s.sumxy36 - s.sumx36*s.sumy36) / (s.n36*s.sumx2_36 - s.sumx36*s.sumx36)) * (s.sumx36/s.n36))
         ELSE NULL END::FLOAT8 AS intercept36
  FROM reg36_stats s
),
reg36_res AS (
  SELECT
    f.RC_CODE, f.month_end, f.bal_num, f.t,
    (CASE WHEN f.slope36 IS NULL THEN NULL ELSE (f.slope36*f.t + f.intercept36) END)::FLOAT8 AS fc_reg36,
    (f.bal_num - (CASE WHEN f.slope36 IS NULL THEN NULL ELSE (f.slope36*f.t + f.intercept36) END))::FLOAT8 AS resid_reg36,
    AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE)                                  AS mean_y36,
    SUM( ((f.bal_num - (CASE WHEN f.slope36 IS NULL THEN NULL ELSE (f.slope36*f.t + f.intercept36) END))
         * (f.bal_num - (CASE WHEN f.slope36 IS NULL THEN NULL ELSE (f.slope36*f.t + f.intercept36) END))) ) 
         OVER (PARTITION BY f.RC_CODE)                                            AS sse_reg36,
    SUM( (f.bal_num - AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE))
        * (f.bal_num - AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE)) )
         OVER (PARTITION BY f.RC_CODE)                                            AS sst36,
    COUNT(*) OVER (PARTITION BY f.RC_CODE)                                        AS n_reg36,
    ROW_NUMBER() OVER (PARTITION BY f.RC_CODE ORDER BY f.month_end DESC)          AS rn36
  FROM reg36_fit f
),
reg36_metrics AS (
  SELECT
    RC_CODE,
    CASE WHEN sst36 > 0 AND sse_reg36 IS NOT NULL THEN 1.0 - sse_reg36/sst36 ELSE NULL END AS r2_reg36,
    CASE WHEN n_reg36 > 1 AND sse_reg36 IS NOT NULL THEN SQRT(sse_reg36 / n_reg36) ELSE NULL END AS rmse_reg36
  FROM reg36_res
  WHERE rn36 = 1
),

/* -------------------- MA-6 on last12 -------------------- */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.bal_num, i.t,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx i
),
ma6_last12 AS (
  SELECT m.*
  FROM ma_all m
  JOIN last12 l ON l.RC_CODE = m.RC_CODE AND l.month_end = m.month_end
  WHERE m.fc_ma6 IS NOT NULL
),
ma6_res AS (
  SELECT
    a.RC_CODE, a.month_end, a.bal_num,
    a.fc_ma6,
    (a.bal_num - a.fc_ma6)::FLOAT8 AS resid_ma6,
    AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE)                     AS mean_y12_ma6,
    SUM( (a.bal_num - a.fc_ma6) * (a.bal_num - a.fc_ma6) )
      OVER (PARTITION BY a.RC_CODE)                                   AS sse_ma6,
    SUM( (a.bal_num - AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE))
        * (a.bal_num - AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE)) )
      OVER (PARTITION BY a.RC_CODE)                                   AS sst12_ma6,
    COUNT(*) OVER (PARTITION BY a.RC_CODE)                            AS n_ma6,
    ROW_NUMBER() OVER (PARTITION BY a.RC_CODE ORDER BY a.month_end DESC) AS rn_ma6
  FROM ma6_last12 a
),
ma6_metrics AS (
  SELECT
    RC_CODE,
    CASE WHEN sst12_ma6 > 0 AND sse_ma6 IS NOT NULL THEN 1.0 - sse_ma6/sst12_ma6 ELSE NULL END AS r2_ma6,
    CASE WHEN n_ma6 > 1 AND sse_ma6 IS NOT NULL THEN SQRT(sse_ma6 / n_ma6) ELSE NULL END AS rmse_ma6
  FROM ma6_res
  WHERE rn_ma6 = 1
),

/* -------------------- MA-12 on last36 -------------------- */
ma12_last36 AS (
  SELECT m.*
  FROM ma_all m
  JOIN last36 l ON l.RC_CODE = m.RC_CODE AND l.month_end = m.month_end
  WHERE m.fc_ma12 IS NOT NULL
),
ma12_res AS (
  SELECT
    a.RC_CODE, a.month_end, a.bal_num,
    a.fc_ma12,
    (a.bal_num - a.fc_ma12)::FLOAT8 AS resid_ma12,
    AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE)                      AS mean_y36_ma12,
    SUM( (a.bal_num - a.fc_ma12) * (a.bal_num - a.fc_ma12) )
      OVER (PARTITION BY a.RC_CODE)                                    AS sse_ma12,
    SUM( (a.bal_num - AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE))
        * (a.bal_num - AVG(a.bal_num) OVER (PARTITION BY a.RC_CODE)) )
      OVER (PARTITION BY a.RC_CODE)                                    AS sst36_ma12,
    COUNT(*) OVER (PARTITION BY a.RC_CODE)                             AS n_ma12,
    ROW_NUMBER() OVER (PARTITION BY a.RC_CODE ORDER BY a.month_end DESC) AS rn_ma12
  FROM ma12_last36 a
),
ma12_metrics AS (
  SELECT
    RC_CODE,
    CASE WHEN sst36_ma12 > 0 AND sse_ma12 IS NOT NULL THEN 1.0 - sse_ma12/sst36_ma12 ELSE NULL END AS r2_ma12,
    CASE WHEN n_ma12 > 1 AND sse_ma12 IS NOT NULL THEN SQRT(sse_ma12 / n_ma12) ELSE NULL END AS rmse_ma12
  FROM ma12_res
  WHERE rn_ma12 = 1
)

/* -------------------- Final: join metrics & pick best -------------------- */
SELECT
  x.RC_CODE,
  r12.r2_reg12, r12.rmse_reg12,
  r36.r2_reg36, r36.rmse_reg36,
  m6.r2_ma6,    m6.rmse_ma6,
  m12.r2_ma12,  m12.rmse_ma12,
  /* pick best by RMSE, with regression eligible only if R²>=0.5 */
  CASE
    WHEN r12.rmse_reg12 IS NOT NULL AND r12.r2_reg12 >= 0.5
       AND ( (r36.rmse_reg36 IS NULL OR r36.r2_reg36 < 0.5 OR r12.rmse_reg12 <= r36.rmse_reg36)
         AND (m6.rmse_ma6   IS NULL OR r12.rmse_reg12 <= m6.rmse_ma6)
         AND (m12.rmse_ma12 IS NULL OR r12.rmse_reg12 <= m12.rmse_ma12) )
      THEN 'REG12'

    WHEN r36.rmse_reg36 IS NOT NULL AND r36.r2_reg36 >= 0.5
       AND ( (r12.rmse_reg12 IS NULL OR r12.r2_reg12 < 0.5 OR r36.rmse_reg36 < r12.rmse_reg12)
         AND (m6.rmse_ma6   IS NULL OR r36.rmse_reg36 <= m6.rmse_ma6)
         AND (m12.rmse_ma12 IS NULL OR r36.rmse_ma12 <= m12.rmse_ma12) )
      THEN 'REG36'

    WHEN m6.rmse_ma6 IS NOT NULL
       AND ( (m12.rmse_ma12 IS NULL OR m6.rmse_ma6 <= m12.rmse_ma12)
         AND (r12.rmse_reg12 IS NULL OR r12.r2_reg12 < 0.5 OR m6.rmse_ma6 < r12.rmse_reg12)
         AND (r36.rmse_reg36 IS NULL OR r36.r2_reg36 < 0.5 OR m6.rmse_ma6 <= r36.rmse_reg36) )
      THEN 'MA6'

    ELSE 'MA12'
  END AS Best_Model
FROM (SELECT DISTINCT RC_CODE FROM idx) x
LEFT JOIN reg12_metrics r12 ON r12.RC_CODE = x.RC_CODE
LEFT JOIN reg36_metrics r36 ON r36.RC_CODE = x.RC_CODE
LEFT JOIN ma6_metrics  m6  ON m6.RC_CODE  = x.RC_CODE
LEFT JOIN ma12_metrics m12 ON m12.RC_CODE = x.RC_CODE
ORDER BY x.RC_CODE;





WITH
-- 0) Base
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

-- 1) Index and per-RC max t
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
    MAX(ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end))
      OVER (PARTITION BY RC_CODE) AS tmax
  FROM base b
),

-- 2) Window subsets (evaluation sets)
last12 AS ( SELECT * FROM idx WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx WHERE t >= tmax - 35 ),

-- 3) Regression params for each window
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

-- 4) Regression fits over their windows
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        /* slope12 * t + intercept12 */
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

-- 5) Moving averages computed once, then restricted to windows
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.bal_num, i.t,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx i
),
ma6_12 AS (  -- evaluate MA6 on last12
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_36 AS ( -- evaluate MA12 on last36
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

-- 6) Means and SST per window (computed separately, then used downstream)
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

-- 7) SSE and counts per model/window (no nested aggregates)
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6_12,
         COUNT(*) AS n_ma6_12
  FROM ma6_12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12_36,
         COUNT(*) AS n_ma12_36
  FROM ma12_36 m
  GROUP BY m.RC_CODE
),

-- 8) Compute RMSE and R2 (no aggregates here; just arithmetic)
metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12, s36.sst36,

    ar12.sse_reg12, ar12.n_reg12,
    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 AND ar12.sse_reg12 IS NOT NULL THEN 1.0 - ar12.sse_reg12 / s12.sst12 ELSE NULL END AS r2_reg12,

    ar36.sse_reg36, ar36.n_reg36,
    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 AND ar36.sse_reg36 IS NOT NULL THEN 1.0 - ar36.sse_reg36 / s36.sst36 ELSE NULL END AS r2_reg36,

    am6.sse_ma6_12,  am6.n_ma6_12,
    CASE WHEN am6.n_ma6_12  > 1 THEN SQRT(am6.sse_ma6_12  / am6.n_ma6_12)  ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12     > 0 AND am6.sse_ma6_12  IS NOT NULL THEN 1.0 - am6.sse_ma6_12  / s12.sst12 ELSE NULL END AS r2_ma6,

    am12.sse_ma12_36, am12.n_ma12_36,
    CASE WHEN am12.n_ma12_36 > 1 THEN SQRT(am12.sse_ma12_36 / am12.n_ma12_36) ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36     > 0 AND am12.sse_ma12_36 IS NOT NULL THEN 1.0 - am12.sse_ma12_36 / s36.sst36 ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx) x
    LEFT JOIN sst12 s12        ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36        ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12   ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36   ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6   ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12 ON am12.RC_CODE = x.RC_CODE
),

-- 9) Best model selection (compare plain numbers; no aggregates)
pick AS (
  SELECT
    m.RC_CODE,
    m.r2_reg12, m.rmse_reg12,
    m.r2_reg36, m.rmse_reg36,
    m.r2_ma6,   m.rmse_ma6,
    m.r2_ma12,  m.rmse_ma12,

    /* regression eligibility (R² >= 0.5) */
    CASE WHEN m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END AS rmse_reg12_elig,
    CASE WHEN m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END AS rmse_reg36_elig,

    /* min MA RMSE */
    CASE WHEN m.rmse_ma6 IS NULL THEN m.rmse_ma12
         WHEN m.rmse_ma12 IS NULL THEN m.rmse_ma6
         WHEN m.rmse_ma6 <= m.rmse_ma12 THEN m.rmse_ma6 ELSE m.rmse_ma12 END AS min_ma_rmse,

    /* min eligible REG RMSE */
    CASE WHEN m.rmse_reg12_elig <= m.rmse_reg36_elig THEN m.rmse_reg12_elig ELSE m.rmse_reg36_elig END AS min_reg_rmse
  FROM metrics m
)

SELECT
  p.RC_CODE,
  p.r2_reg12, p.rmse_reg12,
  p.r2_reg36, p.rmse_reg36,
  p.r2_ma6,   p.rmse_ma6,
  p.r2_ma12,  p.rmse_ma12,

  CASE
    WHEN p.min_reg_rmse < p.min_ma_rmse THEN
         CASE WHEN p.rmse_reg12_elig <= p.rmse_reg36_elig THEN 'REG12' ELSE 'REG36' END
    ELSE
         CASE
           WHEN p.rmse_ma6 IS NULL THEN 'MA12'
           WHEN p.rmse_ma12 IS NULL THEN 'MA6'
           WHEN p.rmse_ma6 <= p.rmse_ma12 THEN 'MA6' ELSE 'MA12'
         END
  END AS Best_Model
FROM pick p
ORDER BY p.RC_CODE;





WITH
-- 0) Base
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

-- 1) Index and max-t per RC
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
    MAX(ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end))
      OVER (PARTITION BY RC_CODE) AS tmax
  FROM base b
),

-- 2) Window subsets
last12 AS (
  SELECT * FROM idx WHERE t >= tmax - 11  -- up to 12 rows if history long enough
),
last36 AS (
  SELECT * FROM idx WHERE t >= tmax - 35  -- up to 36 rows
),

-- 3) Regression params per window
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n12,
    SUM(t)::FLOAT8           AS sumx12,
    SUM(bal_num)::FLOAT8     AS sumy12,
    SUM(t*bal_num)::FLOAT8   AS sumxy12,
    SUM(t*t)::FLOAT8         AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)                 AS n36,
    SUM(t)::FLOAT8           AS sumx36,
    SUM(bal_num)::FLOAT8     AS sumy36,
    SUM(t*bal_num)::FLOAT8   AS sumxy36,
    SUM(t*t)::FLOAT8         AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

-- 4) Regression fits per window (only over their evaluation windows)
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        /* slope12 */ ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        /* intercept12 */ + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.bal_num, l.t
  , CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

-- 5) Moving averages computed over full series, then restricted to windows
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.bal_num, i.t,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx i
),
ma6_12 AS (  -- evaluate MA6 on last12
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_36 AS ( -- evaluate MA12 on last36
  SELECT m.RC_CODE, m.month_end, m.bal_num, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

-- 6) Means and SST per window
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

-- 7) SSE and counts per model/window
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6_12,
         COUNT(*) AS n_ma6_12
  FROM ma6_12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12_36,
         COUNT(*) AS n_ma12_36
  FROM ma12_36 m
  GROUP BY m.RC_CODE
),

-- 8) Combine & compute metrics
scores AS (
  SELECT
    x.RC_CODE,

    -- join all aggregates & SSTs
    s12.sst12, s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6_12, am6.n_ma6_12,
    am12.sse_ma12_36, am12.n_ma12_36,

    -- R2 (guarded) and RMSE per model
    CASE WHEN s12.sst12 > 0 AND ar12.sse_reg12 IS NOT NULL THEN 1.0 - ar12.sse_reg12 / s12.sst12 ELSE NULL END AS r2_reg12,
    CASE WHEN ar12.n_reg12 > 0 AND ar12.sse_reg12 IS NOT NULL THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,

    CASE WHEN s36.sst36 > 0 AND ar36.sse_reg36 IS NOT NULL THEN 1.0 - ar36.sse_reg36 / s36.sst36 ELSE NULL END AS r2_reg36,
    CASE WHEN ar36.n_reg36 > 0 AND ar36.sse_reg36 IS NOT NULL THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,

    CASE WHEN s12.sst12 > 0 AND am6.sse_ma6_12 IS NOT NULL THEN 1.0 - am6.sse_ma6_12 / s12.sst12 ELSE NULL END AS r2_ma6,
    CASE WHEN am6.n_ma6_12 > 0 AND am6.sse_ma6_12 IS NOT NULL THEN SQRT(am6.sse_ma6_12 / am6.n_ma6_12) ELSE NULL END AS rmse_ma6,

    CASE WHEN s36.sst36 > 0 AND am12.sse_ma12_36 IS NOT NULL THEN 1.0 - am12.sse_ma12_36 / s36.sst36 ELSE NULL END AS r2_ma12,
    CASE WHEN am12.n_ma12_36 > 0 AND am12.sse_ma12_36 IS NOT NULL THEN SQRT(am12.sse_ma12_36 / am12.n_ma12_36) ELSE NULL END AS rmse_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx) x
    LEFT JOIN sst12 s12      ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36      ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12 ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36 ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6 ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12 ON am12.RC_CODE = x.RC_CODE
)

-- 9) Final selection (regression eligible only if R² ≥ 0.5)
SELECT
  s.RC_CODE,
  s.r2_reg12, s.rmse_reg12,
  s.r2_reg36, s.rmse_reg36,
  s.r2_ma6,   s.rmse_ma6,
  s.r2_ma12,  s.rmse_ma12,

  CASE
    WHEN COALESCE(
           CASE WHEN s.r2_reg12 >= 0.5 THEN s.rmse_reg12 ELSE NULL END,
           9e99
         ) <= LEAST(
           COALESCE(s.rmse_ma6, 9e99),
           COALESCE(s.rmse_ma12, 9e99),
           COALESCE(
             CASE WHEN s.r2_reg36 >= 0.5 THEN s.rmse_reg36 ELSE NULL END,
             9e99
           )
         ) THEN 'REG12'

    WHEN COALESCE(
           CASE WHEN s.r2_reg36 >= 0.5 THEN s.rmse_reg36 ELSE NULL END,
           9e99
         ) <= LEAST(
           COALESCE(s.rmse_ma6, 9e99),
           COALESCE(s.rmse_ma12, 9e99),
           COALESCE(
             CASE WHEN s.r2_reg12 >= 0.5 THEN s.rmse_reg12 ELSE NULL END,
             9e99
           )
         ) THEN 'REG36'

    WHEN COALESCE(s.rmse_ma6, 9e99) <= LEAST(
           COALESCE(s.rmse_ma12, 9e99),
           COALESCE(
             CASE WHEN s.r2_reg12 >= 0.5 THEN s.rmse_reg12 ELSE NULL END,
             9e99
           ),
           COALESCE(
             CASE WHEN s.r2_reg36 >= 0.5 THEN s.rmse_reg36 ELSE NULL END,
             9e99
           )
         ) THEN 'MA6'

    ELSE 'MA12'
  END AS Best_Model
FROM scores s
ORDER BY s.RC_CODE;





WITH base AS (
    SELECT
        RC_CODE,
        RC_DESCRIPTION,
        CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
        SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

idx AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
    FROM base b
),

-- Per RC mean for SST (needed for R²)
means AS (
    SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y
    FROM idx
    GROUP BY RC_CODE
),

-- Regression params (full history, same slope/intercept used for 12 or 36 cutoff)
regression_params AS (
    SELECT
        RC_CODE,
        COUNT(*) AS n,
        SUM(t)::FLOAT8 AS sum_t,
        SUM(bal_num)::FLOAT8 AS sum_y,
        SUM(t*bal_num)::FLOAT8 AS sum_ty,
        SUM(t*t)::FLOAT8 AS sum_t2
    FROM idx
    GROUP BY RC_CODE
),

regression_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        i.t,
        /* slope/intercept full sample */
        ( (r.sum_y - ((r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0))*r.sum_t) / r.n )::FLOAT8
        + ( (r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0) )::FLOAT8 * i.t
        AS forecast_reg
    FROM idx i
    JOIN regression_params r ON i.RC_CODE = r.RC_CODE
),

-- Moving averages (6 and 12 months)
ma_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma6,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma12
    FROM idx i
),

-- Combine all fits
fits AS (
    SELECT
        f.RC_CODE,
        f.month_end,
        f.bal_num,
        f.forecast_reg,
        m.forecast_ma6,
        m.forecast_ma12
    FROM regression_fit f
    JOIN ma_fit m
      ON f.RC_CODE = m.RC_CODE AND f.month_end = m.month_end
),

-- Residual sums for each model
residuals AS (
    SELECT
        ft.RC_CODE,
        mn.mean_y,
        COUNT(*) AS n_obs,

        -- Regression (using all history, call this "Regression-12")
        SUM( (ft.bal_num - ft.forecast_reg) * (ft.bal_num - ft.forecast_reg) ) AS sse_reg,
        -- MA6
        SUM( (ft.bal_num - ft.forecast_ma6) * (ft.bal_num - ft.forecast_ma6) ) AS sse_ma6,
        -- MA12
        SUM( (ft.bal_num - ft.forecast_ma12) * (ft.bal_num - ft.forecast_ma12) ) AS sse_ma12,
        -- SST for R²
        SUM( (ft.bal_num - mn.mean_y) * (ft.bal_num - mn.mean_y) ) AS sst
    FROM fits ft
    JOIN means mn ON ft.RC_CODE = mn.RC_CODE
    GROUP BY ft.RC_CODE, mn.mean_y
)

SELECT
    r.RC_CODE,

    -- Regression (treated as "Regression-12 full sample")
    (1.0 - r.sse_reg / NULLIF(r.sst,0))::FLOAT8 AS r2_reg,
    SQRT(r.sse_reg / r.n_obs)::FLOAT8 AS rmse_reg,

    -- MA6
    (1.0 - r.sse_ma6 / NULLIF(r.sst,0))::FLOAT8 AS r2_ma6,
    SQRT(r.sse_ma6 / r.n_obs)::FLOAT8 AS rmse_ma6,

    -- MA12
    (1.0 - r.sse_ma12 / NULLIF(r.sst,0))::FLOAT8 AS r2_ma12,
    SQRT(r.sse_ma12 / r.n_obs)::FLOAT8 AS rmse_ma12,

    CASE
        WHEN (1.0 - r.sse_reg/NULLIF(r.sst,0)) < 0.5 THEN 
             CASE WHEN r.rmse_ma6 <= r.rmse_ma12 THEN 'MA6' ELSE 'MA12' END
        WHEN r.rmse_reg <= r.rmse_ma6 AND r.rmse_reg <= r.rmse_ma12 THEN 'REGRESSION'
        WHEN r.rmse_ma6 <= r.rmse_ma12 THEN 'MA6'
        ELSE 'MA12'
    END AS Best_Model

FROM residuals r
ORDER BY r.RC_CODE;




WITH base AS (
    SELECT
        RC_CODE,
        RC_DESCRIPTION,
        CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
        SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

idx AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
    FROM base b
),

-- regression params
regression_params AS (
    SELECT
        RC_CODE,
        COUNT(*) AS n,
        SUM(t)::FLOAT8 AS sum_t,
        SUM(bal_num)::FLOAT8 AS sum_y,
        SUM(t*bal_num)::FLOAT8 AS sum_ty,
        SUM(t*t)::FLOAT8 AS sum_t2
    FROM idx
    GROUP BY RC_CODE
),

regression_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        ( (r.sum_y - ((r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0))*r.sum_t) / r.n )::FLOAT8
        + ( (r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0) )::FLOAT8 * i.t
        AS forecast_reg
    FROM idx i
    JOIN regression_params r ON i.RC_CODE = r.RC_CODE
),

ma12_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma12
    FROM idx i
),

-- per RC_CODE mean of bal_num (needed for SST in R²)
means AS (
    SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y
    FROM idx
    GROUP BY RC_CODE
),

-- collect residual sums
residuals AS (
    SELECT
        f.RC_CODE,
        SUM( (f.bal_num - f.forecast_reg) * (f.bal_num - f.forecast_reg) )::FLOAT8 AS sse_reg,
        SUM( (m.bal_num - m.forecast_ma12) * (m.bal_num - m.forecast_ma12) )::FLOAT8 AS sse_ma12,
        SUM( (f.bal_num - mn.mean_y) * (f.bal_num - mn.mean_y) )::FLOAT8 AS sst,
        COUNT(*) AS n_obs
    FROM regression_fit f
    JOIN ma12_fit m
      ON f.RC_CODE = m.RC_CODE AND f.month_end = m.month_end
    JOIN means mn
      ON f.RC_CODE = mn.RC_CODE
    GROUP BY f.RC_CODE, mn.mean_y
)

SELECT
    r.RC_CODE,

    -- Regression fit
    (1.0 - r.sse_reg / NULLIF(r.sst,0))::FLOAT8 AS r2_reg,
    SQRT(r.sse_reg / r.n_obs)::FLOAT8 AS rmse_reg,
    (SUM(ABS(f.bal_num - f.forecast_reg)) / NULLIF(SUM(ABS(f.bal_num)),0))::FLOAT8 AS mape_reg,

    -- MA12 fit
    (1.0 - r.sse_ma12 / NULLIF(r.sst,0))::FLOAT8 AS r2_ma12,
    SQRT(r.sse_ma12 / r.n_obs)::FLOAT8 AS rmse_ma12,
    (SUM(ABS(m.bal_num - m.forecast_ma12)) / NULLIF(SUM(ABS(m.bal_num)),0))::FLOAT8 AS mape_ma12,

    CASE
        WHEN (1.0 - r.sse_reg/NULLIF(r.sst,0)) < 0.5 THEN 'MA12'
        WHEN r.sse_reg <= r.sse_ma12 THEN 'REGRESSION'
        ELSE 'MA12'
    END AS Best_Model

FROM residuals r
JOIN regression_fit f ON f.RC_CODE = r.RC_CODE
JOIN ma12_fit m       ON m.RC_CODE = r.RC_CODE AND m.month_end = f.month_end
GROUP BY r.RC_CODE, r.sse_reg, r.sse_ma12, r.sst, r.n_obs
ORDER BY r.RC_CODE;





WITH base AS (
    SELECT
        RC_CODE,
        RC_DESCRIPTION,
        CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
        SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

idx AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
    FROM base b
),

-- regression params
regression_params AS (
    SELECT
        RC_CODE,
        COUNT(*) AS n,
        SUM(t)::FLOAT8 AS sum_t,
        SUM(bal_num)::FLOAT8 AS sum_y,
        SUM(t*bal_num)::FLOAT8 AS sum_ty,
        SUM(t*t)::FLOAT8 AS sum_t2
    FROM idx
    GROUP BY RC_CODE
),

regression_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        ( (r.sum_y - ((r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0))*r.sum_t) / r.n )::FLOAT8
        + ( (r.n*r.sum_ty - r.sum_t*r.sum_y) 
             / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0) )::FLOAT8 * i.t
        AS forecast_reg
    FROM idx i
    JOIN regression_params r ON i.RC_CODE = r.RC_CODE
),

ma12_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma12
    FROM idx i
),

-- per RC_CODE mean of bal_num (needed for SST in R²)
means AS (
    SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y
    FROM idx
    GROUP BY RC_CODE
),

-- collect residual sums
residuals AS (
    SELECT
        f.RC_CODE,
        SUM(POWER(f.bal_num - f.forecast_reg, 2.0::FLOAT8)) AS sse_reg,
        SUM(POWER(m.bal_num - m.forecast_ma12, 2.0::FLOAT8)) AS sse_ma12,
        SUM(POWER(f.bal_num - mn.mean_y, 2.0::FLOAT8)) AS sst,
        COUNT(*) AS n_obs
    FROM regression_fit f
    JOIN ma12_fit m
      ON f.RC_CODE = m.RC_CODE AND f.month_end = m.month_end
    JOIN means mn
      ON f.RC_CODE = mn.RC_CODE
    GROUP BY f.RC_CODE, mn.mean_y
)

SELECT
    r.RC_CODE,

    -- Regression fit
    (1.0 - r.sse_reg / NULLIF(r.sst,0))::FLOAT8 AS r2_reg,
    SQRT(r.sse_reg / r.n_obs)::FLOAT8 AS rmse_reg,
    (SUM(ABS(f.bal_num - f.forecast_reg)) / NULLIF(SUM(ABS(f.bal_num)),0))::FLOAT8 AS mape_reg,

    -- MA12 fit
    (1.0 - r.sse_ma12 / NULLIF(r.sst,0))::FLOAT8 AS r2_ma12,
    SQRT(r.sse_ma12 / r.n_obs)::FLOAT8 AS rmse_ma12,
    (SUM(ABS(m.bal_num - m.forecast_ma12)) / NULLIF(SUM(ABS(m.bal_num)),0))::FLOAT8 AS mape_ma12,

    CASE
        WHEN (1.0 - r.sse_reg/NULLIF(r.sst,0)) < 0.5 THEN 'MA12'
        WHEN r.sse_reg <= r.sse_ma12 THEN 'REGRESSION'
        ELSE 'MA12'
    END AS Best_Model

FROM residuals r
JOIN regression_fit f ON f.RC_CODE = r.RC_CODE
JOIN ma12_fit m       ON m.RC_CODE = r.RC_CODE AND m.month_end = f.month_end
GROUP BY r.RC_CODE, r.sse_reg, r.sse_ma12, r.sst, r.n_obs
ORDER BY r.RC_CODE;





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist	
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts




WITH base AS (
    SELECT
        RC_CODE,
        RC_DESCRIPTION,
        CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
        SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

idx AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
    FROM base b
),

-- regression params
regression_params AS (
    SELECT
        RC_CODE,
        COUNT(*) AS n,
        SUM(t)::FLOAT8 AS sum_t,
        SUM(bal_num)::FLOAT8 AS sum_y,
        SUM(t*bal_num)::FLOAT8 AS sum_ty,
        SUM(t*t)::FLOAT8 AS sum_t2
    FROM idx
    GROUP BY RC_CODE
),
regression_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        ( (r.sum_y - ((r.n*r.sum_ty - r.sum_t*r.sum_y) / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0))*r.sum_t) / r.n )::FLOAT8
        + ( (r.n*r.sum_ty - r.sum_t*r.sum_y) / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0) )::FLOAT8 * i.t
        AS forecast_reg
    FROM idx i
    JOIN regression_params r ON i.RC_CODE = r.RC_CODE
),
ma12_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma12
    FROM idx i
),

-- per RC_CODE mean of bal_num (needed for SST in R²)
means AS (
    SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y
    FROM idx
    GROUP BY RC_CODE
),

-- collect residual sums
residuals AS (
    SELECT
        f.RC_CODE,
        SUM(POWER(f.bal_num - f.forecast_reg,2))::FLOAT8 AS sse_reg,
        SUM(POWER(m.bal_num - m.forecast_ma12,2))::FLOAT8 AS sse_ma12,
        SUM(POWER(f.bal_num - mn.mean_y,2))::FLOAT8 AS sst
    FROM regression_fit f
    JOIN ma12_fit m
      ON f.RC_CODE = m.RC_CODE AND f.month_end = m.month_end
    JOIN means mn
      ON f.RC_CODE = mn.RC_CODE
    GROUP BY f.RC_CODE, mn.mean_y
)

SELECT
    r.RC_CODE,

    -- Regression fit
    (1.0 - r.sse_reg / NULLIF(r.sst,0))::FLOAT8 AS r2_reg,
    SQRT(r.sse_reg / COUNT(*))::FLOAT8 AS rmse_reg,
    (SUM(ABS(f.bal_num - f.forecast_reg)) / NULLIF(SUM(ABS(f.bal_num)),0))::FLOAT8 AS mape_reg,

    -- MA12 fit
    (1.0 - r.sse_ma12 / NULLIF(r.sst,0))::FLOAT8 AS r2_ma12,
    SQRT(r.sse_ma12 / COUNT(*))::FLOAT8 AS rmse_ma12,
    (SUM(ABS(m.bal_num - m.forecast_ma12)) / NULLIF(SUM(ABS(m.bal_num)),0))::FLOAT8 AS mape_ma12,

    CASE
        WHEN (1.0 - r.sse_reg/NULLIF(r.sst,0)) < 0.5 THEN 'MA12'
        WHEN r.sse_reg <= r.sse_ma12 THEN 'REGRESSION'
        ELSE 'MA12'
    END AS Best_Model

FROM residuals r
JOIN regression_fit f ON f.RC_CODE = r.RC_CODE
JOIN ma12_fit m       ON m.RC_CODE = r.RC_CODE AND m.month_end = f.month_end
GROUP BY r.RC_CODE, r.sse_reg, r.sse_ma12, r.sst
ORDER BY r.RC_CODE;





WITH base AS (
    SELECT
        RC_CODE,
        RC_DESCRIPTION,
        CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
        SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

-- Add index t for regression
idx AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
    FROM base b
),

-- Regression fit parameters
regression_params AS (
    SELECT
        RC_CODE,
        COUNT(*) AS n,
        SUM(t)::FLOAT8 AS sum_t,
        SUM(bal_num)::FLOAT8 AS sum_y,
        SUM(t*bal_num)::FLOAT8 AS sum_ty,
        SUM(t*t)::FLOAT8 AS sum_t2
    FROM idx
    GROUP BY RC_CODE
),
regression_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        ( (r.sum_y - ((r.n*r.sum_ty - r.sum_t*r.sum_y) / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0))*r.sum_t) / r.n )::FLOAT8
        + ( (r.n*r.sum_ty - r.sum_t*r.sum_y) / NULLIF(r.n*r.sum_t2 - r.sum_t*r.sum_t,0) )::FLOAT8 * i.t
        AS forecast_reg
    FROM idx i
    JOIN regression_params r ON i.RC_CODE = r.RC_CODE
),

-- Moving average 12
ma12_fit AS (
    SELECT
        i.RC_CODE,
        i.month_end,
        i.bal_num,
        AVG(i.bal_num) OVER (
            PARTITION BY i.RC_CODE ORDER BY i.month_end
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        )::FLOAT8 AS forecast_ma12
    FROM idx i
),

-- Metrics
metrics AS (
    SELECT
        f.RC_CODE,

        -- Regression
        1.0 - SUM(POWER(f.bal_num - f.forecast_reg,2))::FLOAT8 
              / NULLIF(SUM(POWER(f.bal_num - AVG(f.bal_num) OVER (PARTITION BY f.RC_CODE),2))::FLOAT8,0) AS r2_reg,
        SQRT(AVG(POWER(f.bal_num - f.forecast_reg,2)))::FLOAT8 AS rmse_reg,
        AVG(ABS(f.bal_num - f.forecast_reg) / NULLIF(ABS(f.bal_num),0))::FLOAT8 AS mape_reg,

        -- MA12
        1.0 - SUM(POWER(m.bal_num - m.forecast_ma12,2))::FLOAT8 
              / NULLIF(SUM(POWER(m.bal_num - AVG(m.bal_num) OVER (PARTITION BY m.RC_CODE),2))::FLOAT8,0) AS r2_ma12,
        SQRT(AVG(POWER(m.bal_num - m.forecast_ma12,2)))::FLOAT8 AS rmse_ma12,
        AVG(ABS(m.bal_num - m.forecast_ma12) / NULLIF(ABS(m.bal_num),0))::FLOAT8 AS mape_ma12

    FROM regression_fit f
    JOIN ma12_fit m
      ON f.RC_CODE = m.RC_CODE AND f.month_end = m.month_end
    GROUP BY f.RC_CODE
)

-- Final selection
SELECT
    RC_CODE,
    r2_reg, rmse_reg, mape_reg,
    r2_ma12, rmse_ma12, mape_ma12,

    CASE
        WHEN r2_reg IS NULL OR r2_reg < 0.5 THEN 'MA12'   -- safeguard: regression must explain something
        WHEN rmse_reg <= rmse_ma12 THEN 'REGRESSION'
        ELSE 'MA12'
    END AS Best_Model
FROM metrics
ORDER BY RC_CODE;





//@version=5
strategy("QQQ 5m Momentum Trend (EMA + DMI)", overlay=true, initial_capital=100000,
     pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.0025)

//==== Inputs
emaLen     = input.int(50,  "Trend EMA Length", minval=1)
diLen      = input.int(14,  "DI Length",        minval=1)
adxSmooth  = input.int(14,  "ADX Smoothing",    minval=1)
adxThresh  = input.float(20,"ADX Threshold",    minval=1, step=0.5)
atrLen     = input.int(14,  "ATR Length",       minval=1)
atrMult    = input.float(2.0,"ATR Stop Mult",   minval=0.1, step=0.1)
confirmBar = input.bool(true, "Confirm on Bar Close")

//==== Core calcs
ema = ta.ema(close, emaLen)
[diplus, diminus, adx] = ta.dmi(diLen, adxSmooth)
atrVal = ta.atr(atrLen)

//==== Filters: trade with trend, only when momentum is strong
longCondRaw  = close > ema  and diplus  > diminus and adx > adxThresh
shortCondRaw = close < ema  and diminus > diplus  and adx > adxThresh
longCond  = (confirmBar ? barstate.isconfirmed : true) and longCondRaw
shortCond = (confirmBar ? barstate.isconfirmed : true) and shortCondRaw

//==== Entries (flip when signal reverses; no pyramiding)
if (longCond  and strategy.position_size <= 0)
    strategy.entry("Long",  strategy.long)
if (shortCond and strategy.position_size >= 0)
    strategy.entry("Short", strategy.short)

//==== Dynamic ATR stops (updated each bar while in position)
longStop  = strategy.position_avg_price - atrVal * atrMult
shortStop = strategy.position_avg_price + atrVal * atrMult
if (strategy.position_size > 0)
    strategy.exit("L-Exit", from_entry="Long",  stop=longStop)
if (strategy.position_size < 0)
    strategy.exit("S-Exit", from_entry="Short", stop=shortStop)

//==== Visuals
plot(ema, "EMA", color=color.orange, linewidth=2)
plotshape(longCond,  title="Long Signal",  style=shape.triangleup,   color=color.new(color.green,0), size=size.tiny, location=location.belowbar, text="LONG")
plotshape(shortCond, title="Short Signal", style=shape.triangledown, color=color.new(color.red,0),   size=size.tiny, location=location.abovebar, text="SHORT")

//==== Alerts
alertcondition(longCond,  title="Long Alert",  message="QQQ 5m: LONG momentum signal")
alertcondition(shortCond, title="Short Alert", message="QQQ 5m: SHORT momentum signal")






//@version=5
strategy("QQQ 5m Momentum Trend (EMA+ADX)", overlay=true, initial_capital=100000, pyramiding=0,
     commission_type=strategy.commission.percent, commission_value=0.0025)

// Inputs
emaLen    = input.int(50,  "Trend EMA Length", minval=1)
adxLen    = input.int(14,  "ADX Length", minval=1)
adxThresh = input.float(20,"ADX Threshold",   minval=1, step=0.5)
atrLen    = input.int(14,  "ATR Length",      minval=1)
atrMult   = input.float(2.0,"ATR Stop Mult",  minval=0.1, step=0.1)
useTP     = input.bool(false, "Use Take-Profit?")
tpRR      = input.float(1.5,  "TP Risk/Reward", minval=0.5, step=0.1)

// Core calcs
ema     = ta.ema(close, emaLen)
adxVal  = ta.adx(adxLen)
diPlus  = ta.diPlus(adxLen)
diMinus = ta.diMinus(adxLen)
atrVal  = ta.atr(atrLen)

// Trade conditions (bar-close)
longCond  = close > ema  and diPlus  > diMinus and adxVal > adxThresh
shortCond = close < ema  and diMinus > diPlus  and adxVal > adxThresh

// Dynamic stops
longStop  = close - atrVal * atrMult
shortStop = close + atrVal * atrMult

// Entries (no pyramiding)
if (longCond and strategy.position_size <= 0)
    strategy.entry("Long", strategy.long)
if (shortCond and strategy.position_size >= 0)
    strategy.entry("Short", strategy.short)

// Exits (optional TP based on entry risk to stop)
if (strategy.position_size > 0)
    if useTP
        longRisk = strategy.position_avg_price - longStop
        longTP   = strategy.position_avg_price + longRisk * tpRR
        strategy.exit("L-Exit", from_entry="Long", stop=longStop, limit=longTP)
    else
        strategy.exit("L-Exit", from_entry="Long", stop=longStop)

if (strategy.position_size < 0)
    if useTP
        shortRisk = shortStop - strategy.position_avg_price
        shortTP   = strategy.position_avg_price - shortRisk * tpRR
        strategy.exit("S-Exit", from_entry="Short", stop=shortStop, limit=shortTP)
    else
        strategy.exit("S-Exit", from_entry="Short", stop=shortStop)

// Visuals
plot(ema, "EMA", color=color.orange, linewidth=2)
plotshape(longCond,  title="Long Signal",  style=shape.triangleup,   color=color.new(color.green,0), size=size.tiny, location=location.belowbar, text="LONG")
plotshape(shortCond, title="Short Signal", style=shape.triangledown, color=color.new(color.red,0),   size=size.tiny, location=location.abovebar, text="SHORT")

// Alerts
alertcondition(longCond,  title="Long Alert",  message="QQQ 5m: LONG momentum signal")
alertcondition(shortCond, title="Short Alert", message="QQQ 5m: SHORT momentum signal")




//@version=5
strategy("QQQ 5m Momentum Trend Strategy", overlay=true, margin_long=100, margin_short=100)

// Inputs
emaLen     = input.int(50,  "Trend EMA Length")
adxLen     = input.int(14,  "ADX Length")
adxThresh  = input.float(20,"ADX Threshold")
atrMult    = input.float(2.0,"ATR Stop Multiplier")
atrLen     = input.int(14,  "ATR Length")

// Indicators
ema        = ta.ema(close, emaLen)
adx        = ta.adx(adxLen)
plusDI     = ta.plusdi(adxLen)
minusDI    = ta.minusdi(adxLen)
atr        = ta.atr(atrLen)

// Momentum filters
longCond   = close > ema and plusDI > minusDI and adx > adxThresh
shortCond  = close < ema and minusDI > plusDI and adx > adxThresh

// Dynamic stop levels
longStop   = close - atr * atrMult
shortStop  = close + atr * atrMult

// Strategy execution
if (longCond)
    strategy.entry("Long", strategy.long)
    strategy.exit("Long Exit", "Long", stop=longStop)

if (shortCond)
    strategy.entry("Short", strategy.short)
    strategy.exit("Short Exit", "Short", stop=shortStop)

// Plotting
plot(ema, color=color.orange, title="EMA Trend")
plotshape(longCond,  title="Long Signal",  style=shape.triangleup,   color=color.green, size=size.small, location=location.belowbar)
plotshape(shortCond, title="Short Signal", style=shape.triangledown, color=color.red,   size=size.small, location=location.abovebar)

// Alerts
alertcondition(longCond,  title="Long Alert",  message="Momentum Long Signal on QQQ")
alertcondition(shortCond, title="Short Alert", message="Momentum Short Signal on QQQ")






WITH
/* 1) Base: certified month-end for Total Loans */
base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      CAST(END_OF_MONTH_DATE AS DATE)           AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8        AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 2) Indexing, prior balance, quarter-of-year, and MA windows */
idx_ma AS (
  SELECT
      b.RC_CODE,
      b.RC_DESCRIPTION,
      b.month_end,
      b.bal_num,
      ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t,
      CEIL(EXTRACT(MONTH FROM b.month_end)/3.0)::INTEGER              AS qoy,
      LAG(b.bal_num) OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS prev_bal,

      /* MAs (use only MA-12 for forecast to keep query compact) */
      AVG(b.bal_num) OVER (
        PARTITION BY b.RC_CODE ORDER BY b.month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_12
  FROM base b
),

/* 3) Simple quarterly lifts from ratio = actual / MA12, then normalize+shrink+cap */
lifts AS (
  /* raw mean ratio per RC×quarter */
  SELECT
      r.RC_CODE,
      r.qoy,
      /* mean ratio vs MA12 */
      AVG(r.ratio_ma12)::FLOAT8 AS qlift_raw
  FROM (
    SELECT
      i.RC_CODE,
      i.qoy,
      CASE WHEN i.ma_12 IS NULL OR i.ma_12 = 0 THEN NULL
           ELSE (i.bal_num / i.ma_12)::FLOAT8
      END AS ratio_ma12
    FROM idx_ma i
    WHERE i.ma_12 IS NOT NULL
  ) r
  WHERE r.ratio_ma12 IS NOT NULL
  GROUP BY r.RC_CODE, r.qoy
),
lifts_norm AS (
  /* normalize each RC’s 4 quarter lifts to mean 1.0, then shrink 50% toward 1 and cap to [0.80,1.20] */
  SELECT
      l.RC_CODE,
      l.qoy,
      /* normalize to RC mean */
      CASE
        WHEN a.avg_all IS NULL OR a.avg_all = 0 THEN 1.0
        ELSE l.qlift_raw / a.avg_all
      END::FLOAT8 AS qlift_norm
  FROM lifts l
  JOIN (
    SELECT RC_CODE, AVG(qlift_raw)::FLOAT8 AS avg_all
    FROM lifts
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = l.RC_CODE
),
lifts_final AS (
  SELECT
      RC_CODE,
      qoy,
      /* shrinkage alpha = 0.5; caps = [0.80, 1.20] (tunable) */
      LEAST(1.20, GREATEST(0.80, 1.0 + 0.5*(qlift_norm - 1.0)))::FLOAT8 AS qlift_final
  FROM lifts_norm
),

/* 4) Join lifts → forecast (MA12 × lift) → residuals & MoM signals */
signals AS (
  SELECT
      i.RC_CODE,
      i.RC_DESCRIPTION,
      i.month_end,
      i.t,
      i.qoy,
      i.bal_num,
      i.prev_bal,

      COALESCE(f.qlift_final, 1.0)::FLOAT8 AS qlift_final,
      i.ma_12,

      /* seasonally adjusted forecast from MA-12 */
      (i.ma_12 * COALESCE(f.qlift_final,1.0))::FLOAT8 AS forecast_ma12_adj,

      /* residuals and MoM */
      (i.bal_num - (i.ma_12 * COALESCE(f.qlift_final,1.0)))::FLOAT8 AS resid_ma12_adj,
      ABS(i.bal_num - (i.ma_12 * COALESCE(f.qlift_final,1.0)))::FLOAT8 AS abs_resid,

      CASE WHEN i.prev_bal IS NULL THEN NULL ELSE ABS(i.bal_num - i.prev_bal) END::FLOAT8 AS mom_abs,
      CASE
        WHEN i.prev_bal IS NULL THEN NULL
        WHEN ABS(i.prev_bal) < 1.0 THEN ABS(i.bal_num - i.prev_bal) / 1.0
        ELSE ABS(i.bal_num - i.prev_bal) / ABS(i.prev_bal)
      END::FLOAT8 AS mom_pct_abs,

      /* include if any positive in last 3 months */
      SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM idx_ma i
  LEFT JOIN lifts_final f
    ON f.RC_CODE = i.RC_CODE AND f.qoy = i.qoy
),

/* 5) RC-level means & stddevs for z-scores (per RC_CODE across time) */
rc_stats AS (
  SELECT
      RC_CODE,
      AVG(abs_resid)::FLOAT8   AS mean_abs_resid,
      STDDEV_SAMP(abs_resid)   AS sd_abs_resid,
      AVG(mom_abs)::FLOAT8     AS mean_mom_abs,
      STDDEV_SAMP(mom_abs)     AS sd_mom_abs,
      AVG(mom_pct_abs)::FLOAT8 AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs) AS sd_mom_pct
  FROM signals
  GROUP BY RC_CODE
),

/* 6) Portfolio scale for the dollar-boost component */
port_max AS (
  SELECT MAX(abs_resid) AS max_abs_resid FROM signals
)

/* 7) Final output with z-scores and severity */
SELECT
  s.RC_CODE,
  s.RC_DESCRIPTION,
  s.month_end,
  s.t,
  s.qoy,
  s.bal_num,
  s.prev_bal,

  s.qlift_final,
  s.ma_12,
  s.forecast_ma12_adj,
  s.resid_ma12_adj,
  s.abs_resid,
  s.mom_abs,
  s.mom_pct_abs,

  CASE WHEN s.pos3_count >= 1 THEN 1 ELSE 0 END AS include3_anypos,

  /* z-scores (guarded) */
  CASE WHEN r.sd_abs_resid IS NULL OR r.sd_abs_resid = 0 THEN 0
       ELSE (s.abs_resid - r.mean_abs_resid) / r.sd_abs_resid END AS z_resid,

  CASE WHEN r.sd_mom_abs IS NULL OR r.sd_mom_abs = 0 THEN 0
       ELSE (s.mom_abs - r.mean_mom_abs) / r.sd_mom_abs END       AS z_mom_abs,

  CASE WHEN r.sd_mom_pct IS NULL OR r.sd_mom_pct = 0 THEN 0
       ELSE (s.mom_pct_abs - r.mean_mom_pct) / r.sd_mom_pct END   AS z_mom_pct,

  /* severity: emphasize $ residuals, still keep unusualness and MoM spikes */
  (
    0.60 * ABS( CASE WHEN r.sd_abs_resid IS NULL OR r.sd_abs_resid = 0 THEN 0
                     ELSE (s.abs_resid - r.mean_abs_resid) / r.sd_abs_resid END )
  + 0.35 * ABS( CASE WHEN r.sd_mom_abs   IS NULL OR r.sd_mom_abs   = 0 THEN 0
                     ELSE (s.mom_abs - r.mean_mom_abs) / r.sd_mom_abs END )
  + 0.05 * ABS( CASE WHEN r.sd_mom_pct   IS NULL OR r.sd_mom_pct   = 0 THEN 0
                     ELSE (s.mom_pct_abs - r.mean_mom_pct) / r.sd_mom_pct END )
  + 0.40 * ( s.abs_resid / NULLIF(p.max_abs_resid,0) )
  )::FLOAT8 AS severity_raw_v3

FROM signals s
LEFT JOIN rc_stats r ON r.RC_CODE = s.RC_CODE
CROSS JOIN port_max p
ORDER BY s.RC_CODE, s.month_end;





/* A) Ratios vs MA_12 with quarter */
ratio_for_lifts AS (
  SELECT
      w.RC_CODE, w.RC_DESCRIPTION, w.month_end, w.bal_num, w.t,
      CEIL(EXTRACT(MONTH FROM w.month_end)/3.0)::INTEGER AS qoy,
      w.ma_6, w.ma_12, w.ma_36,
      (w.bal_num / NULLIF(w.ma_12,0.0))::FLOAT8 AS ratio_ma12
  FROM with_ma w
  WHERE w.ma_12 IS NOT NULL
),

/* B) months since (for time-decay weights) */
months_since AS (
  SELECT
      r.*,
      (
        (EXTRACT(YEAR FROM m.max_me)::INTEGER * 12 + EXTRACT(MONTH FROM m.max_me)::INTEGER)
        - (EXTRACT(YEAR FROM r.month_end)::INTEGER * 12 + EXTRACT(MONTH FROM r.month_end)::INTEGER)
      )::INTEGER AS mon_gap
  FROM ratio_for_lifts r
  CROSS JOIN max_month m
),

/* C) Get 5th/95th percentiles per RC×quarter to winsorize */
rq_p AS (
  SELECT
      RC_CODE,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INTEGER AS qoy,
      PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY ratio_ma12) AS p05,
      PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY ratio_ma12) AS p95
  FROM months_since
  GROUP BY RC_CODE, CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INTEGER
),

/* D) Winsorize ratios and apply a mild outlier weight + time-decay */
rq_winsor AS (
  SELECT
      ms.*,
      rp.p05, rp.p95,
      /* winsorized ratio */
      CASE
        WHEN ms.ratio_ma12 < rp.p05 THEN rp.p05
        WHEN ms.ratio_ma12 > rp.p95 THEN rp.p95
        ELSE ms.ratio_ma12
      END::FLOAT8 AS ratio_win,
      /* simple outlier weight: distance from median of (p05,p95) */
      /* (avoid MEDIAN/MAD; center = (p05+p95)/2, scale = (p95-p05)/2) */
      CASE
        WHEN (rp.p95 - rp.p05) = 0 THEN 1.0
        ELSE LEAST(1.0,
                   2.0 / NULLIF(ABS( (ms.ratio_ma12 - (rp.p05+rp.p95)/2.0 )
                                      / ((rp.p95 - rp.p05)/2.0) ),0.0))
      END::FLOAT8 AS w_outlier,
      /* time-decay: half-life 12 months */
      POWER(0.5, GREATEST(ms.mon_gap,0)/12.0)::FLOAT8 AS w_time
  FROM months_since ms
  JOIN rq_p rp
    ON rp.RC_CODE = ms.RC_CODE
   AND rp.qoy     = CEIL(EXTRACT(MONTH FROM ms.month_end)/3.0)::INTEGER
),

/* E) Weighted average of winsorized ratios per RC×quarter */
rq_lift_raw AS (
  SELECT
      RC_CODE,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INTEGER AS qoy,
      SUM( ratio_win * w_outlier * w_time )::FLOAT8 / NULLIF(SUM( w_outlier * w_time )::FLOAT8, 0.0) AS qlift_raw
  FROM rq_winsor
  GROUP BY RC_CODE, CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INTEGER
),

/* F) Normalize lifts to mean 1.0 per RC */
rq_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE WHEN a.avg_all IS NULL OR a.avg_all = 0 THEN 1.0
           ELSE r.qlift_raw / a.avg_all
      END::FLOAT8 AS qlift_norm
  FROM rq_lift_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_raw)::FLOAT8 AS avg_all
    FROM rq_lift_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

/* G) Shrink and cap */
lifts_final AS (
  SELECT
      n.RC_CODE,
      n.qoy,
      LEAST(1.20, GREATEST(0.80, 1.0 + 0.5*(n.qlift_norm - 1.0)))::FLOAT8 AS qlift_final
  FROM rq_norm n
),

/* H) Attach back */
joined AS (
  SELECT
      r.RC_CODE, r.RC_DESCRIPTION, r.month_end, r.bal_num, r.t,
      CEIL(EXTRACT(MONTH FROM r.month_end)/3.0)::INTEGER AS qoy,
      r.prev_bal, r.ma_6, r.ma_12, r.ma_36,
      COALESCE(f.qlift_final, 1.0)::FLOAT8 AS qlift_final
  FROM with_ma r
  LEFT JOIN lifts_final f
    ON f.RC_CODE = r.RC_CODE AND f.qoy = CEIL(EXTRACT(MONTH FROM r.month_end)/3.0)::INTEGER
)





WITH
/* =========================
   0) Base: certified month-end (Total Loans only)
   ========================= */
base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      CAST(END_OF_MONTH_DATE AS DATE)           AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8        AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Indexing, quarter-of-year, previous balance */
idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INT                AS qoy,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM base
),

/* 2) Moving averages (6/12/36) */
with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      )::FLOAT8  AS ma_6,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8  AS ma_12,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      )::FLOAT8  AS ma_36
  FROM idx
),

/* 3) Latest month in data (for time-decay) */
max_month AS (
  SELECT MAX(month_end) AS max_me FROM base
),

/* =========================
   ROBUST + ADAPTIVE QUARTERLY LIFTS (no exclusions)
   ========================= */

/* A) Ratios vs MA_12 with quarter */
ratio_for_lifts AS (
  SELECT
      w.RC_CODE, w.RC_DESCRIPTION, w.month_end, w.bal_num, w.t,
      CEIL(EXTRACT(MONTH FROM w.month_end)/3.0)::INT AS qoy,
      w.ma_6, w.ma_12, w.ma_36,
      CASE WHEN w.ma_12 IS NULL THEN NULL ELSE w.bal_num / NULLIF(w.ma_12,0.0) END::FLOAT8 AS ratio_ma12
  FROM with_ma w
  WHERE w.ma_12 IS NOT NULL
),

/* B) Months since (for time-decay weights); compute yyyymm delta */
months_since AS (
  SELECT
      r.*,
      (
        (EXTRACT(YEAR  FROM m.max_me)::INT * 12 + EXTRACT(MONTH FROM m.max_me)::INT)
        - (EXTRACT(YEAR  FROM r.month_end)::INT * 12 + EXTRACT(MONTH FROM r.month_end)::INT)
      )::INT AS mon_gap
  FROM ratio_for_lifts r
  CROSS JOIN max_month m
),

/* C) Robust center/scale per RC×quarter: MEDIAN + MAD */
rq_stats AS (
  SELECT
      RC_CODE,
      qoy,
      MEDIAN(ratio_ma12)::FLOAT8 AS med_ratio
  FROM months_since
  GROUP BY RC_CODE, qoy
),
rq_mad AS (
  SELECT
      ms.RC_CODE, ms.qoy,
      MEDIAN(ABS(ms.ratio_ma12 - s.med_ratio))::FLOAT8 AS mad_ratio
  FROM months_since ms
  JOIN rq_stats s
    ON s.RC_CODE = ms.RC_CODE AND s.qoy = ms.qoy
  GROUP BY ms.RC_CODE, ms.qoy
),

/* D) Robust z, Huber outlier weight, time-decay weight (half-life 12 months) */
rq_weighted AS (
  SELECT
      ms.*,
      s.med_ratio,
      COALESCE(m.mad_ratio, 0.0) AS mad_ratio,
      /* robust z via MAD (1.4826 ~= sigma factor) */
      CASE
        WHEN COALESCE(m.mad_ratio,0)=0 THEN 0.0
        ELSE (ms.ratio_ma12 - s.med_ratio) / (1.4826 * m.mad_ratio)
      END::FLOAT8 AS z_rob,
      /* Huber weight with c=2.0 (tunable) */
      CASE
        WHEN COALESCE(m.mad_ratio,0)=0 THEN 1.0
        ELSE LEAST(1.0, 2.0 / NULLIF(ABS((ms.ratio_ma12 - s.med_ratio) / (1.4826 * m.mad_ratio)),0.0))
      END::FLOAT8 AS w_huber,
      /* time-decay: half-life 12 months (tunable) */
      POWER(0.5, GREATEST(ms.mon_gap,0)/12.0)::FLOAT8 AS w_time
  FROM months_since ms
  JOIN rq_stats s
    ON s.RC_CODE = ms.RC_CODE AND s.qoy = ms.qoy
  LEFT JOIN rq_mad m
    ON m.RC_CODE = ms.RC_CODE AND m.qoy = ms.qoy
),

/* E) Weighted average ratio per RC×quarter (robust × adaptive) */
rq_lift_raw AS (
  SELECT
      RC_CODE,
      qoy,
      SUM( ratio_ma12 * w_huber * w_time ) / NULLIF(SUM( w_huber * w_time ),0.0) AS qlift_raw
  FROM rq_weighted
  GROUP BY RC_CODE, qoy
),

/* F) Normalize lifts across quarters to mean 1.0 per RC */
rq_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE
        WHEN a.avg_all IS NULL OR a.avg_all=0 THEN 1.0
        ELSE r.qlift_raw / a.avg_all
      END::FLOAT8 AS qlift_norm
  FROM rq_lift_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_raw)::FLOAT8 AS avg_all
    FROM rq_lift_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

/* G) Shrink toward 1.0 and cap to keep sanity */
lifts_final AS (
  SELECT
      n.RC_CODE,
      n.qoy,
      /* shrink alpha=0.5; caps [0.80, 1.20] (all tunable) */
      LEAST(1.20, GREATEST(0.80, 1.0 + 0.5*(n.qlift_norm - 1.0)))::FLOAT8 AS qlift_final
  FROM rq_norm n
),

/* H) Attach the lift to all rows */
joined AS (
  SELECT
      r.RC_CODE, r.RC_DESCRIPTION, r.month_end, r.bal_num, r.t,
      CEIL(EXTRACT(MONTH FROM r.month_end)/3.0)::INT AS qoy,
      r.prev_bal, r.ma_6, r.ma_12, r.ma_36,
      COALESCE(f.qlift_final, 1.0)::FLOAT8 AS qlift_final
  FROM with_ma r
  LEFT JOIN lifts_final f
    ON f.RC_CODE = r.RC_CODE AND f.qoy = CEIL(EXTRACT(MONTH FROM r.month_end)/3.0)::INT
),

/* =========================
   Candidate Forecasts (MA & Regression with seasonal lift)
   ========================= */

/* Regression window helpers: rolling sums (12 & 36) */
reg_feats AS (
  SELECT
    j.*,
    /* 12 months */
    COUNT(*)        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)                      AS n12,
    SUM(t)::FLOAT8  OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)                      AS sumX12,
    SUM(bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)                 AS sumY12,
    SUM(t*bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)               AS sumXY12,
    SUM(t*t)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)                     AS sumX2_12,

    /* 36 months */
    COUNT(*)        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)                      AS n36,
    SUM(t)::FLOAT8  OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)                      AS sumX36,
    SUM(bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)                 AS sumY36,
    SUM(t*bal_num)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)               AS sumXY36,
    SUM(t*t)::FLOAT8 OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)                     AS sumX2_36
  FROM joined j
),

/* Slopes/intercepts (nesting to avoid alias reuse issues) */
reg_models AS (
  SELECT
    r.*,
    /* 12 */
    (r.n12 * r.sumXY12 - r.sumX12 * r.sumY12)::FLOAT8 AS num12,
    (r.n12 * r.sumX2_12 - r.sumX12 * r.sumX12)::FLOAT8 AS den12,
    /* 36 */
    (r.n36 * r.sumXY36 - r.sumX36 * r.sumY36)::FLOAT8 AS num36,
    (r.n36 * r.sumX2_36 - r.sumX36 * r.sumX36)::FLOAT8 AS den36
  FROM reg_feats r
),
reg_final AS (
  SELECT
    rm.*,
    CASE WHEN rm.n12 >= 2 AND rm.den12 <> 0
         THEN (rm.num12 / rm.den12) ELSE NULL END::FLOAT8 AS slope12,
    CASE WHEN rm.n12 >= 1 AND rm.den12 <> 0
         THEN (rm.sumY12 / rm.n12) - ( (rm.num12 / rm.den12) * (rm.sumX12 / rm.n12) )
         ELSE NULL END::FLOAT8 AS intercept12,

    CASE WHEN rm.n36 >= 2 AND rm.den36 <> 0
         THEN (rm.num36 / rm.den36) ELSE NULL END::FLOAT8 AS slope36,
    CASE WHEN rm.n36 >= 1 AND rm.den36 <> 0
         THEN (rm.sumY36 / rm.n36) - ( (rm.num36 / rm.den36) * (rm.sumX36 / rm.n36) )
         ELSE NULL END::FLOAT8 AS intercept36
  FROM reg_models rm
),

/* Candidate forecasts (seasonally adjusted) */
candidates AS (
  SELECT
    c.*,
    (c.ma_6  * c.qlift_final)::FLOAT8                                  AS fc_ma6_adj,
    (c.ma_12 * c.qlift_final)::FLOAT8                                  AS fc_ma12_adj,
    (CASE WHEN c.slope12 IS NULL THEN NULL ELSE (c.slope12 * c.t + c.intercept12) END * c.qlift_final)::FLOAT8 AS fc_reg12_adj,
    (CASE WHEN c.slope36 IS NULL THEN NULL ELSE (c.slope36 * c.t + c.intercept36) END * c.qlift_final)::FLOAT8 AS fc_reg36_adj
  FROM reg_final c
),

/* Residuals per candidate at each row */
fit AS (
  SELECT
    a.*,
    (CASE WHEN fc_ma6_adj  IS NULL THEN NULL ELSE (bal_num - fc_ma6_adj)  END)::FLOAT8 AS resid_ma6,
    (CASE WHEN fc_ma12_adj IS NULL THEN NULL ELSE (bal_num - fc_ma12_adj) END)::FLOAT8 AS resid_ma12,
    (CASE WHEN fc_reg12_adj IS NULL THEN NULL ELSE (bal_num - fc_reg12_adj) END)::FLOAT8 AS resid_reg12,
    (CASE WHEN fc_reg36_adj IS NULL THEN NULL ELSE (bal_num - fc_reg36_adj) END)::FLOAT8 AS resid_reg36
  FROM candidates a
),

/* Rolling RMSE & SST (per window) to compute R² */
fit_agg AS (
  SELECT
    f.*,

    /* RMSE over trailing windows */
    SQRT( AVG( CASE WHEN resid_ma6  IS NULL THEN NULL ELSE resid_ma6*resid_ma6  END )
          OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 5 PRECEDING  AND CURRENT ROW) ) AS rmse_ma6,

    SQRT( AVG( CASE WHEN resid_ma12 IS NULL THEN NULL ELSE resid_ma12*resid_ma12 END )
          OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) ) AS rmse_ma12,

    SQRT( AVG( CASE WHEN resid_reg12 IS NULL THEN NULL ELSE resid_reg12*resid_reg12 END )
          OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) ) AS rmse_reg12,

    SQRT( AVG( CASE WHEN resid_reg36 IS NULL THEN NULL ELSE resid_reg36*resid_reg36 END )
          OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW) ) AS rmse_reg36,

    /* SST approximations over same windows (avg squared devs) */
    AVG( (bal_num - AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 5 PRECEDING  AND CURRENT ROW))^2 )
      OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 5 PRECEDING  AND CURRENT ROW) AS sst6,

    AVG( (bal_num - AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW))^2 )
      OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS sst12,

    AVG( (bal_num - AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW))^2 )
      OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 35 PRECEDING AND CURRENT ROW) AS sst36

  FROM fit f
),

/* R² per window (bounded) */
fit_r2 AS (
  SELECT
    fa.*,
    CASE WHEN sst6  IS NULL OR sst6  <= 0 OR rmse_ma6  IS NULL THEN NULL
         ELSE GREATEST(0.0, LEAST(1.0, 1 - (rmse_ma6  * rmse_ma6)  / sst6 )) END AS r2_ma6,
    CASE WHEN sst12 IS NULL OR sst12 <= 0 OR rmse_ma12 IS NULL THEN NULL
         ELSE GREATEST(0.0, LEAST(1.0, 1 - (rmse_ma12 * rmse_ma12) / sst12)) END AS r2_ma12,
    CASE WHEN sst12 IS NULL OR sst12 <= 0 OR rmse_reg12 IS NULL THEN NULL
         ELSE GREATEST(0.0, LEAST(1.0, 1 - (rmse_reg12 * rmse_reg12) / sst12)) END AS r2_reg12,
    CASE WHEN sst36 IS NULL OR sst36 <= 0 OR rmse_reg36 IS NULL THEN NULL
         ELSE GREATEST(0.0, LEAST(1.0, 1 - (rmse_reg36 * rmse_reg36) / sst36)) END AS r2_reg36
  FROM fit_agg fa
),

/* Portfolio MoM sigma (reference) + RC 12-mo max MoM abs */
mom_calc AS (
  SELECT
    RC_CODE, month_end, bal_num,
    ABS(bal_num - LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end))::FLOAT8 AS mom_abs
  FROM base
),
portfolio_mom_sigma AS (
  SELECT STDDEV_SAMP(mom_abs) AS sigma_mom FROM mom_calc WHERE mom_abs IS NOT NULL
),
rc_vol AS (
  SELECT
    f.*,
    MAX(ABS(bal_num - LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end)))
      OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS max_mom_abs_12
  FROM fit_r2 f
),

/* History length & sigma join */
chosen AS (
  SELECT
    v.*,
    COUNT(*) OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS month_count,
    p.sigma_mom
  FROM rc_vol v
  CROSS JOIN portfolio_mom_sigma p
),

/* Decision tree → best_method + forecast_selected */
decided AS (
  SELECT
    c.*,
    CASE
      WHEN month_count < 6  THEN 'MA6'
      WHEN month_count < 12 THEN 'MA6'
      WHEN month_count < 24 AND (max_mom_abs_12 IS NOT NULL AND COALESCE(c.sigma_mom,0) > 0 AND max_mom_abs_12 > 3.0 * c.sigma_mom)
        THEN 'MA12'
      WHEN month_count < 24 THEN 'REG12'
      WHEN month_count >= 24 AND (max_mom_abs_12 IS NOT NULL AND COALESCE(c.sigma_mom,0) > 0 AND max_mom_abs_12 > 3.0 * c.sigma_mom)
        THEN ( CASE WHEN COALESCE(rmse_ma12,9e99) <= COALESCE(rmse_ma6,9e99) THEN 'MA12' ELSE 'MA6' END )
      ELSE
        CASE
          WHEN COALESCE(r2_reg36,-1) > COALESCE(r2_reg12,-1) THEN 'REG36'
          WHEN COALESCE(r2_reg12,-1) >= COALESCE(r2_reg36,-1) THEN 'REG12'
          WHEN COALESCE(rmse_reg36,9e99) < COALESCE(rmse_reg12,9e99) THEN 'REG36'
          ELSE 'REG12'
        END
    END AS best_method,

    CASE
      WHEN month_count < 6  THEN fc_ma6_adj
      WHEN month_count < 12 THEN fc_ma6_adj
      WHEN month_count < 24 AND (max_mom_abs_12 IS NOT NULL AND COALESCE(c.sigma_mom,0) > 0 AND max_mom_abs_12 > 3.0 * c.sigma_mom)
        THEN fc_ma12_adj
      WHEN month_count < 24 THEN fc_reg12_adj
      WHEN month_count >= 24 AND (max_mom_abs_12 IS NOT NULL AND COALESCE(c.sigma_mom,0) > 0 AND max_mom_abs_12 > 3.0 * c.sigma_mom)
        THEN ( CASE WHEN COALESCE(rmse_ma12,9e99) <= COALESCE(rmse_ma6,9e99) THEN fc_ma12_adj ELSE fc_ma6_adj END )
      ELSE
        CASE
          WHEN COALESCE(r2_reg36,-1) > COALESCE(r2_reg12,-1) THEN fc_reg36_adj
          WHEN COALESCE(r2_reg12,-1) >= COALESCE(r2_reg36,-1) THEN fc_reg12_adj
          WHEN COALESCE(rmse_reg36,9e99) < COALESCE(rmse_reg12,9e99) THEN fc_reg36_adj
          ELSE fc_reg12_adj
        END
    END::FLOAT8 AS forecast_selected
  FROM chosen c
),

/* Activity flag (any positive in last 3 months), MoM %, Severity inputs */
signals AS (
  SELECT
      d.*,

      /* residual vs selected forecast */
      (d.bal_num - d.forecast_selected)::FLOAT8 AS resid_selected,
      ABS(d.bal_num - d.forecast_selected)::FLOAT8 AS abs_resid,

      /* MoM $ and % */
      CASE WHEN d.prev_bal IS NULL THEN NULL ELSE ABS(d.bal_num - d.prev_bal) END::FLOAT8 AS mom_abs,
      CASE
        WHEN d.prev_bal IS NULL THEN NULL
        WHEN ABS(d.prev_bal) < 1.0 THEN ABS(d.bal_num - d.prev_bal) / 1.0
        ELSE ABS(d.bal_num - d.prev_bal) / ABS(d.prev_bal)
      END::FLOAT8 AS mom_pct_abs,

      /* sign flip flag */
      CASE WHEN d.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN d.prev_bal<0 THEN -1 WHEN d.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN d.bal_num <0 THEN -1 WHEN d.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END AS sign_flip,

      /* include if any positive in last 3 months */
      SUM(CASE WHEN d.bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY d.RC_CODE ORDER BY d.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM decided d
),

/* RC-level stats for Z-scores */
rc_stats AS (
  SELECT
      RC_CODE,
      AVG(ABS(resid_selected))::FLOAT8 AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_selected)) AS sd_abs_resid,
      AVG(mom_abs)::FLOAT8             AS mean_mom_abs,
      STDDEV_SAMP(mom_abs)             AS sd_mom_abs,
      AVG(mom_pct_abs)::FLOAT8         AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs)         AS sd_mom_pct
  FROM signals
  GROUP BY RC_CODE
),

/* Final severity components (dollar-impact focused) */
scored AS (
  SELECT
      s.*,
      r.mean_abs_resid, r.sd_abs_resid,
      r.mean_mom_abs,   r.sd_mom_abs,
      r.mean_mom_pct,   r.sd_mom_pct,

      /* Z-scores (guarded) */
      CASE WHEN r.sd_abs_resid IS NULL OR r.sd_abs_resid = 0 THEN 0
           ELSE (ABS(s.resid_selected) - r.mean_abs_resid) / r.sd_abs_resid END AS z_resid,

      CASE WHEN r.sd_mom_abs IS NULL OR r.sd_mom_abs = 0 THEN 0
           ELSE (s.mom_abs - r.mean_mom_abs) / r.sd_mom_abs END                 AS z_mom_abs,

      CASE WHEN r.sd_mom_pct IS NULL OR r.sd_mom_pct = 0 THEN 0
           ELSE (s.mom_pct_abs - r.mean_mom_pct) / r.sd_mom_pct END             AS z_mom_pct
  FROM signals s
  LEFT JOIN rc_stats r
    ON r.RC_CODE = s.RC_CODE
),

/* Portfolio max |residual| for dollar-normalized severity */
port_max AS (
  SELECT MAX(ABS(resid_selected)) AS max_abs_resid FROM scored
)

/* =========================
   FINAL RESULT
   ========================= */
SELECT
  a.RC_CODE,
  a.RC_DESCRIPTION,
  a.month_end,
  a.t,
  a.qoy,
  a.bal_num,
  a.prev_bal,

  /* Robust seasonal lift used */
  a.qlift_final,

  /* Candidate forecasts (seasonally adjusted) */
  a.fc_ma6_adj, a.fc_ma12_adj, a.fc_reg12_adj, a.fc_reg36_adj,

  /* Rolling fit metrics per window */
  a.rmse_ma6, a.rmse_ma12, a.rmse_reg12, a.rmse_reg36,
  a.r2_ma6,   a.r2_ma12,   a.r2_reg12,   a.r2_reg36,

  /* Model choice */
  a.month_count,
  a.max_mom_abs_12,
  a.sigma_mom,
  a.best_method,
  a.forecast_selected,

  /* Anomaly signals */
  b.resid_selected,
  b.abs_resid,
  b.mom_abs,
  b.mom_pct_abs,
  b.z_resid,
  b.z_mom_abs,
  b.z_mom_pct,
  CASE WHEN b.pos3_count >= 1 THEN 1 ELSE 0 END AS include3_anypos,
  b.sign_flip,

  /* Dollar-impact focused severity (hybrid): 60% $resid (Z), 35% MoM$ (Z), 5% MoM% (Z),
     plus a global dollar scale so huge misses always surface */
  (
    0.60 * ABS(b.z_resid)
  + 0.35 * ABS(b.z_mom_abs)
  + 0.05 * ABS(b.z_mom_pct)
  + 0.40 * ( ABS(b.resid_selected) / NULLIF(pm.max_abs_resid,0) )  -- global $ scale boost
  )::FLOAT8 AS severity_raw_v3

FROM decided a
JOIN scored  b ON b.RC_CODE = a.RC_CODE AND b.month_end = a.month_end
CROSS JOIN port_max pm
ORDER BY a.RC_CODE, a.month_end;





R² (Latest, Active) :=
VAR sse = [SSE (Latest, Active)]
VAR sst = [SST (Latest, Active)]
RETURN IF ( sst > 0, MAX ( 0, MIN ( 1, 1 - sse / sst ) ), BLANK () )





SSE (Latest, Active) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    [SSE (Portfolio)],
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
)

SST (Latest, Active) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    [SST (Portfolio)],
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
)

R² (Latest, Active) :=
VAR sse = [SSE (Latest, Active)]
VAR sst = [SST (Latest, Active)]
RETURN IF ( sst > 0, MAX ( 0, MIN ( 1, 1 - sse / sst ) ), BLANK () )

RMSE (Latest, Active) :=
VAR lm = [Latest Month]
VAR n =
    CALCULATE (
        COUNTROWS ( VALUES ( T[RC_CODE] ) ),
        T[include3_anypos] = 1,
        FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
    )
VAR sse = [SSE (Latest, Active)]
RETURN IF ( n > 0, SQRT ( sse / n ), BLANK () )

WAPE (Latest, Active) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    [WAPE (Portfolio)],
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
)







-- Current latest certified month-end (from your Date table)
Latest Month :=
CALCULATE ( MAX ( 'Date'[MonthEnd] ), ALL ( 'Date' ) )

-- Actual & Forecast (respect current filter context)
Actual :=
SUM ( T[bal_num] )

Forecast :=
SUM ( T[forecast_ma12_adj] )

Residual :=
[Actual] - [Forecast]





-- Sum of squared errors (∑ residual_i^2)
SSE (Portfolio) :=
SUMX (
    VALUES ( T[RC_CODE] ),
    VAR r = CALCULATE ( [Residual] )
    RETURN r * r
)

-- Mean actual across the RCs in the same context
Mean Actual (Context) :=
AVERAGEX (
    VALUES ( T[RC_CODE] ),
    CALCULATE ( [Actual] )
)

-- Total variance vs that mean (∑ (actual_i - mean)^2)
SST (Portfolio) :=
VAR mu = [Mean Actual (Context)]
RETURN
SUMX (
    VALUES ( T[RC_CODE] ),
    VAR a = CALCULATE ( [Actual] )
    RETURN ( a - mu ) ^ 2
)

-- R² = 1 - SSE/SST (bounded and safe)
R² (Portfolio) :=
VAR sse = [SSE (Portfolio)]
VAR sst = [SST (Portfolio)]
RETURN
IF ( sst > 0, MAX ( 0, MIN ( 1, 1 - sse / sst ) ), BLANK () )

-- RMSE across RCs in context = sqrt(SSE / N)
RMSE (Portfolio) :=
VAR n = COUNTROWS ( VALUES ( T[RC_CODE] ) )
VAR sse = [SSE (Portfolio)]
RETURN IF ( n > 0, SQRT ( sse / n ), BLANK () )

-- WAPE (exposure-weighted MAPE) = ∑|A-F| / ∑|A|
WAPE (Portfolio) :=
DIVIDE (
    SUMX ( VALUES ( T[RC_CODE] ), ABS ( CALCULATE ( [Residual] ) ) ),
    SUMX ( VALUES ( T[RC_CODE] ), ABS ( CALCULATE ( [Actual] ) ) )
)

-- sMAPE (symmetric MAPE), averaged across RCs
sMAPE (Portfolio) :=
AVERAGEX (
    VALUES ( T[RC_CODE] ),
    VAR a = CALCULATE ( [Actual] )
    VAR f = CALCULATE ( [Forecast] )
    VAR denom = ABS ( a ) + ABS ( f )
    RETURN IF ( denom > 0, 2 * ABS ( a - f ) / denom, BLANK () )
)







Flagged Systems (Trend, Hard 70) :=
VAR thr = 70
RETURN
CALCULATE(
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[include3_anypos] = 1,
    FILTER ( VALUES ( T[RC_CODE] ), [Severity (0-100)] >= thr )
)





Flagged Exposure (Trend, Hard 70) :=
VAR thr = 70
RETURN
CALCULATE(
    SUM ( T[bal_num] ),
    T[include3_anypos] = 1,
    FILTER ( VALUES ( T[RC_CODE] ), [Severity (0-100)] >= thr )
)





Largest Residual $ (Latest) :=
VAR lm =
    [Latest Month]
RETURN
MAXX (
    FILTER ( ALL ( T ), EOMONTH ( T[month_end], 0 ) = lm ),
    ABS ( T[abs_resid] )
)





Largest Residual $ (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    MAX ( ABS ( T[abs_resid] ) ),
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
)






P95 Severity Raw :=
PERCENTILEX.INC ( ALLSELECTED ( T ), T[severity_raw_v3], 0.95 )

Severity (0-100) :=
VAR p95 = [P95 Severity Raw]
VAR raw = MAX ( T[severity_raw_v3] )
RETURN IF ( p95 > 0, 100 * MIN ( raw / p95, 1 ), BLANK () )



Active Systems (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[include3_anypos] = 1,
    T[month_end] = lm
)



Active Systems (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm )
)



Flagged Systems (Latest, Hard 70) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm ),
    FILTER ( VALUES ( T[RC_CODE] ), [Severity (0-100)] >= 70 )
)



% Systems Flagged (Latest, Hard 70) :=
DIVIDE ( [Flagged Systems (Latest, Hard 70)], [Active Systems (Latest)] )




Flagged Exposure (Latest, Hard 70) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( T[bal_num] ),
    T[include3_anypos] = 1,
    FILTER ( ALL ( T[month_end] ), EOMONTH ( T[month_end], 0 ) = lm ),
    FILTER ( VALUES ( T[RC_CODE] ), [Severity (0-100)] >= 70 )
)










Latest Month :=
CALCULATE ( MAX ( Date[MonthEnd] ), ALL ( Date ) )



P95 Severity Raw :=
PERCENTILEX.INC ( ALLSELECTED ( T ), T[severity_raw_v3], 0.95 )

Severity (0-100) :=
VAR p95 = [P95 Severity Raw]
VAR raw = MAX ( T[severity_raw_v3] )
RETURN IF ( p95 > 0, 100 * MIN ( raw / p95, 1 ), BLANK () )

Active Systems (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[month_end] = lm,
    T[include3_anypos] = 1
)





Date =
VAR MinEOM =
    MINX ( ALL ( T ), T[month_end] )
VAR MaxEOM =
    MAXX ( ALL ( T ), T[month_end] )
RETURN
ADDCOLUMNS (
    CALENDAR ( MinEOM, MaxEOM ),
    "Year", YEAR ( [Date] ),
    "MonthNum", MONTH ( [Date] ),
    "MonthName", FORMAT ( [Date], "MMM" ),
    "Quarter", "Q" & ROUNDUP ( MONTH ( [Date] ) / 3, 0 ),
    "MonthEnd", EOMONTH ( [Date], 0 ),
    "YearMonth", FORMAT ( [Date], "YYYY-MM" ),
    "MonthEndSort", YEAR ( EOMONTH ( [Date], 0 ) ) * 100 + MONTH ( EOMONTH ( [Date], 0 ) ),
    "IsMonthEnd", IF ( [Date] = EOMONTH ( [Date], 0 ), 1, 0 )
)






DimMonth :=
VAR StartMonthEnd =
    EOMONTH ( MINX ( ALL ( T ), T[month_end] ), 0 )
VAR EndMonthEnd =
    EOMONTH ( MAXX ( ALL ( T ), T[month_end] ), 0 )
VAR DailyCalendar =
    ADDCOLUMNS (
        CALENDAR ( StartMonthEnd, EndMonthEnd ),
        "MonthEnd", EOMONTH ( [Date], 0 )
    )
RETURN
SUMMARIZE (
    DailyCalendar,
    [MonthEnd],
    "MonthStart", DATE ( YEAR ( [MonthEnd] ), MONTH ( [MonthEnd] ), 1 ),
    "Year",       YEAR ( [MonthEnd] ),
    "MonthNum",   MONTH ( [MonthEnd] ),
    "Quarter",    "Q" & ROUNDUP ( MONTH ( [MonthEnd] ) / 3, 0 ),
    "YearMonth",  FORMAT ( [MonthEnd], "YYYY-MM" ),
    "MonthName",  FORMAT ( [MonthEnd], "MMM" ),
    "MonthEndSort", YEAR ( [MonthEnd] ) * 100 + MONTH ( [MonthEnd] )
)






P95 Severity Raw :=
PERCENTILEX.INC (
    ALLSELECTED ( T ),
    T[severity_raw_v3],
    0.95
)




Severity (0-100) :=
VAR p95 = [P95 Severity Raw]
VAR raw = MAX ( T[severity_raw_v3] )
RETURN
IF ( p95 > 0, 100 * MIN ( raw / p95, 1 ), BLANK () )



Flagged Exposure (Latest, Hard 70) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    SUM ( T[bal_num] ),
    T[month_end] = lm,
    T[include3_anypos] = 1,
    FILTER ( VALUES ( T[RC_CODE] ), [Severity (0-100)] >= 70 )
)






Active Systems (Latest) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[month_end] = lm,
    T[include3_anypos] = 1
)



Total Exposure (Latest, Active) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    SUM ( T[bal_num] ),
    T[month_end] = lm,
    T[include3_anypos] = 1
)




Flagged Systems (Latest, Hard 70) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[month_end] = lm,
    T[include3_anypos] = 1,
    [Severity (0-100)] >= 70   -- hard-coded threshold
)




% Systems Flagged (Latest, Hard 70) :=
DIVIDE ( [Flagged Systems (Latest, Hard 70)], [Active Systems (Latest)] )




Flagged Exposure (Latest, Hard 70) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    SUM ( T[bal_num] ),
    T[month_end] = lm,
    T[include3_anypos] = 1,
    [Severity (0-100)] >= 70
)




Active Systems (Latest) :=
VAR lm = CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[RC_CODE] ),
    T[month_end] = lm,
    T[include3_anypos] = 1
)







-- Latest certified month-end in the current model
Latest Month :=
CALCULATE ( MAX ( T[month_end] ), ALL ( T ) )

-- 95th percentile cap for severity scaling
P95 Severity Raw :=
PERCENTILEX.INC ( ALLSELECTED ( T ), T[severity_raw_v3], 0.95 )

-- 0–100 severity (scaled by P95)
Severity (0-100) :=
VAR p95 = [P95 Severity Raw]
VAR raw = AVERAGE ( T[severity_raw_v3] )
RETURN IF ( p95 <= 0, BLANK (), 100 * MIN ( raw / p95, 1 ) )

-- Optional what-if parameter (create a What-If parameter named 'Severity Threshold'
-- or fallback to 70 if not present)
Severity Threshold (Value) :=
SELECTEDVALUE ( 'Severity Threshold'[Severity Threshold Value], 70 )






WITH
-- Optional: codes that are structurally negative; leave empty (LIMIT 0) if not needed
rc_struct_neg AS (
  SELECT '___PUT_CODE_HERE___'::VARCHAR(100) AS rc_code, 1 AS is_struct_neg
  LIMIT 0
),

/* 1) Base: certified EOM + Total Loans */
base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      CAST(END_OF_MONTH_DATE AS DATE)           AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8        AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 2) Per-RC month index and quarter-of-year */
idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INT                AS qoy
  FROM base
),

/* 3) Previous balance */
with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),

/* 4) Moving averages (6/12/36) in FLOAT8 */
with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_12,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_6,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_36
  FROM with_lags
),

/* 5) Ratio vs MA_12 to estimate quarter lifts (seasonality) */
ratio_for_lifts AS (
  SELECT
      RC_CODE, RC_DESCRIPTION, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE WHEN ma_12 IS NULL THEN NULL
           ELSE bal_num / NULLIF(ma_12, 0.0)
      END::FLOAT8 AS ratio_ma12
  FROM with_ma
),

/* 6) Quarter lifts per RC_CODE × QoY (raw) */
q_lifts_raw AS (
  SELECT
      RC_CODE, qoy,
      AVG(ratio_ma12)::FLOAT8 AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),

/* 7) Normalize quarter lifts to mean 1.00 per RC_CODE */
q_lifts_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE WHEN a.avg_all IS NULL OR a.avg_all = 0.0 THEN 1.0::FLOAT8
           ELSE r.qlift_ma12_raw / a.avg_all
      END AS qlift_ma12_norm
  FROM q_lifts_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_ma12_raw)::FLOAT8 AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

/* 8) Attach normalized lifts */
joined AS (
  SELECT
      f.*,
      COALESCE(l.qlift_ma12_norm, 1.0)::FLOAT8 AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE AND l.qoy = f.qoy
),

/* 9) Signals: forecast (MA12 adj), residual, MoM $ / %, sign flip, active-3 */
signals AS (
  SELECT
      j.*,

      /* Seasonally adjusted MA-12 forecast */
      (j.ma_12 * j.qlift_ma12_norm)::FLOAT8                 AS forecast_ma12_adj,

      /* Residual ($); also store absolute for convenience */
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm))::FLOAT8   AS resid_ma12_adj,

      /* Absolute MoM $ change */
      CASE WHEN j.prev_bal IS NULL THEN NULL
           ELSE ABS(j.bal_num - j.prev_bal)
      END::FLOAT8                                           AS mom_abs,

      /* Absolute MoM % (epsilon=1.0 to avoid blow-ups on tiny prev) */
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1.0 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END::FLOAT8                                           AS mom_pct_abs,

      /* Sign flip (kept for context; not used in severity below) */
      CASE WHEN j.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN j.prev_bal<0 THEN -1 WHEN j.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN j.bal_num <0 THEN -1 WHEN j.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END                                AS sign_flip,

      /* Active in last 3 months: any positive in the rolling 3-window */
      SUM(CASE WHEN j.bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY j.RC_CODE ORDER BY j.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM joined j
),

/* 10) Structural negatives (optional) */
with_struct AS (
  SELECT
      s.*,
      COALESCE(rsn.is_struct_neg, 0) AS is_struct_neg
  FROM signals s
  LEFT JOIN rc_struct_neg rsn
    ON UPPER(TRIM(rsn.rc_code)) = UPPER(TRIM(s.RC_CODE))
),

/* 11) Per-RC stats (means/SDs) for z-scores */
stats AS (
  SELECT
      RC_CODE,
      AVG(ABS(resid_ma12_adj))::FLOAT8 AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_ma12_adj)) AS sd_abs_resid,
      AVG(mom_abs)::FLOAT8             AS mean_mom_abs,
      STDDEV_SAMP(mom_abs)             AS sd_mom_abs,
      AVG(mom_pct_abs)::FLOAT8         AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs)         AS sd_mom_pct
  FROM with_struct
  GROUP BY RC_CODE
)

/* 12) Final output */
SELECT
    w.RC_CODE,
    w.RC_DESCRIPTION,
    w.month_end,
    w.t,
    w.qoy,
    w.bal_num,
    w.prev_bal,

    /* Forecast + raw signals */
    w.forecast_ma12_adj,
    w.resid_ma12_adj,
    ABS(w.resid_ma12_adj) AS abs_resid,   -- (1) absolute $ residual
    w.mom_abs,                            -- (2) absolute MoM $ change
    w.mom_pct_abs,                        -- (4) absolute MoM % change (least important)
    w.sign_flip,
    CASE WHEN w.pos3_count >= 1 THEN 1 ELSE 0 END AS include3_anypos,

    /* Per-RC reference stats */
    s.mean_abs_resid,
    s.sd_abs_resid,
    s.mean_mom_abs,
    s.sd_mom_abs,
    s.mean_mom_pct,
    s.sd_mom_pct,

    /* (3) Z-scores */
    CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
         ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid) / s.sd_abs_resid END AS z_resid,

    CASE WHEN s.sd_mom_abs IS NULL OR s.sd_mom_abs = 0 THEN 0
         ELSE (w.mom_abs - s.mean_mom_abs) / s.sd_mom_abs END                 AS z_mom_abs,

    CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
         ELSE (w.mom_pct_abs - s.mean_mom_pct) / s.sd_mom_pct END             AS z_mom_pct,

    /* Dollar-impact severity (resid $ and MoM $ emphasized; MoM % light) */
    ( 0.60*ABS(
        CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
             ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid)/s.sd_abs_resid END
      )
    + 0.35*ABS(
        CASE WHEN s.sd_mom_abs IS NULL OR s.sd_mom_abs = 0 THEN 0
             ELSE (w.mom_abs - s.mean_mom_abs)/s.sd_mom_abs END
      )
    + 0.05*ABS(
        CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
             ELSE (w.mom_pct_abs - s.mean_mom_pct)/s.sd_mom_pct END
      )
    )::FLOAT8 AS severity_raw_v2

FROM with_struct w
LEFT JOIN stats s
  ON s.RC_CODE = w.RC_CODE
ORDER BY w.RC_CODE, w.month_end;






WITH
-- Optional list of RC_CODEs that are structurally negative (leave empty to ignore)
rc_struct_neg AS (
  SELECT '___PUT_CODE_HERE___'::VARCHAR(100) AS rc_code, 1 AS is_struct_neg
  LIMIT 0
),

/* 1) Base: certified month-end + aggregated balance (Total Loans only) */
base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      CAST(END_OF_MONTH_DATE AS DATE)           AS month_end,   -- certified EOM
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8        AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'       -- << requested filter
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 2) Per-RC indexing and quarter-of-year (1..4) */
idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INT                AS qoy
  FROM base
),

/* 3) Previous balance (for MoM%) */
with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),

/* 4) Moving averages (6/12/36) */
with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_12,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_6,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_36
  FROM with_lags
),

/* 5) Ratio vs MA_12 for quarterly seasonality lifts */
ratio_for_lifts AS (
  SELECT
      RC_CODE, RC_DESCRIPTION, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE
        WHEN ma_12 IS NULL THEN NULL
        ELSE bal_num / NULLIF(ma_12, 0.0)
      END::FLOAT8 AS ratio_ma12
  FROM with_ma
),

/* 6) Quarter lifts (raw) per RC_CODE × QoY */
q_lifts_raw AS (
  SELECT
      RC_CODE, qoy,
      AVG(ratio_ma12)::FLOAT8 AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),

/* 7) Normalize quarter lifts to mean 1.00 per RC_CODE */
q_lifts_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE
        WHEN a.avg_all IS NULL OR a.avg_all = 0.0 THEN 1.0::FLOAT8
        ELSE r.qlift_ma12_raw / a.avg_all
      END AS qlift_ma12_norm
  FROM q_lifts_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_ma12_raw)::FLOAT8 AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

/* 8) Attach normalized lifts */
joined AS (
  SELECT
      f.*,
      COALESCE(l.qlift_ma12_norm, 1.0)::FLOAT8 AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE
   AND l.qoy     = f.qoy
),

/* 9) Signals: forecast, residual, MoM%, sign flip */
signals AS (
  SELECT
      j.*,
      (j.ma_12 * j.qlift_ma12_norm)::FLOAT8                 AS forecast_ma12_adj,
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm))::FLOAT8   AS resid_ma12_adj,
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1.0 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END::FLOAT8                                           AS mom_pct_abs,
      CASE WHEN j.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN j.prev_bal<0 THEN -1 WHEN j.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN j.bal_num <0 THEN -1 WHEN j.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END                                AS sign_flip
  FROM joined j
),

/* 10) Active-in-last-3: any positive balance in the last 3 months window */
active3 AS (
  SELECT
      s.*,
      SUM(CASE WHEN bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM signals s
),

/* 11) Structural negatives (optional) */
with_struct AS (
  SELECT
      a.*,
      COALESCE(rsn.is_struct_neg, 0) AS is_struct_neg
  FROM active3 a
  LEFT JOIN rc_struct_neg rsn
    ON UPPER(TRIM(rsn.rc_code)) = UPPER(TRIM(a.RC_CODE))
),

/* 12) Per-RC stats for z-scores */
stats AS (
  SELECT
      RC_CODE,
      AVG(ABS(resid_ma12_adj))::FLOAT8 AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_ma12_adj)) AS sd_abs_resid,
      AVG(mom_pct_abs)::FLOAT8         AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs)         AS sd_mom_pct
  FROM with_struct
  GROUP BY RC_CODE
)

/* 13) Final output */
SELECT
    w.RC_CODE,
    w.RC_DESCRIPTION,
    w.month_end,
    w.t,
    w.qoy,
    w.bal_num,
    w.prev_bal,
    w.ma_6, w.ma_12, w.ma_36,
    w.qlift_ma12_norm,
    w.forecast_ma12_adj,
    w.resid_ma12_adj,
    w.mom_pct_abs,
    CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END AS sign_flip,
    CASE WHEN w.pos3_count >= 1 THEN 1 ELSE 0 END           AS include3_anypos,

    s.mean_abs_resid,
    s.sd_abs_resid,
    s.mean_mom_pct,
    s.sd_mom_pct,

    /* Row-level Z-scores with guards */
    CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
         ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid) / s.sd_abs_resid END AS z_resid,

    CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
         ELSE (w.mom_pct_abs - s.mean_mom_pct) / s.sd_mom_pct END            AS z_mom,

    /* Severity (raw): 0.7*|z_resid| + 0.3*|z_mom| + 0.25*flip */
    (0.7*ABS(
        CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
             ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid)/s.sd_abs_resid END
     )
     +
     0.3*ABS(
        CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
             ELSE (w.mom_pct_abs - s.mean_mom_pct)/s.sd_mom_pct END
     )
     +
     0.25*(CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END)
    )::FLOAT8 AS severity_raw
FROM with_struct w
LEFT JOIN stats s
  ON s.RC_CODE = w.RC_CODE
ORDER BY w.RC_CODE, w.month_end;





WITH
-- Optional: list RC_CODEs expected to be structurally negative (overdraft/chargeoff).
-- Leave empty (LIMIT 0) if you don't want to use this feature now.
rc_struct_neg AS (
  SELECT '___PUT_CODE_HERE___'::VARCHAR(100) AS rc_code, 1 AS is_struct_neg
  LIMIT 0
),

/* 1) Base: certified month-end and aggregated balance */
base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      CAST(END_OF_MONTH_DATE AS DATE)           AS month_end,   -- use certified EOM date
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8        AS bal_num      -- cast early to float8
  FROM V_SECURE_PORTFOLIO_LOANHUB_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 2) Indexing per RC + quarter-of-year (1..4) */
idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INT                AS qoy
  FROM base
),

/* 3) Lag for MoM */
with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),

/* 4) Moving averages (6/12/36) */
with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_12,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_6,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      )::FLOAT8 AS ma_36
  FROM with_lags
),

/* 5) Ratio vs MA_12 for quarter lifts (seasonality) */
ratio_for_lifts AS (
  SELECT
      RC_CODE, RC_DESCRIPTION, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE
        WHEN ma_12 IS NULL THEN NULL
        ELSE bal_num / NULLIF(ma_12, 0.0)
      END::FLOAT8 AS ratio_ma12
  FROM with_ma
),

/* 6) Quarter lifts (raw) per RC_CODE × QoY */
q_lifts_raw AS (
  SELECT
      RC_CODE, qoy,
      AVG(ratio_ma12)::FLOAT8 AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),

/* 7) Normalize quarter lifts to mean 1.00 per RC_CODE */
q_lifts_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE
        WHEN a.avg_all IS NULL OR a.avg_all = 0.0 THEN 1.0::FLOAT8
        ELSE r.qlift_ma12_raw / a.avg_all
      END AS qlift_ma12_norm
  FROM q_lifts_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_ma12_raw)::FLOAT8 AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

/* 8) Attach normalized lifts */
joined AS (
  SELECT
      f.*,
      COALESCE(l.qlift_ma12_norm, 1.0)::FLOAT8 AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE
   AND l.qoy     = f.qoy
),

/* 9) Signals: forecast, residual, MoM%, sign flip */
signals AS (
  SELECT
      j.*,
      (j.ma_12 * j.qlift_ma12_norm)::FLOAT8                 AS forecast_ma12_adj,
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm))::FLOAT8   AS resid_ma12_adj,
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1.0 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END::FLOAT8                                           AS mom_pct_abs,
      CASE WHEN j.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN j.prev_bal<0 THEN -1 WHEN j.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN j.bal_num <0 THEN -1 WHEN j.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END                                AS sign_flip
  FROM joined j
),

/* 10) Active-in-last-3 (any positive in the 3-month window) */
active3 AS (
  SELECT
      s.*,
      SUM(CASE WHEN bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM signals s
),

/* 11) Optional structural negatives */
with_struct AS (
  SELECT
      a.*,
      COALESCE(rsn.is_struct_neg, 0) AS is_struct_neg
  FROM active3 a
  LEFT JOIN rc_struct_neg rsn
    ON UPPER(TRIM(rsn.rc_code)) = UPPER(TRIM(a.RC_CODE))
),

/* 12) Per-RC stats for z-scores */
stats AS (
  SELECT
      RC_CODE,
      AVG(ABS(resid_ma12_adj))::FLOAT8 AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_ma12_adj)) AS sd_abs_resid,
      AVG(mom_pct_abs)::FLOAT8         AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs)         AS sd_mom_pct
  FROM with_struct
  GROUP BY RC_CODE
)

/* 13) Final output */
SELECT
    w.RC_CODE,
    w.RC_DESCRIPTION,
    w.month_end,
    w.t,
    w.qoy,
    w.bal_num,
    w.prev_bal,
    w.ma_6, w.ma_12, w.ma_36,
    w.qlift_ma12_norm,
    w.forecast_ma12_adj,
    w.resid_ma12_adj,
    w.mom_pct_abs,
    CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END AS sign_flip,   -- suppress flip penalty for structural negatives
    CASE WHEN w.pos3_count >= 1 THEN 1 ELSE 0 END           AS include3_anypos,

    s.mean_abs_resid,
    s.sd_abs_resid,
    s.mean_mom_pct,
    s.sd_mom_pct,

    /* Z-scores (guard against sd=0) */
    CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
         ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid) / s.sd_abs_resid END AS z_resid,

    CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
         ELSE (w.mom_pct_abs - s.mean_mom_pct) / s.sd_mom_pct END            AS z_mom,

    /* Severity (raw): 0.7*|z_resid| + 0.3*|z_mom| + 0.25*flip */
    (0.7*ABS(
        CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
             ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid)/s.sd_abs_resid END
     )
     +
     0.3*ABS(
        CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
             ELSE (w.mom_pct_abs - s.mean_mom_pct)/s.sd_mom_pct END
     )
     +
     0.25*(CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END)
    )::FLOAT8 AS severity_raw
FROM with_struct w
LEFT JOIN stats s
  ON s.RC_CODE = w.RC_CODE
ORDER BY w.RC_CODE, w.month_end;





WITH
rc_struct_neg AS (
  -- optional; leave empty if not used
  SELECT '___PUT_CODE_HERE___'::VARCHAR(100) AS rc_code, 1 AS is_struct_neg
  LIMIT 0
),

base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      DATE_TRUNC('month', END_OF_MONTH_DATE)::DATE AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8          AS bal_num        -- cast to float8 early
  FROM V_SECURE_PORTFOLIO_LOANHUB_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
  GROUP BY RC_CODE, RC_DESCRIPTION, DATE_TRUNC('month', END_OF_MONTH_DATE)
),

idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end)   AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)::INT                  AS qoy   -- 1..4
  FROM base
),

with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),

with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)::FLOAT8 AS ma_12,
      AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5  PRECEDING AND CURRENT ROW)::FLOAT8 AS ma_6,
      AVG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW)::FLOAT8 AS ma_36
  FROM with_lags
),

ratio_for_lifts AS (
  SELECT
      RC_CODE, RC_DESCRIPTION, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE
        WHEN ma_12 IS NULL THEN NULL
        ELSE bal_num / NULLIF(ma_12,0.0)            -- safe divide
      END::FLOAT8 AS ratio_ma12
  FROM with_ma
),

q_lifts_raw AS (
  SELECT
      RC_CODE, qoy,
      AVG(ratio_ma12)::FLOAT8 AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),

q_lifts_norm AS (
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE WHEN a.avg_all IS NULL OR a.avg_all = 0.0 THEN 1.0::FLOAT8
           ELSE r.qlift_ma12_raw / a.avg_all
      END AS qlift_ma12_norm
  FROM q_lifts_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_ma12_raw)::FLOAT8 AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

joined AS (
  SELECT
      f.*,
      COALESCE(l.qlift_ma12_norm, 1.0)::FLOAT8 AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE AND l.qoy = f.qoy
),

signals AS (
  SELECT
      j.*,
      (j.ma_12 * j.qlift_ma12_norm)::FLOAT8                         AS forecast_ma12_adj,
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm))::FLOAT8           AS resid_ma12_adj,
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1.0 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END::FLOAT8                                                   AS mom_pct_abs,
      CASE WHEN j.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN j.prev_bal<0 THEN -1 WHEN j.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN j.bal_num <0 THEN -1 WHEN j.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END                                        AS sign_flip
  FROM joined j
),

active3 AS (
  SELECT
      s.*,
      SUM(CASE WHEN bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM signals s
),

with_struct AS (
  SELECT
      a.*,
      COALESCE(rsn.is_struct_neg, 0) AS is_struct_neg
  FROM active3 a
  LEFT JOIN rc_struct_neg rsn
    ON UPPER(TRIM(rsn.rc_code)) = UPPER(TRIM(a.RC_CODE))
),

stats AS (
  SELECT
      RC_CODE,
      AVG(ABS(resid_ma12_adj))::FLOAT8  AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_ma12_adj))  AS sd_abs_resid,   -- float8 because resid is float8
      AVG(mom_pct_abs)::FLOAT8          AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs)          AS sd_mom_pct
  FROM with_struct
  GROUP BY RC_CODE
)

SELECT
    w.RC_CODE,
    w.RC_DESCRIPTION,
    w.month_end,
    w.t,
    w.qoy,
    w.bal_num,
    w.prev_bal,
    w.ma_6, w.ma_12, w.ma_36,
    w.qlift_ma12_norm,
    w.forecast_ma12_adj,
    w.resid_ma12_adj,
    w.mom_pct_abs,
    CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END AS sign_flip,
    CASE WHEN w.pos3_count >= 1 THEN 1 ELSE 0 END          AS include3_anypos,

    s.mean_abs_resid,
    s.sd_abs_resid,
    s.mean_mom_pct,
    s.sd_mom_pct,

    CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
         ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid) / s.sd_abs_resid END AS z_resid,

    CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
         ELSE (w.mom_pct_abs - s.mean_mom_pct) / s.sd_mom_pct END            AS z_mom,

    (0.7*ABS(
        CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
             ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid)/s.sd_abs_resid END
     )
     +
     0.3*ABS(
        CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
             ELSE (w.mom_pct_abs - s.mean_mom_pct)/s.sd_mom_pct END
     )
     +
     0.25*(CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END)
    )::FLOAT8 AS severity_raw
FROM with_struct w
LEFT JOIN stats s
  ON s.RC_CODE = w.RC_CODE
ORDER BY w.RC_CODE, w.month_end;





WITH
-- (optional) list RC_CODEs expected to be structurally negative (overdraft/chargeoff)
rc_struct_neg AS (
  SELECT '___PUT_CODE_HERE___'::VARCHAR(100) AS rc_code, 1 AS is_struct_neg
  UNION ALL SELECT '___EXAMPLE2___', 1
  -- Or keep empty; later join will default to 0
),

base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      DATE_TRUNC('month', END_OF_MONTH_DATE)::DATE AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)                   AS bal_num
  FROM V_SECURE_PORTFOLIO_LOANHUB_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
  GROUP BY RC_CODE, RC_DESCRIPTION, DATE_TRUNC('month', END_OF_MONTH_DATE)
),

idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end)             AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)                                  AS qoy  -- 1..4 quarter-of-year
  FROM base
),

with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),

with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      ) AS ma_12,

      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      ) AS ma_6,

      AVG(bal_num) OVER (
        PARTITION BY RC_CODE ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      ) AS ma_36
  FROM with_lags
),

ratio_for_lifts AS (
  -- Use MA_12 as seasonal baseline to estimate quarter lifts
  SELECT
      RC_CODE, RC_DESCRIPTION, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE WHEN ma_12 IS NULL OR ma_12 = 0 THEN NULL ELSE bal_num / ma_12 END AS ratio_ma12
  FROM with_ma
),

q_lifts_raw AS (
  SELECT
      RC_CODE, qoy,
      AVG(ratio_ma12) AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),

q_lifts_norm AS (
  -- Normalize lifts so the average over 4 quarters = 1.0 per RC_CODE
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE
        WHEN a.avg_all IS NULL OR a.avg_all = 0 THEN 1.0
        ELSE r.qlift_ma12_raw / a.avg_all
      END AS qlift_ma12_norm
  FROM q_lifts_raw r
  JOIN (
    SELECT RC_CODE, AVG(qlift_ma12_raw) AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a ON a.RC_CODE = r.RC_CODE
),

joined AS (
  SELECT
      f.*,
      COALESCE(l.qlift_ma12_norm, 1.0) AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE AND l.qoy = f.qoy
),

signals AS (
  SELECT
      j.*,
      -- Seasonally adjusted MA-12 forecast
      (j.ma_12 * j.qlift_ma12_norm)                                 AS forecast_ma12_adj,

      -- Residual (actual - forecast)
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm))                   AS resid_ma12_adj,

      -- Absolute MoM % with epsilon=1 to avoid div/0 when |prev|<1
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END                                                          AS mom_pct_abs,

      -- Sign function (avoid SIGN() portability issues)
      CASE WHEN j.prev_bal IS NULL THEN 0
           WHEN (CASE WHEN j.prev_bal<0 THEN -1 WHEN j.prev_bal>0 THEN 1 ELSE 0 END)
              <> (CASE WHEN j.bal_num <0 THEN -1 WHEN j.bal_num >0 THEN 1 ELSE 0 END)
           THEN 1 ELSE 0 END                                       AS sign_flip
  FROM joined j
),

active3 AS (
  -- "Include if ANY of last 3 months had positive balance"
  SELECT
      s.*,
      SUM(CASE WHEN bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM signals s
),

with_struct AS (
  SELECT
      a.*,
      COALESCE(rsn.is_struct_neg, 0) AS is_struct_neg
  FROM active3 a
  LEFT JOIN rc_struct_neg rsn
    ON UPPER(TRIM(rsn.rc_code)) = UPPER(TRIM(a.RC_CODE))
),

stats AS (
  -- Per-RC_CODE means/SDs for |residual| and MoM%
  SELECT
      RC_CODE,
      AVG(ABS(resid_ma12_adj)) AS mean_abs_resid,
      STDDEV_SAMP(ABS(resid_ma12_adj)) AS sd_abs_resid,
      AVG(mom_pct_abs) AS mean_mom_pct,
      STDDEV_SAMP(mom_pct_abs) AS sd_mom_pct
  FROM with_struct
  GROUP BY RC_CODE
)

SELECT
    w.RC_CODE,
    w.RC_DESCRIPTION,
    w.month_end,
    w.t,
    w.qoy,
    w.bal_num,
    w.prev_bal,
    w.ma_6, w.ma_12, w.ma_36,
    w.qlift_ma12_norm,
    w.forecast_ma12_adj,
    w.resid_ma12_adj,
    w.mom_pct_abs,
    CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END AS sign_flip,  -- suppress flip penalty if structurally negative
    CASE WHEN w.pos3_count >= 1 THEN 1 ELSE 0 END AS include3_anypos,

    -- Per-RC stats
    s.mean_abs_resid,
    s.sd_abs_resid,
    s.mean_mom_pct,
    s.sd_mom_pct,

    -- Z-scores (guard against sd=0)
    CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
         ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid) / s.sd_abs_resid END AS z_resid,

    CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
         ELSE (w.mom_pct_abs - s.mean_mom_pct) / s.sd_mom_pct END            AS z_mom,

    -- Severity_Raw = 0.7*|z_resid| + 0.3*|z_mom| + 0.25*sign_flip (tunable)
    (0.7*ABS(
        CASE WHEN s.sd_abs_resid IS NULL OR s.sd_abs_resid = 0 THEN 0
             ELSE (ABS(w.resid_ma12_adj) - s.mean_abs_resid)/s.sd_abs_resid END
     )
     +
     0.3*ABS(
        CASE WHEN s.sd_mom_pct IS NULL OR s.sd_mom_pct = 0 THEN 0
             ELSE (w.mom_pct_abs - s.mean_mom_pct)/s.sd_mom_pct END
     )
     +
     0.25* (CASE WHEN w.is_struct_neg=1 THEN 0 ELSE w.sign_flip END)
    ) AS severity_raw
FROM with_struct w
LEFT JOIN stats s
  ON s.RC_CODE = w.RC_CODE
ORDER BY w.RC_CODE, w.month_end;





CREATE OR REPLACE VIEW rc_base_with_signals AS
WITH base AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      DATE_TRUNC('month', END_OF_MONTH_DATE)::date AS month_end,
      SUM(SOURCE_SYSTEM_BALANCE)                    AS bal_num
  FROM V_SECURE_PORTFOLIO_LOANHUB_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
  GROUP BY RC_CODE, RC_DESCRIPTION, DATE_TRUNC('month', END_OF_MONTH_DATE)
),
idx AS (
  SELECT
      RC_CODE,
      RC_DESCRIPTION,
      month_end,
      bal_num,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t,
      CEIL(EXTRACT(MONTH FROM month_end)/3.0)                      AS qoy
  FROM base
),
with_lags AS (
  SELECT
      *,
      LAG(bal_num) OVER (PARTITION BY RC_CODE ORDER BY month_end) AS prev_bal
  FROM idx
),
with_ma AS (
  SELECT
      *,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE
        ORDER BY month_end
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
      ) AS ma_12,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE
        ORDER BY month_end
        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
      ) AS ma_6,
      AVG(bal_num) OVER (
        PARTITION BY RC_CODE
        ORDER BY month_end
        ROWS BETWEEN 35 PRECEDING AND CURRENT ROW
      ) AS ma_36
  FROM with_lags
),
ratio_for_lifts AS (
  -- Use MA_12 as the seasonal baseline; build ratios by RC_CODE × quarter-of-year
  SELECT
      RC_CODE, month_end, bal_num, prev_bal, t, qoy,
      ma_6, ma_12, ma_36,
      CASE WHEN ma_12 IS NULL OR ma_12 = 0 THEN NULL ELSE bal_num / ma_12 END AS ratio_ma12
  FROM with_ma
),
q_lifts_raw AS (
  SELECT
      RC_CODE,
      qoy,
      AVG(ratio_ma12) AS qlift_ma12_raw
  FROM ratio_for_lifts
  WHERE ratio_ma12 IS NOT NULL
  GROUP BY RC_CODE, qoy
),
q_lifts_norm AS (
  -- Normalize quarter lifts to mean 1.00 per RC_CODE
  SELECT
      r.RC_CODE,
      r.qoy,
      CASE
        WHEN avg_all = 0 OR avg_all IS NULL THEN 1.0
        ELSE r.qlift_ma12_raw / avg_all
      END AS qlift_ma12_norm
  FROM (
    SELECT RC_CODE, AVG(qlift_ma12_raw) AS avg_all
    FROM q_lifts_raw
    GROUP BY RC_CODE
  ) a
  JOIN q_lifts_raw r
    ON a.RC_CODE = r.RC_CODE
),
joined AS (
  SELECT
      f.RC_CODE,
      f.RC_DESCRIPTION,
      f.month_end,
      f.t,
      f.qoy,
      f.bal_num,
      f.prev_bal,
      f.ma_6, f.ma_12, f.ma_36,
      COALESCE(l.qlift_ma12_norm, 1.0) AS qlift_ma12_norm
  FROM ratio_for_lifts f
  LEFT JOIN q_lifts_norm l
    ON l.RC_CODE = f.RC_CODE
   AND l.qoy     = f.qoy
),
final AS (
  SELECT
      j.*,
      -- Seasonally adjusted MA_12 forecast
      (j.ma_12 * j.qlift_ma12_norm) AS forecast_ma12_adj,

      -- Residual (actual - forecast)
      (j.bal_num - (j.ma_12 * j.qlift_ma12_norm)) AS resid_ma12_adj,

      -- Absolute MoM % (with epsilon to avoid div/0)
      CASE
        WHEN j.prev_bal IS NULL THEN NULL
        WHEN ABS(j.prev_bal) < 1 THEN ABS(j.bal_num - j.prev_bal) / 1.0
        ELSE ABS(j.bal_num - j.prev_bal) / ABS(j.prev_bal)
      END AS mom_pct_abs,

      -- Sign flip (1 if sign changes; 0 otherwise)
      CASE
        WHEN j.prev_bal IS NULL THEN 0
        WHEN SIGN(j.prev_bal) <> SIGN(j.bal_num) THEN 1
        ELSE 0
      END AS sign_flip
  FROM joined j
),
active AS (
  -- "Active in last 3 months" = any positive balance in window of current & 2 prev months
  SELECT
      f.*,
      SUM(CASE WHEN bal_num > 0 THEN 1 ELSE 0 END)
        OVER (PARTITION BY RC_CODE ORDER BY month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        AS pos3_count
  FROM final f
)
SELECT
    RC_CODE,
    RC_DESCRIPTION,
    month_end,
    t,
    qoy,
    bal_num,
    prev_bal,
    ma_6, ma_12, ma_36,
    qlift_ma12_norm,
    forecast_ma12_adj,
    resid_ma12_adj,
    mom_pct_abs,
    sign_flip,
    CASE WHEN pos3_count >= 1 THEN 1 ELSE 0 END AS include3_anypos
FROM active;







DECLARE @CUST_LINE_NBR VARCHAR(50) = '<<PUT_LINE_NUMBER_HERE>>';

WITH target_dates AS (
    SELECT CAST('2024-06-30' AS date) AS loaddt UNION ALL
    SELECT CAST('2024-09-30' AS date) UNION ALL
    SELECT CAST('2024-12-31' AS date)
),
creditline AS (
    SELECT
        cl.LOADDT,
        cl.CUST_LINE_NBR,
        CAST(NULL AS VARCHAR(100)) AS ACCTNBR,
        cl.AMORTIZED_COST_BASIS,
        CAST(NULL AS DECIMAL(38, 6)) AS DERIVED_AMORTIZED_COST_BASIS,
        'CREDITLINE' AS SOURCE_TYPE
    FROM CRDADMPRD.dbo.CDM_CREDITLINES_ALL_TOPSIDED cl
    INNER JOIN target_dates d
        ON cl.LOADDT = d.loaddt
    WHERE cl.CUST_LINE_NBR = @CUST_LINE_NBR
),
instrument AS (
    SELECT
        i.LOADDT,
        i.CUST_LINE_NBR,
        i.ACCTNBR,
        i.AMORTIZED_COST_BASIS,
        i.DERIVED_AMORTIZED_COST_BASIS,
        'INSTRUMENT' AS SOURCE_TYPE
    FROM CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED i
    INNER JOIN target_dates d
        ON i.LOADDT = d.loaddt
    WHERE i.CUST_LINE_NBR = @CUST_LINE_NBR
),
combined AS (
    SELECT * FROM creditline
    UNION ALL
    SELECT * FROM instrument
)
SELECT
    c.LOADDT,
    c.CUST_LINE_NBR,
    c.ACCTNBR,
    c.SOURCE_TYPE,
    c.AMORTIZED_COST_BASIS,
    c.DERIVED_AMORTIZED_COST_BASIS,

    /* 1) Sum of Amortized_Cost_Basis from BOTH tables, per CUST_LINE_NBR × LOADDT */
    SUM(COALESCE(c.AMORTIZED_COST_BASIS, 0.0))
        OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT) AS SUM_AMORTIZED_COST_BASIS_ALL_SOURCES,

    /* 2) Sum of (Instruments.DERIVED_AMORTIZED_COST_BASIS) + (Creditlines.AMORTIZED_COST_BASIS),
          per CUST_LINE_NBR × LOADDT */
    (
        /* instruments' DERIVED_... */
        SUM(CASE WHEN c.SOURCE_TYPE = 'INSTRUMENT'
                 THEN COALESCE(c.DERIVED_AMORTIZED_COST_BASIS, 0.0) ELSE 0.0 END)
            OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT)
        +
        /* creditlines' AMORTIZED_... */
        SUM(CASE WHEN c.SOURCE_TYPE = 'CREDITLINE'
                 THEN COALESCE(c.AMORTIZED_COST_BASIS, 0.0) ELSE 0.0 END)
            OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT)
    ) AS SUM_DERIVED_INSTR_PLUS_AMORT_CREDITLINE
FROM combined c
ORDER BY c.LOADDT, c.SOURCE_TYPE, c.ACCTNBR;




DECLARE @CUST_LINE_NBR VARCHAR(50) = '<<PUT_LINE_NUMBER_HERE>>';

WITH target_dates AS (
    SELECT CAST('2024-06-30' AS date) AS loaddt UNION ALL
    SELECT CAST('2024-09-30' AS date) UNION ALL
    SELECT CAST('2024-12-31' AS date)
),
creditline AS (
    SELECT
        cl.LOADDT,
        cl.CUST_LINE_NBR,
        /* Handle possible misspelling: prefer correct name, else fallback */
        COALESCE(cl.AMORTIZED_COST_BASIS, cl.ANORTIZED_COST_BASIS) AS AMORTIZED_COST_BASIS,
        CAST(NULL AS VARCHAR(100)) AS ACCTNBR,
        CAST(NULL AS DECIMAL(38, 6)) AS DERIVED_AMORTIZED_COST_BASIS,
        'CREDITLINE' AS SOURCE_TYPE
    FROM [CRDADMPRD].[dbo].[CDM_CREDITLINES_TOPSIDED] cl
    INNER JOIN target_dates d
        ON cl.LOADDT = d.loaddt
    WHERE cl.CUST_LINE_NBR = @CUST_LINE_NBR
),
instrument AS (
    SELECT
        i.LOADDT,
        i.CUST_LINE_NBR,
        CAST(NULL AS DECIMAL(38, 6)) AS AMORTIZED_COST_BASIS,
        i.ACCTNBR,
        i.DERIVED_AMORTIZED_COST_BASIS,
        'INSTRUMENT' AS SOURCE_TYPE
    FROM [CRDADMPRD].[dbo].[CDM_INSTRUMENTS_ALL_TOPSIDED] i
    INNER JOIN target_dates d
        ON i.LOADDT = d.loaddt
    WHERE i.CUST_LINE_NBR = @CUST_LINE_NBR
),
combined AS (
    SELECT * FROM creditline
    UNION ALL
    SELECT * FROM instrument
)
SELECT
    c.LOADDT,
    c.CUST_LINE_NBR,
    c.ACCTNBR,
    c.SOURCE_TYPE,
    c.AMORTIZED_COST_BASIS,
    c.DERIVED_AMORTIZED_COST_BASIS,

    /* Total across BOTH sources for this CUST_LINE_NBR × LOADDT */
    SUM(COALESCE(c.AMORTIZED_COST_BASIS, 0) + COALESCE(c.DERIVED_AMORTIZED_COST_BASIS, 0))
        OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT) AS TOTAL_AMORTIZED_COST_BASIS_ALL_SOURCES,

    /* Same total, but only displayed on the CREDITLINE rows */
    CASE WHEN c.SOURCE_TYPE = 'CREDITLINE' THEN
        SUM(COALESCE(c.AMORTIZED_COST_BASIS, 0) + COALESCE(c.DERIVED_AMORTIZED_COST_BASIS, 0))
            OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT)
    END AS TOTAL_AMORTIZED_COST_BASIS_AT_CREDITLINE_LEVEL,

    /* Explicit sum: (Creditline AMORTIZED_COST_BASIS) + (Instruments DERIVED_AMORTIZED_COST_BASIS),
       computed at the CUST_LINE_NBR × LOADDT level and shown only on CREDITLINE rows. */
    CASE WHEN c.SOURCE_TYPE = 'CREDITLINE' THEN
        /* Sum only the creditline contribution */
        SUM(COALESCE(c.AMORTIZED_COST_BASIS, 0))
            OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT)
        +
        /* Plus the instruments contribution */
        SUM(COALESCE(c.DERIVED_AMORTIZED_COST_BASIS, 0))
            OVER (PARTITION BY c.CUST_LINE_NBR, c.LOADDT)
    END AS CREDITLINE_PLUS_INSTRUMENT_BASIS_AT_CREDITLINE_LEVEL

FROM combined c
ORDER BY c.LOADDT, c.SOURCE_TYPE, c.ACCTNBR;







=LET(
  rc, [@RC_CODE],
  mask, (T[RC_CODE]=rc)*(ISNUMBER(T[AbsResidual])),
  n,   SUMPRODUCT(--mask),
  vals, N(T[AbsResidual]),
  s,   SUMPRODUCT(--mask, vals),
  ss,  SUMPRODUCT(--mask, vals^2),
  IF(n>1, SQRT( (n*ss - s^2) / (n*(n-1)) ), 0)






=LET(
  rc,[@RC_CODE],
  n,  COUNTIFS(T[RC_CODE],rc),
  s,  SUMIFS(T[AbsResidual],T[RC_CODE],rc),
  ss, SUMPRODUCT((T[RC_CODE]=rc)*(T[AbsResidual]^2)),
  IF(n>1, SQRT((n*ss - s^2)/(n*(n-1))), NA())
)





SELECT
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE,

    /* Month index per RC_CODE (for regression) */
    ROW_NUMBER() OVER (
        PARTITION BY RC_CODE
        ORDER BY END_OF_MONTH_DATE
    ) AS t,

    /* Sequential quarter index per RC_CODE (keeps increasing: 1,2,3,4,5,...) */
    CEIL(
        ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY END_OF_MONTH_DATE) / 3.0
    ) AS q_seq,

    /* Quarter-of-year 1..4 (use this for seasonality) */
    CEIL(EXTRACT(MONTH FROM END_OF_MONTH_DATE) / 3.0) AS qoy,

    SUM(SOURCE_SYSTEM_BALANCE) AS BAL_num
FROM V_SECURE_PORTFOLIO_LOANHUB_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
GROUP BY
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE
ORDER BY
    RC_CODE,
    END_OF_MONTH_DATE;





1. Review of the Quarter

Let’s start by reflecting on the past quarter:
	•	Career & Projects – Did you make meaningful progress on the corporate dashboards, anomaly detection, and model performance KPIs? Any new wins in automating processes or creating impactful visualizations?
	•	Side Hustles – How many PuckIQ posts did you get live? Did you experiment with reels or content calendars? Did EnduroFacts move forward at all?
	•	Trading & Finance – How did your core/satellite portfolio perform? Did you stick to your rebalancing rules? How did your futures trading go (bull flag strategy + ATR stops)?
	•	Fitness & Health – Were you consistent with triathlon training or hockey? Any new PRs or habits?
	•	Relationships & Lifestyle – Did you and Sharon make progress on Costa Rica/elopement plans, wedding planning, or quality time goals?
	•	Spirituality & Inner Peace – Have you added reflection, journaling, or mindfulness into your routine?

⸻

2. Alignment Check

Ask yourself:
	•	Are these actions moving you toward your 5-year vision (entrepreneurial freedom, healthy body/mind, strong relationships)?
	•	Which areas feel most in alignment? (e.g., health and relationships)
	•	Which feel out of alignment or underinvested? (e.g., career fulfillment, spirituality)

⸻

3. Next-Quarter Goals

We can then set SMART goals (specific, measurable, achievable, relevant, time-bound). Here are examples based on what I know about you:
	•	Career: Deliver a fully functional, two-page Power BI dashboard (with R², RMSE, MoM trends, system SD bands). Automate data pulls where possible.
	•	Side Hustles: Publish 4–6 PuckIQ posts, experiment with first reel, and capture 20+ email leads via opt-in.
	•	Trading/Finance: Execute at least 20 backtested trades with strict risk management. Reassess satellite holdings and rebalance if drift >5%.
	•	Fitness: Maintain 4–5 workouts/week, including hockey skill work and at least one brick session for triathlon.
	•	Relationships: Finalize Costa Rica lodging and vendors, set April 2026 save-the-dates.
	•	Personal Growth: Daily 5-min mindfulness practice, monthly journaling on alignment.

⸻

4. Metrics & Check-Ins
	•	Monthly Review: Brief check-in each month on each pillar — green/yellow/red score.
	•	Quarter-End: Do another deep-dive like this one and adjust for next quarter.






SELECT
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE,
    
    -- Numeric month index (t)
    ROW_NUMBER() OVER (
        PARTITION BY RC_CODE
        ORDER BY END_OF_MONTH_DATE
    ) AS t,

    -- Quarter number within each RC_CODE’s timeline
    CEIL(
        ROW_NUMBER() OVER (
            PARTITION BY RC_CODE
            ORDER BY END_OF_MONTH_DATE
        ) / 3.0
    ) AS q,

    SUM(SOURCE_SYSTEM_BALANCE) AS BAL_num
FROM V_SECURE_PORTFOLIO_LOANHUB_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
GROUP BY
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE
ORDER BY
    RC_CODE,
    END_OF_MONTH_DATE;







SELECT
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE,
    -- create numeric month index (optional, for Excel t_num)
    ROW_NUMBER() OVER (
        PARTITION BY RC_CODE
        ORDER BY END_OF_MONTH_DATE
    ) AS t_num,
    SUM(SOURCE_SYSTEM_BALANCE) AS BAL_num
FROM V_SECURE_PORTFOLIO_LOANHUB_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
GROUP BY
    RC_CODE,
    RC_DESCRIPTION,
    END_OF_MONTH_DATE
ORDER BY
    RC_CODE,
    END_OF_MONTH_DATE;





-- SSE per cohort/system
SSE :=
SUMX ( T, T[Residual_Final] * T[Residual_Final] )

-- Mean per cohort/system (context-sensitive)
MeanCohortSystem :=
AVERAGE ( T[BAL_num] )

-- SST per cohort/system
SST :=
SUMX ( T, ( T[BAL_num] - [MeanCohortSystem] ) ^ 2 )

-- R²
R2 :=
VAR sst = [SST]
RETURN IF ( sst = 0, BLANK(), 1 - DIVIDE( [SSE], sst ) )





-- 1) Actual & Forecast lines (use SUM or AVERAGE as you do today)
Actual :=
SUM ( T[BAL_num] )

Forecast :=
SUM ( T[Forecast_Final] )

-- 2) One SD per system, fixed across the chart (computed from residuals)
Residual_SD_System_Fixed :=
VAR sys = SELECTEDVALUE ( T[System_key] )
RETURN
IF (
    ISBLANK ( sys ),
    BLANK(),
    CALCULATE (
        STDEVX.S ( 
            FILTER ( T, T[System_key] = sys && NOT ISBLANK ( T[Residual_Final] ) ),
            T[Residual_Final]
        ),
        REMOVEFILTERS ( DimMonth )   -- ignore month so SD stays constant across the line
    )
)

-- 3) ±2σ band around Forecast
Band_Upper := [Forecast] + 2 * [Residual_SD_System_Fixed]
Band_Lower := [Forecast] - 2 * [Residual_SD_System_Fixed]

-- (optional) Build a shaded band with stacked areas:
Band_Base  := [Band_Lower]
Band_Width := [Band_Upper] - [Band_Lower]








DimMonth =
VAR MinMonth = MINX ( ALL ( T ), T[MonthStart] )
VAR MaxMonth = MAXX ( ALL ( T ), T[MonthStart] )
VAR Base =
    ADDCOLUMNS (
        CALENDAR ( MinMonth, MaxMonth ),
        "MonthStart", DATE ( YEAR ( [Date] ), MONTH ( [Date] ), 1 ),
        "MonthEnd",   EOMONTH ( [Date], 0 ),
        "Year",       YEAR ( [Date] ),
        "MonthName",  FORMAT ( [Date], "MMMM" ),
        "YearMonth",  FORMAT ( [Date], "YYYY-MM" )
    )
RETURN
SELECTCOLUMNS (
    Base,
    "MonthStart", [MonthStart],
    "MonthEnd",   [MonthEnd],
    "Year",       [Year],
    "MonthName",  [MonthName],
    "YearMonth",  [YearMonth]
)





DimMonth =
VAR MinMonth =
    CALCULATE ( MIN ( DATE ( YEAR ( T[MonthStart] ), MONTH ( T[MonthStart] ), 1 ) ), ALL ( T ) )
VAR MaxMonth =
    CALCULATE ( MAX ( DATE ( YEAR ( T[MonthStart] ), MONTH ( T[MonthStart] ), 1 ) ), ALL ( T ) )
RETURN
ADDCOLUMNS (
    CALENDAR ( MinMonth, EOMONTH ( MaxMonth, 0 ) ),
    "MonthStart", DATE ( YEAR ( [Date] ), MONTH ( [Date] ), 1 ),
    "MonthEnd",   EOMONTH ( [Date], 0 ),
    "Year",       YEAR ( [Date] ),
    "Month",      FORMAT ( [Date], "MMMM" ),
    "YearMonth",  FORMAT ( [Date], "YYYY-MM" )
)





let
  Source = T,
  Typed =
    Table.TransformColumnTypes(
      Source,
      {
        {"System_key", type text},
        {"t_num", Int64.Type},
        {"Severity", type number},
        {"Cohort", type text}
      }
    ),
  SeverityThreshold = 70,
  AddedFlag =
    Table.AddColumn(Typed, "Flagged",
      each if [Severity] >= SeverityThreshold then 1 else 0,
      Int64.Type),

  LatestMonth = List.Max( AddedFlag[t_num] ),
  LatestOnly  = Table.SelectRows( AddedFlag, each [t_num] = LatestMonth ),

  Grouped =
    Table.Group(
      LatestOnly,
      {"Cohort"},
      {
        {"FlaggedSystems",
          each List.Count( List.Distinct( Table.SelectRows(_, each [Flagged]=1)[System_key] ) ),
          Int64.Type},
        {"TotalSystems",
          each List.Count( List.Distinct( _[System_key] ) ),
          Int64.Type}
      }
    ),

  WithPct =
    Table.AddColumn(
      Grouped, "Pct_Systems_Flagged",
      each if [TotalSystems]=0 then 0 else Number.From([FlaggedSystems]) / Number.From([TotalSystems]),
      type number
    )
in
  WithPct





let
  Source = #"T",
  Typed =
    Table.TransformColumnTypes(
      Source,
      {
        {"System_key", type text},
        {"t_num", Int64.Type},
        {"Severity", type number},
        {"Cohort", type text}
      }
    ),
  AddedFlag =
    Table.AddColumn(Typed, "Flagged",
      each if [Severity] >= 70 then 1 else 0,
      Int64.Type),

  LatestMonth = List.Max( AddedFlag[t_num] ),
  LatestOnly  = Table.SelectRows( AddedFlag, each [t_num] = LatestMonth ),

  // Group by Cohort; inside each group count distinct systems and distinct flagged systems
  Grouped =
    Table.Group(
      LatestOnly,
      {"Cohort"},
      {
        {"FlaggedSystems", each List.Count( List.Distinct( Table.SelectRows(_, each [Flagged]=1)[System_key] ) ), Int64.Type},
        {"TotalSystems",   each List.Count( List.Distinct( _[System_key] ) ), Int64.Type}
      }
    ),

  WithPct =
    Table.AddColumn(
      Grouped, "Pct_Systems_Flagged",
      each if [TotalSystems]=0 then 0 else Number.From([FlaggedSystems]) / Number.From([TotalSystems]),
      type number
    )
in
  WithPct






let
  // 0) Source: reference your existing table/query
  Source = #"T",

  // 1) Ensure types are correct (adjust names/types to match your columns)
  Typed =
    Table.TransformColumnTypes(
      Source,
      {
        {"System_key", type text},
        {"t_num", Int64.Type},
        {"Severity", type number}
      }
    ),

  // 2) Add a numeric Flag column (1 if Severity >= 70, else 0)
  AddedFlag =
    Table.AddColumn(
      Typed, "Flagged",
      each if [Severity] >= 70 then 1 else 0,
      Int64.Type
    ),

  // 3) Find the latest month (from rows that actually exist)
  LatestMonth = List.Max( AddedFlag[t_num] ),

  // 4) Filter to latest month only
  LatestOnly =
    Table.SelectRows( AddedFlag, each [t_num] = LatestMonth ),

  // 5) Distinct counts at latest month
  DistinctSystemsLatest = List.Count( List.Distinct( LatestOnly[System_key] ) ),
  DistinctFlaggedLatest =
    List.Count( List.Distinct(
      Table.SelectRows(LatestOnly, each [Flagged] = 1)[System_key]
    )),

  // 6) Percent (safe divide)
  Pct_Systems_Flagged =
    if DistinctSystemsLatest = 0
    then 0
    else Number.From(DistinctFlaggedLatest) / Number.From(DistinctSystemsLatest),

  // 7) Return a tiny 1-row table you can use as a KPI source
  Out =
    #table(
      type table [t_num=Int64.Type, FlaggedSystems=Int64.Type, TotalSystems=Int64.Type, Pct_Systems_Flagged=number],
      { { LatestMonth, DistinctFlaggedLatest, DistinctSystemsLatest, Pct_Systems_Flagged } }
    )
in
  Out





= Table.AddColumn(T, "Flagged", each if [Severity] >= 70 then 1 else 0, Int64.Type)

= Table.Group(
    #"Added Flagged",
    {"t_num"},
    {
      {"FlaggedSystems",
        each List.Count(List.Distinct(
               Table.SelectRows(_, each [Flagged]=1)[System_key] )),
        Int64.Type},
      {"TotalSystems",
        each List.Count(List.Distinct(_[System_key])),
        Int64.Type}
    }
)


= Table.AddColumn(#"Grouped Rows", "Pct_Systems_Flagged",
    each if [TotalSystems]=0 then 0 else Number.From([FlaggedSystems])/[TotalSystems],
    type number)


= Table.SelectRows(#"Added Pct", each [t_num] = List.Max(#"Added Pct"[t_num]))







Pct_Systems_Flagged :=
VAR latest_t =
    MAX ( T[t_num] )                     -- latest month within current filters
VAR vt_latest =
    FILTER (
        ALLSELECTED ( T ),               -- respect page slicers (cohort, region, etc.)
        T[t_num] = latest_t
    )
VAR flaggedSystemsAtLatest :=
    CALCULATE (
        DISTINCTCOUNT ( T[System_key] ),
        vt_latest,
        T[Severity] >= 70                -- or use T[Severity_Flag] IN {"High","Critical"}
    )
VAR totalSystemsAtLatest :=
    CALCULATE (
        DISTINCTCOUNT ( T[System_key] ),
        vt_latest
    )
RETURN
DIVIDE ( flaggedSystemsAtLatest, totalSystemsAtLatest, 0 )




-- 2) # systems flagged at that latest month (respects slicers)
Systems_Flagged :=
VAR latest = [Latest_t_in_context]
RETURN
CALCULATE (
    DISTINCTCOUNT ( T[System_key] ),
    KEEPFILTERS ( T[t_num] = latest ),
    KEEPFILTERS ( T[Severity] >= 70 )   -- or use T[Severity_Flag] IN {"High","Critical"}
)



-- 3) % of systems flagged (denominator = total systems at that latest month in current context)
Pct_Systems_Flagged :=
VAR latest = [Latest_t_in_context]
VAR totalAtLatest :=
    CALCULATE (
        DISTINCTCOUNT ( T[System_key] ),
        KEEPFILTERS ( T[t_num] = latest )
    )
RETURN
DIVIDE ( [Systems_Flagged], totalAtLatest, 0 )







Systems_Flagged :=
CALCULATE (
    DISTINCTCOUNT ( T[System_key] ),
    FILTER (
        ALL ( T ),
        T[t_num] = [Latest_t]
            && T[Severity] >= 70      -- or use a flag column if you prefer
    )
)



Pct_Systems_Flagged :=
VAR totalSystemsAtLatest =
    CALCULATE (
        DISTINCTCOUNT ( T[System_key] ),
        FILTER ( ALL ( T ), T[t_num] = [Latest_t] )
    )
RETURN
DIVIDE ( [Systems_Flagged], totalSystemsAtLatest, 0 )





System | Cohort | BestWindow | R²_Reg_Selected | R²_MA | ΔR² | RMSE_Reg_Selected | RMSE_MA | ΔRMSE | MAPE_Reg | MAPE_MA | ΔMAPE |






Q1_Lift_6 :=
AVERAGEIFS(
  t[Residual_6],
  t[System_key],[@System_key],
  t[q],1,
  t[t_num],">="&[@Latest_t]-5, t[t_num],"<="&[@Latest_t]
)

Q2_Lift_6 := (same, with t[q]=2)
Q3_Lift_6 := (same, with t[q]=3)
Q4_Lift_6 := (same, with t[q]=4)





=IFERROR(
  RSQ(
    FILTER(t[BAL_num], (t[System_key]=[@System_key])*(t[t_num]>=[@Latest_t]-5)*(t[t_num]<=[@Latest_t])),
    FILTER(t[t_num],   (t[System_key]=[@System_key])*(t[t_num]>=[@Latest_t]-5)*(t[t_num]<=[@Latest_t]))
  ),
  NA()
)




System_key	Latest_t	n_6	sumX_6	sumY_6	sumXY_6	sumX2_6	sumY2_6	denom_6	slope_6	intercept_6	r_6	R2_6
AL	68.00	6	393	4294854040.04	237531760195.50	25759.00	2208937195310310000.00	17.50	-2501781681.55	164582509148.18	#NUM!	





=IF(
  [@n_6]<2,
  NA(),
  LET(
    n,[@n_6],
    sx,[@sumX_6], sy,[@sumY_6], sxy,[@sumXY_6],
    sx2,[@sumX2_6], sy2,[@sumY2_6],
    varX, MAX(n*sx2 - sx^2, 0),
    varY, MAX(n*sy2 - sy^2, 0),
    num, (n*sxy - sx*sy)^2,
    den, varX * varY,
    IF(den=0, NA(), num / den)
  )
)




R2_6 :=
IF(
  OR([@n_6]<2),
  NA(),
  LET(
    n,[@n_6],
    sx,[@sumX_6], sy,[@sumY_6], sxy,[@sumXY_6], sx2,[@sumX2_6], sy2,[@sumY2_6],
    varX, MAX(n*sx2 - sx^2, 0),
    varY, MAX(n*sy2 - sy^2, 0),
    num,  (n*sxy - sx*sy)^2,
    den,  varX * varY,
    IF(den=0, NA(), num/den)
  )
)





=IF(
  OR([@n_6]<2,
     ([@n_6]*[@sumX2_6]-[@sumX_6]^2)<=0,
     ([@n_6]*[@sumY2_6]-[@sumY_6]^2)<=0),
  NA(),
  (([@n_6]*[@sumXY_6]-[@sumX_6]*[@sumY_6])^2) /
  ( ([@n_6]*[@sumX2_6]-[@sumX_6]^2) * ([@n_6]*[@sumY2_6]-[@sumY_6]^2) )
)




r_6 := IF(
  OR([@n_6]<2,
     ([@n_6]*[@sumX2_6]-[@sumX_6]^2)=0,
     ([@n_6]*[@sumY2_6]-[@sumY_6]^2)=0),
  NA(),
  ( [@n_6]*[@sumXY_6] - [@sumX_6]*[@sumY_6] ) /
  SQRT( ( [@n_6]*[@sumX2_6] - [@sumX_6]^2 ) * ( [@n_6]*[@sumY2_6] - [@sumY_6]^2 ) )
)




=LET(
  sys, [@System_key],
  t0,  [@t_num],
  z0,  ABS([@Residual_Z_Cohort]),
  z1,  ABS(XLOOKUP(1,(t[System_key]=sys)*(t[t_num]=t0-1),t[Residual_Z_Cohort],NA())),
  z2,  ABS(XLOOKUP(1,(t[System_key]=sys)*(t[t_num]=t0-2),t[Residual_Z_Cohort],NA())),
  count, 3 - COUNTIF({z0,z1,z2},NA()),
  IF(count=0, NA(), (IFNA(z0,0)+IFNA(z1,0)+IFNA(z2,0))/count)
)






=IF(
  [@t_num]=1,
  NA(),
  [@BAL_num] - SUMIFS(
    t[BAL_num],
    t[System_key],[@System_key],
    t[t_num],[@t_num]-1
  )
)




=COUNTIF(
  INDEX(T[System], MATCH([@System], T[System], 0)) : [@System],
  [@System]
)





=LET(
  sys, [@System],
  s,   MATCH(sys, T[System], 0),
  n,   COUNTIF(T[System], sys),
  IF(n<2, NA(),
     SLOPE(
       N(INDEX(T[BAL], s):INDEX(T[BAL], s+n-1)),
       N(INDEX(T[t],   s):INDEX(T[t],   s+n-1))
     )
  )
)





-- 1) Monthly totals by system (ONLY what you need)
WITH m AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    END_OF_MONTH_DATE,
    CAST(SUM(SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS BAL
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) Add month index t (per system) and quarter
b AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    END_OF_MONTH_DATE,
    BAL,
    ROW_NUMBER() OVER (PARTITION BY CONTRACT_SOURCE_SYSTEM
                       ORDER BY END_OF_MONTH_DATE) AS t,
    EXTRACT(QUARTER FROM END_OF_MONTH_DATE)::INTEGER AS q
  FROM m
)

SELECT
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE,
  t,
  q,
  BAL
FROM b
ORDER BY CONTRACT_SOURCE_SYSTEM, END_OF_MONTH_DATE;






/* Fast MoM KDE summary (RC_CODE, RC_DESCRIPTION, CRE_FLAG only) */
WITH
params AS (
  /* Raise during close to speed things up (e.g., 100000.0). Set to 0.0 to include all. */
  SELECT 100000.0::FLOAT8 AS min_abs_bal_delta
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

/* 1) Single scan for just 2 months, lean columns */
two_mo AS (
  SELECT DISTINCT  -- helps if duplicates exist per account/month
    t.ACCOUNT_IDENTIFIER,
    t.END_OF_MONTH_DATE,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS BAL,
    t.RC_CODE,
    t.RC_DESCRIPTION,
    t.CRE_FLAG
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE IN (r.prev_eom, r.max_eom)
),

/* 2) Per-account pivot: prev/curr into columns (no self-join) */
per_acct AS (
  SELECT
    ACCOUNT_IDENTIFIER,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN BAL END) AS prev_bal,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN BAL END) AS curr_bal,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(RC_CODE        AS VARCHAR(2000)) END) AS p_RC,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(RC_CODE        AS VARCHAR(2000)) END) AS c_RC,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(RC_DESCRIPTION AS VARCHAR(2000)) END) AS p_RC_DESC,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(RC_DESCRIPTION AS VARCHAR(2000)) END) AS c_RC_DESC,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(CRE_FLAG       AS VARCHAR(2000)) END) AS p_CRE,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(CRE_FLAG       AS VARCHAR(2000)) END) AS c_CRE

  FROM two_mo
  GROUP BY ACCOUNT_IDENTIFIER
  HAVING
      MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN 1 ELSE 0 END) = 1
  AND MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN 1 ELSE 0 END) = 1
),

/* 3) Change flags + $ threshold + “any-change” filter */
acct_changes AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    prev_bal, curr_bal,
    (NVL(c_RC,'#')      <> NVL(p_RC,'#'))       AS chg_RC,
    (NVL(c_RC_DESC,'#') <> NVL(p_RC_DESC,'#'))  AS chg_RC_DESC,
    (NVL(c_CRE,'#')     <> NVL(p_CRE,'#'))      AS chg_CRE
  FROM per_acct
  WHERE ABS(NVL(curr_bal,0) - NVL(prev_bal,0)) >= (SELECT min_abs_bal_delta FROM params)
    AND ( (NVL(c_RC,'#')      <> NVL(p_RC,'#'))
       OR (NVL(c_RC_DESC,'#') <> NVL(p_RC_DESC,'#'))
       OR (NVL(c_CRE,'#')     <> NVL(p_CRE,'#')) )
)

/* 4) Tiny 3-row KDE summary */
SELECT KDE, changed_count, exposure_change_dollars
FROM (
  SELECT 'RC_CODE' AS KDE,
         SUM(CASE WHEN chg_RC      THEN 1 ELSE 0 END) AS changed_count,
         SUM(CASE WHEN chg_RC      THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END) AS exposure_change_dollars
  FROM acct_changes

  UNION ALL
  SELECT 'RC_DESCRIPTION',
         SUM(CASE WHEN chg_RC_DESC THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_RC_DESC THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'CRE_FLAG',
         SUM(CASE WHEN chg_CRE     THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_CRE     THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes
) AS k
ORDER BY ABS(exposure_change_dollars) DESC;





/* Fast 2-month KDE summary (no temp tables), with DAYS_PAST_DUE and CRE_FLAG */
WITH
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

/* 1) One scan for just two months, lean columns */
two_mo AS (
  SELECT
    t.ACCOUNT_IDENTIFIER,
    t.END_OF_MONTH_DATE,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS BAL,
    t.BORROWER_RISK_RATING,
    t.PD_GRADE,
    t.STATUS_CODE_DESCRIPTION,
    t.INSTRUMENT_TYPE,
    t.NON_ACCRUAL_FLAG,
    t.DAYS_PAST_DUE,        -- <-- corrected
    t.RC_CODE,
    t.RC_DESCRIPTION,
    t.CRE_FLAG              -- <-- new KDE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE IN (r.prev_eom, r.max_eom)
    /* Optional narrowers to speed up:
       AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB','L-CIT')
       AND t.SOURCE_SYSTEM_BALANCE >= 5000
    */
),

/* 2) Per-account pivot: prev/curr into columns (no self-join) */
per_acct AS (
  SELECT
    ACCOUNT_IDENTIFIER,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN BAL END) AS prev_bal,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN BAL END) AS curr_bal,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(BORROWER_RISK_RATING    AS VARCHAR(2000)) END) AS p_BRR,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(BORROWER_RISK_RATING    AS VARCHAR(2000)) END) AS c_BRR,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(PD_GRADE                AS VARCHAR(2000)) END) AS p_PD,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(PD_GRADE                AS VARCHAR(2000)) END) AS c_PD,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) END) AS p_STATUS,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) END) AS c_STATUS,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) END) AS p_INSTR,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) END) AS c_INSTR,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) END) AS p_NA,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) END) AS c_NA,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(DAYS_PAST_DUE           AS VARCHAR(2000)) END) AS p_DPD,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(DAYS_PAST_DUE           AS VARCHAR(2000)) END) AS c_DPD,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(RC_CODE                 AS VARCHAR(2000)) END) AS p_RC,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(RC_CODE                 AS VARCHAR(2000)) END) AS c_RC,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(RC_DESCRIPTION          AS VARCHAR(2000)) END) AS p_RC_DESC,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(RC_DESCRIPTION          AS VARCHAR(2000)) END) AS c_RC_DESC,

    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN CAST(CRE_FLAG                AS VARCHAR(2000)) END) AS p_CRE,
    MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN CAST(CRE_FLAG                AS VARCHAR(2000)) END) AS c_CRE

  FROM two_mo
  GROUP BY ACCOUNT_IDENTIFIER
  HAVING
      MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM rng) THEN 1 ELSE 0 END) = 1
  AND MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom  FROM rng) THEN 1 ELSE 0 END) = 1
),

/* 3) Change flags + optional $ threshold and “any-change” filter */
acct_changes AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    prev_bal, curr_bal,
    (NVL(c_BRR,'#')    <> NVL(p_BRR,'#'))       AS chg_BRR,
    (NVL(c_PD,'#')     <> NVL(p_PD,'#'))        AS chg_PD,
    (NVL(c_STATUS,'#') <> NVL(p_STATUS,'#'))    AS chg_STATUS,
    (NVL(c_INSTR,'#')  <> NVL(p_INSTR,'#'))     AS chg_INSTR,
    (NVL(c_NA,'#')     <> NVL(p_NA,'#'))        AS chg_NA,
    (NVL(c_DPD,'#')    <> NVL(p_DPD,'#'))       AS chg_DPD,        -- uses DAYS_PAST_DUE
    (NVL(c_RC,'#')     <> NVL(p_RC,'#'))        AS chg_RC,
    (NVL(c_RC_DESC,'#')<> NVL(p_RC_DESC,'#'))   AS chg_RC_DESC,
    (NVL(c_CRE,'#')    <> NVL(p_CRE,'#'))       AS chg_CRE         -- new KDE
  FROM per_acct
  WHERE
        /* speed knob: ignore tiny balance moves; set to 0.0 to include all */
        ABS(NVL(curr_bal,0) - NVL(prev_bal,0)) >= 50000.0
    AND (
         (NVL(c_BRR,'#')    <> NVL(p_BRR,'#'))
      OR (NVL(c_PD,'#')     <> NVL(p_PD,'#'))
      OR (NVL(c_STATUS,'#') <> NVL(p_STATUS,'#'))
      OR (NVL(c_INSTR,'#')  <> NVL(p_INSTR,'#'))
      OR (NVL(c_NA,'#')     <> NVL(p_NA,'#'))
      OR (NVL(c_DPD,'#')    <> NVL(p_DPD,'#'))
      OR (NVL(c_RC,'#')     <> NVL(p_RC,'#'))
      OR (NVL(c_RC_DESC,'#')<> NVL(p_RC_DESC,'#'))
      OR (NVL(c_CRE,'#')    <> NVL(p_CRE,'#'))
    )
)

/* 4) Tiny KDE summary (now 9 rows incl. CRE_FLAG) */
SELECT KDE, changed_count, exposure_change_dollars
FROM (
  SELECT 'BORROWER_RISK_RATING' AS KDE,
         SUM(CASE WHEN chg_BRR     THEN 1 ELSE 0 END) AS changed_count,
         SUM(CASE WHEN chg_BRR     THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END) AS exposure_change_dollars
  FROM acct_changes

  UNION ALL
  SELECT 'PD_GRADE',
         SUM(CASE WHEN chg_PD      THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_PD      THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'STATUS_CODE_DESCRIPTION',
         SUM(CASE WHEN chg_STATUS  THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_STATUS  THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'INSTRUMENT_TYPE',
         SUM(CASE WHEN chg_INSTR   THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_INSTR   THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'NON_ACCRUAL_FLAG',
         SUM(CASE WHEN chg_NA      THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_NA      THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'DAYS_PAST_DUE',
         SUM(CASE WHEN chg_DPD     THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_DPD     THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'RC_CODE',
         SUM(CASE WHEN chg_RC      THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_RC      THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'RC_DESCRIPTION',
         SUM(CASE WHEN chg_RC_DESC THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_RC_DESC THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes

  UNION ALL
  SELECT 'CRE_FLAG',
         SUM(CASE WHEN chg_CRE     THEN 1 ELSE 0 END),
         SUM(CASE WHEN chg_CRE     THEN (NVL(curr_bal,0)-NVL(prev_bal,0)) ELSE 0 END)
  FROM acct_changes
) AS k
ORDER BY ABS(exposure_change_dollars) DESC;






/* === Fast MoM KDE summary without temp tables === */
WITH
params AS (
  /* Tune this: set to 0 for everything, or e.g., 50000.0 to ignore tiny moves */
  SELECT 0.0::FLOAT8 AS min_abs_bal_delta
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),
prev_base AS (
  SELECT
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    t.BORROWER_RISK_RATING, t.PD_GRADE, t.STATUS_CODE_DESCRIPTION,
    t.INSTRUMENT_TYPE, t.NON_ACCRUAL_FLAG, t.DAYS_PAST_DUE_BUCKET,
    t.RC_CODE, t.RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    /* Optional narrowers (uncomment & edit):
       AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB','L-CIT')
       AND t.SOURCE_SYSTEM_BALANCE >= 5000
    */
),
curr_base AS (
  SELECT
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    t.BORROWER_RISK_RATING, t.PD_GRADE, t.STATUS_CODE_DESCRIPTION,
    t.INSTRUMENT_TYPE, t.NON_ACCRUAL_FLAG, t.DAYS_PAST_DUE_BUCKET,
    t.RC_CODE, t.RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    /* Optional narrowers:
       AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB','L-CIT')
       AND t.SOURCE_SYSTEM_BALANCE >= 5000
    */
),
joined_flags AS (
  SELECT
    c.ACCOUNT_IDENTIFIER,
    p.prev_bal, c.curr_bal,

    /* NULL-safe, text-based compare per KDE */
    CASE WHEN NVL(CAST(c.BORROWER_RISK_RATING   AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.BORROWER_RISK_RATING   AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_BRR,

    CASE WHEN NVL(CAST(c.PD_GRADE               AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.PD_GRADE               AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_PD,

    CASE WHEN NVL(CAST(c.STATUS_CODE_DESCRIPTION AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.STATUS_CODE_DESCRIPTION AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_STATUS,

    CASE WHEN NVL(CAST(c.INSTRUMENT_TYPE        AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.INSTRUMENT_TYPE        AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_INSTR,

    CASE WHEN NVL(CAST(c.NON_ACCRUAL_FLAG       AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.NON_ACCRUAL_FLAG       AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_NA,

    CASE WHEN NVL(CAST(c.DAYS_PAST_DUE_BUCKET   AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.DAYS_PAST_DUE_BUCKET   AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_DPD,

    CASE WHEN NVL(CAST(c.RC_CODE                AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.RC_CODE                AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_RC,

    CASE WHEN NVL(CAST(c.RC_DESCRIPTION         AS VARCHAR(2000)),'#')
           <> NVL(CAST(p.RC_DESCRIPTION         AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS chg_RC_DESC
  FROM curr_base c
  JOIN prev_base p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  WHERE ABS(c.curr_bal - p.prev_bal) >= (SELECT min_abs_bal_delta FROM params)
    /* BIG speedup: keep only rows where ANY KDE changed */
    AND (
         NVL(CAST(c.BORROWER_RISK_RATING AS VARCHAR(2000)),'#') <> NVL(CAST(p.BORROWER_RISK_RATING AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.PD_GRADE             AS VARCHAR(2000)),'#') <> NVL(CAST(p.PD_GRADE             AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.STATUS_CODE_DESCRIPTION AS VARCHAR(2000)),'#') <> NVL(CAST(p.STATUS_CODE_DESCRIPTION AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.INSTRUMENT_TYPE      AS VARCHAR(2000)),'#') <> NVL(CAST(p.INSTRUMENT_TYPE      AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.NON_ACCRUAL_FLAG     AS VARCHAR(2000)),'#') <> NVL(CAST(p.NON_ACCRUAL_FLAG     AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.DAYS_PAST_DUE_BUCKET AS VARCHAR(2000)),'#') <> NVL(CAST(p.DAYS_PAST_DUE_BUCKET AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.RC_CODE              AS VARCHAR(2000)),'#') <> NVL(CAST(p.RC_CODE              AS VARCHAR(2000)),'#')
      OR NVL(CAST(c.RC_DESCRIPTION       AS VARCHAR(2000)),'#') <> NVL(CAST(p.RC_DESCRIPTION       AS VARCHAR(2000)),'#')
    )
)
SELECT KDE, changed_count, exposure_change_dollars
FROM (
  SELECT 'BORROWER_RISK_RATING' AS KDE,
         SUM(chg_BRR) AS changed_count,
         SUM(CASE WHEN chg_BRR=1 THEN (curr_bal - prev_bal) ELSE 0 END) AS exposure_change_dollars
  FROM joined_flags

  UNION ALL
  SELECT 'PD_GRADE',
         SUM(chg_PD),
         SUM(CASE WHEN chg_PD=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'STATUS_CODE_DESCRIPTION',
         SUM(chg_STATUS),
         SUM(CASE WHEN chg_STATUS=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'INSTRUMENT_TYPE',
         SUM(chg_INSTR),
         SUM(CASE WHEN chg_INSTR=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'NON_ACCRUAL_FLAG',
         SUM(chg_NA),
         SUM(CASE WHEN chg_NA=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'DAYS_PAST_DUE_BUCKET',
         SUM(chg_DPD),
         SUM(CASE WHEN chg_DPD=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'RC_CODE',
         SUM(chg_RC),
         SUM(CASE WHEN chg_RC=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags

  UNION ALL
  SELECT 'RC_DESCRIPTION',
         SUM(chg_RC_DESC),
         SUM(CASE WHEN chg_RC_DESC=1 THEN (curr_bal - prev_bal) ELSE 0 END)
  FROM joined_flags
) AS k
ORDER BY ABS(exposure_change_dollars) DESC;






/* Account × KDE change-only extract (slim) */
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

prev AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

curr AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- Join once (keeps it fast) 
j AS (
  SELECT
    c.ACCOUNT_IDENTIFIER,
    p.prev_bal,
    c.curr_bal
    ,p.BORROWER_RISK_RATING AS p_BRR, c.BORROWER_RISK_RATING AS c_BRR
    ,p.PD_GRADE             AS p_PD,  c.PD_GRADE             AS c_PD
    ,p.STATUS_CODE_DESCRIPTION AS p_STATUS, c.STATUS_CODE_DESCRIPTION AS c_STATUS
    ,p.INSTRUMENT_TYPE      AS p_INSTR, c.INSTRUMENT_TYPE     AS c_INSTR
    ,p.NON_ACCRUAL_FLAG     AS p_NA,  c.NON_ACCRUAL_FLAG      AS c_NA
    ,p.DAYS_PAST_DUE_BUCKET AS p_DPD, c.DAYS_PAST_DUE_BUCKET  AS c_DPD
    ,p.RC_CODE              AS p_RC,  c.RC_CODE               AS c_RC
    ,p.RC_DESCRIPTION       AS p_RC_DESC, c.RC_DESCRIPTION    AS c_RC_DESC
  FROM curr c
  INNER JOIN prev p ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),

/* UNPIVOT into Account×KDE rows with prev/curr values and change flag.
   We keep only changed rows in the final SELECT to shrink data. */
kde_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS KDE,
         CAST(p_BRR AS VARCHAR(2000)) AS prev_val, CAST(c_BRR AS VARCHAR(2000)) AS curr_val,
         CASE WHEN NVL(CAST(p_BRR AS VARCHAR(2000)),'#') <> NVL(CAST(c_BRR AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END AS changed_flag,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',
         CAST(p_PD AS VARCHAR(2000)), CAST(c_PD AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_PD AS VARCHAR(2000)),'#') <> NVL(CAST(c_PD AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION',
         CAST(p_STATUS AS VARCHAR(2000)), CAST(c_STATUS AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_STATUS AS VARCHAR(2000)),'#') <> NVL(CAST(c_STATUS AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',
         CAST(p_INSTR AS VARCHAR(2000)), CAST(c_INSTR AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_INSTR AS VARCHAR(2000)),'#') <> NVL(CAST(c_INSTR AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',
         CAST(p_NA AS VARCHAR(2000)), CAST(c_NA AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_NA AS VARCHAR(2000)),'#') <> NVL(CAST(c_NA AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',
         CAST(p_DPD AS VARCHAR(2000)), CAST(c_DPD AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_DPD AS VARCHAR(2000)),'#') <> NVL(CAST(c_DPD AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',
         CAST(p_RC AS VARCHAR(2000)), CAST(c_RC AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_RC AS VARCHAR(2000)),'#') <> NVL(CAST(c_RC AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
  UNION ALL
  SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',
         CAST(p_RC_DESC AS VARCHAR(2000)), CAST(c_RC_DESC AS VARCHAR(2000)),
         CASE WHEN NVL(CAST(p_RC_DESC AS VARCHAR(2000)),'#') <> NVL(CAST(c_RC_DESC AS VARCHAR(2000)),'#') THEN 1 ELSE 0 END,
         prev_bal, curr_bal
  FROM j
)

SELECT
  ACCOUNT_IDENTIFIER,
  KDE,
  prev_val,
  curr_val,
  (curr_bal - prev_bal) AS bal_delta,     -- account $ change (useful for weighting)
  prev_bal,
  curr_bal
FROM kde_long
WHERE changed_flag = 1
ORDER BY ABS(curr_bal - prev_bal) DESC;   -- optional for quick triage



-- KDE summary (one row per KDE)
SELECT
  KDE,
  COUNT(*)                          AS changed_accounts,
  SUM(curr_bal - prev_bal)          AS exposure_change_dollars
FROM kde_long
WHERE changed_flag = 1
GROUP BY KDE
ORDER BY ABS(SUM(curr_bal - prev_bal)) DESC;







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
)

SELECT
  t.ACCOUNT_IDENTIFIER,
  t.END_OF_MONTH_DATE,
  CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS balance,
  t.BORROWER_RISK_RATING,
  t.PD_GRADE,
  t.STATUS_CODE_DESCRIPTION,
  t.INSTRUMENT_TYPE,
  t.NON_ACCRUAL_FLAG,
  t.DAYS_PAST_DUE_BUCKET,
  t.RC_CODE,
  t.RC_DESCRIPTION
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
CROSS JOIN rng r
WHERE t.END_OF_MONTH_DATE IN (r.prev_eom, r.max_eom)
  AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
  AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans';





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

-- Trimmed snapshots
prev_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

curr_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- Tall views for EXCEPT-based diff
prev_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM prev_base
),
curr_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM curr_base
),

-- Symmetric difference (with aliases)
delta_rows AS (
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
  ) AS a
  UNION
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
  ) AS b
),

changed AS (
  SELECT DISTINCT ACCOUNT_IDENTIFIER, kde FROM delta_rows
),

-- RENAMED from "matched" -> "matched_set"
matched_set AS (
  SELECT COUNT(*)::FLOAT8 AS matched_accounts
  FROM (
    SELECT c.ACCOUNT_IDENTIFIER
    FROM curr_base c
    INNER JOIN prev_base p ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  ) AS matchset
),

exposure AS (
  SELECT
    ch.kde,
    COUNT(*)::FLOAT8 AS changed_count,
    SUM(NVL(c.curr_bal,0) - NVL(p.prev_bal,0)) AS exposure_change_dollars,
    SUM(NVL(c.curr_bal,0)) AS curr_exposure_on_changed,
    SUM(NVL(p.prev_bal,0)) AS prev_exposure_on_changed
  FROM changed ch
  LEFT JOIN curr_base c ON ch.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
  LEFT JOIN prev_base p ON ch.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  GROUP BY ch.kde
)

SELECT
  e.kde,
  e.changed_count                                      AS mom_change_count,
  (e.changed_count / NULLIF(ms.matched_accounts,0))    AS mom_change_count_pct,
  e.exposure_change_dollars                            AS mom_exposure_change_dollars,
  CASE WHEN NULLIF(e.prev_exposure_on_changed,0) IS NOT NULL
       THEN e.exposure_change_dollars / e.prev_exposure_on_changed
       ELSE NULL END                                   AS mom_exposure_change_pct
FROM exposure e
CROSS JOIN matched_set ms
ORDER BY ABS(e.exposure_change_dollars) DESC
FETCH FIRST 10 ROWS ONLY;




WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

-- Trimmed snapshots
prev_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

curr_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

prev_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM prev_base
),
curr_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM curr_base
),

-- Symmetric difference (with aliases!)
delta_rows AS (
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
  ) AS a
  UNION
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
  ) AS b
),

changed AS (
  SELECT DISTINCT ACCOUNT_IDENTIFIER, kde FROM delta_rows
),

matched AS (
  SELECT COUNT(*)::FLOAT8 AS matched_accounts
  FROM (
    SELECT c.ACCOUNT_IDENTIFIER
    FROM curr_base c
    INNER JOIN prev_base p USING (ACCOUNT_IDENTIFIER)
  ) AS matchset
),

exposure AS (
  SELECT
    ch.kde,
    COUNT(*)::FLOAT8 AS changed_count,
    SUM(NVL(c.curr_bal,0) - NVL(p.prev_bal,0)) AS exposure_change_dollars,
    SUM(NVL(c.curr_bal,0)) AS curr_exposure_on_changed,
    SUM(NVL(p.prev_bal,0)) AS prev_exposure_on_changed
  FROM changed ch
  LEFT JOIN curr_base c USING (ACCOUNT_IDENTIFIER)
  LEFT JOIN prev_base p USING (ACCOUNT_IDENTIFIER)
  GROUP BY ch.kde
)

SELECT
  e.kde,
  e.changed_count                                      AS mom_change_count,
  (e.changed_count / NULLIF(m.matched_accounts,0))     AS mom_change_count_pct,
  e.exposure_change_dollars                            AS mom_exposure_change_dollars,
  CASE WHEN NULLIF(e.prev_exposure_on_changed,0) IS NOT NULL
       THEN e.exposure_change_dollars / e.prev_exposure_on_changed
       ELSE NULL END                                   AS mom_exposure_change_pct
FROM exposure e
CROSS JOIN matched m
ORDER BY ABS(e.exposure_change_dollars) DESC
FETCH FIRST 10 ROWS ONLY;





-- === PARAMETERS YOU CAN EDIT ===
-- Pick your KDE fields (add/remove blocks in the *_long CTEs)
-- Keep filters lean; Total Loans + non-null balance usually enough.

WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

-- Trimmed snapshots (min columns = FAST)
prev_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

curr_base AS (
  SELECT
    ACCOUNT_IDENTIFIER,
    CAST(SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    BORROWER_RISK_RATING,
    PD_GRADE,
    STATUS_CODE_DESCRIPTION,
    INSTRUMENT_TYPE,
    NON_ACCRUAL_FLAG,
    DAYS_PAST_DUE_BUCKET,
    RC_CODE,
    RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- Make “tall” views (field per row) – EASY to diff with EXCEPT
prev_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM prev_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM prev_base
),
curr_long AS (
  SELECT ACCOUNT_IDENTIFIER, 'BORROWER_RISK_RATING' AS kde, CAST(BORROWER_RISK_RATING AS VARCHAR(2000)) AS val FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'STATUS_CODE_DESCRIPTION', CAST(STATUS_CODE_DESCRIPTION AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'INSTRUMENT_TYPE',         CAST(INSTRUMENT_TYPE         AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'NON_ACCRUAL_FLAG',        CAST(NON_ACCRUAL_FLAG        AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'DAYS_PAST_DUE_BUCKET',    CAST(DAYS_PAST_DUE_BUCKET    AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_CODE',                 CAST(RC_CODE                 AS VARCHAR(2000)) FROM curr_base
  UNION ALL SELECT ACCOUNT_IDENTIFIER, 'RC_DESCRIPTION',          CAST(RC_DESCRIPTION          AS VARCHAR(2000)) FROM curr_base
),

-- Symmetric difference (what changed): EXCEPT in both directions
delta_rows AS (
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
  )
  UNION
  SELECT ACCOUNT_IDENTIFIER, kde FROM (
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM prev_long
    EXCEPT
    SELECT ACCOUNT_IDENTIFIER, kde, val FROM curr_long
  )
),
-- Distinct account × kde that changed
changed AS (
  SELECT DISTINCT ACCOUNT_IDENTIFIER, kde FROM delta_rows
),

-- Matched set size for % calcs (only accounts present both months)
matched AS (
  SELECT COUNT(*)::FLOAT8 AS matched_accounts
  FROM (
    SELECT c.ACCOUNT_IDENTIFIER
    FROM curr_base c
    INNER JOIN prev_base p USING (ACCOUNT_IDENTIFIER)
  ) x
),

-- Exposure deltas on changed accounts only (curr - prev)
exposure AS (
  SELECT
    ch.kde,
    COUNT(*)::FLOAT8 AS changed_count,
    SUM(NVL(c.curr_bal,0) - NVL(p.prev_bal,0)) AS exposure_change_dollars,
    SUM(NVL(c.curr_bal,0)) AS curr_exposure_on_changed,
    SUM(NVL(p.prev_bal,0)) AS prev_exposure_on_changed
  FROM changed ch
  LEFT JOIN curr_base c USING (ACCOUNT_IDENTIFIER)
  LEFT JOIN prev_base p USING (ACCOUNT_IDENTIFIER)
  GROUP BY ch.kde
)

SELECT
  e.kde,
  e.changed_count                                      AS mom_change_count,
  (e.changed_count / NULLIF(m.matched_accounts,0))     AS mom_change_count_pct,
  e.exposure_change_dollars                            AS mom_exposure_change_dollars,
  CASE WHEN NULLIF(e.prev_exposure_on_changed,0) IS NOT NULL
       THEN e.exposure_change_dollars / e.prev_exposure_on_changed
       ELSE NULL END                                   AS mom_exposure_change_pct
FROM exposure e
CROSS JOIN matched m
ORDER BY ABS(e.exposure_change_dollars) DESC
FETCH FIRST 10 ROWS ONLY;





-- Top 10 KDEs by MoM change: count (# & %) and exposure ($ & %)
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom FROM latest
),

-- Previous month slice (trim to essentials to keep it fast)
prev_mo AS (
  SELECT
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS prev_bal,
    t.BORROWER_RISK_RATING,
    t.PD_GRADE,
    t.STATUS_CODE_DESCRIPTION,
    t.INSTRUMENT_TYPE,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.CONTRACT_SOURCE_SYSTEM,
    t.NON_ACCRUAL_FLAG,
    t.DAYS_PAST_DUE_BUCKET,
    t.RC_CODE,
    t.RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.prev_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- Current month slice
curr_mo AS (
  SELECT
    t.ACCOUNT_IDENTIFIER,
    CAST(t.SOURCE_SYSTEM_BALANCE AS FLOAT8) AS curr_bal,
    t.BORROWER_RISK_RATING,
    t.PD_GRADE,
    t.STATUS_CODE_DESCRIPTION,
    t.INSTRUMENT_TYPE,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.CONTRACT_SOURCE_SYSTEM,
    t.NON_ACCRUAL_FLAG,
    t.DAYS_PAST_DUE_BUCKET,
    t.RC_CODE,
    t.RC_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE = r.max_eom
    AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- Only accounts present in both months so we can detect changes
joined AS (
  SELECT
    c.ACCOUNT_IDENTIFIER,
    c.curr_bal, p.prev_bal,

    -- columns we will check (add/remove as needed)
    c.BORROWER_RISK_RATING AS c_BORROWER_RISK_RATING, p.BORROWER_RISK_RATING AS p_BORROWER_RISK_RATING,
    c.PD_GRADE             AS c_PD_GRADE,             p.PD_GRADE             AS p_PD_GRADE,
    c.STATUS_CODE_DESCRIPTION AS c_STATUS_CODE_DESCRIPTION, p.STATUS_CODE_DESCRIPTION AS p_STATUS_CODE_DESCRIPTION,
    c.INSTRUMENT_TYPE      AS c_INSTRUMENT_TYPE,      p.INSTRUMENT_TYPE      AS p_INSTRUMENT_TYPE,
    c.GL_ACCOUNT_HIER_LEVEL_4 AS c_GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4 AS p_GL_ACCOUNT_HIER_LEVEL_4,
    c.CONTRACT_SOURCE_SYSTEM AS c_CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM AS p_CONTRACT_SOURCE_SYSTEM,
    c.NON_ACCRUAL_FLAG     AS c_NON_ACCRUAL_FLAG,     p.NON_ACCRUAL_FLAG     AS p_NON_ACCRUAL_FLAG,
    c.DAYS_PAST_DUE_BUCKET AS c_DPD_BUCKET,           p.DAYS_PAST_DUE_BUCKET AS p_DPD_BUCKET,
    c.RC_CODE              AS c_RC_CODE,              p.RC_CODE              AS p_RC_CODE,
    c.RC_DESCRIPTION       AS c_RC_DESCRIPTION,       p.RC_DESCRIPTION       AS p_RC_DESCRIPTION
  FROM curr_mo c
  INNER JOIN prev_mo p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),

totals AS (
  SELECT
    COUNT(*)::FLOAT8 AS matched_accts,
    SUM(prev_bal)    AS total_prev_bal_on_matched,
    SUM(curr_bal)    AS total_curr_bal_on_matched
  FROM joined
),

-- Helper: NULL-safe compare by casting to text
-- Netezza doesn’t have IS DISTINCT FROM, so we emulate it with CAST + NVL
per_kde AS (
  /* 1) BORROWER_RISK_RATING */
  SELECT
    'BORROWER_RISK_RATING' AS KDE,
    SUM(CASE WHEN NVL(CAST(p_BORROWER_RISK_RATING AS VARCHAR(4000)),'#')
                 <> NVL(CAST(c_BORROWER_RISK_RATING AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END) AS changed_count,
    SUM(CASE WHEN NVL(CAST(p_BORROWER_RISK_RATING AS VARCHAR(4000)),'#')
                 <> NVL(CAST(c_BORROWER_RISK_RATING AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END) AS curr_exposure_on_changed,
    SUM(CASE WHEN NVL(CAST(p_BORROWER_RISK_RATING AS VARCHAR(4000)),'#')
                 <> NVL(CAST(c_BORROWER_RISK_RATING AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END) AS prev_exposure_on_changed
  FROM joined

  UNION ALL
  /* 2) PD_GRADE */
  SELECT
    'PD_GRADE',
    SUM(CASE WHEN NVL(CAST(p_PD_GRADE AS VARCHAR(4000)),'#') <> NVL(CAST(c_PD_GRADE AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_PD_GRADE AS VARCHAR(4000)),'#') <> NVL(CAST(c_PD_GRADE AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_PD_GRADE AS VARCHAR(4000)),'#') <> NVL(CAST(c_PD_GRADE AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 3) STATUS_CODE_DESCRIPTION */
  SELECT
    'STATUS_CODE_DESCRIPTION',
    SUM(CASE WHEN NVL(CAST(p_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_STATUS_CODE_DESCRIPTION AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 4) INSTRUMENT_TYPE */
  SELECT
    'INSTRUMENT_TYPE',
    SUM(CASE WHEN NVL(CAST(p_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') <> NVL(CAST(c_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') <> NVL(CAST(c_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') <> NVL(CAST(c_INSTRUMENT_TYPE AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 5) GL_ACCOUNT_HIER_LEVEL_4 */
  SELECT
    'GL_ACCOUNT_HIER_LEVEL_4',
    SUM(CASE WHEN NVL(CAST(p_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') <> NVL(CAST(c_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') <> NVL(CAST(c_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') <> NVL(CAST(c_GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 6) CONTRACT_SOURCE_SYSTEM */
  SELECT
    'CONTRACT_SOURCE_SYSTEM',
    SUM(CASE WHEN NVL(CAST(p_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') <> NVL(CAST(c_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') <> NVL(CAST(c_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') <> NVL(CAST(c_CONTRACT_SOURCE_SYSTEM AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 7) NON_ACCRUAL_FLAG */
  SELECT
    'NON_ACCRUAL_FLAG',
    SUM(CASE WHEN NVL(CAST(p_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') <> NVL(CAST(c_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') <> NVL(CAST(c_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') <> NVL(CAST(c_NON_ACCRUAL_FLAG AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 8) DAYS_PAST_DUE_BUCKET */
  SELECT
    'DAYS_PAST_DUE_BUCKET',
    SUM(CASE WHEN NVL(CAST(p_DPD_BUCKET AS VARCHAR(4000)),'#') <> NVL(CAST(c_DPD_BUCKET AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_DPD_BUCKET AS VARCHAR(4000)),'#') <> NVL(CAST(c_DPD_BUCKET AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_DPD_BUCKET AS VARCHAR(4000)),'#') <> NVL(CAST(c_DPD_BUCKET AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 9) RC_CODE */
  SELECT
    'RC_CODE',
    SUM(CASE WHEN NVL(CAST(p_RC_CODE AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_CODE AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_RC_CODE AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_CODE AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_RC_CODE AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_CODE AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined

  UNION ALL
  /* 10) RC_DESCRIPTION */
  SELECT
    'RC_DESCRIPTION',
    SUM(CASE WHEN NVL(CAST(p_RC_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_DESCRIPTION AS VARCHAR(4000)),'#') THEN 1 ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_RC_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_DESCRIPTION AS VARCHAR(4000)),'#') THEN curr_bal ELSE 0 END),
    SUM(CASE WHEN NVL(CAST(p_RC_DESCRIPTION AS VARCHAR(4000)),'#') <> NVL(CAST(c_RC_DESCRIPTION AS VARCHAR(4000)),'#') THEN prev_bal ELSE 0 END)
  FROM joined
),

scored AS (
  SELECT
    k.KDE,
    k.changed_count::FLOAT8 AS changed_count,
    (k.changed_count::FLOAT8 / NULLIF(t.matched_accts,0)) AS changed_count_pct,
    -- $ exposure change among accounts where that KDE changed
    (k.curr_exposure_on_changed - k.prev_exposure_on_changed) AS exposure_change_dollars,
    CASE WHEN NULLIF(k.prev_exposure_on_changed,0) IS NOT NULL
         THEN (k.curr_exposure_on_changed - k.prev_exposure_on_changed) / k.prev_exposure_on_changed
         ELSE NULL END AS exposure_change_pct
  FROM per_kde k
  CROSS JOIN totals t
)

SELECT *
FROM scored
ORDER BY ABS(exposure_change_dollars) DESC
FETCH FIRST 10 ROWS ONLY;





WITH latest AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
    SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom
    FROM latest
),

-- 1) Current month KDE exposure
curr AS (
    SELECT
        t.KDE,
        COUNT(*) AS curr_count,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS curr_exposure
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.END_OF_MONTH_DATE = r.max_eom
      AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    GROUP BY t.KDE
),

-- 2) Previous month KDE exposure
prev AS (
    SELECT
        t.KDE,
        COUNT(*) AS prev_count,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS prev_exposure
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.END_OF_MONTH_DATE = r.prev_eom
      AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    GROUP BY t.KDE
),

-- 3) Join & calculate MoM deltas
mom AS (
    SELECT
        COALESCE(c.KDE, p.KDE) AS KDE,
        COALESCE(c.curr_count, 0) AS curr_count,
        COALESCE(p.prev_count, 0) AS prev_count,
        COALESCE(c.curr_exposure, 0) AS curr_exposure,
        COALESCE(p.prev_exposure, 0) AS prev_exposure,
        COALESCE(c.curr_count, 0) - COALESCE(p.prev_count, 0) AS mom_count_change,
        CASE WHEN COALESCE(p.prev_count, 0) <> 0
             THEN (COALESCE(c.curr_count, 0) - COALESCE(p.prev_count, 0)) * 1.0 / p.prev_count
             ELSE NULL END AS mom_count_change_pct,
        COALESCE(c.curr_exposure, 0) - COALESCE(p.prev_exposure, 0) AS mom_exposure_change,
        CASE WHEN COALESCE(p.prev_exposure, 0) <> 0
             THEN (COALESCE(c.curr_exposure, 0) - COALESCE(p.prev_exposure, 0)) / p.prev_exposure
             ELSE NULL END AS mom_exposure_change_pct
    FROM curr c
    FULL OUTER JOIN prev p ON c.KDE = p.KDE
)

-- 4) Rank & filter to top 10 by $ exposure change
SELECT *
FROM mom
ORDER BY ABS(mom_exposure_change) DESC
FETCH FIRST 10 ROWS ONLY;





WITH latest AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
    SELECT ADD_MONTHS(max_eom, -1) AS prev_eom, max_eom
    FROM latest
),

-- 1) Current month KDE exposure
curr AS (
    SELECT
        t.KDE,
        COUNT(*) AS curr_count,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS curr_exposure
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.END_OF_MONTH_DATE = r.max_eom
      AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    GROUP BY t.KDE
),

-- 2) Previous month KDE exposure
prev AS (
    SELECT
        t.KDE,
        COUNT(*) AS prev_count,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS prev_exposure
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.END_OF_MONTH_DATE = r.prev_eom
      AND t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    GROUP BY t.KDE
),

-- 3) Join & calculate MoM deltas
mom AS (
    SELECT
        COALESCE(c.KDE, p.KDE) AS KDE,
        COALESCE(c.curr_count, 0) AS curr_count,
        COALESCE(p.prev_count, 0) AS prev_count,
        COALESCE(c.curr_exposure, 0) AS curr_exposure,
        COALESCE(p.prev_exposure, 0) AS prev_exposure,
        COALESCE(c.curr_count, 0) - COALESCE(p.prev_count, 0) AS mom_count_change,
        CASE WHEN COALESCE(p.prev_count, 0) <> 0
             THEN (COALESCE(c.curr_count, 0) - COALESCE(p.prev_count, 0)) * 1.0 / p.prev_count
             ELSE NULL END AS mom_count_change_pct,
        COALESCE(c.curr_exposure, 0) - COALESCE(p.prev_exposure, 0) AS mom_exposure_change,
        CASE WHEN COALESCE(p.prev_exposure, 0) <> 0
             THEN (COALESCE(c.curr_exposure, 0) - COALESCE(p.prev_exposure, 0)) / p.prev_exposure
             ELSE NULL END AS mom_exposure_change_pct
    FROM curr c
    FULL OUTER JOIN prev p ON c.KDE = p.KDE
)

-- 4) Rank & filter to top 10 by $ exposure change
SELECT *
FROM mom
ORDER BY ABS(mom_exposure_change) DESC
FETCH FIRST 10 ROWS ONLY;





WITH sel AS (
  SELECT
    c.column_name,
    c.data_type,
    ROW_NUMBER() OVER (ORDER BY UPPER(c.column_name)) AS rn
  FROM INFORMATION_SCHEMA.COLUMNS c
  /* Anchor: cross-join a single row from a user object to avoid "system-only" window agg error */
  CROSS JOIN (
    SELECT 1 AS anchor
    FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
    FETCH FIRST 1 ROW ONLY
  ) a
  WHERE UPPER(c.table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    AND UPPER(c.column_name) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- prune noisy/audit columns; adjust as needed
    AND UPPER(c.column_name) NOT LIKE '%_TS'
    AND UPPER(c.column_name) NOT LIKE '%_DT'
    AND UPPER(c.column_name) NOT LIKE 'CREATED_%'
    AND UPPER(c.column_name) NOT LIKE 'UPDATED_%'
    AND UPPER(c.column_name) NOT LIKE '%_USER'
    AND UPPER(c.column_name) NOT LIKE '%USER_ID%'
    AND UPPER(c.column_name) NOT LIKE '%HASH%'
    AND UPPER(c.column_name) NOT LIKE '%CHECKSUM%'
    AND UPPER(c.column_name) NOT LIKE '%BATCH%'
    AND UPPER(c.column_name) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM sel
  WHERE rn BETWEEN 1 AND 25   -- <<< change this range each run (e.g., 26-50, 51-75, ...)
)
SELECT
  CASE
    WHEN POSITION('CHAR' IN UPPER(data_type))>0 OR POSITION('VARCHAR' IN UPPER(data_type))>0
         OR POSITION('NCHAR' IN UPPER(data_type))>0 OR POSITION('NVARCHAR' IN UPPER(data_type))>0
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    WHEN UPPER(data_type) LIKE '%DATE%' OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    ELSE
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
  END AS sql_line
FROM batch
ORDER BY rn;






WITH sel AS (
  SELECT
    column_name,
    data_type,
    ROW_NUMBER() OVER (ORDER BY UPPER(column_name)) AS rn
  FROM INFORMATION_SCHEMA.COLUMNS
  WHERE UPPER(table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
    -- keep keys out
    AND UPPER(column_name) NOT IN (
      'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
      'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
    )
    -- skip noisy/audit columns (tune as needed)
    AND UPPER(column_name) NOT LIKE '%_TS'
    AND UPPER(column_name) NOT LIKE '%_DT'
    AND UPPER(column_name) NOT LIKE 'CREATED_%'
    AND UPPER(column_name) NOT LIKE 'UPDATED_%'
    AND UPPER(column_name) NOT LIKE '%_USER'
    AND UPPER(column_name) NOT LIKE '%USER_ID%'
    AND UPPER(column_name) NOT LIKE '%HASH%'
    AND UPPER(column_name) NOT LIKE '%CHECKSUM%'
    AND UPPER(column_name) NOT LIKE '%BATCH%'
    AND UPPER(column_name) NOT LIKE '%RUN_ID%'
),
batch AS (
  SELECT * FROM sel
  WHERE rn BETWEEN 1 AND 25   -- <<< change this range each run (e.g., 26 AND 50, 51 AND 75, ...)
)
SELECT
  CASE
    WHEN POSITION('CHAR' IN UPPER(data_type))>0 OR POSITION('VARCHAR' IN UPPER(data_type))>0
         OR POSITION('NCHAR' IN UPPER(data_type))>0 OR POSITION('NVARCHAR' IN UPPER(data_type))>0
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    WHEN UPPER(data_type) LIKE '%DATE%' OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
    ELSE
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
  END AS sql_line
FROM batch
ORDER BY rn;















SELECT
  CASE
    /* text-like */
    WHEN POSITION('CHAR' IN UPPER(data_type))>0 OR POSITION('VARCHAR' IN UPPER(data_type))>0
         OR POSITION('NCHAR' IN UPPER(data_type))>0 OR POSITION('NVARCHAR' IN UPPER(data_type))>0
    THEN
'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM map_prev mp
 JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
            AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
 JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
            AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
 WHERE mp.prev_eom IS NOT NULL
   AND ( UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
         OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'

    /* date/timestamp */
    WHEN UPPER(data_type) LIKE '%DATE%' OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM map_prev mp
 JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
            AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
 JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
            AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
 WHERE mp.prev_eom IS NOT NULL
   AND ( c."'||column_name||'" <> p."'||column_name||'"
         OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'

    /* numeric/other */
    ELSE
'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM map_prev mp
 JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
            AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
 JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
            AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
            AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
 WHERE mp.prev_eom IS NOT NULL
   AND ( c."'||column_name||'" <> p."'||column_name||'"
         OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'
  END AS sql_line
FROM INFORMATION_SCHEMA.COLUMNS
WHERE UPPER(table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
  -- optional schema filter: AND UPPER(table_schema) IN ('CIDPR','DATAHUB')
  AND UPPER(column_name) NOT IN (
    'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
    'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
  )
  -- common noisy/audit fields to skip (edit as needed)
  AND UPPER(column_name) NOT LIKE '%_TS'
  AND UPPER(column_name) NOT LIKE '%_DT'
  AND UPPER(column_name) NOT LIKE 'CREATED_%'
  AND UPPER(column_name) NOT LIKE 'UPDATED_%'
  AND UPPER(column_name) NOT LIKE '%_USER'
  AND UPPER(column_name) NOT LIKE '%USER_ID%'
  AND UPPER(column_name) NOT LIKE '%HASH%'
  AND UPPER(column_name) NOT LIKE '%CHECKSUM%'
  AND UPPER(column_name) NOT LIKE '%BATCH%'
  AND UPPER(column_name) NOT LIKE '%RUN_ID%'
  -- *** BATCH FILTER: adjust these two to split runs ***
  AND UPPER(SUBSTR(column_name,1,1)) BETWEEN 'A' AND 'F'
ORDER BY column_name;




WITH
cfg AS (
  SELECT
    25000000::FLOAT8 AS per_kde_min_exposure,  -- show KDEs with >= $25MM current change exposure
    100000::FLOAT8   AS per_account_min_ssb    -- ignore tiny accounts (< $100k) when counting events
),

-- last two month-ends (curr & prev) and prevprev to allow the prev-month change calc
bounds AS (
  SELECT
    MAX(END_OF_MONTH_DATE) AS curr_eom,
    (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
      WHERE END_OF_MONTH_DATE < (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME)) AS prev_eom
),
-- bring 3 months of positive SSB accounts to keep sizes small
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
base AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures m
    ON m.END_OF_MONTH_DATE = t.END_OF_MONTH_DATE
   AND m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY = t.ACCOUNT_KEY
),
-- map every (acct,system,month) to its prev month
map_prev AS (
  SELECT DISTINCT
    b.END_OF_MONTH_DATE, b.CONTRACT_SOURCE_SYSTEM, b.ACCOUNT_KEY,
    LAG(b.END_OF_MONTH_DATE) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM, b.ACCOUNT_KEY
      ORDER BY b.END_OF_MONTH_DATE
    ) AS prev_eom
  FROM base b
),

/* ==== CHANGE EVENTS for selected columns (paste block here) ==== */
kde_changes AS (
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE, ''::VARCHAR(1) AS KDE, 0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE GENERATED UNION LINES HERE >>> */
),

/* roll up month×KDE (current-month changes and previous-month changes both present) */
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),

/* isolate the two months we care about */
two_months AS (
  SELECT
    km.END_OF_MONTH_DATE, km.KDE, km.change_count, km.exposure_dollars
  FROM kde_monthly km
  WHERE km.END_OF_MONTH_DATE IN (
    (SELECT curr_eom FROM bounds),
    (SELECT prev_eom FROM bounds)
  )
),

/* self-join to compute MoM deltas (curr vs prev) */
final AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    c.change_count,
    c.exposure_dollars,
    p.change_count      AS prev_change_count,
    p.exposure_dollars  AS prev_exposure_dollars,
    (c.change_count - p.change_count) AS mom_change_count_delta,
    CASE WHEN p.change_count > 0
         THEN (c.change_count - p.change_count) / p.change_count::FLOAT8 END AS mom_change_count_pct,
    (c.exposure_dollars - p.exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN p.exposure_dollars <> 0
         THEN (c.exposure_dollars - p.exposure_dollars) / p.exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM two_months c
  LEFT JOIN two_months p
    ON p.KDE = c.KDE
   AND p.END_OF_MONTH_DATE = (SELECT prev_eom FROM bounds)
  WHERE c.END_OF_MONTH_DATE = (SELECT curr_eom FROM bounds)
)

SELECT *
FROM final
JOIN cfg ON 1=1
WHERE exposure_dollars >= cfg.per_kde_min_exposure
ORDER BY exposure_dollars DESC, KDE
FETCH FIRST 50 ROWS ONLY;









WITH
cfg AS (
  SELECT
    100000::FLOAT8   AS per_account_min_ssb,   -- ignore tiny accounts in event scan (e.g., $100k)
    25000000::FLOAT8 AS per_kde_min_exposure   -- show KDEs with ≥ $25MM exposure this month
),
-- find the last three month-ends
month_bounds AS (
  SELECT
    MAX(END_OF_MONTH_DATE) AS max_eom,
    (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
      WHERE END_OF_MONTH_DATE < (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME)) AS prev_eom,
    (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
      WHERE END_OF_MONTH_DATE < (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
                                   WHERE END_OF_MONTH_DATE < (SELECT MAX(END_OF_MONTH_DATE) FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME))) AS prevprev_eom
),
-- positive SSB sets per month (keeps row volumes down)
measures_c AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY, SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, month_bounds mb
  WHERE t.END_OF_MONTH_DATE = mb.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
measures_p AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY, SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, month_bounds mb
  WHERE t.END_OF_MONTH_DATE = mb.prev_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
measures_pp AS (
  SELECT t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY, SUM(t.SOURCE_SYSTEM_BALANCE) AS SSB
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t, month_bounds mb
  WHERE t.END_OF_MONTH_DATE = mb.prevprev_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2 HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- bring full rows only for the intersected accounts we care about, and filter tiny SSB early
base_c AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures_c m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY            = t.ACCOUNT_KEY
  JOIN month_bounds mb ON t.END_OF_MONTH_DATE = mb.max_eom
  JOIN cfg ON 1=1
  WHERE t.SOURCE_SYSTEM_BALANCE >= cfg.per_account_min_ssb
),
base_p AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures_p m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY            = t.ACCOUNT_KEY
  JOIN month_bounds mb ON t.END_OF_MONTH_DATE = mb.prev_eom
),
base_pp AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures_pp m
    ON m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY            = t.ACCOUNT_KEY
  JOIN month_bounds mb ON t.END_OF_MONTH_DATE = mb.prevprev_eom
),

/* --------- CURRENT MONTH changes: (curr vs prev) ---------- */
kde_changes_curr AS (
  -- seed
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE, ''::VARCHAR(1) AS KDE, 0::FLOAT8 AS CURR_SSB WHERE 1=0

  /* <<< PASTE GENERATED UNION LINES HERE (they reference base_c and base_p) >>> */
),
kde_monthly_curr AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes_curr
  GROUP BY 1,2
),

/* --------- PREVIOUS MONTH changes: (prev vs prevprev) ---------- */
-- reuse the *same* generator block, but it’s okay here because we alias
-- the later month as "base_p" and the earlier month as "base_pp".
kde_changes_prev AS (
  -- seed
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE, ''::VARCHAR(1) AS KDE, 0::FLOAT8 AS CURR_SSB WHERE 1=0

  /* <<< PASTE THE SAME GENERATED UNION LINES HERE, unchanged >>> */
),
kde_monthly_prev AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes_prev
  GROUP BY 1,2
),

/* --------- Denominators for current month only ---------- */
month_totals_c AS (
  SELECT mb.max_eom AS END_OF_MONTH_DATE,
         COUNT(DISTINCT ('x'||m.CONTRACT_SOURCE_SYSTEM||'|'||m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SSB) AS month_total_ssb
  FROM measures_c m, month_bounds mb
  GROUP BY mb.max_eom
),

/* --------- Join current to previous for MoM ---------- */
joined AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    c.change_count,
    c.exposure_dollars,
    p.change_count     AS prev_change_count,
    p.exposure_dollars AS prev_exposure_dollars
  FROM kde_monthly_curr c
  LEFT JOIN kde_monthly_prev p
    ON p.KDE = c.KDE
),

/* --------- Normalize & compute MoM metrics ---------- */
scored AS (
  SELECT
    j.END_OF_MONTH_DATE,
    j.KDE,
    j.change_count,
    j.exposure_dollars,
    j.prev_change_count,
    j.prev_exposure_dollars,

    (j.change_count - j.prev_change_count) AS mom_change_count_delta,
    CASE WHEN j.prev_change_count > 0
         THEN (j.change_count - j.prev_change_count) / j.prev_change_count::FLOAT8 END AS mom_change_count_pct,

    (j.exposure_dollars - j.prev_exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN j.prev_exposure_dollars <> 0
         THEN (j.exposure_dollars - j.prev_exposure_dollars) / j.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct,

    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN j.change_count    / mt.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN mt.month_total_ssb      > 0 THEN j.exposure_dollars/ mt.month_total_ssb::FLOAT8      END AS exposure_share
  FROM joined j
  JOIN month_totals_c mt ON mt.END_OF_MONTH_DATE = j.END_OF_MONTH_DATE
  JOIN cfg ON 1=1
  WHERE j.exposure_dollars >= cfg.per_kde_min_exposure
)

SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  exposure_dollars,
  prev_change_count,
  prev_exposure_dollars,
  mom_change_count_delta,
  mom_change_count_pct,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  change_rate,
  exposure_share
FROM scored
ORDER BY exposure_dollars DESC, KDE
FETCH FIRST 50 ROWS ONLY;





SELECT
  CASE
    /* TEXT-like: compare UPPER(TRIM(...)) with null-safety */
    WHEN POSITION('CHAR' IN UPPER(data_type))  > 0
      OR POSITION('VARCHAR' IN UPPER(data_type)) > 0
      OR POSITION('NCHAR' IN UPPER(data_type))   > 0
      OR POSITION('NVARCHAR' IN UPPER(data_type))> 0
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'

    /* DATE/TIMESTAMP */
    WHEN UPPER(data_type) LIKE '%DATE%' OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'

    /* NUMERIC & the rest: direct compare with null-safety */
    ELSE
'UNION ALL SELECT c.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
 FROM base_c c
 JOIN base_p p
   ON p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  AND p.ACCOUNT_KEY            = c.ACCOUNT_KEY
 WHERE (c."'||column_name||'" <> p."'||column_name||'")
    OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL))'
  END AS sql_line
FROM INFORMATION_SCHEMA.COLUMNS
WHERE UPPER(table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
  -- Optional: AND UPPER(table_schema) IN ('CIDPR','DATAHUB')
  AND UPPER(column_name) NOT IN (
    'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
    'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
  )
  -- Common noisy/audit fields to skip (edit as needed)
  AND UPPER(column_name) NOT LIKE '%_TS'
  AND UPPER(column_name) NOT LIKE '%_DT'
  AND UPPER(column_name) NOT LIKE 'CREATED_%'
  AND UPPER(column_name) NOT LIKE 'UPDATED_%'
  AND UPPER(column_name) NOT LIKE '%_USER'
  AND UPPER(column_name) NOT LIKE '%USER_ID%'
  AND UPPER(column_name) NOT LIKE '%HASH%'
  AND UPPER(column_name) NOT LIKE '%CHECKSUM%'
  AND UPPER(column_name) NOT LIKE '%BATCH%'
  AND UPPER(column_name) NOT LIKE '%RUN_ID%'
ORDER BY column_name;





WITH
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),

/* positive SSB population */
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* bring full rows for the positive-SSB accounts only */
base AS (
  SELECT t.*
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN measures m
    ON m.END_OF_MONTH_DATE = t.END_OF_MONTH_DATE
   AND m.CONTRACT_SOURCE_SYSTEM = t.CONTRACT_SOURCE_SYSTEM
   AND m.ACCOUNT_KEY = t.ACCOUNT_KEY
),

/* map each acct×system×month to its prior month */
key_dates AS (
  SELECT DISTINCT END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY
  FROM base
),
map_prev AS (
  SELECT kd.*,
         LAG(kd.END_OF_MONTH_DATE) OVER (
           PARTITION BY kd.CONTRACT_SOURCE_SYSTEM, kd.ACCOUNT_KEY
           ORDER BY kd.END_OF_MONTH_DATE
         ) AS prev_eom
  FROM key_dates kd
),

/* === CHANGE EVENTS for ALL columns === */
kde_changes AS (
  /* seed */
  SELECT DATE '1900-01-01'::DATE AS END_OF_MONTH_DATE, ''::VARCHAR(1) AS KDE, 0::FLOAT8 AS CURR_SSB
  WHERE 1=0

  /* <<< PASTE GENERATED UNION LINES HERE >>> */
),

/* month × KDE rollup */
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),

/* denominators */
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM||'|'||m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* normalized + prev for MoM */
with_denoms AS (
  SELECT km.*,
         mt.month_total_accounts,
         mt.month_total_ssb,
         CASE WHEN mt.month_total_accounts > 0 THEN km.change_count    / mt.month_total_accounts::FLOAT8 END AS change_rate,
         CASE WHEN mt.month_total_ssb      > 0 THEN km.exposure_dollars/ mt.month_total_ssb::FLOAT8      END AS exposure_share
  FROM kde_monthly km
  JOIN month_totals mt USING (END_OF_MONTH_DATE)
),
with_prev AS (
  SELECT w.*,
         LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
         LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars
  FROM with_denoms w
),
with_mom AS (
  SELECT p.*,
         (p.change_count - p.prev_change_count) AS mom_change_count_delta,
         CASE WHEN p.prev_change_count > 0
              THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
         (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
         CASE WHEN p.prev_exposure_dollars <> 0
              THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM with_prev p
),

/* simple 12-mo baselines and z-scores */
trends AS (
  SELECT m.*,
         AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
         AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
         STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
         STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12
  FROM with_mom m
),
scored AS (
  SELECT t.*,
         CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND trend_rate_12  IS NOT NULL
              THEN (change_rate    - trend_rate_12)  / std_rate_12  END AS z_rate,
         CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND trend_share_12 IS NOT NULL
              THEN (exposure_share - trend_share_12) / std_share_12 END AS z_share
  FROM trends t
)
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, exposure_dollars, change_rate, exposure_share,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  z_rate, z_share,
  COALESCE(ABS(z_rate),0) + COALESCE(ABS(z_share),0) + COALESCE(ABS(mom_exposure_dollars_pct),0) AS severity_score,
  DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE ORDER BY
                     COALESCE(ABS(z_rate),0) + COALESCE(ABS(z_share),0) + COALESCE(ABS(mom_exposure_dollars_pct),0) DESC, KDE) AS severity_rank_in_month
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY severity_rank_in_month, KDE;






SELECT
  CASE
    /* TEXT-like types: compare with UPPER(TRIM(...)) and null-safety */
    WHEN POSITION('CHAR' IN UPPER(data_type)) > 0
         OR POSITION('VARCHAR' IN UPPER(data_type)) > 0
         OR POSITION('NCHAR' IN UPPER(data_type)) > 0
         OR POSITION('NVARCHAR' IN UPPER(data_type)) > 0
    THEN
      'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
       FROM map_prev mp
       JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
                  AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
       JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
                  AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
       WHERE mp.prev_eom IS NOT NULL
         AND ( UPPER(TRIM(c."'||column_name||'")) <> UPPER(TRIM(p."'||column_name||'"))
               OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'

    /* DATE / TIMESTAMP types */
    WHEN UPPER(data_type) LIKE '%DATE%'
         OR UPPER(data_type) LIKE '%TIMESTAMP%'
    THEN
      'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
       FROM map_prev mp
       JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
                  AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
       JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
                  AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
       WHERE mp.prev_eom IS NOT NULL
         AND ( c."'||column_name||'" <> p."'||column_name||'"
               OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'

    /* NUMERIC & everything else: direct compare with null-safety */
    ELSE
      'UNION ALL SELECT mp.END_OF_MONTH_DATE, '''||column_name||''' AS KDE, c.SOURCE_SYSTEM_BALANCE AS CURR_SSB
       FROM map_prev mp
       JOIN base c ON c.END_OF_MONTH_DATE = mp.END_OF_MONTH_DATE
                  AND c.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND c.ACCOUNT_KEY = mp.ACCOUNT_KEY
       JOIN base p ON p.END_OF_MONTH_DATE = mp.prev_eom
                  AND p.CONTRACT_SOURCE_SYSTEM = mp.CONTRACT_SOURCE_SYSTEM
                  AND p.ACCOUNT_KEY = mp.ACCOUNT_KEY
       WHERE mp.prev_eom IS NOT NULL
         AND ( c."'||column_name||'" <> p."'||column_name||'"
               OR ((c."'||column_name||'" IS NULL) <> (p."'||column_name||'" IS NULL)) )'
  END AS sql_line
FROM INFORMATION_SCHEMA.COLUMNS
WHERE UPPER(table_name) = 'V_DPRT_CREDIT_INSTRUMENTS_ME'
  /* optional: narrow by schema if needed
     AND UPPER(table_schema) IN ('CIDPR','DATAHUB')
  */
  AND UPPER(column_name) NOT IN (
    'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','ACCOUNT_KEY',
    'SOURCE_SYSTEM_BALANCE','GL_ACCOUNT_HIER_LEVEL_4'
  )
ORDER BY column_name;





Eleanor:
•	Two parts of the portfolio covered by SVB Special Assets Group (SAG) 1) Loans (covers majority of the portfolio), 2) Cards (small chunk)
•	For Loans, the primary tool for managing Non-Accrual is the NPL Tool 
o	Produces the automated NPL report used in managing / reconciling non-accruals
o	sources data from FRDS.
o	Only includes loans with a Risk Rating of 8, 9, and 10 (i.e., non-accruals)
o	Report is generated automatically every Tuesday
•	The NPL report is the primary monitoring / management tool for non-accruals 
o	This report is routinely review by SAG as well as the relationships managers
o	For month 1 and 2 of each quarter, it's reviewed bi-weekly
o	For month 3 of each quarter, it's reviewed weekly
•	Changes to Non-Accrual status are decided by Relationship Managers. 
o	nCino packages are created for changes and once approved (e.g., changing risk rating or covenant etc.)
o	Loan Ops updates the Loan Accounting System.
o	nCino changes cascade down to FRDS and NPL Tool gets refreshed when FRDS is updated
•	Changes in NPL report are shared with Global Loan Ops to double check everything is booked. Eleanor follows up with GLO to ensure changes occurred
•	During the last 3 days of the month, Eleanor pays special attention to non-accrual reconciliation 
o	A Charge-off log and a downgrade log is shared with Loan Ops
o	While no specific log exists for upgrades, they are also handled during the last 3 business days (if any)
•	Sub-segment of Wine NA loans managed by Brian Bell are not in NPL tool.
•	A small sub-segment in Eleanor's queue managed by Casey
•	For standalone cards (i.e., no associated loan) , Eleanor CCMT CCMT Team for validation 
o	If it's a NA card with an associated charged-off loan, Eleanor checks with the CCMT Team as well








WITH
-- latest month
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),

-- book population (positive SSB only)
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- denominators per month
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- monthly KDE snapshot for change detection (keep only fields we use)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.NON_ACCRUAL_FLAG) AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG) AS CRE_FLAG,
    MAX(t.RISK_UNIT) AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE) AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE) AS LIFESTAGE,
    MAX(t.NICHE_CD) AS NICHE_CD,
    MAX(t.RBC_CODE) AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE) AS RC_CODE,
    MAX(t.RATE_TYPE) AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM






-- Master CONTRACT_SOURCE_SYSTEM anomaly detector:
-- Rolling 18m regression + MoM Z + prediction intervals + unified severity.
-- Netezza-safe: no analytic REGR_* calls, no nested window aggregates, no alias reuse in same SELECT.

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Pull 36 months to support 18m rolling windows ---- */
base_raw AS (
  SELECT
    t.END_OF_MONTH_DATE::DATE AS END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -36)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY 1,2
),

/* ---- Drop systems that were zero for the entire slice ---- */
active_systems AS (
  SELECT CONTRACT_SOURCE_SYSTEM
  FROM base_raw
  GROUP BY CONTRACT_SOURCE_SYSTEM
  HAVING MAX(ABS(SOURCE_SYSTEM_BALANCE)) > 0
),

base AS (
  SELECT b.*
  FROM base_raw b
  JOIN active_systems a
    ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft (same logic as legacy) ---- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Time index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE)          AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE)
         AS FLOAT8)                                                                                 AS x_idx
  FROM tagged t
),

/* ---- Rolling OLS moments for 18m regression on y ~ x_idx ---- */
moments AS (
  SELECT
    i.*,
    COUNT(*) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS n18,
    SUM(i.x_idx) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sx18,
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sy18,
    SUM(i.x_idx * i.x_idx) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sxx18,
    SUM(i.x_idx * i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sxy18
  FROM idx i
),

/* ---- Rolling slope/intercept, in-sample fit (t), residuals ---- */
reg AS (
  SELECT
    m.*,
    (m.n18*m.sxx18 - m.sx18*m.sx18)                                                               AS denom18,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18))
      ELSE NULL
    END                                                                                           AS beta1_slope_18,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      ELSE NULL
    END                                                                                           AS beta0_int_18,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.x_idx
           + (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      ELSE NULL
    END                                                                                           AS yhat_t,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN m.SOURCE_SYSTEM_BALANCE - (
           ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.x_idx
           + (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      )
      ELSE NULL
    END                                                                                           AS resid_t
  FROM moments m
),

/* ---- Rolling residual mean/std for Z-score + PI around yhat_t ---- */
resid_stats AS (
  SELECT
    r.*,
    AVG(r.resid_t) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                             AS resid_mean_18,
    STDDEV_SAMP(r.resid_t) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                             AS resid_std_18
  FROM reg r
),

/* ---- MoM delta computed alone (no nesting) ---- */
delta AS (
  SELECT
    s.*,
    LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY s.CONTRACT_SOURCE_SYSTEM
      ORDER BY s.END_OF_MONTH_DATE
    )                                                                                             AS prev_balance,
    s.SOURCE_SYSTEM_BALANCE
      - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
          PARTITION BY s.CONTRACT_SOURCE_SYSTEM
          ORDER BY s.END_OF_MONTH_DATE
        )                                                                                         AS mom_delta
  FROM resid_stats s
),

/* ---- Rolling MoM baseline (exclude current) ---- */
mom_stats AS (
  SELECT
    d.*,
    AVG(d.mom_delta) OVER (
      PARTITION BY d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
    )                                                                                             AS mom_avg_18,
    STDDEV_SAMP(d.mom_delta) OVER (
      PARTITION BY d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
    )                                                                                             AS mom_std_18
  FROM delta d
),

/* ---- One-step-ahead forecast at t for t+1, plus PI using resid_std_18 ---- */
forecast AS (
  SELECT
    m.*,

    -- one-step-ahead forecast
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL
      THEN m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)
      ELSE NULL
    END AS yhat_t1,

    -- PI around in-sample prediction (yhat_t)
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  - 1.9599 * m.resid_std_18 END AS pi95_lo_t,
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  + 1.9599 * m.resid_std_18 END AS pi95_hi_t,

    -- PI around t+1 forecast: recompute yhat_t1 expression inline (no alias reuse)
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL AND m.resid_std_18 IS NOT NULL
      THEN (m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)) - 1.9599 * m.resid_std_18
    END AS pi95_lo_t1,
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL AND m.resid_std_18 IS NOT NULL
      THEN (m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)) + 1.9599 * m.resid_std_18
    END AS pi95_hi_t1
  FROM mom_stats m
),

/* ---- Next-period anchors to evaluate t→t+1 forecast error ---- */
anchors AS (
  SELECT
    f.*,
    LEAD(f.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY f.CONTRACT_SOURCE_SYSTEM ORDER BY f.END_OF_MONTH_DATE
    )                                                                                             AS actual_next,
    LEAD(f.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY f.CONTRACT_SOURCE_SYSTEM ORDER BY f.END_OF_MONTH_DATE
    )                                                                                             AS next_period
  FROM forecast f
),

/* ---- Final scoring metrics (stage 1): compute z-scores & components ---- */
scored_base AS (
  SELECT
    a.*,

    -- Standardized surprises
    CASE
      WHEN a.resid_std_18 IS NOT NULL AND a.resid_std_18 > 0
      THEN (a.resid_t - COALESCE(a.resid_mean_18, 0.0)) / a.resid_std_18
      ELSE NULL
    END                                           AS resid_z,

    CASE
      WHEN a.mom_std_18 IS NOT NULL AND a.mom_std_18 > 0
      THEN (a.mom_delta - COALESCE(a.mom_avg_18, 0.0)) / a.mom_std_18
      ELSE NULL
    END                                           AS mom_z,

    -- In-sample deviations (actual vs yhat_t)
    (a.SOURCE_SYSTEM_BALANCE - a.yhat_t)          AS dev_abs_t,
    CASE WHEN a.yhat_t IS NOT NULL AND a.yhat_t <> 0
         THEN (a.SOURCE_SYSTEM_BALANCE - a.yhat_t) / a.yhat_t END
                                                  AS dev_pct_t,

    -- Flags vs 95% bands around yhat_t
    CASE
      WHEN a.pi95_lo_t IS NULL OR a.pi95_hi_t IS NULL THEN NULL
      WHEN a.SOURCE_SYSTEM_BALANCE < a.pi95_lo_t OR a.SOURCE_SYSTEM_BALANCE > a.pi95_hi_t THEN TRUE
      ELSE FALSE
    END                                           AS outside_95_t
  FROM anchors a
),

/* ---- Final scoring metrics (stage 2): compute severity using aliases from stage 1 ---- */
scored AS (
  SELECT
    sb.*,
    100.0 * (
      0.50 * LEAST(ABS(COALESCE(sb.resid_z,0.0)) / 3.0, 1.0)
    + 0.30 * LEAST(ABS(COALESCE(sb.mom_z,  0.0)) / 3.0, 1.0)
    + 0.20 * (
         0.5 * LEAST(ABS(COALESCE(sb.dev_pct_t,0.0)) / 0.10, 1.0)
       + 0.5 * LEAST(ABS(COALESCE(sb.dev_abs_t,0.0)) / NULLIF(0.10*ABS(COALESCE(sb.yhat_t,0.0)),0), 1.0)
      )
    )
    + CASE WHEN (sb.pi95_lo_t IS NOT NULL AND sb.pi95_hi_t IS NOT NULL
                 AND (sb.SOURCE_SYSTEM_BALANCE < sb.pi95_lo_t OR sb.SOURCE_SYSTEM_BALANCE > sb.pi95_hi_t))
           THEN 5.0 ELSE 0.0 END
                                                  AS severity_0_100
  FROM scored_base sb
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.END_OF_MONTH_DATE                 AS model_asof_period,   -- t
    s.next_period                       AS forecast_period,     -- t+1
    s.actual_next                       AS actual,              -- actual at t+1
    s.yhat_t1                           AS forecast_val,        -- regression forecast t→t+1
    s.resid_std_18                      AS sigma_est,           -- use rolling resid_std for PI
    s.is_synthetic,
    s.is_overdraft,
    (SELECT max_eom FROM latest)        AS max_eom
  FROM scored s
  WHERE s.next_period IS NOT NULL
)

/* ===================== FINAL PANELS ===================== */
SELECT * FROM (

  /* 1) Latest-only diagnostics (actual vs yhat_t) */
  SELECT
    CASE
      WHEN s.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN s.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    s.CONTRACT_SOURCE_SYSTEM,
    s.END_OF_MONTH_DATE                 AS period_date,
    s.SOURCE_SYSTEM_BALANCE             AS actual,
    s.yhat_t                            AS forecast_val,
    s.resid_std_18                      AS sigma_est,
    s.pi95_lo_t                         AS pi95_lo,
    s.pi95_hi_t                         AS pi95_hi,
    s.dev_abs_t                         AS dev_abs,
    s.dev_pct_t                         AS dev_pct,
    s.resid_z                           AS z_score_resid,
    s.mom_z                             AS z_score_mom,
    s.severity_0_100                    AS severity_0_100,
    s.outside_95_t                      AS outside_95_band,
    -- transparency
    s.is_synthetic, s.is_overdraft,
    s.beta1_slope_18                    AS regr_slope_18,
    s.prev_balance, s.mom_delta, s.mom_avg_18, s.mom_std_18
  FROM scored s
  WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* 2) Historical error (backtest t→t+1 inside the slice, excluding latest) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                   AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est END                             AS z_score_resid,
    NULL::FLOAT8                           AS z_score_mom,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    )                                           AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    b.is_synthetic, b.is_overdraft,
    NULL::FLOAT8 AS regr_slope_18,
    NULL::FLOAT8 AS prev_balance, NULL::FLOAT8 AS mom_delta, NULL::FLOAT8 AS mom_avg_18, NULL::FLOAT8 AS mom_std_18
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* 3) Latest month anomaly view vs t→t+1 forecast */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                   AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est END                             AS z_score_resid,
    NULL::FLOAT8                           AS z_score_mom,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    )                                           AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    b.is_synthetic, b.is_overdraft,
    NULL::FLOAT8 AS regr_slope_18,
    NULL::FLOAT8 AS prev_balance, NULL::FLOAT8 AS mom_delta, NULL::FLOAT8 AS mom_avg_18, NULL::FLOAT8 AS mom_std_18
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






forecast AS (
  SELECT
    m.*,

    -- one-step-ahead forecast
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL
      THEN m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)
      ELSE NULL
    END AS yhat_t1,

    -- PI around in-sample prediction (yhat_t)
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  - 1.9599 * m.resid_std_18 END AS pi95_lo_t,
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  + 1.9599 * m.resid_std_18 END AS pi95_hi_t,

    -- PI around t+1 forecast: recompute yhat_t1 expression inline
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL AND m.resid_std_18 IS NOT NULL
      THEN (m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)) - 1.9599 * m.resid_std_18
    END AS pi95_lo_t1,
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL AND m.resid_std_18 IS NOT NULL
      THEN (m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)) + 1.9599 * m.resid_std_18
    END AS pi95_hi_t1
  FROM mom_stats m
)



-- Master CONTRACT_SOURCE_SYSTEM anomaly detector:
-- Rolling 18m regression + MoM Z + prediction intervals + unified severity.
-- Netezza-safe: no analytic REGR_*, no nested windowed aggregates.

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Pull 36 months to support 18m rolling windows ---- */
base_raw AS (
  SELECT
    t.END_OF_MONTH_DATE::DATE AS END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -36)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY 1,2
),

/* ---- Drop systems that were zero for the entire slice ---- */
active_systems AS (
  SELECT CONTRACT_SOURCE_SYSTEM
  FROM base_raw
  GROUP BY CONTRACT_SOURCE_SYSTEM
  HAVING MAX(ABS(SOURCE_SYSTEM_BALANCE)) > 0
),

base AS (
  SELECT b.*
  FROM base_raw b
  JOIN active_systems a
    ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft (same logic as legacy) ---- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Time index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE)          AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE)
         AS FLOAT8)                                                                                 AS x_idx
  FROM tagged t
),

/* ---- Rolling OLS moments for 18m regression on y ~ x_idx ---- */
moments AS (
  SELECT
    i.*,
    COUNT(*) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS n18,
    SUM(i.x_idx) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sx18,
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sy18,
    SUM(i.x_idx * i.x_idx) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sxx18,
    SUM(i.x_idx * i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                               AS sxy18
  FROM idx i
),

/* ---- Rolling slope/intercept, in-sample fit (t), residuals ---- */
reg AS (
  SELECT
    m.*,
    -- denom guard
    (m.n18*m.sxx18 - m.sx18*m.sx18)                                                               AS denom18,

    -- slope & intercept
    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18))
      ELSE NULL
    END                                                                                           AS beta1_slope_18,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      ELSE NULL
    END                                                                                           AS beta0_int_18,

    -- in-sample prediction at t and residual
    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.x_idx
           + (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      ELSE NULL
    END                                                                                           AS yhat_t,

    CASE
      WHEN m.n18 >= 6 AND (m.n18*m.sxx18 - m.sx18*m.sx18) <> 0
      THEN m.SOURCE_SYSTEM_BALANCE - (
           ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.x_idx
           + (m.sy18 - ((m.n18*m.sxy18 - m.sx18*m.sy18) / (m.n18*m.sxx18 - m.sx18*m.sx18)) * m.sx18) / m.n18
      )
      ELSE NULL
    END                                                                                           AS resid_t
  FROM moments m
),

/* ---- Rolling residual mean/std for Z-score + PI around yhat_t ---- */
resid_stats AS (
  SELECT
    r.*,
    AVG(r.resid_t) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                             AS resid_mean_18,
    STDDEV_SAMP(r.resid_t) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
    )                                                                                             AS resid_std_18
  FROM reg r
),

/* ---- MoM delta computed alone (no nesting) ---- */
delta AS (
  SELECT
    s.*,
    LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY s.CONTRACT_SOURCE_SYSTEM
      ORDER BY s.END_OF_MONTH_DATE
    )                                                                                             AS prev_balance,
    s.SOURCE_SYSTEM_BALANCE
      - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
          PARTITION BY s.CONTRACT_SOURCE_SYSTEM
          ORDER BY s.END_OF_MONTH_DATE
        )                                                                                         AS mom_delta
  FROM resid_stats s
),

/* ---- Rolling MoM baseline (exclude current) ---- */
mom_stats AS (
  SELECT
    d.*,
    AVG(d.mom_delta) OVER (
      PARTITION BY d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
    )                                                                                             AS mom_avg_18,
    STDDEV_SAMP(d.mom_delta) OVER (
      PARTITION BY d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
    )                                                                                             AS mom_std_18
  FROM delta d
),

/* ---- One-step-ahead forecast at t for t+1, plus PI using resid_std_18 ---- */
forecast AS (
  SELECT
    m.*,
    CASE
      WHEN m.beta1_slope_18 IS NOT NULL AND m.beta0_int_18 IS NOT NULL
      THEN m.beta0_int_18 + m.beta1_slope_18 * (m.x_idx + 1.0)
      ELSE NULL
    END                                                                                           AS yhat_t1,

    -- 95% bands around both in-sample fit and t+1 forecast (using rolling resid_std_18)
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  - 1.9599 * m.resid_std_18 END                                            AS pi95_lo_t,
    CASE WHEN m.yhat_t  IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t  + 1.9599 * m.resid_std_18 END                                            AS pi95_hi_t,

    CASE WHEN m.yhat_t1 IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t1 - 1.9599 * m.resid_std_18 END                                            AS pi95_lo_t1,
    CASE WHEN m.yhat_t1 IS NOT NULL AND m.resid_std_18 IS NOT NULL
         THEN m.yhat_t1 + 1.9599 * m.resid_std_18 END                                            AS pi95_hi_t1
  FROM mom_stats m
),

/* ---- Next-period anchors to evaluate t→t+1 forecast error ---- */
anchors AS (
  SELECT
    f.*,
    LEAD(f.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY f.CONTRACT_SOURCE_SYSTEM ORDER BY f.END_OF_MONTH_DATE
    )                                                                                             AS actual_next,
    LEAD(f.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY f.CONTRACT_SOURCE_SYSTEM ORDER BY f.END_OF_MONTH_DATE
    )                                                                                             AS next_period
  FROM forecast f
),

/* ---- Final scoring metrics ---- */
scored AS (
  SELECT
    a.*,

    -- Standardized surprises
    CASE
      WHEN a.resid_std_18 IS NOT NULL AND a.resid_std_18 > 0
      THEN (a.resid_t - COALESCE(a.resid_mean_18, 0.0)) / a.resid_std_18
      ELSE NULL
    END                                                                                           AS resid_z,

    CASE
      WHEN a.mom_std_18 IS NOT NULL AND a.mom_std_18 > 0
      THEN (a.mom_delta - COALESCE(a.mom_avg_18, 0.0)) / a.mom_std_18
      ELSE NULL
    END                                                                                           AS mom_z,

    -- In-sample deviations (actual vs yhat_t) for the same month
    (a.SOURCE_SYSTEM_BALANCE - a.yhat_t)                                                         AS dev_abs_t,
    CASE WHEN a.yhat_t IS NOT NULL AND a.yhat_t <> 0
         THEN (a.SOURCE_SYSTEM_BALANCE - a.yhat_t) / a.yhat_t END                                AS dev_pct_t,

    -- Flags vs 95% bands around yhat_t
    CASE
      WHEN a.pi95_lo_t IS NULL OR a.pi95_hi_t IS NULL THEN NULL
      WHEN a.SOURCE_SYSTEM_BALANCE < a.pi95_lo_t OR a.SOURCE_SYSTEM_BALANCE > a.pi95_hi_t THEN TRUE
      ELSE FALSE
    END                                                                                           AS outside_95_t,

    -- Unified severity (0–100 style):
    -- 50% resid_z, 30% mom_z, 20% blend of % and $ deviation (scaled), plus bonus when outside 95%.
    100.0 * (
      0.50 * LEAST(ABS(COALESCE(a.resid_z,0.0)) / 3.0, 1.0)
    + 0.30 * LEAST(ABS(COALESCE(a.mom_z,0.0))   / 3.0, 1.0)
    + 0.20 * (
         0.5 * LEAST(ABS(COALESCE(a.dev_pct_t,0.0)) / 0.10, 1.0)         -- 10% move saturates
       + 0.5 * LEAST(ABS(COALESCE(a.dev_abs_t,0.0)) / NULLIF(0.10*ABS(COALESCE(a.yhat_t,0.0)),0), 1.0)
      )
    ) + CASE WHEN (a.pi95_lo_t IS NOT NULL AND a.pi95_hi_t IS NOT NULL
                   AND (a.SOURCE_SYSTEM_BALANCE < a.pi95_lo_t OR a.SOURCE_SYSTEM_BALANCE > a.pi95_hi_t))
             THEN 5.0 ELSE 0.0 END                                                               AS severity_0_100
  FROM anchors a
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.END_OF_MONTH_DATE                 AS model_asof_period,   -- t
    s.next_period                       AS forecast_period,     -- t+1
    s.actual_next                       AS actual,              -- actual at t+1
    s.yhat_t1                           AS forecast_val,        -- regression forecast t→t+1
    s.resid_std_18                      AS sigma_est,           -- use rolling resid_std for PI
    s.is_synthetic,
    s.is_overdraft,
    (SELECT max_eom FROM latest)        AS max_eom
  FROM scored s
  WHERE s.next_period IS NOT NULL
)

/* ===================== FINAL PANELS ===================== */
SELECT * FROM (

  /* 1) Latest-only diagnostics (actual vs yhat_t) */
  SELECT
    CASE
      WHEN s.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN s.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    s.CONTRACT_SOURCE_SYSTEM,
    s.END_OF_MONTH_DATE                 AS period_date,
    s.SOURCE_SYSTEM_BALANCE             AS actual,
    s.yhat_t                            AS forecast_val,
    s.resid_std_18                      AS sigma_est,
    s.pi95_lo_t                         AS pi95_lo,
    s.pi95_hi_t                         AS pi95_hi,
    s.dev_abs_t                         AS dev_abs,
    s.dev_pct_t                         AS dev_pct,
    s.resid_z                           AS z_score_resid,
    s.mom_z                             AS z_score_mom,
    s.severity_0_100                    AS severity_0_100,
    s.outside_95_t                      AS outside_95_band,
    -- transparency
    s.is_synthetic, s.is_overdraft,
    s.beta1_slope_18                    AS regr_slope_18,
    s.prev_balance, s.mom_delta, s.mom_avg_18, s.mom_std_18
  FROM scored s
  WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* 2) Historical error (backtest t→t+1 inside the slice, excluding latest) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                   AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est END                             AS z_score_resid,
    NULL::FLOAT8                           AS z_score_mom,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    )                                           AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    b.is_synthetic, b.is_overdraft,
    NULL::FLOAT8 AS regr_slope_18,
    NULL::FLOAT8 AS prev_balance, NULL::FLOAT8 AS mom_delta, NULL::FLOAT8 AS mom_avg_18, NULL::FLOAT8 AS mom_std_18
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* 3) Latest month anomaly view vs t→t+1 forecast */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                   AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est END                             AS z_score_resid,
    NULL::FLOAT8                           AS z_score_mom,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    )                                           AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    b.is_synthetic, b.is_overdraft,
    NULL::FLOAT8 AS regr_slope_18,
    NULL::FLOAT8 AS prev_balance, NULL::FLOAT8 AS mom_delta, NULL::FLOAT8 AS mom_avg_18, NULL::FLOAT8 AS mom_std_18
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





--CCZ Variance Analysis: Faster + Outlier Filter
WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- 13-month window (fast), Total Loans, exclude BPLN ---- */
base_raw AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -13)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- OUTLIER FILTER: drop systems with $0 for the entire 13 months ---- */
active_systems AS (
  SELECT CONTRACT_SOURCE_SYSTEM
  FROM base_raw
  GROUP BY CONTRACT_SOURCE_SYSTEM
  HAVING MAX(ABS(SOURCE_SYSTEM_BALANCE)) > 0  -- keep only systems that had any non-zero month
),

base AS (
  SELECT b.*
  FROM base_raw b
  JOIN active_systems a
    ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft (TA%, UU%, US) ---- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling windows (6M stats; 12M regression components) ---- */
win AS (
  SELECT
    i.*,

    /* 6-month rolling sums for mean/std */
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    LEAST(i.rn, 6)  AS n6,

    /* 12-row regression components on (x = rn_f, y = balance) */
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    LEAST(i.rn, 12) AS n12,

    /* anchors / alignment */
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats + regression + forecast(t→t+1) ---- */
calc AS (
  SELECT
    w.*,

    /* 6M mean/std */
    CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN w.n6 > 1 THEN
        SQRT( GREATEST( (w.sum6_y2 - ((w.sum6_y * w.sum6_y) / CAST(w.n6 AS FLOAT8))), 0.0 )
             / CAST(w.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12M regression slope/intercept; guard divide-by-zero */
    CASE
      WHEN w.n12 >= 2
       AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
      THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
           / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN w.n12 >= 1 THEN
        ( w.sum12_y
          - ( COALESCE(
                CASE
                  WHEN w.n12 >= 2
                   AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                  THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                       / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                  ELSE NULL
                END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12,

    /* forecast chooser at t for t+1: regression → lag12 → 6M mean */
    COALESCE(
      CASE
        WHEN w.n12 >= 2
         AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
        THEN
          /* intercept + slope * (rn + 1) */
          ( w.sum12_y
            - ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
              ) * w.sum12_x
          ) / CAST(w.n12 AS FLOAT8)
          +
          ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
            / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
          ) * CAST(w.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      w.lag12_balance,
      CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END
    ) AS forecast_val_t1
  FROM win w
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE  AS model_asof_period,  -- t
    c.next_period        AS forecast_period,    -- t+1
    c.actual_next        AS actual,             -- actual at t+1
    c.forecast_val_t1    AS forecast_val,
    c.roll_std_6         AS sigma_est,
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS ===================== */
SELECT * FROM (

  /* Latest-only diagnostics (no forecast), split into MAIN/SYNTH/OD */
  SELECT
    CASE
      WHEN c.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN c.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* Historical error (prior months inside the 13-month slice) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* Latest month anomaly view (key panel) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






-- Rolling-window regression (18m) + MoM anomaly scoring for CONTRACT_SOURCE_SYSTEM
-- No nested aggregates; works on Netezza.

WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -36) AS start_eom, max_eom FROM latest
),

-- 1) Monthly system totals
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                     AS END_OF_MONTH_DATE
    , t.CONTRACT_SOURCE_SYSTEM
    , CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) Time index per system
idx AS (
  SELECT
      b.*
    , DENSE_RANK() OVER (
        PARTITION BY b.CONTRACT_SOURCE_SYSTEM
        ORDER BY b.END_OF_MONTH_DATE
      )                                            AS month_idx
  FROM base b
),

-- 3) Rolling OLS moments (18m window) — analytic SUM/COUNT only
moments AS (
  SELECT
      i.*
    , COUNT(*) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                            AS n_win
    , SUM(i.month_idx::FLOAT8) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                            AS sx
    , SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                            AS sy
    , SUM((i.month_idx::FLOAT8)*(i.month_idx::FLOAT8)) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                            AS sxx
    , SUM((i.month_idx::FLOAT8)*i.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                            AS sxy
  FROM idx i
),

-- 4) Rolling slope/intercept, predictions, residuals (no window fns here)
reg AS (
  SELECT
      m.*
    , (m.n_win*m.sxy - m.sx*m.sy) /
      NULLIF((m.n_win*m.sxx - m.sx*m.sx), 0)::FLOAT8     AS beta1_slope
    , CASE
        WHEN (m.n_win*m.sxx - m.sx*m.sx) = 0 THEN NULL
        ELSE (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                       NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.sx) / m.n_win
      END                                                AS beta0_intercept
    , CASE
        WHEN m.n_win >= 6 AND (m.n_win*m.sxx - m.sx*m.sx) <> 0
        THEN ((m.n_win*m.sxy - m.sx*m.sy) /
              NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.month_idx
             + (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                        NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.sx) / m.n_win
        ELSE NULL
      END                                                AS yhat_pred
    , CASE
        WHEN m.n_win >= 6 AND (m.n_win*m.sxx - m.sx*m.sx) <> 0
        THEN m.SOURCE_SYSTEM_BALANCE - (
             ((m.n_win*m.sxy - m.sx*m.sy) /
               NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.month_idx
             + (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                        NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.sx) / m.n_win
        )
        ELSE NULL
      END                                                AS resid
  FROM moments m
),

-- 5) Rolling residual dispersion for Z-scores
resid_stats AS (
  SELECT
      r.*
    , STDDEV_SAMP(r.resid) OVER (
        PARTITION BY r.CONTRACT_SOURCE_SYSTEM
        ORDER BY r.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                AS resid_std
    , AVG(r.resid) OVER (
        PARTITION BY r.CONTRACT_SOURCE_SYSTEM
        ORDER BY r.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                AS resid_mean
  FROM reg r
),

-- 6) Compute MoM delta alone (no aggregates here)
delta AS (
  SELECT
      s.*
    , LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY s.CONTRACT_SOURCE_SYSTEM
        ORDER BY s.END_OF_MONTH_DATE
      )                                                AS prev_balance
    , s.SOURCE_SYSTEM_BALANCE
      - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
          PARTITION BY s.CONTRACT_SOURCE_SYSTEM
          ORDER BY s.END_OF_MONTH_DATE
        )                                              AS mom_delta
  FROM resid_stats s
),

-- 7) Rolling stats over mom_delta (exclude current row; no nested windows)
mom_stats AS (
  SELECT
      d.*
    , AVG(d.mom_delta) OVER (
        PARTITION BY d.CONTRACT_SOURCE_SYSTEM
        ORDER BY d.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
      )                                                AS mom_avg
    , STDDEV_SAMP(d.mom_delta) OVER (
        PARTITION BY d.CONTRACT_SOURCE_SYSTEM
        ORDER BY d.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
      )                                                AS mom_std
  FROM delta d
),

-- 8) Final scoring (no aggregates here)
scored AS (
  SELECT
      m.*
    , CASE
        WHEN m.resid IS NOT NULL AND m.resid_std IS NOT NULL AND m.resid_std > 0
        THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
        ELSE NULL
      END                                              AS resid_z
    , CASE
        WHEN m.mom_delta IS NOT NULL AND m.mom_std IS NOT NULL AND m.mom_std > 0
        THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
        ELSE NULL
      END                                              AS mom_z
    , CASE WHEN ABS(
             CASE WHEN m.resid_std > 0
                  THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
                  ELSE 0 END
           ) >= 2.0 THEN 1 ELSE 0 END                  AS reg_anom_flag
    , CASE WHEN ABS(
             CASE WHEN m.mom_std > 0
                  THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
                  ELSE 0 END
           ) >= 2.0 THEN 1 ELSE 0 END                  AS mom_anom_flag
    , (0.6 * COALESCE(ABS(
         CASE WHEN m.resid_std > 0
              THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std END
       ),0.0)
       + 0.4 * COALESCE(ABS(
         CASE WHEN m.mom_std > 0
              THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std END
       ),0.0)
       + CASE WHEN
           (CASE WHEN m.resid_std > 0
                 THEN ABS((m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std) ELSE 0 END) >= 2.0
           AND
           (CASE WHEN m.mom_std > 0
                 THEN ABS((m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std) ELSE 0 END) >= 2.0
         THEN 0.75 ELSE 0 END
      )                                                AS severity_score
  FROM mom_stats m
)

SELECT
    END_OF_MONTH_DATE
  , CONTRACT_SOURCE_SYSTEM
  , SOURCE_SYSTEM_BALANCE
  , yhat_pred                       AS REG_PRED_18M
  , resid                           AS REG_RESID
  , resid_z                         AS REG_RESID_Z
  , reg_anom_flag                   AS REG_ANOM_FLAG
  , prev_balance
  , mom_delta
  , mom_avg
  , mom_std
  , mom_z                           AS MOM_Z
  , mom_anom_flag                   AS MOM_ANOM_FLAG
  , severity_score
  , n_win                           AS WINDOW_OBS
  , beta1_slope                     AS TREND_SLOPE_18M
  , beta0_intercept                 AS TREND_INTERCEPT_18M
FROM scored
ORDER BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM;





-- Rolling-window regression without REGR_* (works in Netezza)
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -36) AS start_eom, max_eom FROM latest
),

-- 1) monthly totals
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                           AS END_OF_MONTH_DATE
    , t.CONTRACT_SOURCE_SYSTEM
    , CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8)       AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  GROUP BY 1,2
),

-- 2) month index per system
idx AS (
  SELECT
      b.*
    , DENSE_RANK() OVER (
        PARTITION BY b.CONTRACT_SOURCE_SYSTEM
        ORDER BY b.END_OF_MONTH_DATE
      )                                                  AS month_idx
  FROM base b
),

-- 3) rolling moments for OLS: n, sum(x), sum(y), sum(x^2), sum(xy)
moments AS (
  SELECT
      i.*
    , COUNT(*) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS n_win

    , SUM(i.month_idx::FLOAT8) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS sx

    , SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS sy

    , SUM((i.month_idx::FLOAT8)*(i.month_idx::FLOAT8)) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS sxx

    , SUM((i.month_idx::FLOAT8)*i.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS sxy
  FROM idx i
),

-- 4) slope/intercept from moments; predictions and residuals
reg AS (
  SELECT
      m.*
    , (m.n_win*m.sxy - m.sx*m.sy) /
      NULLIF((m.n_win*m.sxx - m.sx*m.sx), 0)::FLOAT8     AS beta1_slope

    , CASE
        WHEN (m.n_win*m.sxx - m.sx*m.sx) = 0 THEN NULL
        ELSE (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                      NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8)*m.sx) / m.n_win
      END                                                AS beta0_intercept

    , CASE
        WHEN m.n_win >= 6 AND (m.n_win*m.sxx - m.sx*m.sx) <> 0
        THEN ((m.n_win*m.sxy - m.sx*m.sy) /
              NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.month_idx
             + (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                        NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8)*m.sx) / m.n_win
        ELSE NULL
      END                                                AS yhat_pred

    , CASE
        WHEN m.n_win >= 6 AND (m.n_win*m.sxx - m.sx*m.sx) <> 0
        THEN m.SOURCE_SYSTEM_BALANCE - (
             ((m.n_win*m.sxy - m.sx*m.sy) /
               NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8) * m.month_idx
             + (m.sy - ((m.n_win*m.sxy - m.sx*m.sy) /
                        NULLIF((m.n_win*m.sxx - m.sx*m.sx),0)::FLOAT8)*m.sx) / m.n_win
        )
        ELSE NULL
      END                                                AS resid
  FROM moments m
),

-- 5) residual dispersion (rolling) for Z-scores
resid_stats AS (
  SELECT
      r.*
    , STDDEV_SAMP(r.resid) OVER (
        PARTITION BY r.CONTRACT_SOURCE_SYSTEM
        ORDER BY r.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS resid_std
    , AVG(r.resid) OVER (
        PARTITION BY r.CONTRACT_SOURCE_SYSTEM
        ORDER BY r.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS resid_mean
  FROM reg r
),

-- 6) MoM deltas + rolling baselines (exclude current in stats)
mom AS (
  SELECT
      s.*
    , LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY s.CONTRACT_SOURCE_SYSTEM
        ORDER BY s.END_OF_MONTH_DATE
      )                                                  AS prev_balance
    , (s.SOURCE_SYSTEM_BALANCE
       - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
           PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
         )
      )                                                  AS mom_delta
    , AVG(
        s.SOURCE_SYSTEM_BALANCE
        - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
            PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
          )
      ) OVER (
        PARTITION BY s.CONTRACT_SOURCE_SYSTEM
        ORDER BY s.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
      )                                                  AS mom_avg
    , STDDEV_SAMP(
        s.SOURCE_SYSTEM_BALANCE
        - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
            PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
          )
      ) OVER (
        PARTITION BY s.CONTRACT_SOURCE_SYSTEM
        ORDER BY s.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
      )                                                  AS mom_std
  FROM resid_stats s
),

-- 7) Z-scores, flags, severity
scored AS (
  SELECT
      m.*
    , CASE WHEN m.resid IS NOT NULL AND m.resid_std IS NOT NULL AND m.resid_std > 0
           THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
           ELSE NULL END                                  AS resid_z
    , CASE WHEN m.mom_delta IS NOT NULL AND m.mom_std IS NOT NULL AND m.mom_std > 0
           THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
           ELSE NULL END                                  AS mom_z
    , CASE WHEN ABS(
             CASE WHEN m.resid IS NOT NULL AND m.resid_std IS NOT NULL AND m.resid_std > 0
                  THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
                  ELSE 0 END
           ) >= 2.0 THEN 1 ELSE 0 END                     AS reg_anom_flag
    , CASE WHEN ABS(
             CASE WHEN m.mom_delta IS NOT NULL AND m.mom_std IS NOT NULL AND m.mom_std > 0
                  THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
                  ELSE 0 END
           ) >= 2.0 THEN 1 ELSE 0 END                     AS mom_anom_flag
    , (0.6 * COALESCE(ABS(
         CASE WHEN m.resid_std > 0 THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std END
       ),0.0)
       + 0.4 * COALESCE(ABS(
         CASE WHEN m.mom_std > 0 THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std END
       ),0.0)
       + CASE WHEN
           (CASE WHEN m.resid_std > 0 THEN ABS((m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std) ELSE 0 END) >= 2.0
           AND
           (CASE WHEN m.mom_std   > 0 THEN ABS((m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std)   ELSE 0 END) >= 2.0
         THEN 0.75 ELSE 0 END
      )                                                    AS severity_score
  FROM mom m
)

SELECT
    END_OF_MONTH_DATE
  , CONTRACT_SOURCE_SYSTEM
  , SOURCE_SYSTEM_BALANCE
  , yhat_pred                       AS REG_PRED_18M
  , resid                           AS REG_RESID
  , resid_z                         AS REG_RESID_Z
  , reg_anom_flag                   AS REG_ANOM_FLAG
  , prev_balance
  , mom_delta
  , mom_avg
  , mom_std
  , mom_z                           AS MOM_Z
  , mom_anom_flag                   AS MOM_ANOM_FLAG
  , severity_score
  , n_win                           AS WINDOW_OBS
  , beta1_slope                     AS TREND_SLOPE_18M
  , beta0_intercept                 AS TREND_INTERCEPT_18M
FROM scored
ORDER BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM;





-- Rolling regression + MoM anomaly scoring per CONTRACT_SOURCE_SYSTEM
-- Notes:
--  - Uses 18-month rolling window per system
--  - Requires at least 6 observations in-window to score (configurable)
--  - Casts to FLOAT8 early to avoid integer truncation
--  - Adjust filters (e.g., GL_ACCOUNT_HIER_LEVEL_4) as needed

WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  -- Pull enough history to support an 18-mo window with buffer (e.g., 36 mo)
  SELECT ADD_MONTHS(max_eom, -36) AS start_eom, max_eom FROM latest
),

-- 1) Monthly system totals (one row per system × month)
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                           AS END_OF_MONTH_DATE
    , t.CONTRACT_SOURCE_SYSTEM
    , CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8)       AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional domain filters:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) Month index per system to use as the time regressor (monotonic)
idx AS (
  SELECT
      b.*
    , DENSE_RANK() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM
                         ORDER BY b.END_OF_MONTH_DATE)    AS month_idx
  FROM base b
),

-- 3) Rolling (18-mo) time-trend regression per system
--    REGR_* functions accept (y, x). We window by ROWS 17 PRECEDING..CURRENT.
roll_regr AS (
  SELECT
      i.*
    , COUNT(*) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                   AS win_n

    , REGR_SLOPE(i.SOURCE_SYSTEM_BALANCE, i.month_idx) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                   AS beta1_slope

    , REGR_INTERCEPT(i.SOURCE_SYSTEM_BALANCE, i.month_idx) OVER (
        PARTITION BY i.CONTRACT_SOURCE_SYSTEM
        ORDER BY i.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                   AS beta0_intercept
  FROM idx i
),

-- 4) Predicted value and residual from the rolling regression
pred AS (
  SELECT
      r.*
    , CASE WHEN r.win_n >= 6 AND r.beta1_slope IS NOT NULL AND r.beta0_intercept IS NOT NULL
           THEN (r.beta1_slope * r.month_idx) + r.beta0_intercept
           ELSE NULL
      END                                                AS yhat_pred
    , CASE WHEN r.win_n >= 6 AND r.beta1_slope IS NOT NULL AND r.beta0_intercept IS NOT NULL
           THEN (r.SOURCE_SYSTEM_BALANCE - ((r.beta1_slope * r.month_idx) + r.beta0_intercept))
           ELSE NULL
      END                                                AS resid
  FROM roll_regr r
),

-- 5) Rolling residual dispersion to compute residual Z-scores
resid_stats AS (
  SELECT
      p.*
    , STDDEV_SAMP(p.resid) OVER (
        PARTITION BY p.CONTRACT_SOURCE_SYSTEM
        ORDER BY p.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS resid_std
    , AVG(p.resid) OVER (
        PARTITION BY p.CONTRACT_SOURCE_SYSTEM
        ORDER BY p.END_OF_MONTH_DATE
        ROWS BETWEEN 17 PRECEDING AND CURRENT ROW
      )                                                  AS resid_mean -- near 0 for OLS, but keep robust
  FROM pred p
),

-- 6) MoM deltas + rolling MoM average & std (exclude current by ending at 1 PRECEDING)
mom AS (
  SELECT
      s.*
    , LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
        PARTITION BY s.CONTRACT_SOURCE_SYSTEM
        ORDER BY s.END_OF_MONTH_DATE
      )                                                  AS prev_balance
    , (s.SOURCE_SYSTEM_BALANCE
       - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
           PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
         )
      )                                                  AS mom_delta

    , AVG( (s.SOURCE_SYSTEM_BALANCE
             - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
                 PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
               )
           )
        ) OVER (
          PARTITION BY s.CONTRACT_SOURCE_SYSTEM
          ORDER BY s.END_OF_MONTH_DATE
          ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
        )                                                AS mom_avg

    , STDDEV_SAMP( (s.SOURCE_SYSTEM_BALANCE
             - LAG(s.SOURCE_SYSTEM_BALANCE) OVER (
                 PARTITION BY s.CONTRACT_SOURCE_SYSTEM ORDER BY s.END_OF_MONTH_DATE
               )
           )
        ) OVER (
          PARTITION BY s.CONTRACT_SOURCE_SYSTEM
          ORDER BY s.END_OF_MONTH_DATE
          ROWS BETWEEN 17 PRECEDING AND 1 PRECEDING
        )                                                AS mom_std
  FROM resid_stats s
),

-- 7) Z-scores and anomaly flags
scored AS (
  SELECT
      m.*
    , CASE
        WHEN m.resid IS NOT NULL AND m.resid_std IS NOT NULL AND m.resid_std > 0
        THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
        ELSE NULL
      END                                                AS resid_z

    , CASE
        WHEN m.mom_delta IS NOT NULL AND m.mom_std IS NOT NULL AND m.mom_std > 0
        THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
        ELSE NULL
      END                                                AS mom_z

    , CASE WHEN ABS(
            CASE
              WHEN m.resid IS NOT NULL AND m.resid_std IS NOT NULL AND m.resid_std > 0
              THEN (m.resid - COALESCE(m.resid_mean,0.0)) / m.resid_std
              ELSE 0
            END
          ) >= 2.0
          THEN 1 ELSE 0 END                              AS resid_anomaly_flag

    , CASE WHEN ABS(
            CASE
              WHEN m.mom_delta IS NOT NULL AND m.mom_std IS NOT NULL AND m.mom_std > 0
              THEN (m.mom_delta - COALESCE(m.mom_avg,0.0)) / m.mom_std
              ELSE 0
            END
          ) >= 2.0
          THEN 1 ELSE 0 END                              AS mom_anomaly_flag
  FROM mom m
),

-- 8) Combined severity score (tunable weights)
ranked AS (
  SELECT
      s.*
    , (0.6 * COALESCE(ABS(s.resid_z), 0.0)
       + 0.4 * COALESCE(ABS(s.mom_z),   0.0)
       + CASE WHEN s.resid_anomaly_flag = 1 AND s.mom_anomaly_flag = 1 THEN 0.75 ELSE 0 END
      )                                                  AS severity_score
  FROM scored s
)

SELECT
    END_OF_MONTH_DATE
  , CONTRACT_SOURCE_SYSTEM
  , SOURCE_SYSTEM_BALANCE
  , yhat_pred                       AS REG_PRED_18M
  , resid                           AS REG_RESID
  , resid_z                         AS REG_RESID_Z
  , resid_anomaly_flag              AS REG_ANOM_FLAG
  , prev_balance
  , mom_delta
  , mom_avg
  , mom_std
  , mom_z                           AS MOM_Z
  , mom_anomaly_flag                AS MOM_ANOM_FLAG
  , severity_score
  , win_n                           AS WINDOW_OBS
  , beta1_slope                     AS TREND_SLOPE_18M
  , beta0_intercept                 AS TREND_INTERCEPT_18M
FROM ranked
-- Optional: focus on the most recent N months
-- WHERE END_OF_MONTH_DATE >= ADD_MONTHS((SELECT max_eom FROM latest), -6)
ORDER BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM;





WITH
cfg AS (
  SELECT
    12::INTEGER  AS lookback_n,
    1.0::FLOAT8  AS w_z_rate,
    1.0::FLOAT8  AS w_z_share,
    1.0::FLOAT8  AS w_mom_pct,
    1.5::FLOAT8  AS w_mom_cnt_pct,
    2.0::FLOAT8  AS z_thresh,
    0.25::FLOAT8 AS mom_pct_thresh,
    50000000::FLOAT8 AS abs_dollar_thresh
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
kde_month AS (
  SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
         m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
         MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
         MAX(t.NON_ACCRUAL_FLAG) AS NON_ACCRUAL_FLAG,
         MAX(t.CRE_FLAG) AS CRE_FLAG,
         MAX(t.RISK_UNIT) AS RISK_UNIT,
         MAX(t.FDIC_CALL_CODE) AS FDIC_CALL_CODE,
         MAX(t.LIFESTAGE) AS LIFESTAGE,
         MAX(t.NICHE_CD) AS NICHE_CD,
         MAX(t.RBC_CODE) AS RBC_CODE,
         MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
         MAX(t.RC_CODE) AS RC_CODE,
         MAX(t.RATE_TYPE) AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
kde_changes AS (
  SELECT kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))
  UNION ALL SELECT kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))
  UNION ALL SELECT kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),
kde_with_denoms AS (
  SELECT m.END_OF_MONTH_DATE, m.KDE, m.change_count, m.exposure_dollars,
         t.month_total_accounts, t.month_total_ssb,
         CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
         CASE WHEN t.month_total_ssb > 0      THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
with_prev AS (
  SELECT w.*,
         LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
         LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars
  FROM kde_with_denoms w
),
with_mom AS (
  SELECT p.*,
         (p.change_count - p.prev_change_count) AS mom_change_count_delta,
         CASE WHEN p.prev_change_count > 0
              THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
         (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
         CASE WHEN p.prev_exposure_dollars <> 0
              THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM with_prev p
),
trends AS (
  SELECT m.*,
         AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_N,
         AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_N,
         STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_N,
         STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_N
  FROM with_mom m
),
scored AS (
  SELECT t.*,
         CASE WHEN std_rate_N  IS NOT NULL AND std_rate_N  > 0 AND trend_rate_N  IS NOT NULL
              THEN (change_rate    - trend_rate_N)  / std_rate_N  END AS z_rate,
         CASE WHEN std_share_N IS NOT NULL AND std_share_N > 0 AND trend_share_N IS NOT NULL
              THEN (exposure_share - trend_share_N) / std_share_N END AS z_share
  FROM trends t
),
final_latest AS (
  SELECT
    s.*,
    -- severity (using cfg weights)
    (COALESCE(ABS(z_rate),0)  * c.w_z_rate)  +
    (COALESCE(ABS(z_share),0) * c.w_z_share) +
    (COALESCE(ABS(mom_exposure_dollars_pct),0) * c.w_mom_pct) +
    (COALESCE(ABS(mom_change_count_pct),0)    * c.w_mom_cnt_pct) AS severity_score,
    CASE WHEN
         ABS(COALESCE(z_rate,0))  >= c.z_thresh OR
         ABS(COALESCE(z_share,0)) >= c.z_thresh OR
         ABS(COALESCE(mom_exposure_dollars_pct,0)) >= c.mom_pct_thresh OR
         ABS(COALESCE(mom_exposure_dollars_delta,0)) >= c.abs_dollar_thresh OR
         ABS(COALESCE(mom_change_count_pct,0)) >= c.mom_pct_thresh
    THEN 1 ELSE 0 END AS likely_anomaly_flag
  FROM scored s
  CROSS JOIN cfg c
  WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
)
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, exposure_dollars, change_rate, exposure_share,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  trend_rate_N, trend_share_N, z_rate, z_share,
  severity_score, likely_anomaly_flag,
  DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE ORDER BY severity_score DESC, KDE) AS severity_rank_in_month
FROM final_latest
ORDER BY severity_rank_in_month, KDE;





WITH
cfg AS (
  SELECT
    12::INTEGER  AS lookback_n,
    1.0::FLOAT8  AS w_z_rate,
    1.0::FLOAT8  AS w_z_share,
    1.0::FLOAT8  AS w_mom_pct,
    1.5::FLOAT8  AS w_mom_cnt_pct,
    2.0::FLOAT8  AS z_thresh,
    0.25::FLOAT8 AS mom_pct_thresh,
    50000000::FLOAT8 AS abs_$_thresh
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
kde_month AS (
  SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
         m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
         MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
         MAX(t.NON_ACCRUAL_FLAG) AS NON_ACCRUAL_FLAG,
         MAX(t.CRE_FLAG) AS CRE_FLAG,
         MAX(t.RISK_UNIT) AS RISK_UNIT,
         MAX(t.FDIC_CALL_CODE) AS FDIC_CALL_CODE,
         MAX(t.LIFESTAGE) AS LIFESTAGE,
         MAX(t.NICHE_CD) AS NICHE_CD,
         MAX(t.RBC_CODE) AS RBC_CODE,
         MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
         MAX(t.RC_CODE) AS RC_CODE,
         MAX(t.RATE_TYPE) AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
kde_changes AS (
  SELECT kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))
  UNION ALL SELECT kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))
  UNION ALL SELECT kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB FROM kde_chg kc
   WHERE kc.prev_eom IS NOT NULL AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB FROM kde_chg WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
kde_monthly AS (
  SELECT END_OF_MONTH_DATE, KDE,
         COUNT(*) AS change_count,
         SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),
kde_with_denoms AS (
  SELECT m.END_OF_MONTH_DATE, m.KDE, m.change_count, m.exposure_dollars,
         t.month_total_accounts, t.month_total_ssb,
         CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
         CASE WHEN t.month_total_ssb > 0      THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
with_prev AS (
  SELECT w.*,
         LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
         LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars
  FROM kde_with_denoms w
),
with_mom AS (
  SELECT p.*,
         (p.change_count - p.prev_change_count) AS mom_change_count_delta,
         CASE WHEN p.prev_change_count > 0
              THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
         (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
         CASE WHEN p.prev_exposure_dollars <> 0
              THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM with_prev p
),
-- trends on the 12 months BEFORE current month
latest_window AS (
  SELECT l.max_eom, (l.max_eom - ADD_MONTHS(l.max_eom, -12))::INTEGER AS dummy -- keep CTE
  FROM latest l
),
trends AS (
  SELECT m.*,
         AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_N,
         AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_N,
         STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_N,
         STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_N
  FROM with_mom m
),
scored AS (
  SELECT t.*,
         CASE WHEN std_rate_N  IS NOT NULL AND std_rate_N  > 0 AND trend_rate_N  IS NOT NULL
              THEN (change_rate    - trend_rate_N)  / std_rate_N  END AS z_rate,
         CASE WHEN std_share_N IS NOT NULL AND std_share_N > 0 AND trend_share_N IS NOT NULL
              THEN (exposure_share - trend_share_N) / std_share_N END AS z_share
  FROM trends t
),
final_latest AS (
  SELECT s.*, c.* EXCEPT(lookback_n),
         -- severity
         (COALESCE(ABS(z_rate),0)  * c.w_z_rate)  +
         (COALESCE(ABS(z_share),0) * c.w_z_share) +
         (COALESCE(ABS(mom_exposure_dollars_pct),0) * c.w_mom_pct) +
         (COALESCE(ABS(mom_change_count_pct),0)    * c.w_mom_cnt_pct) AS severity_score,
         CASE WHEN ABS(COALESCE(z_rate,0))  >= c.z_thresh OR
                   ABS(COALESCE(z_share,0)) >= c.z_thresh OR
                   ABS(COALESCE(mom_exposure_dollars_pct,0)) >= c.mom_pct_thresh OR
                   ABS(COALESCE(mom_exposure_dollars_delta,0)) >= c.abs_$_thresh OR
                   ABS(COALESCE(mom_change_count_pct,0)) >= c.mom_pct_thresh
              THEN 1 ELSE 0 END AS likely_anomaly_flag
  FROM scored s
  CROSS JOIN cfg c
  WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
)
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, exposure_dollars, change_rate, exposure_share,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  trend_rate_N, trend_share_N, z_rate, z_share,
  severity_score, likely_anomaly_flag,
  DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE ORDER BY severity_score DESC, KDE) AS severity_rank_in_month
FROM final_latest
ORDER BY severity_rank_in_month, KDE;





WITH
/* ---------------------------- config ---------------------------- */
params AS (
  SELECT
    36::INTEGER AS months_back,     -- history pulled
    12::INTEGER AS lookback_n       -- rolling baseline length (excludes current month)
),
severity_cfg AS (
  SELECT
    1.0::FLOAT8 AS w_z_rate,        -- weight for |z_rate|
    1.0::FLOAT8 AS w_z_share,       -- weight for |z_share|
    1.0::FLOAT8 AS w_mom_pct,       -- weight for |MoM $ pct|
    2.0::FLOAT8 AS w_mom_cnt_pct,   -- optional weight for |MoM count %| (kept light)
    2.0::FLOAT8 AS z_thresh,        -- flag if z-score exceeds this
    0.25::FLOAT8 AS mom_pct_thresh, -- 25% MoM % threshold
    50000000::FLOAT8 AS abs_$_thresh-- $50MM MoM absolute $ threshold
),

/* ------------------------ date range bounds --------------------- */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

/* ---------- population: pos balance per acct x system ---------- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

/* ---------------- UNPIVOT (booleans + DPD + categoricals) ------ */
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG
  SELECT kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))
  UNION ALL
  -- BOOLEAN: CRE_FLAG
  SELECT kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))
  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE (count events)
  SELECT kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
  -- CATEGORICALS (count-only)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

/* ---------------- Month × KDE rollup (actuals) ----------------- */
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)      AS change_count,
    SUM(CURR_SSB) AS exposure_dollars
  FROM kde_changes
  GROUP BY 1,2
),

/* ---------------- add denominators & rates/shares --------------- */
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

/* ------------------- prev month snapshots ---------------------- */
with_prev AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars
  FROM kde_with_denoms w
),

/* ------------- MoM deltas & percents (simple) ------------------ */
with_mom AS (
  SELECT
    p.*,
    (p.change_count     - p.prev_change_count)     AS mom_change_count_delta,
    CASE WHEN p.prev_change_count > 0
         THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
    (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN p.prev_exposure_dollars <> 0
         THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct
  FROM with_prev p
),

/* --------- rolling trends (N-month averages) & stddevs ---------- */
trends AS (
  SELECT
    m.*,
    AVG(change_count)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS trend_count_N,
    AVG(exposure_dollars) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS trend_exposure_N,
    AVG(change_rate)      OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS trend_rate_N,
    AVG(exposure_share)   OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS trend_share_N,
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                      ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS std_rate_N,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                      ROWS BETWEEN (SELECT lookback_n FROM params) PRECEDING AND 1 PRECEDING) AS std_share_N
  FROM with_mom m
),

/* ------------------- severity & ranking ------------------------- */
scored AS (
  SELECT
    t.*,
    -- z-scores on normalized metrics
    CASE WHEN std_rate_N  IS NOT NULL AND std_rate_N  > 0 AND trend_rate_N  IS NOT NULL
         THEN (change_rate    - trend_rate_N)  / std_rate_N  END AS z_rate,
    CASE WHEN std_share_N IS NOT NULL AND std_share_N > 0 AND trend_share_N IS NOT NULL
         THEN (exposure_share - trend_share_N) / std_share_N END AS z_share,

    -- severity = weighted sum of absolute components (tunable)
    COALESCE(ABS( CASE WHEN std_rate_N  > 0 AND trend_rate_N  IS NOT NULL THEN (change_rate    - trend_rate_N)  / std_rate_N  END ), 0) * (SELECT w_z_rate  FROM severity_cfg)
  + COALESCE(ABS( CASE WHEN std_share_N > 0 AND trend_share_N IS NOT NULL THEN (exposure_share - trend_share_N) / std_share_N END ), 0) * (SELECT w_z_share FROM severity_cfg)
  + COALESCE(ABS(mom_exposure_dollars_pct), 0) * (SELECT w_mom_pct FROM severity_cfg)
  + COALESCE(ABS(mom_change_count_pct),   0) * (SELECT w_mom_cnt_pct FROM severity_cfg)
      AS severity_score,

    -- simple anomaly flag using a few crisp thresholds
    CASE WHEN
        ABS( CASE WHEN std_share_N > 0 AND trend_share_N IS NOT NULL THEN (exposure_share - trend_share_N)/std_share_N END ) >= (SELECT z_thresh FROM severity_cfg)
     OR ABS( CASE WHEN std_rate_N  > 0 AND trend_rate_N  IS NOT NULL THEN (change_rate    - trend_rate_N) /std_rate_N  END ) >= (SELECT z_thresh FROM severity_cfg)
     OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_thresh FROM severity_cfg)
     OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_$_thresh FROM severity_cfg)
     OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_thresh FROM severity_cfg)
      THEN 1 ELSE 0 END AS likely_anomaly_flag
  FROM trends t
),
ranked AS (
  SELECT
    s.*,
    DENSE_RANK() OVER (PARTITION BY s.END_OF_MONTH_DATE ORDER BY s.severity_score DESC, s.KDE) AS severity_rank_in_month
  FROM scored s
)

SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- actuals
  change_count,
  exposure_dollars,
  change_rate,
  exposure_share,

  -- MoM deltas
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,

  -- baselines
  trend_count_N,
  trend_exposure_N,
  trend_rate_N,
  trend_share_N,

  -- z-scores
  z_rate,
  z_share,

  -- severity & flags
  severity_score,
  likely_anomaly_flag,
  severity_rank_in_month

FROM ranked
ORDER BY END_OF_MONTH_DATE DESC, severity_rank_in_month, KDE;





Coverage % :=
VAR BaseRows =
    FILTER (
        ALLSELECTED ( tblVariance ),
        NOT ISBLANK ( tblVariance[actual] )
            && NOT ISBLANK ( tblVariance[pi95_lo] )
            && NOT ISBLANK ( tblVariance[pi95_hi] )
    )
VAR TotalCount = COUNTROWS ( BaseRows )
VAR OutsideCount =
    COUNTROWS ( FILTER ( BaseRows, tblVariance[OUTSIDE_95_BAND] = TRUE () ) )
RETURN IF ( TotalCount > 0, 1 - DIVIDE ( OutsideCount, TotalCount ) )





RMSE :=
VAR _rows :=
    FILTER(
        ALLSELECTED(tblVariance),
        NOT ISBLANK(tblVariance[actual]) &&
        NOT ISBLANK(tblVariance[forecast_val])
    )
VAR _sumSq :=
    SUMX(_rows, POWER(tblVariance[actual] - tblVariance[forecast_val], 2))
VAR _n := COUNTROWS(_rows)
RETURN IF(_n > 0, SQRT(DIVIDE(_sumSq, _n)))




Coverage % :=
VAR _base :=
    FILTER(
        ALLSELECTED(tblVariance),
        NOT ISBLANK(tblVariance[actual])   &&
        NOT ISBLANK(tblVariance[pi95_lo]) &&
        NOT ISBLANK(tblVariance[pi95_hi])
    )
VAR _total   := COUNTROWS(_base)
VAR _outside := COUNTROWS( FILTER(_base, tblVariance[OUTSIDE_95_BAND] = TRUE() ) )
RETURN IF(_total > 0, 1 - DIVIDE(_outside, _total))







WITH
/* ---------------------------- config ---------------------------- */
params AS (
  SELECT 36::INTEGER AS months_back
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1::INTEGER  AS use_trend6,        -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::FLOAT8 AS weight_trend,
    0.30::FLOAT8 AS weight_seasonal,
    2.5  ::FLOAT8 AS z_threshold,              -- z-like threshold for rate/share
    0.25 ::FLOAT8 AS mom_pct_threshold,        -- 25%
    50000000::FLOAT8 AS abs_dollar_threshold,  -- $50MM
    0.15 ::FLOAT8 AS rel_vs_expected_threshold -- 15%
),

/* ------------------------ date range bounds --------------------- */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

/* ---------- population: pos balance per acct x system ---------- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$') THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$') THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98 THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98 THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
),

/* ---------------- UNPIVOT (booleans + numerics) ---------------- */
kde_changes_a AS (
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- PD_GRADE (validated numeric set)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
),

/* -------------------- UNPIVOT (dates) --------------------------- */
kde_changes_dates AS (
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )
  UNION ALL
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0, NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
),

/* ---------------- UNPIVOT (categoricals) ------------------------ */
kde_changes_cats AS (
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT'               AS KDE, CURR_SSB, 0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
    FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

/* ----------------- combine and roll up monthly ------------------ */
kde_changes AS (
  SELECT * FROM kde_changes_a
  UNION ALL SELECT * FROM kde_changes_dates
  UNION ALL SELECT * FROM kde_changes_cats
),
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

/* ---------------- add denominators & rates/shares --------------- */
kde_with_denoms AS (
  SELECT
    m.*,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

/* ------------------- MoM deltas & prevs ------------------------ */
with_prev AS (
  SELECT
    w.*,
    LAG(w.change_count)           OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars)       OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)          OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)         OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude)  OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)         OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved
  FROM kde_with_denoms w
),
with_mom AS (
  SELECT
    p.*,
    (p.change_count - p.prev_change_count) AS mom_change_count_delta,
    CASE WHEN p.prev_change_count > 0
         THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
    (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN p.prev_exposure_dollars <> 0
         THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct,
    (p.flag_on_count  - p.prev_flag_on_count)  AS mom_flag_on_delta,
    (p.flag_off_count - p.prev_flag_off_count) AS mom_flag_off_delta,
    (p.sum_numeric_magnitude - p.prev_sum_numeric_magnitude) AS mom_sum_numeric_mag_delta,
    (p.sum_days_moved        - p.prev_sum_days_moved)        AS mom_sum_days_moved_delta
  FROM with_prev p
),

/* ---- rolling trends (6/12 mo) & same-month seasonality -------- */
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

/* -------- expected rates/shares + stddevs + expected count/$ ---- */
expected AS (
  SELECT
    b.*,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

/* --------------------------- final ------------------------------ */
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive surprises + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;






, kde_with_denoms AS (
  SELECT
    m.*,                              -- carries flag_on/off, magnitudes, etc.
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
)



, with_prev AS (
  SELECT
    w.*,
    LAG(w.change_count)           OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars)       OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)          OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)         OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude)  OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)         OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved
  FROM kde_with_denoms w
),
with_mom AS (
  SELECT
    p.*,
    /* counts */
    (p.change_count - p.prev_change_count) AS mom_change_count_delta,
    CASE WHEN p.prev_change_count > 0
         THEN (p.change_count - p.prev_change_count) / p.prev_change_count::FLOAT8 END AS mom_change_count_pct,
    /* exposure $ */
    (p.exposure_dollars - p.prev_exposure_dollars) AS mom_exposure_dollars_delta,
    CASE WHEN p.prev_exposure_dollars <> 0
         THEN (p.exposure_dollars - p.prev_exposure_dollars) / p.prev_exposure_dollars::FLOAT8 END AS mom_exposure_dollars_pct,
    /* extras */
    (p.flag_on_count  - p.prev_flag_on_count)  AS mom_flag_on_delta,
    (p.flag_off_count - p.prev_flag_off_count) AS mom_flag_off_delta,
    (p.sum_numeric_magnitude - p.prev_sum_numeric_magnitude) AS mom_sum_numeric_mag_delta,
    (p.sum_days_moved        - p.prev_sum_days_moved)        AS mom_sum_days_moved_delta
  FROM with_prev p
)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,      prev_change_count,      mom_change_count_delta,      mom_change_count_pct,
  exposure_dollars,  prev_exposure_dollars,  mom_exposure_dollars_delta,  mom_exposure_dollars_pct,
  flag_on_count,     prev_flag_on_count,     mom_flag_on_delta,
  flag_off_count,    prev_flag_off_count,    mom_flag_off_delta,
  sum_numeric_magnitude, prev_sum_numeric_magnitude, mom_sum_numeric_mag_delta,
  sum_days_moved,        prev_sum_days_moved,        mom_sum_days_moved_delta,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share
FROM with_mom
ORDER BY END_OF_MONTH_DATE DESC, KDE
LIMIT 200;





, with_prev AS (
  SELECT
    w.*,
    LAG(w.change_count)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)       OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)      OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved
  FROM kde_with_denoms w
)
SELECT END_OF_MONTH_DATE, KDE,
       change_count, prev_change_count,
       exposure_dollars, prev_exposure_dollars
FROM with_prev
ORDER BY END_OF_MONTH_DATE DESC, KDE
LIMIT 50;





WITH
/* ---------- population: pos balance per acct x system ---------- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$') THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$') THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98 THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98 THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
),

/* ---------------- UNPIVOT (booleans + numerics) ---------------- */
kde_changes_a AS (
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- PD_GRADE (validated numeric set)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
),

/* -------------------- UNPIVOT (dates) --------------------------- */
kde_changes_dates AS (
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )
  UNION ALL
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0, NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
),

/* ---------------- UNPIVOT (categoricals) ------------------------ */
kde_changes_cats AS (
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT'               AS KDE, CURR_SSB, 0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
    FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

/* ----------------- combine and roll up monthly ------------------ */
kde_changes AS (
  SELECT * FROM kde_changes_a
  UNION ALL SELECT * FROM kde_changes_dates
  UNION ALL SELECT * FROM kde_changes_cats
),
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

/* ---------------- add denominators & rates/shares --------------- */
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

/* ------------------- NEW: MoM deltas & %s ---------------------- */
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
)

SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,      prev_change_count,      mom_change_count_delta,      mom_change_count_pct,
  exposure_dollars,  prev_exposure_dollars,  mom_exposure_dollars_delta,  mom_exposure_dollars_pct,
  flag_on_count,     prev_flag_on_count,
  flag_off_count,    prev_flag_off_count,
  sum_numeric_magnitude, prev_sum_numeric_magnitude,
  sum_days_moved,       prev_sum_days_moved,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share
FROM with_mom
ORDER BY END_OF_MONTH_DATE DESC, KDE
LIMIT 200;






MoM $ Change =
VAR CurrentSystem = tblVariance[CONTRACT_SOURCE_SYSTEM]
VAR CurrentDate   = tblVariance[period_date]
VAR PriorActual   =
    CALCULATE (
        MAX ( tblVariance[actual] ),
        FILTER (
            tblVariance,
            tblVariance[CONTRACT_SOURCE_SYSTEM] = CurrentSystem &&
            tblVariance[period_date] = EOMONTH ( CurrentDate, -1 )
        )
    )
RETURN
IF ( NOT ISBLANK (PriorActual), tblVariance[actual] - PriorActual )




MoM % Change =
VAR CurrentSystem = tblVariance[CONTRACT_SOURCE_SYSTEM]
VAR CurrentDate   = tblVariance[period_date]
VAR PriorActual   =
    CALCULATE (
        MAX ( tblVariance[actual] ),
        FILTER (
            tblVariance,
            tblVariance[CONTRACT_SOURCE_SYSTEM] = CurrentSystem &&
            tblVariance[period_date] = EOMONTH ( CurrentDate, -1 )
        )
    )
RETURN
IF (
    NOT ISBLANK (PriorActual) && PriorActual <> 0,
    (tblVariance[actual] - PriorActual) / PriorActual
)





WITH
measures AS (...),
month_totals AS (...),
kde_month AS (...),
kde_chg AS (...),
pd_cast AS (...),
pd_cast_valid AS (...),

kde_changes_a AS ( ...your working Part 1 block... ),
kde_changes_dates AS ( ...from Step 2... ),
kde_changes_cats  AS ( ...from Step 3... ),

kde_changes AS (
  SELECT * FROM kde_changes_a
  UNION ALL SELECT * FROM kde_changes_dates
  UNION ALL SELECT * FROM kde_changes_cats
),
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
kde_with_denoms AS (
  SELECT
    m.*,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
)
SELECT *
FROM kde_with_denoms
ORDER BY END_OF_MONTH_DATE DESC, KDE
LIMIT 100;







WITH
measures AS (...same as before...),
month_totals AS (...same...),
kde_month AS (...same...),
kde_chg AS (...same...),

kde_changes_cats AS (
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT'               AS KDE, CURR_SSB, 0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_cats
GROUP BY KDE
ORDER BY KDE;





, -- Step 2: dates only
kde_changes_dates AS (
  -- MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_dates
GROUP BY KDE
ORDER BY KDE;




WITH
/* ---------------- population: pos balance per acct x system ----- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),

pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
)





WITH
-- reuse your working CTEs verbatim:
measures AS (...same as you ran...),
month_totals AS (...same...),
kde_month AS (...same...),
kde_chg AS (...same...),
pd_cast AS (...same...),
pd_cast_valid AS (...same...),

kde_changes_a AS (
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- PD_GRADE (validated numeric set)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_a
GROUP BY KDE
ORDER BY KDE;





WITH
measures AS (...), month_totals AS (...), kde_month AS (...), kde_chg AS (...),

kde_changes_dates AS (
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_dates
GROUP BY KDE
ORDER BY KDE;





WITH
/* ---------------------------- config ---------------------------- */
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::FLOAT8 AS weight_trend,
    0.30::FLOAT8 AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::FLOAT8 AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),
/* ------------------------ date range bounds --------------------- */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),
/* ---------------- population: pos balance per acct x system ----- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw (no normalization)
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
),
/* ------------- UNPIVOT to per-KDE change events (type-aware) ------------- */
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE (valid set only)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE (moved days)
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE (moved days)
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
/* ---------------- Month × KDE rollup (actuals) ----------------- */
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
/* ------------- join denominators; compute rates/shares ---------- */
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
/* -------------------- MoM deltas and %s ------------------------ */
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,
    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),
/* ---- rolling trends (6/12 mo) & same-month seasonality -------- */
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),
/* -------- expected rates/shares + stddevs + expected count/$ ---- */
expected AS (
  SELECT
    b.*,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)
/* --------------------------- final ------------------------------ */
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive surprises + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;





pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,

    /* Parse PD_GRADE text → INT only if it is purely digits */
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,

    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
/* Validate allowed set and expose as FLOAT8 for math */
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
)



JOIN pd_cast_valid p
  ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
 AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
 AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY




WITH ...measures..., ...month_totals..., ...kde_month..., ...kde_chg...,
pd_cast AS ( /* first CTE above */ ),
pd_cast_valid AS ( /* second CTE above */ )
SELECT
  COUNT(*) AS rows_all,
  SUM(CASE WHEN PD_NUM IS NOT NULL OR PREV_PD_NUM IS NOT NULL THEN 1 ELSE 0 END) AS rows_valid_pd,
  SUM(CASE WHEN PD_NUM IS NULL  AND PREV_PD_NUM IS NULL  THEN 1 ELSE 0 END) AS rows_dropped
FROM pd_cast_valid;





WITH
...same measures, month_totals, kde_month, kde_chg...,
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN PD_GRADE::FLOAT8 ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN prev_pd::FLOAT8 ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
)
SELECT
  COUNT(*) AS rows_pd_cast,
  SUM(CASE WHEN PD_NUM IS NOT NULL OR PREV_PD_NUM IS NOT NULL THEN 1 ELSE 0 END) AS rows_valid_pd
FROM pd_cast;




WITH
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
kde_month AS (
  SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
         m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
         MAX(t.PD_GRADE)      AS PD_GRADE,
         MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
         MAX(t.MATURITY_DATE) AS MATURITY_DATE,
         MAX(t.BOOK_DATE)     AS BOOK_DATE,
         MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
         MAX(t.CRE_FLAG)                AS CRE_FLAG,
         MAX(t.RISK_UNIT)               AS RISK_UNIT,
         MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
         MAX(t.LIFESTAGE)               AS LIFESTAGE,
         MAX(t.NICHE_CD)                AS NICHE_CD,
         MAX(t.RBC_CODE)                AS RBC_CODE,
         MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
         MAX(t.RC_CODE)                 AS RC_CODE,
         MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
)
SELECT
  COUNT(*) AS rows_kde_chg,
  SUM(CASE WHEN prev_eom IS NOT NULL THEN 1 ELSE 0 END) AS rows_with_prev,
  MIN(END_OF_MONTH_DATE) AS min_eom,
  MAX(END_OF_MONTH_DATE) AS max_eom
FROM kde_chg;





WITH
measures AS (...same as before...),
month_totals AS (...same as above...),
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE
    -- (you can add more KDE fields here, but start small to debug)
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
)
SELECT * FROM kde_month LIMIT 20;





WITH measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
)
SELECT COUNT(*) AS cnt, MIN(END_OF_MONTH_DATE) AS min_eom, MAX(END_OF_MONTH_DATE) AS max_eom
FROM measures;





WITH
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),
-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
-- 4b) PD_GRADE numeric validation (0–14, 98)
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN PD_GRADE::FLOAT8 ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN prev_pd::FLOAT8 ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),
-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)) AS numeric_mag,
    NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
-- 6) Month × KDE rollup
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
-- 8) MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,
    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),
-- 9) Rolling trends (6 & 12 mo) & same-month seasonality
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),
-- 10) Expected rates/shares + stddevs; expected count/$
expected AS (
  SELECT
    b.*,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)
-- Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count, exposure_dollars,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share,
  flag_on_count, flag_off_count,
  sum_numeric_magnitude, avg_numeric_magnitude,
  sum_days_moved, avg_days_moved,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  prev_flag_on_count, mom_flag_on_delta,
  prev_flag_off_count, mom_flag_off_delta,
  prev_sum_numeric_magnitude, mom_sum_numeric_mag_delta,
  prev_sum_days_moved, mom_sum_days_moved_delta,
  expected_count, expected_exposure, expected_rate, expected_share,
  (change_count - expected_count)           AS resid_count,
  (exposure_dollars - expected_exposure)    AS resid_exposure,
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate - expected_rate) / std_rate_12 END  AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG
FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







CREATE TABLE KDE_TMP_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

SELECT COUNT(*) FROM KDE_TMP_MEASURES;






CREATE VIEW KDE_V_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  -- force floating type without nested CAST on the aggregate
  (SUM(t.SOURCE_SYSTEM_BALANCE) * 1.0)::FLOAT8 AS SOURCE_SYSTEM_BALANCE
FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;









CREATE OR REPLACE VIEW CIDPR..KDE_V_MEASURES AS
SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
       CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

CREATE OR REPLACE VIEW CIDPR..KDE_V_MONTH_TOTALS AS
SELECT END_OF_MONTH_DATE,
       COUNT(DISTINCT (CONTRACT_SOURCE_SYSTEM || '|' || ACCOUNT_KEY)) AS month_total_accounts,
       SUM(SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_V_MEASURES
GROUP BY 1;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_MONTH AS
SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
       m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
       MAX(t.PD_GRADE) PD_GRADE, MAX(t.DAYS_PAST_DUE) DAYS_PAST_DUE,
       MAX(t.MATURITY_DATE) MATURITY_DATE, MAX(t.BOOK_DATE) BOOK_DATE,
       MAX(t.NON_ACCRUAL_FLAG) NON_ACCRUAL_FLAG, MAX(t.CRE_FLAG) CRE_FLAG,
       MAX(t.RISK_UNIT) RISK_UNIT, MAX(t.FDIC_CALL_CODE) FDIC_CALL_CODE,
       MAX(t.LIFESTAGE) LIFESTAGE, MAX(t.NICHE_CD) NICHE_CD,
       MAX(t.RBC_CODE) RBC_CODE, MAX(t.REVOLVING_NON_REVOLVING) REVOLVING_NON_REVOLVING,
       MAX(t.RC_CODE) RC_CODE, MAX(t.RATE_TYPE) RATE_TYPE
FROM CIDPR..KDE_V_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_CHG AS
SELECT k.*,
       LAG(k.END_OF_MONTH_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
       LAG(k.PD_GRADE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
       LAG(k.DAYS_PAST_DUE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
       LAG(k.MATURITY_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
       LAG(k.BOOK_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
       LAG(k.NON_ACCRUAL_FLAG) OVER (...) AS prev_na,
       LAG(k.CRE_FLAG)        OVER (...) AS prev_cre,
       LAG(k.RISK_UNIT)       OVER (...) AS prev_risk_unit,
       LAG(k.FDIC_CALL_CODE)  OVER (...) AS prev_fcc,
       LAG(k.LIFESTAGE)       OVER (...) AS prev_lifestage,
       LAG(k.NICHE_CD)        OVER (...) AS prev_niche,
       LAG(k.RBC_CODE)        OVER (...) AS prev_rbc,
       LAG(k.REVOLVING_NON_REVOLVING) OVER (...) AS prev_revolver,
       LAG(k.RC_CODE)         OVER (...) AS prev_rc,
       LAG(k.RATE_TYPE)       OVER (...) AS prev_rate_type
FROM CIDPR..KDE_V_KDE_MONTH k;





CREATE OR REPLACE VIEW CIDPR..KDE_V_MEASURES AS
SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
       CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

CREATE OR REPLACE VIEW CIDPR..KDE_V_MONTH_TOTALS AS
SELECT END_OF_MONTH_DATE,
       COUNT(DISTINCT (CONTRACT_SOURCE_SYSTEM || '|' || ACCOUNT_KEY)) AS month_total_accounts,
       SUM(SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_V_MEASURES
GROUP BY 1;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_MONTH AS
SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
       m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
       MAX(t.PD_GRADE) PD_GRADE, MAX(t.DAYS_PAST_DUE) DAYS_PAST_DUE,
       MAX(t.MATURITY_DATE) MATURITY_DATE, MAX(t.BOOK_DATE) BOOK_DATE,
       MAX(t.NON_ACCRUAL_FLAG) NON_ACCRUAL_FLAG, MAX(t.CRE_FLAG) CRE_FLAG,
       MAX(t.RISK_UNIT) RISK_UNIT, MAX(t.FDIC_CALL_CODE) FDIC_CALL_CODE,
       MAX(t.LIFESTAGE) LIFESTAGE, MAX(t.NICHE_CD) NICHE_CD,
       MAX(t.RBC_CODE) RBC_CODE, MAX(t.REVOLVING_NON_REVOLVING) REVOLVING_NON_REVOLVING,
       MAX(t.RC_CODE) RC_CODE, MAX(t.RATE_TYPE) RATE_TYPE
FROM CIDPR..KDE_V_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_CHG AS
SELECT k.*,
       LAG(k.END_OF_MONTH_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
       LAG(k.PD_GRADE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
       LAG(k.DAYS_PAST_DUE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
       LAG(k.MATURITY_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
       LAG(k.BOOK_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
       LAG(k.NON_ACCRUAL_FLAG) OVER (...) AS prev_na,
       LAG(k.CRE_FLAG)        OVER (...) AS prev_cre,
       LAG(k.RISK_UNIT)       OVER (...) AS prev_risk_unit,
       LAG(k.FDIC_CALL_CODE)  OVER (...) AS prev_fcc,
       LAG(k.LIFESTAGE)       OVER (...) AS prev_lifestage,
       LAG(k.NICHE_CD)        OVER (...) AS prev_niche,
       LAG(k.RBC_CODE)        OVER (...) AS prev_rbc,
       LAG(k.REVOLVING_NON_REVOLVING) OVER (...) AS prev_revolver,
       LAG(k.RC_CODE)         OVER (...) AS prev_rc,
       LAG(k.RATE_TYPE)       OVER (...) AS prev_rate_type
FROM CIDPR..KDE_V_KDE_MONTH k;






-- ================================================================
-- KDE Monthly Monitor (Netezza, single statement)
-- ================================================================

WITH
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 4b) PD_GRADE numeric validation (0–14, 98); ignore others in magnitude
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality
baselines AS (
  SELECT
    x.*,

    -- exclude current row
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; expected count/$
expected AS (
  SELECT
    b.*,

    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







-- Clean up prior runs (safe if first time)
DROP TABLE IF EXISTS CIDPR..KDE_TMP_MEASURES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_MONTH_TOTALS;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_MONTH;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_CHG;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_PD_CAST;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_CHANGES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_MONTHLY;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_WITH_DENOMS;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_WITH_MOM;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_BASELINES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_EXPECTED;

-- A) measures
CREATE TABLE CIDPR..KDE_TMP_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

-- B) month_totals
CREATE TABLE CIDPR..KDE_TMP_MONTH_TOTALS AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_TMP_MEASURES m
GROUP BY 1;

-- C) kde_month
CREATE TABLE CIDPR..KDE_TMP_KDE_MONTH AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
  MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM CIDPR..KDE_TMP_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

-- D) kde_chg (add LAGs)
CREATE TABLE CIDPR..KDE_TMP_KDE_CHG AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM CIDPR..KDE_TMP_KDE_MONTH k;

-- E) pd_cast (PD_GRADE valid 0–14, 98)
CREATE TABLE CIDPR..KDE_TMP_PD_CAST AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98
       THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98
       THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM CIDPR..KDE_TMP_KDE_CHG;

-- F) kde_changes (UNION ALL)
CREATE TABLE CIDPR..KDE_TMP_KDE_CHANGES AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  JOIN CIDPR..KDE_TMP_PD_CAST p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);

-- G) kde_monthly
CREATE TABLE CIDPR..KDE_TMP_KDE_MONTHLY AS
SELECT
  END_OF_MONTH_DATE,
  KDE,
  COUNT(*)                                      AS change_count,
  SUM(CURR_SSB)                                 AS exposure_dollars,
  SUM(bool_on)                                  AS flag_on_count,
  SUM(bool_off)                                 AS flag_off_count,
  SUM(numeric_mag)                               AS sum_numeric_magnitude,
  AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
  SUM(days_mag)                                  AS sum_days_moved,
  AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
FROM CIDPR..KDE_TMP_KDE_CHANGES
GROUP BY 1,2;

-- H) with_denoms
CREATE TABLE CIDPR..KDE_TMP_WITH_DENOMS AS
SELECT
  m.END_OF_MONTH_DATE,
  m.KDE,
  m.change_count,
  m.exposure_dollars,
  t.month_total_accounts,
  t.month_total_ssb,
  CASE WHEN t.month_total_accounts > 0
       THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
  CASE WHEN t.month_total_ssb > 0
       THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
  m.flag_on_count, m.flag_off_count,
  m.sum_numeric_magnitude, m.avg_numeric_magnitude,
  m.sum_days_moved,        m.avg_days_moved,
  EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
FROM CIDPR..KDE_TMP_KDE_MONTHLY m
JOIN CIDPR..KDE_TMP_MONTH_TOTALS t USING (END_OF_MONTH_DATE);

-- I) with_mom
CREATE TABLE CIDPR..KDE_TMP_WITH_MOM AS
SELECT
  w.*,
  LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
  LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
  LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
  LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
  LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
  LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

  (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
  (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

  CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
       THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

  CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
       THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
FROM CIDPR..KDE_TMP_WITH_DENOMS w;

-- J) baselines
CREATE TABLE CIDPR..KDE_TMP_BASELINES AS
SELECT
  x.*,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
  AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
  AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
FROM CIDPR..KDE_TMP_WITH_MOM x;

-- K) expected
CREATE TABLE CIDPR..KDE_TMP_EXPECTED AS
SELECT
  b.*,
  /* choose 6-mo trend (1) vs 12-mo (0) */
  CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
  CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

  0.70::DOUBLE PRECISION AS weight_trend,
  0.30::DOUBLE PRECISION AS weight_seasonal,

  COALESCE(0.70 * (CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END) + 0.30 * same_month_rate,
           (CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END),
           same_month_rate) AS expected_rate,

  COALESCE(0.70 * (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30 * same_month_share,
           (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
           same_month_share) AS expected_share,

  STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
  STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

  CASE WHEN month_total_accounts IS NOT NULL THEN
    COALESCE(0.70*(CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) + 0.30*same_month_rate,
             (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
             same_month_rate) * month_total_accounts END AS expected_count,

  CASE WHEN month_total_ssb IS NOT NULL THEN
    COALESCE(0.70*(CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30*same_month_share,
             (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
             same_month_share) * month_total_ssb END AS expected_exposure
FROM CIDPR..KDE_TMP_BASELINES b;

-- L) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count, exposure_dollars,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share,
  flag_on_count, flag_off_count,
  sum_numeric_magnitude, avg_numeric_magnitude,
  sum_days_moved, avg_days_moved,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  prev_flag_on_count, mom_flag_on_delta,
  prev_flag_off_count, mom_flag_off_delta,
  prev_sum_numeric_magnitude, mom_sum_numeric_mag_delta,
  prev_sum_days_moved, mom_sum_days_moved_delta,
  expected_count, expected_exposure, expected_rate, expected_share,
  (change_count - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= 2.5
       OR ABS(exposure_dollars - expected_exposure) >= 50000000
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= 0.15)
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= 50000000
       OR ABS(COALESCE(mom_change_count_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG
FROM CIDPR..KDE_TMP_EXPECTED
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;




-- ======================================================================
-- CONFIG
-- ======================================================================
-- Change this if your writable scratch schema is different:
SET SCHEMA 'CIDPR.DATAHUB';

-- Optional: clean up any leftovers from prior runs
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_MEASURES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_MONTH_TOTALS;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_MONTH;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_CHG;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_PD_CAST;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_CHANGES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_MONTHLY;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_WITH_DENOMS;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_WITH_MOM;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_BASELINES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_EXPECTED;

-- ======================================================================
-- A) measures  (positive-balance population)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_MEASURES
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

SELECT COUNT(*) AS CNT_MEASURES FROM CIDPR.DATAHUB.TMP_MEASURES;

-- ======================================================================
-- B) month_totals (denominators)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_MONTH_TOTALS
DISTRIBUTE ON (END_OF_MONTH_DATE) AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR.DATAHUB.TMP_MEASURES m
GROUP BY 1;

SELECT COUNT(*) AS CNT_MONTH_TOTALS FROM CIDPR.DATAHUB.TMP_MONTH_TOTALS;

-- ======================================================================
-- C) kde_month (snapshot with KDEs; RC_CODE left raw)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_MONTH
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
  MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM CIDPR.DATAHUB.TMP_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

SELECT COUNT(*) AS CNT_KDE_MONTH FROM CIDPR.DATAHUB.TMP_KDE_MONTH;

-- ======================================================================
-- D) kde_chg (add prior month snapshots via LAG)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_CHG
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM CIDPR.DATAHUB.TMP_KDE_MONTH k;

SELECT COUNT(*) AS CNT_KDE_CHG FROM CIDPR.DATAHUB.TMP_KDE_CHG;

-- ======================================================================
-- E) pd_cast (PD_GRADE numeric validation: 0–14, 98)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_PD_CAST
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98
       THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98
       THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM CIDPR.DATAHUB.TMP_KDE_CHG;

SELECT COUNT(*) AS CNT_PD_CAST FROM CIDPR.DATAHUB.TMP_PD_CAST;

-- ======================================================================
-- F) kde_changes  (the UNION ALL — most common parse hotspot)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_CHANGES
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE (valid 0–14, 98 only)
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  JOIN CIDPR.DATAHUB.TMP_PD_CAST p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL: (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);

SELECT COUNT(*) AS CNT_KDE_CHANGES FROM CIDPR.DATAHUB.TMP_KDE_CHANGES;

-- ======================================================================
-- G) kde_monthly (rollup)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_MONTHLY
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  END_OF_MONTH_DATE,
  KDE,
  COUNT(*)                                      AS change_count,
  SUM(CURR_SSB)                                 AS exposure_dollars,
  SUM(bool_on)                                  AS flag_on_count,
  SUM(bool_off)                                 AS flag_off_count,
  SUM(numeric_mag)                               AS sum_numeric_magnitude,
  AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
  SUM(days_mag)                                  AS sum_days_moved,
  AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
FROM CIDPR.DATAHUB.TMP_KDE_CHANGES
GROUP BY 1,2;

SELECT COUNT(*) AS CNT_KDE_MONTHLY FROM CIDPR.DATAHUB.TMP_KDE_MONTHLY;

-- ======================================================================
-- H) with_denoms (join denominators; compute rates/shares)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_WITH_DENOMS
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  m.END_OF_MONTH_DATE,
  m.KDE,
  m.change_count,
  m.exposure_dollars,
  t.month_total_accounts,
  t.month_total_ssb,
  CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
  CASE WHEN t.month_total_ssb > 0 THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
  m.flag_on_count, m.flag_off_count,
  m.sum_numeric_magnitude, m.avg_numeric_magnitude,
  m.sum_days_moved,        m.avg_days_moved,
  EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
FROM CIDPR.DATAHUB.TMP_KDE_MONTHLY m
JOIN CIDPR.DATAHUB.TMP_MONTH_TOTALS t USING (END_OF_MONTH_DATE);

SELECT COUNT(*) AS CNT_WITH_DENOMS FROM CIDPR.DATAHUB.TMP_WITH_DENOMS;

-- ======================================================================
-- I) with_mom (MoM deltas & %)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_WITH_MOM
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  w.*,
  LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
  LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
  LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
  LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
  LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
  LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

  (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
  (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

  CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
       THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

  CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
       THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
FROM CIDPR.DATAHUB.TMP_WITH_DENOMS w;

SELECT COUNT(*) AS CNT_WITH_MOM FROM CIDPR.DATAHUB.TMP_WITH_MOM;

-- ======================================================================
-- J) baselines (6/12-mo trends + same-month seasonality)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_BASELINES
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  x.*,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
  AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
  AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
FROM CIDPR.DATAHUB.TMP_WITH_MOM x;

SELECT COUNT(*) AS CNT_BASELINES FROM CIDPR.DATAHUB.TMP_BASELINES;

-- ======================================================================
-- K) expected (choose trend window; build expected + stddevs + expected count/$)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_EXPECTED
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  b.*,

  -- choose 6-mo trend (more reactive) or 12-mo (smoother)
  CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END AS trend_rate_sel,
  CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

  -- weights (tune here if you want without editing above tables)
  0.70::DOUBLE PRECISION AS weight_trend,
  0.30::DOUBLE PRECISION AS weight_seasonal,

  COALESCE(0.70* (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) +
           0.30*  same_month_rate,
           (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
           same_month_rate) AS expected_rate,

  COALESCE(0.70* (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) +
           0.30*  same_month_share,
           (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
           same_month_share) AS expected_share,

  STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
  STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

  CASE WHEN month_total_accounts IS NOT NULL THEN
    COALESCE(0.70* (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) + 0.30* same_month_rate,
             (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
             same_month_rate) * month_total_accounts END AS expected_count,

  CASE WHEN month_total_ssb IS NOT NULL THEN
    COALESCE(0.70* (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30* same_month_share,
             (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
             same_month_share) * month_total_ssb END AS expected_exposure
FROM CIDPR.DATAHUB.TMP_BASELINES b;

SELECT COUNT(*) AS CNT_EXPECTED FROM CIDPR.DATAHUB.TMP_EXPECTED;

-- ======================================================================
-- L) Final SELECT (you can materialize if desired)
-- ======================================================================
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (tune thresholds here if you like)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= 2.5
       OR ABS(exposure_dollars - expected_exposure) >= 50000000
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= 0.15)
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= 50000000
       OR ABS(COALESCE(mom_change_count_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM CIDPR.DATAHUB.TMP_EXPECTED
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;




-- E. pd_cast
DROP TABLE IF EXISTS tmp_pd_cast;
CREATE TEMP TABLE tmp_pd_cast AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM tmp_kde_chg;
SELECT COUNT(*) AS cnt_pd_cast FROM tmp_pd_cast;

-- F. kde_changes (union)
DROP TABLE IF EXISTS tmp_kde_changes;
CREATE TEMP TABLE tmp_kde_changes AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  JOIN tmp_pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DPD
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);
SELECT COUNT(*) AS cnt_kde_changes FROM tmp_kde_changes;







-- A. measures
DROP TABLE IF EXISTS tmp_measures;
CREATE TEMP TABLE tmp_measures AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;
SELECT COUNT(*) AS cnt_measures FROM tmp_measures;

-- B. month_totals
DROP TABLE IF EXISTS tmp_month_totals;
CREATE TEMP TABLE tmp_month_totals AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM tmp_measures m
GROUP BY 1;
SELECT COUNT(*) AS cnt_month_totals FROM tmp_month_totals;

-- C. kde_month
DROP TABLE IF EXISTS tmp_kde_month;
CREATE TEMP TABLE tmp_kde_month AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
  MAX(t.CRE_FLAG)                AS CRE_FLAG,

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM tmp_measures m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;
SELECT COUNT(*) AS cnt_kde_month FROM tmp_kde_month;

-- D. kde_chg
DROP TABLE IF EXISTS tmp_kde_chg;
CREATE TEMP TABLE tmp_kde_chg AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM tmp_kde_month k;
SELECT COUNT(*) AS cnt_kde_chg FROM tmp_kde_chg;





-- ======================================================================
-- KDE monthly (type-aware) + MoM deltas + Expected vs Actual (SQL-only)
-- Netezza-friendly: DOUBLE PRECISION casts, fixed window frames, RC_CODE raw
-- Assumptions:
--   • *_FLAG fields are Y/N
--   • PD_GRADE is numeric; valid values are 0–14, 98
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- <<< tune these centrally
  SELECT
    1  AS use_trend6,                 -- 1 = use 6-mo trend, 0 = use 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 4b) PD_GRADE numeric validation (0–14, 98); ignore others in magnitude
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (

  -- --------- BOOLEAN KDEs (Y/N) ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (valid 0–14, 98 only)
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(kc.MATURITY_DATE AS DATE) - CAST(kc.prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(kc.BOOK_DATE AS DATE) - CAST(kc.prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs (count-only; exposure via CURR_SSB) ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup (type-aware metrics)
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Add MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality (exclude current)
baselines AS (
  SELECT
    x.*,

    -- 6-mo and 12-mo trends (exclude current row)
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    -- same-month seasonality (up to 10y; exclude current)
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; convert to expected count/$
expected AS (
  SELECT
    b.*,

    -- pick trend window
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    -- expected rates/shares (weighted blend; fallback if one part missing)
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    -- rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- convert to expected count and expected $
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output: actuals, MoM, expected, residuals, z-like, severity, flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive standardized residuals + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (stat surprise OR big $ delta OR big MoM)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250  -- tune if needed
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;





-- ======================================================================
-- KDE monthly (type-aware) + MoM deltas + Expected vs Actual (SQL-only)
-- Netezza-friendly: DOUBLE PRECISION casts, fixed window frames, RC_CODE raw
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- <<< tune these in one place
  SELECT
    1  AS use_trend6,                 -- 1 = use 6-mo trend, 0 = use 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (

  -- --------- BOOLEAN KDEs ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN (UPPER(TRIM(prev_na)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_na)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> prev_na) OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)) )

  UNION ALL
  -- CRE_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN (UPPER(TRIM(prev_cre)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (CRE_FLAG <> prev_cre) OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)) )

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (numeric-ish)
  SELECT
    END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(CAST(NULLIF(PD_GRADE,'') AS DOUBLE PRECISION) - CAST(NULLIF(prev_pd,'') AS DOUBLE PRECISION)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (PD_GRADE <> prev_pd) OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (DAYS_PAST_DUE <> prev_dpd) OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE
  SELECT
    END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(MATURITY_DATE AS DATE) - CAST(prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (MATURITY_DATE <> prev_mty) OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(BOOK_DATE AS DATE) - CAST(prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (BOOK_DATE <> prev_book) OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs (count-only; exposure via CURR_SSB) ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup (type-aware metrics)
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Add MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality (exclude current)
baselines AS (
  SELECT
    x.*,

    -- 6-mo and 12-mo trends (exclude current row)
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    -- same-month seasonality (up to 10y; exclude current)
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; convert to expected count/$
expected AS (
  SELECT
    b.*,

    -- pick trend window
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    -- expected rates/shares (weighted blend; fallback if one part missing)
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    -- rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- convert to expected count and expected $
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output: actuals, MoM, expected, residuals, z-like, severity, flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive standardized residuals + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (stat surprise OR big $ delta OR big MoM)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250  -- tune if needed
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;






-- ======================================================================
-- KDE monthly summary by type + MoM deltas (Netezza-friendly)
--   • Boolean: flag_on_count / flag_off_count
--   • Numeric: sum/avg of absolute magnitude moved
--   • Date:    sum/avg of absolute days moved
--   • Categorical: counted as changes (with $ exposure)
--   • MoM deltas & % for change_count and exposure_dollars (+ type metrics)
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,         -- history window (months)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population per month/account/system
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) One row per month×acct×system with KDEs (RC_CODE left raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 5) UNPIVOT changed rows with type-specific payload
--    Common columns:
--      END_OF_MONTH_DATE, KDE, CURR_SSB,
--      bool_on, bool_off, numeric_mag, days_mag, change_flag
kde_changes AS (

  -- --------- BOOLEAN KDEs ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN
           ( (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE'))::INTEGER
           <> (UPPER(TRIM(prev_na))         IN ('Y','1','TRUE'))::INTEGER )
         THEN 1 ELSE 0 END AS change_flag,
    -- direction
    CASE WHEN (UPPER(TRIM(prev_na)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_na)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> prev_na) OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)) )

  UNION ALL
  -- CRE_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN
           ( (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE'))::INTEGER
           <> (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE'))::INTEGER )
         THEN 1 ELSE 0 END AS change_flag,
    CASE WHEN (UPPER(TRIM(prev_cre)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (CRE_FLAG <> prev_cre) OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)) )

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (numeric-ish; map if needed)
  SELECT
    END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    ABS(CAST(NULLIF(PD_GRADE,'') AS DOUBLE PRECISION) - CAST(NULLIF(prev_pd,'') AS DOUBLE PRECISION)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (PD_GRADE <> prev_pd) OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT
    END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (DAYS_PAST_DUE <> prev_dpd) OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE (days moved, absolute)
  SELECT
    END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(MATURITY_DATE AS DATE) - CAST(prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (MATURITY_DATE <> prev_mty) OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE (days moved, absolute)
  SELECT
    END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(BOOK_DATE AS DATE) - CAST(prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (BOOK_DATE <> prev_book) OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup with type-aware metrics
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    -- Boolean metrics (sum where relevant rows)
    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    -- Numeric magnitudes
    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    -- Date magnitudes (days)
    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  WHERE change_flag = 1  -- safety; all rows here are changes
  GROUP BY 1,2
),

-- 7) Add denominators and compute rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,

    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION
         ELSE NULL END AS change_rate,

    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION
         ELSE NULL END AS exposure_share,

    -- carry type-specific metrics
    m.flag_on_count,
    m.flag_off_count,
    m.sum_numeric_magnitude,
    m.avg_numeric_magnitude,
    m.sum_days_moved,
    m.avg_days_moved
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) MoM deltas & percentages
with_mom AS (
  SELECT
    w.*,

    -- Previous month actuals
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    -- MoM deltas
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    (w.flag_on_count  - LAG(w.flag_on_count)  OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_flag_on_delta,
    (w.flag_off_count - LAG(w.flag_off_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_flag_off_delta,

    (w.sum_numeric_magnitude - LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_sum_numeric_mag_delta,
    (w.sum_days_moved        - LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_sum_days_moved_delta,

    -- MoM % (guard divide-by-zero)
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)
    END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)
    END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
)

-- 9) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware metrics
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM: counts and dollars
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,

  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,

  -- MoM: type-aware extras (optional but useful)
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,

  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta

FROM with_mom
ORDER BY END_OF_MONTH_DATE DESC, KDE;





-- ======================================================================
-- KDE Expected vs Actual + MoM deltas (SQL-only, Netezza-friendly)
--   • Forecasts from rolling trend + same-month seasonality (rates/shares)
--   • Adds MoM $ / % deltas for exposure & count
--   • Standardized residuals (z-like) + materiality + MoM flags
--   • Single output: last N months for all KDEs
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,        -- history window (months)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Snapshot KDE values (RC_CODE left raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Derive per-account changes (current vs prior month within system)
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- 5) UNPIVOT: one row per (month, KDE, changed account) carrying exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)))
),

-- 6) Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)        AS change_count,
    SUM(c.CURR_SSB) AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- 7) Add denominators, rates/shares, calendar month; add prior-month actuals for MoM
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION
         ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION
         ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year,

    -- MoM previous actuals
    LAG(m.exposure_dollars) OVER (PARTITION BY m.KDE ORDER BY m.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(m.change_count)     OVER (PARTITION BY m.KDE ORDER BY m.END_OF_MONTH_DATE) AS prev_change_count
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Rolling trend (12-mo, excl current) & same-month seasonal (10y max, excl current)
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING)  AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING)  AS trend_share,
    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- 9) Expected values = 0.5*trend + 0.5*seasonal (fallbacks if NULL)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- 10) Convert expected rates/shares to expected count/$; add rolling stddevs for standardization; compute MoM deltas
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    -- Rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- MoM deltas (actuals)
    (exposure_dollars - prev_exposure_dollars) AS mom_exposure_delta,
    CASE WHEN prev_exposure_dollars IS NOT NULL AND prev_exposure_dollars <> 0
         THEN (exposure_dollars - prev_exposure_dollars) / prev_exposure_dollars::DOUBLE PRECISION END AS mom_exposure_pct,

    (change_count - prev_change_count) AS mom_count_delta,
    CASE WHEN prev_change_count IS NOT NULL AND prev_change_count <> 0
         THEN (change_count - prev_change_count) / prev_change_count::DOUBLE PRECISION END AS mom_count_pct
  FROM expected e
)

-- 11) Final: Actual vs Forecast, residuals, standardized residuals, MoM metrics & flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals (actual - expected)
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- MoM actuals
  prev_exposure_dollars,
  mom_exposure_delta,
  mom_exposure_pct,
  prev_change_count,
  mom_count_delta,
  mom_count_pct,

  -- Flags (tune thresholds below)
  CASE WHEN
         -- Statistical surprise on exposure share (z-like)
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share) / std_share_12 END) >= 2.5
         -- OR large absolute $ delta vs forecast
         OR ABS(exposure_dollars - expected_exposure) >= 50000000
         -- OR large relative $ delta vs forecast
         OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure) / NULLIF(expected_exposure,0)) >= 0.15)
       THEN 1 ELSE 0 END AS regression_flag,

  CASE WHEN
         -- MoM percent change big
         ABS(COALESCE(mom_exposure_pct,0)) >= 0.25
         -- OR MoM absolute $ change big
         OR ABS(COALESCE(mom_exposure_delta,0)) >= 50000000
       THEN 1 ELSE 0 END AS mom_exposure_flag,

  CASE WHEN
         ABS(COALESCE(mom_count_pct,0)) >= 0.25
         OR ABS(COALESCE(mom_count_delta,0)) >= 250   -- adjust for your scale
       THEN 1 ELSE 0 END AS mom_count_flag,

  -- Combined anomaly flag (trip if any of the above true)
  CASE WHEN
         (CASE WHEN
                 ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                          THEN (exposure_share - expected_share) / std_share_12 END) >= 2.5
                 OR ABS(exposure_dollars - expected_exposure) >= 50000000
                 OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure) / NULLIF(expected_exposure,0)) >= 0.15)
               THEN 1 ELSE 0 END) = 1
         OR (CASE WHEN
                   ABS(COALESCE(mom_exposure_pct,0)) >= 0.25
                   OR ABS(COALESCE(mom_exposure_delta,0)) >= 50000000
                 THEN 1 ELSE 0 END) = 1
         OR (CASE WHEN
                   ABS(COALESCE(mom_count_pct,0)) >= 0.25
                   OR ABS(COALESCE(mom_count_delta,0)) >= 250
                 THEN 1 ELSE 0 END) = 1
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG,

  -- Simple severity ranker = positive standardized residuals + MoM intensity
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate    - expected_rate)  / std_rate_12  END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_pct), 0.0)
  ) AS severity_score

FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







-- ============================================================
-- KDE Monthly Forecast vs Actual (SQL-only, Netezza-friendly)
--  • Forecasts change_count & exposure_dollars from rate/share
--  • Expected = 0.5*rolling_trend + 0.5*same-month-seasonal
--  • Outputs residuals and standardized residuals (z-like)
--  • Single output: full history for last N months
-- ============================================================
WITH params AS (
  SELECT
    36 AS months_back,        -- history window for modeling
    12 AS trend_win,          -- (note: inlined as 12 in window frames below)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- KDE snapshots and changes
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- RC_CODE raw per your direction
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- UNPIVOT per account where a KDE changed; carry exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)))
),

-- Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)        AS change_count,
    SUM(c.CURR_SSB) AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- Add denominators and derived rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb     > 0 THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION     ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- Rolling trend (12-mo avg excl current), and seasonal same-month avg excl current
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share,

    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- Expected values = 0.5*trend + 0.5*seasonal (fallback if one side missing)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- Convert expected rates/shares back to counts/$; rolling std devs for standardization
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12
  FROM expected e
)

-- Final: Actual vs Forecast, residuals & standardized residuals
SELECT
  END_OF_MONTH_DATE,
  KDE,
  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,
  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,
  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,
  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate   - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share- expected_share)/ std_share_12 END AS std_resid_share,
  -- Simple severity (sum of positive standardized residuals)
  COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate   - expected_rate)  / std_rate_12  END),0.0)
  +
  COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share- expected_share)/ std_share_12 END),0.0)
  AS regression_like_severity
FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, regression_like_severity DESC, KDE;






-- ============================================================
-- KDE Monthly Forecast vs Actual (SQL-only, Netezza-friendly)
--  • Forecasts change_count & exposure_dollars from rate/share
--  • Expected = 0.5*rolling_trend + 0.5*same-month-seasonal
--  • Outputs residuals and standardized residuals (z-like)
--  • Single output: full history for last N months
-- ============================================================
WITH params AS (
  SELECT
    36 AS months_back,        -- history window for modeling (increase if you have more)
    12 AS trend_win,          -- rolling months for trend
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- KDE snapshots and changes (you can keep these KDEs aligned with your latest set)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- RC_CODE left raw per your direction
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- UNPIVOT per account where a KDE changed; carry exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR (PD_GRADE IS NULL) <> (prev_pd IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR (NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR (DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR (MATURITY_DATE IS NULL) <> (prev_mty IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR (RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR (FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR (LIFESTAGE IS NULL) <> (prev_lifestage IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR (NICHE_CD IS NULL) <> (prev_niche IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR (RBC_CODE IS NULL) <> (prev_rbc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR (REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR (RC_CODE IS NULL) <> (prev_rc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR (RATE_TYPE IS NULL) <> (prev_rate_type IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR (CRE_FLAG IS NULL) <> (prev_cre IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR (BOOK_DATE IS NULL) <> (prev_book IS NULL))
),

-- Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)          AS change_count,
    SUM(c.CURR_SSB)   AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- Add denominators and derived rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0 THEN m.change_count::FLOAT8 / t.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb     > 0 THEN m.exposure_dollars     / t.month_total_ssb     ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- Rolling trend (12-month avg excluding current), and seasonal same-month avg excluding current
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN (SELECT trend_win FROM params) PRECEDING AND 1 PRECEDING) AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN (SELECT trend_win FROM params) PRECEDING AND 1 PRECEDING) AS trend_share,

    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- Expected values = 0.5*trend + 0.5*seasonal (fallbacks if one side missing)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- Convert expected rates/shares back to counts/$; build rolling std devs for standardization
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    -- Rolling std devs (exclude current) for z-like standardization
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12
  FROM expected e
)

-- Final: Actual vs Forecast, residuals & standardized residuals
SELECT
  END_OF_MONTH_DATE,
  KDE,
  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,
  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,
  -- Residuals
  (change_count      - expected_count)     AS resid_count,
  (exposure_dollars  - expected_exposure)  AS resid_exposure,
  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate   - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share- expected_share)/ std_share_12 END AS std_resid_share,
  -- Simple severity (sum of positive standardized residuals)
  COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate   - expected_rate)  / std_rate_12  END),0.0)
  +
  COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share- expected_share)/ std_share_12 END),0.0)
  AS regression_like_severity
FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, regression_like_severity DESC, KDE;







-- ============================================================
-- Systemic KDE Summary (positive-balance only) — RC_CODE raw
--  • KDE-specific magnitudes
--  • Rates & exposure materiality (exposure_dollars/share)
--  • Z-scores: count_z, rate_z, magnitude_z, exposure_z
--  • SINGLE OUTPUT: full history within lookback
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window (months)
    2.5     AS z_threshold,          -- anomaly threshold (tune 2.0–3.0)
    -- Magnitude caps for normalization to ~0..1
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4     -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators (rates / shares)
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots for positive-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Categoricals / flags (leave RC_CODE RAW as requested)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))        AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))               AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))          AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))               AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))                AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))                AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                               AS RC_CODE,     -- << raw (no normalization)
    MAX(UPPER(TRIM(t.RATE_TYPE)))               AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where a KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha in your data)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical) -- RAW
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)               AS change_count,
    SUM(c.magnitude_raw)   AS sum_magnitude_raw,
    AVG(c.magnitude_raw)   AS avg_magnitude_raw,
    SUM(c.magnitude_norm)  AS sum_magnitude_norm,
    AVG(c.magnitude_norm)  AS avg_magnitude_norm,
    SUM(c.CURR_SSB)        AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators and rates/shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines & z-scores (exclude current month from baseline)
kde_with_stats AS (
  SELECT
    x.*,
    -- counts
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    -- rates
    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    -- magnitudes
    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12,
    -- exposure dollars
    AVG(exposure_dollars)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_exposure_12,
    STDDEV_SAMP(exposure_dollars) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_exposure_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12    IS NOT NULL AND k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12     IS NOT NULL AND k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12      IS NOT NULL AND k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      ELSE NULL END AS magnitude_z,
    CASE WHEN k.std_exposure_12 IS NOT NULL AND k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 ELSE NULL END AS exposure_z,

    -- Combined anomaly score = sum of positive z's (NULL→0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) SINGLE OUTPUT: full history (latest first)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,     3) AS count_z,
  ROUND(rate_z,      3) AS rate_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(exposure_z,  3) AS exposure_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)      >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(exposure_z,0)  >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;






-- ============================================================
-- Systemic KDE Summary (positive-balance only)
--  • KDE-specific magnitudes + RC_CODE normalization
--  • Rates & exposure materiality (exposure_dollars/share)
--  • Z-scores: count_z, rate_z, magnitude_z, exposure_z
--  • SINGLE OUTPUT: full history within lookback
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window
    2.5     AS z_threshold,          -- anomaly threshold (tune)
    -- Magnitude caps for normalization to ~0..1
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4     -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Totals for denominators (rates / shares)
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots for positive-balance population (with hygiene on categoricals)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Categorical / flags (normalized)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))        AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))               AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))          AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))               AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))                AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))                AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    -- RC_CODE: pad to 3 to collapse '1','01','001'
    MAX(LPAD(UPPER(TRIM(t.RC_CODE)), 3, '0'))   AS RC_CODE,
    MAX(UPPER(TRIM(t.RATE_TYPE)))               AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (normalized)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE
  SELECT END_OF_MONTH DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)               AS change_count,
    SUM(c.magnitude_raw)   AS sum_magnitude_raw,
    AVG(c.magnitude_raw)   AS avg_magnitude_raw,
    SUM(c.magnitude_norm)  AS sum_magnitude_norm,
    AVG(c.magnitude_norm)  AS avg_magnitude_norm,
    SUM(c.CURR_SSB)        AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators and rates/shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines & z-scores (exclude current month from baseline)
kde_with_stats AS (
  SELECT
    x.*,
    -- counts
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    -- rates
    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    -- magnitudes
    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12,
    -- exposure dollars (NEW)
    AVG(exposure_dollars)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_exposure_12,
    STDDEV_SAMP(exposure_dollars) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_exposure_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12    IS NOT NULL AND k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12     IS NOT NULL AND k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12      IS NOT NULL AND k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      ELSE NULL END AS magnitude_z,
    CASE WHEN k.std_exposure_12 IS NOT NULL AND k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 ELSE NULL END AS exposure_z,

    -- Combined anomaly score = sum of positive z's (NULL→0). Exposure_z included.
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) SINGLE OUTPUT: full history (latest first)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,     3) AS count_z,
  ROUND(rate_z,      3) AS rate_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(exposure_z,  3) AS exposure_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)      >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(exposure_z,0)  >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;







-- ============================================================
-- Systemic KDE Summary (positive-balance only) — Patched
--  • RC_CODE normalization to catch '1' vs '01' etc.
--  • Adds change_rate and exposure_share
--  • Z-scores on count, rate, and sum_magnitude_norm (not exposure)
--  • Single output: full history
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    2.5     AS z_threshold,          -- slightly more sensitive than 3.0
    -- Normalization caps (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures, POSITIVE balances only
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Totals for rate/share denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots restricted to positive-balance accounts
--    Apply hygiene/normalization to high-risk categoricals
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)     AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Flags / categoricals (normalized)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))       AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))              AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))         AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))              AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))               AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))               AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    -- RC_CODE: pad to 3 and upper/trim to collapse '1','01','001'
    MAX(LPAD(UPPER(TRIM(t.RC_CODE)), 3, '0'))  AS RC_CODE,
    MAX(UPPER(TRIM(t.RATE_TYPE)))              AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))               AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (normalized)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                AS change_count,
    SUM(c.magnitude_raw)    AS sum_magnitude_raw,
    AVG(c.magnitude_raw)    AS avg_magnitude_raw,
    SUM(c.magnitude_norm)   AS sum_magnitude_norm,
    AVG(c.magnitude_norm)   AS avg_magnitude_norm,
    SUM(c.CURR_SSB)         AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators → rates and shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines and z-scores (exclude current month)
kde_with_stats AS (
  SELECT
    x.*,
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,

    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,

    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12 ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12  IS NOT NULL AND k.std_rate_12  > 0
         THEN (k.change_rate  - k.avg_rate_12)  / k.std_rate_12  ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12   IS NOT NULL AND k.std_mag_12   > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12 ELSE NULL END AS magnitude_z,

    -- Summed positive z's (NULL→0). Exposure is NOT z-scored; used as tie-breaker.
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12  > 0 THEN (k.change_rate  - k.avg_rate_12) /k.std_rate_12  END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12   > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) Single output: full history
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,    3) AS count_z,
  ROUND(rate_z,     3) AS rate_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0)>= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;

CASE WHEN exposure_share >= 0.05 OR exposure_dollars >= 25000000 THEN 1 ELSE 0 END AS BIG_$_SPIKE






-- ============================================================
-- Monthly KDE Systemic Summary (positive-balance only)
--  • KDE-specific magnitudes
--  • Z-scores on change_count and sum_magnitude_norm ONLY
--  • exposure_dollars included (no z-score on it)
--  • SINGLE OUTPUT: full history in one result set
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    3.0     AS z_threshold,          -- anomaly flag threshold per z
    -- Magnitude caps to normalize to ~0..1 (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD steps
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD days
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity days (~2y)
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book date days (~1y)
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) KDE snapshots for POSITIVE-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,     -- carry exposure for summary
    -- KDEs (original + added)
    MAX(t.PD_GRADE)                 AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)            AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE,
    MAX(t.RISK_UNIT)                AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)           AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)                AS LIFESTAGE,
    MAX(t.NICHE_CD)                 AS NICHE_CD,
    MAX(t.RBC_CODE)                 AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING)  AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RATE_TYPE)                AS RATE_TYPE,
    MAX(t.CRE_FLAG)                 AS CRE_FLAG,
    MAX(t.BOOK_DATE)                AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)             OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING)    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT rows where a KDE changed; compute magnitude and carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly systemic summary by KDE (+ exposure_dollars)
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                         AS change_count,
    SUM(c.magnitude_raw)             AS sum_magnitude_raw,
    AVG(c.magnitude_raw)             AS avg_magnitude_raw,
    SUM(c.magnitude_norm)            AS sum_magnitude_norm,
    AVG(c.magnitude_norm)            AS avg_magnitude_norm,
    SUM(c.CURR_SSB)                  AS exposure_dollars      -- included (no z-score on it)
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) SINGLE OUTPUT: Full history (within lookback window)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,                   -- exposure impact (no z-score)
  ROUND(count_z,    3) AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;




-- ============================================================
-- Monthly KDE Systemic Summary (positive-balance only)
--  • KDE-specific magnitudes
--  • Z-scores on change_count and sum_magnitude_norm ONLY
--  • Adds exposure_dollars column (no z-score on it)
--  • Latest month ranked by anomaly signal
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    3.0     AS z_threshold,          -- anomaly flag threshold per z
    -- Magnitude caps to normalize to ~0..1 (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD steps
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD days
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity days (~2y)
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book date days (~1y)
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) KDE snapshots for POSITIVE-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,     -- carry exposure for summary
    -- KDEs (original + added)
    MAX(t.PD_GRADE)                 AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)            AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE,
    MAX(t.RISK_UNIT)                AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)           AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)                AS LIFESTAGE,
    MAX(t.NICHE_CD)                 AS NICHE_CD,
    MAX(t.RBC_CODE)                 AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING)  AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RATE_TYPE)                AS RATE_TYPE,
    MAX(t.CRE_FLAG)                 AS CRE_FLAG,
    MAX(t.BOOK_DATE)                AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)             OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING)    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT rows where a KDE changed; compute magnitude and carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly systemic summary by KDE (+ exposure_dollars)
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                         AS change_count,
    SUM(c.magnitude_raw)             AS sum_magnitude_raw,
    AVG(c.magnitude_raw)             AS avg_magnitude_raw,
    SUM(c.magnitude_norm)            AS sum_magnitude_norm,
    AVG(c.magnitude_norm)            AS avg_magnitude_norm,
    SUM(c.CURR_SSB)                  AS exposure_dollars      -- <<< added, no z-score computed
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month systemic KDE signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,                   -- <<< requested column
  ROUND(count_z,    3) AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt: full history (uncomment) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  exposure_dollars,                        -- included in history
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/





-- ============================================
-- Monthly KDE Summary (positive-balance only)
--  • KDE-specific magnitude (incl. your new KDEs)
--  • 12-mo baselines & z-scores
--  • Latest month ranked by anomaly signal
-- ============================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window for baseline
    3.0     AS z_threshold,          -- anomaly threshold for z
    -- Normalization caps for magnitudes (scale different KDEs to ~0..1)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD: steps (e.g., 4 steps => full magnitude)
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD: 60 days => full
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity: 730 days (~2y) => full
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book_Date: 365 days (~1y) => full
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly MEASURES at acct+system, restricting to POSITIVE balances
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0              -- Positive balance only
),

-- 2) Monthly KDE snapshots ONLY for positive-balance accounts (join back to measures)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- Original KDEs
    MAX(t.PD_GRADE)             AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)     AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)        AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)        AS MATURITY_DATE,
    MAX(t.RISK_UNIT)            AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)       AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)            AS LIFESTAGE,
    MAX(t.NICHE_CD)             AS NICHE_CD,
    MAX(t.RBC_CODE)             AS RBC_CODE,
    -- New KDEs
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,
    MAX(t.BOOK_DATE)               AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3
),

-- 3) Add prior-month values per acct+system
kde_chg AS (
  SELECT
    m.*,
    LAG(m.END_OF_MONTH_DATE)   OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(m.PD_GRADE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(m.NON_ACCRUAL_FLAG)    OVER (...) AS PREV_NON_ACCRUAL_FLAG,
    LAG(m.DAYS_PAST_DUE)       OVER (...) AS PREV_DAYS_PAST_DUE,
    LAG(m.MATURITY_DATE)       OVER (...) AS PREV_MATURITY_DATE,
    LAG(m.RISK_UNIT)           OVER (...) AS PREV_RISK_UNIT,
    LAG(m.FDIC_CALL_CODE)      OVER (...) AS PREV_FDIC_CALL_CODE,
    LAG(m.LIFESTAGE)           OVER (...) AS PREV_LIFESTAGE,
    LAG(m.NICHE_CD)            OVER (...) AS PREV_NICHE_CD,
    LAG(m.RBC_CODE)            OVER (...) AS PREV_RBC_CODE,
    LAG(m.REVOLVING_NON_REVOLVING) OVER (...) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(m.RC_CODE)             OVER (...) AS PREV_RC_CODE,
    LAG(m.RATE_TYPE)           OVER (...) AS PREV_RATE_TYPE,
    LAG(m.CRE_FLAG)            OVER (...) AS PREV_CRE_FLAG,
    LAG(m.BOOK_DATE)           OVER (...) AS PREV_BOOK_DATE
  FROM kde_month m
),

-- 4) UNPIVOT: rows only where a KDE changed; compute KDE-specific magnitudes
kde_changes AS (
  -- PD_GRADE (numeric-ish; map if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, 1 AS change_flag,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical flip)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric days)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', 1,
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', 1,
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE', 1,
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary by KDE (systemic view across all positive-balance accounts)
kde_monthly_summary AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)            AS change_count,
    SUM(magnitude_raw)  AS sum_magnitude_raw,
    AVG(magnitude_raw)  AS avg_magnitude_raw,
    SUM(magnitude_norm) AS sum_magnitude_norm,
    AVG(magnitude_norm) AS avg_magnitude_norm
  FROM kde_changes
  GROUP BY END_OF_MONTH_DATE, KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current from baseline)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month KDE systemic signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  ROUND(count_z, 3)     AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt view: full history (uncomment) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/






-- ============================================
-- Monthly KDE Summary (positive-balance only)
--  • KDE-specific magnitude
--  • 12-mo baselines & z-scores
--  • Latest month ranked by anomaly signal
-- ============================================
WITH params AS (
  SELECT
    12                AS months_back,        -- lookback window for baseline
    3.0               AS z_threshold,        -- anomaly threshold for z
    -- Normalization caps for magnitude (scale different KDEs to ~0..1)
    CAST(4.0  AS FLOAT8) AS cap_pd_steps,    -- PD steps: 4 steps => full magnitude
    CAST(60.0 AS FLOAT8) AS cap_dpd_days,    -- DPD: 60 days => full magnitude
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- maturity: 730 days (~2 yrs) => full magnitude
    'Total Loans'     AS target_lvl4         -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly MEASURES at acct+system, restricting to POSITIVE balances
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0               -- <<< positive balance filter
),

-- 2) Monthly KDE snapshots ONLY for positive-balance accounts (join back to measures)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- Your KDEs
    MAX(t.PD_GRADE)            AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)    AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)       AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)       AS MATURITY_DATE,
    MAX(t.RISK_UNIT)           AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)      AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)           AS LIFESTAGE,
    MAX(t.NICHE_CD)            AS NICHE_CD,
    MAX(t.RBC_CODE)            AS RBC_CODE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3
),

-- 3) Add prior-month values per acct+system
kde_chg AS (
  SELECT
    m.*,
    LAG(m.END_OF_MONTH_DATE)   OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(m.PD_GRADE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(m.NON_ACCRUAL_FLAG)    OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(m.DAYS_PAST_DUE)       OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(m.MATURITY_DATE)       OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(m.RISK_UNIT)           OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(m.FDIC_CALL_CODE)      OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(m.LIFESTAGE)           OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(m.NICHE_CD)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(m.RBC_CODE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_RBC_CODE
  FROM kde_month m
),

-- 4) UNPIVOT: rows only where a KDE changed; compute KDE-specific magnitudes
kde_changes AS (
  -- PD_GRADE (assumes numeric-ish; adjust mapping if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, 1 AS change_flag,
         ABS( CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8) ) AS magnitude_raw,
         LEAST(1.0, ABS( CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8) ) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (PD_GRADE <> PREV_PD_GRADE) OR
      (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR
      (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL)
    )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1,
         CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR
      (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR
      (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL)
    )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', 1,
         ABS( COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0) )::FLOAT8,
         LEAST(1.0, ABS( COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0) ) / (SELECT cap_dpd_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR
      (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR
      (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL)
    )

  UNION ALL
  -- MATURITY_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', 1,
         ABS( (CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)) )::FLOAT8,
         LEAST(1.0, ABS( (CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)) ) / (SELECT cap_mty_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (MATURITY_DATE <> PREV_MATURITY_DATE) OR
      (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR
      (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL)
    )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (RISK_UNIT <> PREV_RISK_UNIT) OR
      (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR
      (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL)
    )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR
      (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR
      (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL)
    )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (LIFESTAGE <> PREV_LIFESTAGE) OR
      (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR
      (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL)
    )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (NICHE_CD <> PREV_NICHE_CD) OR
      (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR
      (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL)
    )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (RBC_CODE <> PREV_RBC_CODE) OR
      (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR
      (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL)
    )
),

-- 5) Monthly summary by KDE (systemic view across all positive-balance accounts)
kde_monthly_summary AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                 AS change_count,
    SUM(magnitude_raw)       AS sum_magnitude_raw,
    AVG(magnitude_raw)       AS avg_magnitude_raw,
    SUM(magnitude_norm)      AS sum_magnitude_norm,
    AVG(magnitude_norm)      AS avg_magnitude_norm
  FROM kde_changes
  GROUP BY END_OF_MONTH_DATE, KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current in baseline frame)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,

    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,

    -- Simple combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month KDE systemic signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  ROUND(count_z, 3)     AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt view: full history across months (uncomment to use) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/






-- =========================
-- Parameters (tune freely)
-- =========================
WITH params AS (
  SELECT
    'Total Loans'      AS target_lvl4,     -- optional GL layer filter
    12                 AS months_back,     -- lookback for change log
    CAST(500000.0 AS FLOAT8) AS dollar_anchor, -- scale for "large" $ moves
    CAST(0.15     AS FLOAT8) AS pct_anchor     -- scale for "large" % moves (15%)
),

-- Anchor the window (need N months of points to compute N-1 deltas)
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- ========================
-- Monthly measures (SSB)
-- ========================
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- OPTIONAL system filter:
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- ==================================
-- Monthly KDE attributes (your 9 KDEs)
-- Use MAX() assuming single-valued per acct/month
-- ==================================
attr AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    MAX(t.PD_GRADE)            AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)    AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)       AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)       AS MATURITY_DATE,
    MAX(t.RISK_UNIT)           AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)      AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)           AS LIFESTAGE,
    MAX(t.NICHE_CD)            AS NICHE_CD,
    MAX(t.RBC_CODE)            AS RBC_CODE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- OPTIONAL system filter:
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- Merge measures + KDEs at same grain
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE,
    a.PD_GRADE,
    a.NON_ACCRUAL_FLAG,
    a.DAYS_PAST_DUE,
    a.MATURITY_DATE,
    a.RISK_UNIT,
    a.FDIC_CALL_CODE,
    a.LIFESTAGE,
    a.NICHE_CD,
    a.RBC_CODE
  FROM measures m
  LEFT JOIN attr a
    ON a.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY            = m.ACCOUNT_KEY
),

-- Compute prior values and balance deltas (for impact context only)
chg AS (
  SELECT
    b.*,
    LAG(b.END_OF_MONTH_DATE)     OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(b.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_SSB,

    LAG(b.PD_GRADE)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(b.NON_ACCRUAL_FLAG)   OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(b.DAYS_PAST_DUE)      OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(b.MATURITY_DATE)      OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(b.RISK_UNIT)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(b.FDIC_CALL_CODE)     OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(b.LIFESTAGE)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(b.NICHE_CD)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(b.RBC_CODE)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RBC_CODE
  FROM base b
),

-- Keep only rows that have a prior month
delta AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.PREV_EOM,
    c.CONTRACT_SOURCE_SYSTEM,
    c.ACCOUNT_KEY,

    -- balances for impact scoring (not for triggering)
    c.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    c.PREV_SSB,
    (COALESCE(c.SOURCE_SYSTEM_BALANCE,0) - COALESCE(c.PREV_SSB,0)) AS DELTA_DOLLAR,
    CASE WHEN c.PREV_SSB IS NULL OR c.PREV_SSB = 0 THEN NULL
         ELSE ((c.SOURCE_SYSTEM_BALANCE - c.PREV_SSB) / c.PREV_SSB) * 100 END AS DELTA_PCT,

    -- KDEs: current/prior
    c.PD_GRADE,             c.PREV_PD_GRADE,
    c.NON_ACCRUAL_FLAG,     c.PREV_NON_ACCRUAL_FLAG,
    c.DAYS_PAST_DUE,        c.PREV_DAYS_PAST_DUE,
    c.MATURITY_DATE,        c.PREV_MATURITY_DATE,
    c.RISK_UNIT,            c.PREV_RISK_UNIT,
    c.FDIC_CALL_CODE,       c.PREV_FDIC_CALL_CODE,
    c.LIFESTAGE,            c.PREV_LIFESTAGE,
    c.NICHE_CD,             c.PREV_NICHE_CD,
    c.RBC_CODE,             c.PREV_RBC_CODE
  FROM chg c
  WHERE c.PREV_EOM IS NOT NULL
),

-- ==========================================
-- UNPIVOT: one row per KDE change (9 UNIONs)
-- ==========================================
kde_changes AS (
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'PD_GRADE' AS KDE,
         CAST(PREV_PD_GRADE AS VARCHAR(200)) AS PREV_VAL,
         CAST(PD_GRADE       AS VARCHAR(200)) AS CURR_VAL,
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (PD_GRADE <> PREV_PD_GRADE)
       OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL)
       OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'NON_ACCRUAL_FLAG',
         CAST(PREV_NON_ACCRUAL_FLAG AS VARCHAR(200)),
         CAST(NON_ACCRUAL_FLAG      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG)
       OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL)
       OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'DAYS_PAST_DUE',
         CAST(PREV_DAYS_PAST_DUE AS VARCHAR(200)),
         CAST(DAYS_PAST_DUE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE)
       OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL)
       OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'MATURITY_DATE',
         CAST(PREV_MATURITY_DATE AS VARCHAR(200)),
         CAST(MATURITY_DATE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (MATURITY_DATE <> PREV_MATURITY_DATE)
       OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL)
       OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'RISK_UNIT',
         CAST(PREV_RISK_UNIT AS VARCHAR(200)),
         CAST(RISK_UNIT      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (RISK_UNIT <> PREV_RISK_UNIT)
       OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL)
       OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'FDIC_CALL_CODE',
         CAST(PREV_FDIC_CALL_CODE AS VARCHAR(200)),
         CAST(FDIC_CALL_CODE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE)
       OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL)
       OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'LIFESTAGE',
         CAST(PREV_LIFESTAGE AS VARCHAR(200)),
         CAST(LIFESTAGE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (LIFESTAGE <> PREV_LIFESTAGE)
       OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL)
       OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'NICHE_CD',
         CAST(PREV_NICHE_CD AS VARCHAR(200)),
         CAST(NICHE_CD      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (NICHE_CD <> PREV_NICHE_CD)
       OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL)
       OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'RBC_CODE',
         CAST(PREV_RBC_CODE AS VARCHAR(200)),
         CAST(RBC_CODE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (RBC_CODE <> PREV_RBC_CODE)
       OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL)
       OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )
),

-- Rolling z-score on $ delta per acct+system (computed on change rows)
with_z AS (
  SELECT
    k.*,
    AVG(DELTA_DOLLAR) OVER (
      PARTITION BY ACCOUNT_KEY, CONTRACT_SOURCE_SYSTEM
      ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_avg_12,
    STDDEV_SAMP(DELTA_DOLLAR) OVER (
      PARTITION BY ACCOUNT_KEY, CONTRACT_SOURCE_SYSTEM
      ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_std_12
  FROM kde_changes k
),

scored AS (
  SELECT
    w.*,
    CASE WHEN w.delta_std_12 IS NULL OR w.delta_std_12 = 0
         THEN NULL
         ELSE (w.DELTA_DOLLAR - w.delta_avg_12) / w.delta_std_12
    END AS DELTA_Z_12,

    /* Impact score (0..~5):
       - $: normalized by anchor, capped @1
       - %: normalized by anchor, capped @1
       - z: |z| capped @3
    */
    LEAST(1.0, ABS(w.DELTA_DOLLAR) / (SELECT dollar_anchor FROM params)) +
    LEAST(1.0, COALESCE(ABS(w.DELTA_PCT)/100.0, 0.0) / (SELECT pct_anchor FROM params)) +
    LEAST(3.0, ABS(COALESCE(
        CASE WHEN w.delta_std_12 IS NULL OR w.delta_std_12 = 0 THEN NULL
             ELSE (w.DELTA_DOLLAR - w.delta_avg_12) / w.delta_std_12
        END, 0.0))
    ) AS impact_score
  FROM with_z w
)

-- ======================================================
-- B) Most-recent-month KDE-change "suspects" (default)
--    Sort by impact_score, then $ move.
-- ======================================================
SELECT
  s.END_OF_MONTH_DATE,
  s.CONTRACT_SOURCE_SYSTEM,
  s.ACCOUNT_KEY,
  s.KDE,
  s.PREV_VAL,
  s.CURR_VAL,
  s.CURR_SSB, s.PREV_SSB,
  s.DELTA_DOLLAR, s.DELTA_PCT, s.DELTA_Z_12,
  ROUND(s.impact_score, 3) AS impact_score
FROM scored s
WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY impact_score DESC, ABS(DELTA_DOLLAR) DESC, KDE, ACCOUNT_KEY;

/* ======================================================
-- A) Full 12-month KDE change log (uncomment to use)
SELECT
  END_OF_MONTH_DATE, PREV_EOM,
  CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  KDE, PREV_VAL, CURR_VAL,
  CURR_SSB, PREV_SSB, DELTA_DOLLAR, DELTA_PCT, DELTA_Z_12,
  ROUND(impact_score, 3) AS impact_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, impact_score DESC, KDE, ACCOUNT_KEY;
====================================================== */





-- =========================================
-- Params (edit anchors/weights to taste)
-- =========================================
WITH params AS (
  SELECT
    'Total Loans'       AS target_lvl4,     -- GL layer filter (optional)
    12                  AS months_back,     -- lookback window for changes
    1000000.0::FLOAT8   AS dollar_anchor,   -- $ scale: ~$1M => full 25 pts
    0.20::FLOAT8        AS pct_anchor,      -- % scale: 20% => full 25 pts
    5.0::FLOAT8         AS w_na_flip,       -- KDE weights (max sum = 22)
    4.0::FLOAT8         AS w_rc_code,
    3.0::FLOAT8         AS w_gl_l4,
    3.0::FLOAT8         AS w_gl_code,
    1.0::FLOAT8         AS w_gl_desc,
    3.0::FLOAT8         AS w_facility,
    2.0::FLOAT8         AS w_status_desc,
    1.0::FLOAT8         AS w_maturity
),

-- Latest month and window start (need 13 months to compute 12 deltas)
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
         l.max_eom AS max_eom
  FROM latest l
),

-- =========================================
-- Measures per (account_key, system, month)
-- =========================================
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Optional: limit to research systems
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- =========================================
-- KDE attributes per (account_key, system, month)
-- Use MAX() assuming single-valued per acct/month; safe & fast.
-- If attributes can vary within month, switch to ROW_NUMBER() snapshot.
-- =========================================
attr AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    MAX(t.FACILITY_ID)              AS FACILITY_ID,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RC_DESCRIPTION)           AS RC_DESCRIPTION,
    MAX(t.GL_ACCOUNT_HIER_LEVEL_4)  AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(t.GL_ACCOUNT_CODE)          AS GL_ACCOUNT_CODE,
    MAX(t.GL_ACCOUNT_DESCRIPTION)   AS GL_ACCOUNT_DESCRIPTION,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.STATUS_CODE_DESCRIPTION)  AS STATUS_CODE_DESCRIPTION,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Optional: same system filter as measures
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- Base: measures + attributes at same grain
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- KDEs
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,
    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr a
    ON a.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY            = m.ACCOUNT_KEY
),

-- =========================================
-- Compute MoM prev values and change flags
-- =========================================
changes AS (
  SELECT
    b.*,
    LAG(b.END_OF_MONTH_DATE)        OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(b.SOURCE_SYSTEM_BALANCE)    OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_SSB,
    LAG(b.FACILITY_ID)              OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_FACILITY_ID,
    LAG(b.RC_CODE)                  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(b.RC_DESCRIPTION)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RC_DESCRIPTION,
    LAG(b.GL_ACCOUNT_HIER_LEVEL_4)  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_L4,
    LAG(b.GL_ACCOUNT_CODE)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_CODE,
    LAG(b.GL_ACCOUNT_DESCRIPTION)   OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_DESC,
    LAG(b.NON_ACCRUAL_FLAG)         OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NA_FLAG,
    LAG(b.STATUS_CODE_DESCRIPTION)  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_STATUS_DESC,
    LAG(b.MATURITY_DATE)            OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE
  FROM base b
),

-- Only rows that have a prior month within window
delta AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.ACCOUNT_KEY,

    -- Current values
    c.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    c.FACILITY_ID           AS CURR_FACILITY_ID,
    c.RC_CODE               AS CURR_RC_CODE,
    c.RC_DESCRIPTION        AS CURR_RC_DESCRIPTION,
    c.GL_ACCOUNT_HIER_LEVEL_4 AS CURR_GL_L4,
    c.GL_ACCOUNT_CODE       AS CURR_GL_CODE,
    c.GL_ACCOUNT_DESCRIPTION AS CURR_GL_DESC,
    c.NON_ACCRUAL_FLAG      AS CURR_NA_FLAG,
    c.STATUS_CODE_DESCRIPTION AS CURR_STATUS_DESC,
    c.MATURITY_DATE         AS CURR_MATURITY_DATE,

    -- Prior values
    c.PREV_EOM,
    c.PREV_SSB,
    c.PREV_FACILITY_ID,
    c.PREV_RC_CODE,
    c.PREV_RC_DESCRIPTION,
    c.PREV_GL_L4,
    c.PREV_GL_CODE,
    c.PREV_GL_DESC,
    c.PREV_NA_FLAG,
    c.PREV_STATUS_DESC,
    c.PREV_MATURITY_DATE,

    -- $ and % deltas
    (COALESCE(c.SOURCE_SYSTEM_BALANCE,0) - COALESCE(c.PREV_SSB,0)) AS DELTA_DOLLAR,
    CASE WHEN c.PREV_SSB IS NULL OR c.PREV_SSB = 0
         THEN NULL
         ELSE ((c.SOURCE_SYSTEM_BALANCE - c.PREV_SSB) / c.PREV_SSB) * 100
    END AS DELTA_PCT,

    -- KDE change flags (null-safe comparisons)
    CASE WHEN (c.CURR_FACILITY_ID <> c.PREV_FACILITY_ID)
        OR (c.CURR_FACILITY_ID IS NULL AND c.PREV_FACILITY_ID IS NOT NULL)
        OR (c.CURR_FACILITY_ID IS NOT NULL AND c.PREV_FACILITY_ID IS NULL) THEN 1 ELSE 0 END AS CHG_FACILITY,

    CASE WHEN (c.CURR_RC_CODE <> c.PREV_RC_CODE)
        OR (c.CURR_RC_CODE IS NULL AND c.PREV_RC_CODE IS NOT NULL)
        OR (c.CURR_RC_CODE IS NOT NULL AND c.PREV_RC_CODE IS NULL) THEN 1 ELSE 0 END AS CHG_RC_CODE,

    CASE WHEN (c.CURR_GL_L4 <> c.PREV_GL_L4)
        OR (c.CURR_GL_L4 IS NULL AND c.PREV_GL_L4 IS NOT NULL)
        OR (c.CURR_GL_L4 IS NOT NULL AND c.PREV_GL_L4 IS NULL) THEN 1 ELSE 0 END AS CHG_GL_L4,

    CASE WHEN (c.CURR_GL_CODE <> c.PREV_GL_CODE)
        OR (c.CURR_GL_CODE IS NULL AND c.PREV_GL_CODE IS NOT NULL)
        OR (c.CURR_GL_CODE IS NOT NULL AND c.PREV_GL_CODE IS NULL) THEN 1 ELSE 0 END AS CHG_GL_CODE,

    CASE WHEN (c.CURR_GL_DESC <> c.PREV_GL_DESC)
        OR (c.CURR_GL_DESC IS NULL AND c.PREV_GL_DESC IS NOT NULL)
        OR (c.CURR_GL_DESC IS NOT NULL AND c.PREV_GL_DESC IS NULL) THEN 1 ELSE 0 END AS CHG_GL_DESC,

    CASE WHEN (c.CURR_NA_FLAG <> c.PREV_NA_FLAG)
        OR (c.CURR_NA_FLAG IS NULL AND c.PREV_NA_FLAG IS NOT NULL)
        OR (c.CURR_NA_FLAG IS NOT NULL AND c.PREV_NA_FLAG IS NULL) THEN 1 ELSE 0 END AS CHG_NON_ACCRUAL,

    CASE WHEN (c.CURR_STATUS_DESC <> c.PREV_STATUS_DESC)
        OR (c.CURR_STATUS_DESC IS NULL AND c.PREV_STATUS_DESC IS NOT NULL)
        OR (c.CURR_STATUS_DESC IS NOT NULL AND c.PREV_STATUS_DESC IS NULL) THEN 1 ELSE 0 END AS CHG_STATUS_DESC,

    CASE WHEN (c.CURR_MATURITY_DATE <> c.PREV_MATURITY_DATE)
        OR (c.CURR_MATURITY_DATE IS NULL AND c.PREV_MATURITY_DATE IS NOT NULL)
        OR (c.CURR_MATURITY_DATE IS NOT NULL AND c.PREV_MATURITY_DATE IS NULL) THEN 1 ELSE 0 END AS CHG_MATURITY
  FROM changes c
  WHERE c.PREV_EOM IS NOT NULL
),

-- =========================================
-- Severity scoring and rolling Z-score
-- =========================================
scored AS (
  SELECT
    d.*,
    -- Monetary subscore (0..50): 25 from $ move, 25 from % move (anchors cap)
    (CASE
       WHEN ABS(d.DELTA_DOLLAR) >= (SELECT dollar_anchor FROM params)
       THEN 25.0
       ELSE 25.0 * (ABS(d.DELTA_DOLLAR) / (SELECT dollar_anchor FROM params))
     END)
    +
    (CASE
       WHEN d.DELTA_PCT IS NULL THEN 0.0
       WHEN ABS(d.DELTA_PCT)/100.0 >= (SELECT pct_anchor FROM params)
       THEN 25.0
       ELSE 25.0 * ((ABS(d.DELTA_PCT)/100.0) / (SELECT pct_anchor FROM params))
     END)                                        AS monetary_score_0_50,

    -- KDE subscore (0..50): scale sum of weights by max sum (22)
    50.0 * (
      (d.CHG_NON_ACCRUAL * (SELECT w_na_flip      FROM params)) +
      (d.CHG_RC_CODE     * (SELECT w_rc_code      FROM params)) +
      (d.CHG_GL_L4       * (SELECT w_gl_l4        FROM params)) +
      (d.CHG_GL_CODE     * (SELECT w_gl_code      FROM params)) +
      (d.CHG_GL_DESC     * (SELECT w_gl_desc      FROM params)) +
      (d.CHG_FACILITY    * (SELECT w_facility     FROM params)) +
      (d.CHG_STATUS_DESC * (SELECT w_status_desc  FROM params)) +
      (d.CHG_MATURITY    * (SELECT w_maturity     FROM params))
    ) / 22.0                                      AS kde_score_0_50,

    -- Rolling 12 (including current) Z-score of $ delta per acct+system
    AVG(d.DELTA_DOLLAR) OVER (
      PARTITION BY d.ACCOUNT_KEY, d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_avg_12,
    STDDEV_SAMP(d.DELTA_DOLLAR) OVER (
      PARTITION BY d.ACCOUNT_KEY, d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_std_12
  FROM delta d
),

final AS (
  SELECT
    s.*,
    CASE
      WHEN s.delta_std_12 IS NULL OR s.delta_std_12 = 0 THEN NULL
      ELSE (s.DELTA_DOLLAR - s.delta_avg_12) / s.delta_std_12
    END AS delta_z_12,
    ROUND(s.monetary_score_0_50 + s.kde_score_0_50, 1) AS severity_0_100,

    -- Compact list of changed KDEs
    TRIM(BOTH ',' FROM
      (CASE WHEN CHG_NON_ACCRUAL = 1 THEN ',NON_ACCRUAL' ELSE '' END) ||
      (CASE WHEN CHG_RC_CODE     = 1 THEN ',RC_CODE'     ELSE '' END) ||
      (CASE WHEN CHG_GL_L4       = 1 THEN ',GL_L4'       ELSE '' END) ||
      (CASE WHEN CHG_GL_CODE     = 1 THEN ',GL_CODE'     ELSE '' END) ||
      (CASE WHEN CHG_GL_DESC     = 1 THEN ',GL_DESC'     ELSE '' END) ||
      (CASE WHEN CHG_FACILITY    = 1 THEN ',FACILITY'    ELSE '' END) ||
      (CASE WHEN CHG_STATUS_DESC = 1 THEN ',STATUS'      ELSE '' END) ||
      (CASE WHEN CHG_MATURITY    = 1 THEN ',MATURITY'    ELSE '' END)
    ) AS changed_fields
  FROM scored s
)

SELECT
  END_OF_MONTH_DATE, PREV_EOM,
  CONTRACT_SOURCE_SYSTEM,
  ACCOUNT_KEY,

  -- Balance context
  PREV_SSB, CURR_SSB,
  DELTA_DOLLAR, DELTA_PCT, delta_z_12,

  -- KDE old/new (curr shown here; join back to attr if you also want explicit prev text values)
  CURR_RC_CODE, CURR_RC_DESCRIPTION,
  CURR_GL_L4,   CURR_GL_CODE, CURR_GL_DESC,
  CURR_FACILITY_ID, CURR_STATUS_DESC, CURR_NA_FLAG, CURR_MATURITY_DATE,

  -- KDE flags
  CHG_RC_CODE, CHG_GL_L4, CHG_GL_CODE, CHG_GL_DESC,
  CHG_FACILITY, CHG_STATUS_DESC, CHG_NON_ACCRUAL, CHG_MATURITY,
  changed_fields,

  -- Scores
  ROUND(monetary_score_0_50, 1) AS monetary_score_0_50,
  ROUND(kde_score_0_50, 1)      AS kde_score_0_50,
  severity_0_100

FROM final
-- Focus on real movement or any KDE change; comment WHERE to see all rows
WHERE (COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0))
   OR (CHG_RC_CODE + CHG_GL_L4 + CHG_GL_CODE + CHG_GL_DESC
     + CHG_FACILITY + CHG_STATUS_DESC + CHG_NON_ACCRUAL + CHG_MATURITY) > 0
ORDER BY severity_0_100 DESC, ABS(DELTA_DOLLAR) DESC, END_OF_MONTH_DATE DESC;








/* 2) Snapshot ATTRIBUTES per (account, month) — no UPDATE_TS/LOAD_TS needed */
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,

      -- Attributes you want
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,

      -- Heuristic tie-breaker: prefer rows that are more "material"/informative
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY
          CASE WHEN t.NON_ACCRUAL_FLAG = 'Y' THEN 1 ELSE 0 END DESC,
          COALESCE(t.GL_BALANCE,0)           DESC,
          COALESCE(t.COMMITMENT_BALANCE,0)   DESC,
          COALESCE(t.AVAILABLE_BALANCE,0)    DESC,
          COALESCE(t.MATURITY_DATE, DATE '1900-01-01') DESC,
          t.RC_CODE,
          t.GL_ACCOUNT_CODE
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')  -- edit
  ) s
  WHERE rn = 1
)






-- ========= Parameters you edit =========
-- Put the systems you want to research here
WITH params AS (
  SELECT 'Total Loans' AS target_lvl4
),

latest_month AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
  FROM latest_month
),

/* 1) Aggregate MEASURES per (account, system, month) */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,                 -- << unique id
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN latest_month lm
  CROSS JOIN prior_month pm
  WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    AND t.CONTRACT_SOURCE_SYSTEM IN (
      'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
    )
  GROUP BY 1,2,3
),

/* 2) Snapshot ATTRIBUTES per (account, month) */
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,
      -- Attributes
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,
      -- Tiebreakers (avoid NULLS LAST; prefer explicit null handling)
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY
          CASE WHEN t.UPDATE_TS IS NULL THEN 1 ELSE 0 END, t.UPDATE_TS DESC,
          CASE WHEN t.LOAD_TS   IS NULL THEN 1 ELSE 0 END, t.LOAD_TS   DESC
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN (
        'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
      )
  ) s
  WHERE rn = 1
),

/* 3) Join measures + attributes */
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,

    -- Attributes
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,

    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr_snapshot a
    ON a.END_OF_MONTH_DATE       = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM  = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY             = m.ACCOUNT_KEY
),

/* 4) Tag current vs prior */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN 'CURR' ELSE 'PREV' END AS tag
  FROM base b
),

/* 5) Pivot to prev/curr and compute deltas/flags */
final_pivot AS (
  SELECT
    t.ACCOUNT_KEY,
    t.CONTRACT_SOURCE_SYSTEM,

    -- attributes: take CURR view; keep PREV for change flags
    MAX(CASE WHEN tag='CURR' THEN FACILITY_ID    END) AS CURR_FACILITY_ID,
    MAX(CASE WHEN tag='PREV' THEN FACILITY_ID    END) AS PREV_FACILITY_ID,

    MAX(CASE WHEN tag='CURR' THEN RC_CODE        END) AS RC_CODE,
    MAX(CASE WHEN tag='CURR' THEN RC_DESCRIPTION END) AS RC_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_HIER_LEVEL_4 END) AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_CODE END) AS GL_ACCOUNT_CODE,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_DESCRIPTION END) AS GL_ACCOUNT_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN NON_ACCRUAL_FLAG END) AS NON_ACCRUAL_FLAG,
    MAX(CASE WHEN tag='CURR' THEN STATUS_CODE_DESCRIPTION END) AS STATUS_CODE_DESCRIPTION,

    MAX(CASE WHEN tag='CURR' THEN MATURITY_DATE END) AS CURR_MATURITY_DATE,
    MAX(CASE WHEN tag='PREV' THEN MATURITY_DATE END) AS PREV_MATURITY_DATE,

    -- measures: keep prev/curr for key balances
    MAX(CASE WHEN tag='CURR' THEN SOURCE_SYSTEM_BALANCE END) AS CURR_SSB,
    MAX(CASE WHEN tag='PREV' THEN SOURCE_SYSTEM_BALANCE END) AS PREV_SSB,

    MAX(CASE WHEN tag='CURR' THEN GL_BALANCE END) AS CURR_GL_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN GL_BALANCE END) AS PREV_GL_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN AVAILABLE_BALANCE END) AS CURR_AVAILABLE_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN AVAILABLE_BALANCE END) AS PREV_AVAILABLE_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN COMMITMENT_BALANCE END) AS CURR_COMMITMENT_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN COMMITMENT_BALANCE END) AS PREV_COMMITMENT_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN CHARGE_OFF_AMOUNT_ITD END) AS CURR_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN CHARGE_OFF_AMOUNT_ITD END) AS PREV_CHARGE_OFF_ITD,

    MAX(CASE WHEN tag='CURR' THEN RECOVERY_AMOUNT_ITD END) AS CURR_RECOVERY_ITD,
    MAX(CASE WHEN tag='PREV' THEN RECOVERY_AMOUNT_ITD END) AS PREV_RECOVERY_ITD,

    MAX(CASE WHEN tag='CURR' THEN NET_CHARGE_OFF_ITD END) AS CURR_NET_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN NET_CHARGE_OFF_ITD END) AS PREV_NET_CHARGE_OFF_ITD
  FROM tagged t
  GROUP BY t.ACCOUNT_KEY, t.CONTRACT_SOURCE_SYSTEM
)

SELECT
  ACCOUNT_KEY,
  CONTRACT_SOURCE_SYSTEM,

  -- attributes (current view)
  RC_CODE,
  RC_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  NON_ACCRUAL_FLAG,
  STATUS_CODE_DESCRIPTION,

  -- facility & maturity (with change flags; null-safe comparisons)
  PREV_FACILITY_ID,
  CURR_FACILITY_ID,
  CASE
    WHEN (CURR_FACILITY_ID <> PREV_FACILITY_ID)
       OR (CURR_FACILITY_ID IS NULL AND PREV_FACILITY_ID IS NOT NULL)
       OR (CURR_FACILITY_ID IS NOT NULL AND PREV_FACILITY_ID IS NULL)
    THEN 1 ELSE 0 END AS FACILITY_CHANGED,

  PREV_MATURITY_DATE,
  CURR_MATURITY_DATE,
  CASE
    WHEN (CURR_MATURITY_DATE <> PREV_MATURITY_DATE)
       OR (CURR_MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL)
       OR (CURR_MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL)
    THEN 1 ELSE 0 END AS MATURITY_CHANGED,

  -- measures (prev/curr for the main balances)
  PREV_SSB  AS PREV_SOURCE_SYSTEM_BALANCE,
  CURR_SSB  AS CURR_SOURCE_SYSTEM_BALANCE,
  (COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0))                       AS MOM_SSB_DELTA_DOLLAR,
  CASE WHEN PREV_SSB IS NULL OR PREV_SSB = 0 THEN NULL
       ELSE ((CURR_SSB - PREV_SSB) / PREV_SSB) * 100 END              AS MOM_SSB_DELTA_PCT,

  PREV_GL_BALANCE,
  CURR_GL_BALANCE,

  PREV_AVAILABLE_BALANCE,
  CURR_AVAILABLE_BALANCE,

  PREV_COMMITMENT_BALANCE,
  CURR_COMMITMENT_BALANCE,

  -- ITD metrics (prev/curr)
  PREV_CHARGE_OFF_ITD,
  CURR_CHARGE_OFF_ITD,
  PREV_RECOVERY_ITD,
  CURR_RECOVERY_ITD,
  PREV_NET_CHARGE_OFF_ITD,
  CURR_NET_CHARGE_OFF_ITD,

  -- Account status classification based on SSB visibility
  CASE
    WHEN PREV_SSB IS NULL AND CURR_SSB IS NOT NULL THEN 'NEW'
    WHEN PREV_SSB IS NOT NULL AND CURR_SSB IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
  END AS ACCOUNT_STATUS

FROM final_pivot
-- Only keep movers (by SSB). Remove WHERE if you want everything.
WHERE COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0)
ORDER BY ABS(COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0)) DESC;






-- ========= Parameters you edit =========
-- Put the systems you want to research here
-- Example: 'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'
WITH params AS (
  SELECT
    'Total Loans'::VARCHAR(100) AS target_lvl4
),

latest_month AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
  FROM latest_month
),

/* 1) Aggregate MEASURES per (account, system, month).
      Use sums to be robust if multiple rows exist per account/month.
*/
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,                 -- << unique id
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN latest_month lm
  CROSS JOIN prior_month pm
  -- Pull only the two months we care about
  WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
    -- OPTIONAL: narrow to total-loans layer; keep or remove as needed
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Keep only the systems you want to research
    AND t.CONTRACT_SOURCE_SYSTEM IN (
      'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
    )
  GROUP BY 1,2,3
),

/* 2) Snapshot ATTRIBUTES per (account, month).
      Choose one "best" row per account/month to source attributes from,
      avoiding GROUP BY on every attribute.
*/
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,                              -- << unique id
      -- Attributes you asked for (non-aggregated)
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,
      -- Tiebreakers to pick the most recent/authoritative row
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY t.UPDATE_TS DESC NULLS LAST, t.LOAD_TS DESC NULLS LAST, t.ROWID DESC
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN (
        'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
      )
  ) s
  WHERE rn = 1
),

/* 3) Join measures + attributes at the same grain (account, system, month). */
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,

    -- Attributes (from snapshot)
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,

    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr_snapshot a
    ON a.END_OF_MONTH_DATE       = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM  = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY             = m.ACCOUNT_KEY
),

/* 4) Tag current vs prior to enable clean pivoting. */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN 'CURR' ELSE 'PREV' END AS tag
  FROM base b
),

/* 5) Pivot to prev/curr columns and compute deltas and flags. */
final_pivot AS (
  SELECT
    t.ACCOUNT_KEY,
    t.CONTRACT_SOURCE_SYSTEM,

    -- attributes: take CURR view by default; also keep prev for change flags
    MAX(CASE WHEN tag='CURR' THEN FACILITY_ID    END) AS CURR_FACILITY_ID,
    MAX(CASE WHEN tag='PREV' THEN FACILITY_ID    END) AS PREV_FACILITY_ID,

    MAX(CASE WHEN tag='CURR' THEN RC_CODE        END) AS RC_CODE,
    MAX(CASE WHEN tag='CURR' THEN RC_DESCRIPTION END) AS RC_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_HIER_LEVEL_4 END) AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_CODE END) AS GL_ACCOUNT_CODE,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_DESCRIPTION END) AS GL_ACCOUNT_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN NON_ACCRUAL_FLAG END) AS NON_ACCRUAL_FLAG,
    MAX(CASE WHEN tag='CURR' THEN STATUS_CODE_DESCRIPTION END) AS STATUS_CODE_DESCRIPTION,

    MAX(CASE WHEN tag='CURR' THEN MATURITY_DATE END) AS CURR_MATURITY_DATE,
    MAX(CASE WHEN tag='PREV' THEN MATURITY_DATE END) AS PREV_MATURITY_DATE,

    -- measures: keep prev/curr for key balances
    MAX(CASE WHEN tag='CURR' THEN SOURCE_SYSTEM_BALANCE END) AS CURR_SSB,
    MAX(CASE WHEN tag='PREV' THEN SOURCE_SYSTEM_BALANCE END) AS PREV_SSB,

    MAX(CASE WHEN tag='CURR' THEN GL_BALANCE END) AS CURR_GL_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN GL_BALANCE END) AS PREV_GL_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN AVAILABLE_BALANCE END) AS CURR_AVAILABLE_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN AVAILABLE_BALANCE END) AS PREV_AVAILABLE_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN COMMITMENT_BALANCE END) AS CURR_COMMITMENT_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN COMMITMENT_BALANCE END) AS PREV_COMMITMENT_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN CHARGE_OFF_AMOUNT_ITD END) AS CURR_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN CHARGE_OFF_AMOUNT_ITD END) AS PREV_CHARGE_OFF_ITD,

    MAX(CASE WHEN tag='CURR' THEN RECOVERY_AMOUNT_ITD END) AS CURR_RECOVERY_ITD,
    MAX(CASE WHEN tag='PREV' THEN RECOVERY_AMOUNT_ITD END) AS PREV_RECOVERY_ITD,

    MAX(CASE WHEN tag='CURR' THEN NET_CHARGE_OFF_ITD END) AS CURR_NET_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN NET_CHARGE_OFF_ITD END) AS PREV_NET_CHARGE_OFF_ITD
  FROM tagged t
  GROUP BY t.ACCOUNT_KEY, t.CONTRACT_SOURCE_SYSTEM
)

SELECT
  ACCOUNT_KEY,
  CONTRACT_SOURCE_SYSTEM,

  -- attributes (current view)
  RC_CODE,
  RC_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  NON_ACCRUAL_FLAG,
  STATUS_CODE_DESCRIPTION,

  -- facility & maturity (with change flags)
  PREV_FACILITY_ID,
  CURR_FACILITY_ID,
  CASE WHEN CURR_FACILITY_ID IS DISTINCT FROM PREV_FACILITY_ID THEN 1 ELSE 0 END AS FACILITY_CHANGED,

  PREV_MATURITY_DATE,
  CURR_MATURITY_DATE,
  CASE WHEN CURR_MATURITY_DATE IS DISTINCT FROM PREV_MATURITY_DATE THEN 1 ELSE 0 END AS MATURITY_CHANGED,

  -- measures (prev/curr for the main balances)
  PREV_SSB  AS PREV_SOURCE_SYSTEM_BALANCE,
  CURR_SSB  AS CURR_SOURCE_SYSTEM_BALANCE,
  (COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0))                       AS MOM_SSB_DELTA_DOLLAR,
  CASE WHEN PREV_SSB IS NULL OR PREV_SSB = 0 THEN NULL
       ELSE ((CURR_SSB - PREV_SSB) / PREV_SSB) * 100 END              AS MOM_SSB_DELTA_PCT,

  PREV_GL_BALANCE,
  CURR_GL_BALANCE,

  PREV_AVAILABLE_BALANCE,
  CURR_AVAILABLE_BALANCE,

  PREV_COMMITMENT_BALANCE,
  CURR_COMMITMENT_BALANCE,

  -- ITD metrics (prev/curr)
  PREV_CHARGE_OFF_ITD,
  CURR_CHARGE_OFF_ITD,
  PREV_RECOVERY_ITD,
  CURR_RECOVERY_ITD,
  PREV_NET_CHARGE_OFF_ITD,
  CURR_NET_CHARGE_OFF_ITD,

  -- Account status classification based on SSB visibility
  CASE
    WHEN PREV_SSB IS NULL AND CURR_SSB IS NOT NULL THEN 'NEW'
    WHEN PREV_SSB IS NOT NULL AND CURR_SSB IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
  END AS ACCOUNT_STATUS

FROM final_pivot
-- Only keep movers (by SSB). Remove HAVING if you want everything.
WHERE COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0)
ORDER BY ABS(COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0)) DESC;







FACILITY_ID
GL_BALANCE,
AVAILABLE_BALANCE,
COMMITMENT_BALANCE,
RC_CODE,
RC_DESCRIPTION,
GL_ACCOUNT_HIER_LEVEL_4,
GL_ACCOUNT_HIER_LEVEL_4,
GL_ACCOUNT_CODE,
GL_ACCOUNT_DESCRIPTION,
CHARGE_OFF_AMOUNT_ITD,
RECOVERY_AMOUNT_ITD,
NET_CHARGE_OFF_ITD,
NON_ACCRUAL_FLAG





WITH latest_month AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
    SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
    FROM latest_month
),

-- 1) Base pull for both months, now at ACCOUNT_IDENTIFIER granularity
base AS (
    SELECT
        t.END_OF_MONTH_DATE,
        t.CONTRACT_SOURCE_SYSTEM,
        t.ACCOUNT_IDENTIFIER,
        CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
        -- >>> PLACEHOLDER: Add additional fields here for research <<<
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      AND t.CONTRACT_SOURCE_SYSTEM IN (
            -- List only the systems you want to research:
            'L-FCB_CORE', 'L-CIT_CORE', 'L-SVB_CORE'
      )
    GROUP BY 1,2,3
),

-- 2) Pivot into current/prior columns per account
pivoted AS (
    SELECT
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN SOURCE_SYSTEM_BALANCE END) AS CURR_BAL,
        MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM prior_month) THEN SOURCE_SYSTEM_BALANCE END) AS PREV_BAL
    FROM base
    GROUP BY ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
)

-- 3) Final Output
SELECT
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    PREV_BAL,
    CURR_BAL,
    (CURR_BAL - PREV_BAL) AS MOM_CHANGE_DOLLAR,
    CASE 
        WHEN PREV_BAL = 0 THEN NULL
        ELSE ((CURR_BAL - PREV_BAL) / PREV_BAL) * 100
    END AS MOM_CHANGE_PCT
FROM pivoted
WHERE (CURR_BAL - PREV_BAL) <> 0 -- only show accounts with change
ORDER BY ABS(CURR_BAL - PREV_BAL) DESC;  -- biggest movers first



CASE 
    WHEN PREV_BAL IS NULL THEN 'NEW'
    WHEN CURR_BAL IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
END AS ACCOUNT_STATUS






=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_HISTORICAL_ERROR_MAIN",
    tblVariance[period_date],            EDATE([@period_date], -1)
  ),
"")





=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_HISTORICAL_ERROR_MAIN",
    tblVariance[period_date],            EDATE([@period_date],-1)
  ),
"")





=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_ANOMALY_DETECTION_MAIN",
    tblVariance[period_date],            EDATE([@period_date],-1)
  ),
"")




=EOMONTH(
  MAX( FILTER( tblVariance[period_date], ISNUMBER(tblVariance[period_date]) ) ),
0)


=EOMONTH(
  MAX(
    FILTER(
      tblVariance[period_date],
      (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
      ISNUMBER(tblVariance[period_date])
    )
  ),
0)




=LET(
  sys, [@CONTRACT_SOURCE_SYSTEM],
  dt,  [@period_date],
  val, SUMPRODUCT(
         (tblVariance[CONTRACT_SOURCE_SYSTEM]=sys) *
         ( (tblVariance[row_type]="HISTORY") + (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN") ) *
         (tblVariance[period_date]=EDATE(dt,-1)) *
         tblVariance[actual]
       ),
  IF(val=0,"",val)
)






=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date], -1)
  ),
"")





=IF(
  COUNTIFS(
    tblVariance[CONTRACT_SOURCE_SYSTEM],[#This Row],[CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],              [#This Row],[row_type],
    tblVariance[period_date],           EDATE([#This Row],[period_date],-1)
  )=0,
  "",
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM],[#This Row],[CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],              [#This Row],[row_type],
    tblVariance[period_date],           EDATE([#This Row],[period_date],-1)
  )
)




=IF(
  COUNTIFS(
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date],-1)
  )=0,
  "",
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date],-1)
  )
)






=LET(
  sys, [@CONTRACT_SOURCE_SYSTEM],
  dt,  [@period_date],
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], sys,
    tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN",
    tblVariance[period_date], EDATE(dt,-1)
  )
)



=LET(
  prior, [@[Prior month actual]],
  IF(prior="","", [@actual] - prior)
)



=LET(
  prior, [@[Prior month actual]],
  IF(prior<=0,"", [@[MoM Change ($)]] / prior)
)








=XLOOKUP(1,(tblVariance[CONTRACT_SOURCE_SYSTEM]=C3)*(tblVariance[period_date]=C2)*(tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN"),tblVariance[outside_95_band])







=SUMPRODUCT(
   (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
   (tblVariance[period_date]=LatestMonth)*
   (tblVariance[actual]>=tblVariance[pi95_lo])*
   (tblVariance[actual]<=tblVariance[pi95_hi])
)
/
SUMPRODUCT(
   (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
   (tblVariance[period_date]=LatestMonth)
)





=COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth, tblVariance[Abs % Error], "<=0.1") / COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth)
% of systems within ±10%
Coverage %
=COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth, tblVariance[actual], ">=" & tblVariance[pi95_lo], tblVariance[actual], "<=" & tblVariance[pi95_hi]) / COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth)








=AVERAGEIFS(tblVariance[actual],
            tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
            tblVariance[period_date],MAX(tblVariance[period_date]))


=RMSE_Latest / AvgActual_Latest






=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
                 tblVariance[period_date],MAX(tblVariance[period_date])))


=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
                 tblVariance[period_date],MAX(tblVariance[period_date])))


=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],"SUMMARY_HISTORICAL_ERROR_MAIN"))












/* ========= ANOMALY / VARIANCE with OUTLIER FILTER + 13 MONTHS + REGRESSION =========
   Excludes: systems with $0 balance for the entire 13-month window (“$0 for over a year”).
   Also excludes: CONTRACT_SOURCE_SYSTEM = 'BPLN'.
   Tags: Overdrafts (TA%, UU%, US) and Synthetic list.
   Output columns (16, fixed order):
   1) row_type  2) CONTRACT_SOURCE_SYSTEM  3) period_date  4) actual
   5) forecast_val  6) sigma_est  7) pi95_lo  8) pi95_hi
   9) dev_abs  10) dev_pct  11) z_score  12) severity_0_100
   13) outside_95_band  14) sigma_recent  15) regr_slope_12  16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- 13-month window (fast), Total Loans, exclude BPLN ---- */
base_raw AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -13)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- OUTLIER FILTER: drop systems with $0 for the entire 13 months ---- */
active_systems AS (
  SELECT CONTRACT_SOURCE_SYSTEM
  FROM base_raw
  GROUP BY CONTRACT_SOURCE_SYSTEM
  HAVING MAX(ABS(SOURCE_SYSTEM_BALANCE)) > 0  -- keep only systems that had any non-zero month
),

base AS (
  SELECT b.*
  FROM base_raw b
  JOIN active_systems a
    ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft (TA%, UU%, US) ---- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling windows (6M stats; 12M regression components) ---- */
win AS (
  SELECT
    i.*,

    /* 6-month rolling sums for mean/std */
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    LEAST(i.rn, 6)  AS n6,

    /* 12-row regression components on (x = rn_f, y = balance) */
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    LEAST(i.rn, 12) AS n12,

    /* anchors / alignment */
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats + regression + forecast(t→t+1) ---- */
calc AS (
  SELECT
    w.*,

    /* 6M mean/std */
    CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN w.n6 > 1 THEN
        SQRT( GREATEST( (w.sum6_y2 - ((w.sum6_y * w.sum6_y) / CAST(w.n6 AS FLOAT8))), 0.0 )
             / CAST(w.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12M regression slope/intercept; guard divide-by-zero */
    CASE
      WHEN w.n12 >= 2
       AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
      THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
           / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN w.n12 >= 1 THEN
        ( w.sum12_y
          - ( COALESCE(
                CASE
                  WHEN w.n12 >= 2
                   AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                  THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                       / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                  ELSE NULL
                END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12,

    /* forecast chooser at t for t+1: regression → lag12 → 6M mean */
    COALESCE(
      CASE
        WHEN w.n12 >= 2
         AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
        THEN
          /* intercept + slope * (rn + 1) */
          ( w.sum12_y
            - ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
              ) * w.sum12_x
          ) / CAST(w.n12 AS FLOAT8)
          +
          ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
            / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
          ) * CAST(w.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      w.lag12_balance,
      CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END
    ) AS forecast_val_t1
  FROM win w
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE  AS model_asof_period,  -- t
    c.next_period        AS forecast_period,    -- t+1
    c.actual_next        AS actual,             -- actual at t+1
    c.forecast_val_t1    AS forecast_val,
    c.roll_std_6         AS sigma_est,
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS ===================== */
SELECT * FROM (

  /* Latest-only diagnostics (no forecast), split into MAIN/SYNTH/OD */
  SELECT
    CASE
      WHEN c.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN c.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* Historical error (prior months inside the 13-month slice) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* Latest month anomaly view (key panel) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;




/* ========= SLIM VARIANCE / ANOMALY QUERY (with 12M regression) =========
   Segments: MAIN (non-synth, non-OD), SYNTH, OD (TA%, UU%, US). Excludes BPLN.
   Lookback: 13 months (change to -24/-30 if needed).

   Unified output columns (16):
   1) row_type  2) CONTRACT_SOURCE_SYSTEM  3) period_date  4) actual
   5) forecast_val  6) sigma_est  7) pi95_lo  8) pi95_hi
   9) dev_abs  10) dev_pct  11) z_score  12) severity_0_100
   13) outside_95_band  14) sigma_recent  15) regr_slope_12  16) lag12_balance
*/

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* --- Aggregate monthly (Total Loans), 13-month slice, exclude BPLN --- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -13)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* --- Tag synthetic + overdraft (TA%, UU%, US) --- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* --- Index per system --- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* --- Lightweight rolling windows (6M stats; 12M regression windows) --- */
win AS (
  SELECT
    i.*,

    /* 6-month rolling sums for mean/std */
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    LEAST(i.rn, 6)  AS n6,

    /* 12-row regression components on (x = rn_f, y = balance) */
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    LEAST(i.rn, 12) AS n12,

    /* anchors / alignment */
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* --- Finish stats + regression + forecast(t→t+1) --- */
calc AS (
  SELECT
    w.*,

    /* 6M mean/std */
    CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN w.n6 > 1 THEN
        SQRT( GREATEST( (w.sum6_y2 - ((w.sum6_y * w.sum6_y) / CAST(w.n6 AS FLOAT8))), 0.0 )
             / CAST(w.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12M regression slope/intercept; guard divide-by-zero */
    CASE
      WHEN w.n12 >= 2
       AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
      THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
           / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN w.n12 >= 1 THEN
        ( w.sum12_y
          - ( COALESCE(
                CASE
                  WHEN w.n12 >= 2
                   AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                  THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                       / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                  ELSE NULL
                END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12,

    /* forecast chooser at t for t+1: regression → lag12 → 6M mean */
    COALESCE(
      CASE
        WHEN (CASE
                WHEN w.n12 >= 2
                 AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                     / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                ELSE NULL
              END) IS NOT NULL
         AND (CASE
                WHEN w.n12 >= 1 THEN
                  ( w.sum12_y
                    - ( COALESCE(
                          CASE
                            WHEN w.n12 >= 2
                             AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                            THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                                 / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                            ELSE NULL
                          END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
                ELSE NULL
              END) IS NOT NULL
        THEN
          /* regr_intercept_12 + regr_slope_12 * (rn + 1) */
          (( w.sum12_y
             - ( COALESCE(
                   CASE
                     WHEN w.n12 >= 2
                      AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                     THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                          / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                     ELSE NULL
                   END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
           )
           + (
              ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
              / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
             )
             * CAST(w.rn + 1 AS FLOAT8)
      ELSE NULL
      END,
      w.lag12_balance,
      CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END
    ) AS forecast_val_t1
  FROM win w
),

/* --- Backtest rows: forecast made at t, compared to actual at t+1 --- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE  AS model_asof_period,  -- t
    c.next_period        AS forecast_period,    -- t+1
    c.actual_next        AS actual,             -- actual at t+1
    c.forecast_val_t1    AS forecast_val,
    c.roll_std_6         AS sigma_est,
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS ===================== */
SELECT * FROM (

  /* Latest-only diagnostics (no forecast) */
  SELECT
    CASE
      WHEN c.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN c.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    /* expose regression slope (from same row) for context */
    (SELECT
       CASE
         WHEN w.n12 >= 2
          AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
         THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
              / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
         ELSE NULL
       END
     ) AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* Historical error (prior months inside slice) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* Latest month anomaly view */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;







Field
Meaning
How to Interpret / Use
row_type
Which panel the row belongs to (HISTORY_LITE_MAIN, SUMMARY_HISTORICAL_ERROR_OD, etc.)
Filter on this to drive visuals. Analysts will mostly focus on SUMMARY_ANOMALY_DETECTION_MAIN.
CONTRACT_SOURCE_SYSTEM
Unique source system identifier
Dimension you’ll pivot on; group by this for system-level review.
period_date
Month-end date for the row
Timeline dimension; order chronologically.
actual
Actual SOURCE_SYSTEM_BALANCE for that system/date
The “truth” — compare to forecast_val to see deviation.
forecast_val
Predicted balance for the period based on prior month model (linear regression preferred, fallback to lag-12 or 6-mo mean)
Used to measure surprise — if far from actual, flag as anomaly.
sigma_est
Estimated standard deviation (6-month rolling)
Used for z-score and 95% confidence band; large sigma = more tolerant model.
pi95_lo / pi95_hi
95% prediction interval around forecast
If actual lies outside, it’s statistically surprising.
dev_abs
Actual − Forecast (dollar variance)
Positive = higher than expected, negative = lower than expected.
dev_pct
(Actual − Forecast) ÷ Forecast
Size of surprise relative to expectation; >+10% or <-10% is material.
z_score
Number of sigmas away from forecast
>3 or <-3 = statistically significant.
severity_0_100
Composite anomaly score (0–100): weighted combination of
Use to rank anomalies. ≥80 = high priority review.
outside_95_band
Boolean if actual outside 95% PI
A simple flag for “statistically significant deviation.”
sigma_recent
Rolling std (6-month) used in latest month only (in HISTORY_LITE)
Helps analysts understand system volatility at current close.
regr_slope_12
12-month regression slope (trend)
Positive = trend up, negative = trend down; can explain whether forecast momentum was reasonable.
lag12_balance
Actual balance from same month prior year
Used as seasonal fallback; good for analysts to cross-check.






/* ========= VARIANCE / ANOMALY QUERY with OD SEGMENTATION + BPLN EXCLUSION =========
   Unified output columns (16 columns, same order in every UNION arm):
   1)  row_type
   2)  CONTRACT_SOURCE_SYSTEM
   3)  period_date
   4)  actual
   5)  forecast_val
   6)  sigma_est
   7)  pi95_lo
   8)  pi95_hi
   9)  dev_abs
   10) dev_pct
   11) z_score
   12) severity_0_100
   13) outside_95_band
   14) sigma_recent
   15) regr_slope_12
   16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Monthly totals (Total Loans) over last 24 months, BPLN excluded ---- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'      -- EXCLUDE BPLN
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -24)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft systems ---- */
tagged AS (
  SELECT
    b.*,
    /* synthetic flag */
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,

    /* overdraft flag: TA*, UU*, or explicitly 'US' */
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Row index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                       ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                            ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling components via window frames (fast) ---- */
roll AS (
  SELECT
    i.*,

    -- 6-month rolling stats
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    -- 12-month rolling regression components
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    -- helpers
    LEAST(i.rn, 6)  AS n6,
    LEAST(i.rn, 12) AS n12,

    -- anchors & “next month” alignment
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats & build forecast(t→t+1) ---- */
calc AS (
  SELECT
    r.*,

    /* rolling mean & std (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-month regression (y ~ rn) */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS model_asof_period,  -- t
    c.next_period              AS forecast_period,    -- t+1
    c.actual_next              AS actual,             -- actual at t+1

    /* forecast chooser at t (for t+1): linear → lag12 → 6-mo mean */
    COALESCE(
      CASE
        WHEN c.regr_slope_12 IS NOT NULL AND c.regr_intercept_12 IS NOT NULL
          THEN c.regr_intercept_12 + c.regr_slope_12 * CAST(c.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      c.lag12_balance,
      c.roll_mean_6
    ) AS forecast_val,

    /* sigma estimate (recent 6-mo std) */
    c.roll_std_6 AS sigma_est,

    /* flags & latest marker */
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS (MAIN, SYNTH, OD) ===================== */
SELECT * FROM (

  /* A) Latest-only diagnostics — NON-SYNTH, NON-OD */
  SELECT
    'HISTORY_LITE_MAIN'         AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 0
    AND c.is_overdraft = 0

  UNION ALL

  /* B) Latest-only diagnostics — SYNTH (exclude OD) */
  SELECT
    'HISTORY_LITE_SYNTH'        AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 1
    AND c.is_overdraft = 0

  UNION ALL

  /* C) Historical error (prior months) — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* D) Historical error (prior months) — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  UNION ALL

  /* E) Latest month anomaly — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* F) Latest month anomaly — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  /* -------- OD PANELS (all overdrafts, regardless of synthetic) -------- */

  UNION ALL
  /* G) Latest-only diagnostics — OVERDRAFT */
  SELECT
    'HISTORY_LITE_OD'          AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_overdraft = 1

  UNION ALL
  /* H) Historical error — OVERDRAFT */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period             AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_overdraft = 1

  UNION ALL
  /* I) Latest month anomaly — OVERDRAFT */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period              AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_overdraft = 1

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






/* ========= VARIANCE / ANOMALY QUERY with OVERDRAFT SEGMENTATION =========
   Unified output columns (16 columns, same order in every UNION arm):
   1)  row_type
   2)  CONTRACT_SOURCE_SYSTEM
   3)  period_date
   4)  actual
   5)  forecast_val
   6)  sigma_est
   7)  pi95_lo
   8)  pi95_hi
   9)  dev_abs
   10) dev_pct
   11) z_score
   12) severity_0_100
   13) outside_95_band
   14) sigma_recent
   15) regr_slope_12
   16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Monthly totals (Total Loans) over last 24 months ---- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -24)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft systems ---- */
tagged AS (
  SELECT
    b.*,
    /* synthetic flag */
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,

    /* overdraft flag: TA* or UU* */
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Row index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                       ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                            ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling components via window frames (fast) ---- */
roll AS (
  SELECT
    i.*,

    -- 6-month rolling stats
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    -- 12-month rolling regression components
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    -- helpers
    LEAST(i.rn, 6)  AS n6,
    LEAST(i.rn, 12) AS n12,

    -- anchors & “next month” alignment
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats & build forecast(t→t+1) ---- */
calc AS (
  SELECT
    r.*,

    /* rolling mean & std (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-month regression (y ~ rn) */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS model_asof_period,  -- t
    c.next_period              AS forecast_period,    -- t+1
    c.actual_next              AS actual,             -- actual at t+1

    /* forecast chooser at t (for t+1): linear → lag12 → 6-mo mean */
    COALESCE(
      CASE
        WHEN c.regr_slope_12 IS NOT NULL AND c.regr_intercept_12 IS NOT NULL
          THEN c.regr_intercept_12 + c.regr_slope_12 * CAST(c.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      c.lag12_balance,
      c.roll_mean_6
    ) AS forecast_val,

    /* sigma estimate (recent 6-mo std) */
    c.roll_std_6 AS sigma_est,

    /* flags & latest marker */
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS (six main panels + three OD panels) ===================== */
SELECT * FROM (

  /* A) Latest-only diagnostics — NON-SYNTH, NON-OD */
  SELECT
    'HISTORY_LITE_MAIN'         AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 0
    AND c.is_overdraft = 0

  UNION ALL

  /* B) Latest-only diagnostics — SYNTH (still exclude OD) */
  SELECT
    'HISTORY_LITE_SYNTH'        AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 1
    AND c.is_overdraft = 0

  UNION ALL

  /* C) Historical error (prior months) — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* D) Historical error (prior months) — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  UNION ALL

  /* E) Latest month anomaly — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* F) Latest month anomaly — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  /* -------- OD PANELS (all overdrafts, regardless of synthetic) -------- */

  UNION ALL
  /* G) Latest-only diagnostics — OVERDRAFT */
  SELECT
    'HISTORY_LITE_OD'          AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_overdraft = 1

  UNION ALL
  /* H) Historical error — OVERDRAFT */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period             AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_overdraft = 1

  UNION ALL
  /* I) Latest month anomaly — OVERDRAFT */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period              AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_overdraft = 1

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH
/* ====== PARAMETERS / WINDOW ====== */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ====== SYNTHETIC SYSTEMS (inline list) ====== */
synthetic_list AS (
  SELECT 'ACAR01-EXCPTN' AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'HUBFSV-EXCPTN' UNION ALL
  SELECT 'INFL05-EXCPTN' UNION ALL
  SELECT 'INFL10-EXCPTN' UNION ALL
  SELECT 'LNIQ01-EXCPTN' UNION ALL
  SELECT 'SBO001-EXCPTN' UNION ALL
  SELECT 'STKY01-EXCPTN' UNION ALL
  SELECT 'STRAT1-EXCPTN' UNION ALL
  SELECT 'ALL'           UNION ALL
  SELECT 'GL'            UNION ALL
  SELECT 'LJ'            UNION ALL
  SELECT 'SYN'           UNION ALL
  SELECT 'FRDS_EXCPTN'   UNION ALL
  SELECT 'ADJ'
),

/* ====== 1) Monthly totals (Total Loans) ====== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* synthetic flag once */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ====== 2) Row index per system ====== */
idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ====== 3) Materialize float index ====== */
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ====== 4) Cumulative sums ====== */
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y2,
    SUM(x.rn_f) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x,
    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x2,
    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_xy,
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ====== 5) Rolling windows via csum - lag(csum) + lag12 ====== */
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y, c.csum_y2, c.csum_x, c.csum_x2, c.csum_xy,
    c.cnt_all, c.avg_all, c.avg2_all,
    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ====== 6) Per-row stats ====== */
calc AS (
  SELECT
    r.END_OF_MONTH_DATE,
    r.CONTRACT_SOURCE_SYSTEM,
    r.SOURCE_SYSTEM_BALANCE,
    r.rn, r.rn_f,
    r.csum_y, r.csum_y2, r.csum_x, r.csum_x2, r.csum_xy,
    r.cnt_all, r.avg_all, r.avg2_all,
    r.n6, r.n12,
    r.sum6_y, r.sum6_y2, r.sum12_x, r.sum12_y, r.sum12_x2, r.sum12_xy,
    r.lag12_balance,
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,
    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ====== 7) Latest month per system ====== */
latest_per_sys AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM, MAX(c.END_OF_MONTH_DATE) AS max_eom
  FROM calc c
  GROUP BY c.CONTRACT_SOURCE_SYSTEM
),

/* ====== 8) Backtest panel t-1 -> t (last ~12 origins) ====== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE AS model_asof_period,
    c.END_OF_MONTH_DATE AS forecast_period,
    c.SOURCE_SYSTEM_BALANCE AS actual,
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    ) AS forecast_val,
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    ) AS sigma_est,
    p.avg_all AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
    AND p.END_OF_MONTH_DATE <  l.max_eom
),

/* add synthetic flags */
backtest_split AS (
  SELECT b.CONTRACT_SOURCE_SYSTEM,
         b.model_asof_period,
         b.forecast_period,
         b.actual,
         b.forecast_val,
         b.sigma_est,
         b.avg_level_sys,
         f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM,
         c.END_OF_MONTH_DATE,
         c.SOURCE_SYSTEM_BALANCE,
         c.roll_std_6,
         c.regr_slope_12,
         c.lag12_balance,
         f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* handy join for “t = latest” */
latest_join AS (
  SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
  FROM latest_per_sys l
)

/* ====== FINAL UNION (unified 16 columns) ====== */
SELECT * FROM (
  /* A) HISTORY_LITE — latest only, non-synth */
  SELECT
    'HISTORY_LITE_MAIN'      AS row_type,
    c.CONTRACT_SOURCE_SYSTEM AS CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE      AS period_date,
    c.SOURCE_SYSTEM_BALANCE  AS actual,
    NULL::FLOAT8             AS forecast_val,
    NULL::FLOAT8             AS sigma_est,
    NULL::FLOAT8             AS pi95_lo,
    NULL::FLOAT8             AS pi95_hi,
    NULL::FLOAT8             AS dev_abs,
    NULL::FLOAT8             AS dev_pct,
    NULL::FLOAT8             AS z_score,
    NULL::FLOAT8             AS severity_0_100,
    NULL                     AS outside_95_band,
    c.roll_std_6             AS sigma_recent,
    c.regr_slope_12          AS regr_slope_12,
    c.lag12_balance          AS lag12_balance
  FROM calc_split c
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
   AND l.max_eom                = c.END_OF_MONTH_DATE
  WHERE c.is_synthetic = 0

  UNION ALL

  /* B) HISTORY_LITE — latest only, synth */
  SELECT
    'HISTORY_LITE_SYNTH'     AS row_type,
    c.CONTRACT_SOURCE_SYSTEM AS CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE      AS period_date,
    c.SOURCE_SYSTEM_BALANCE  AS actual,
    NULL::FLOAT8             AS forecast_val,
    NULL::FLOAT8             AS sigma_est,
    NULL::FLOAT8             AS pi95_lo,
    NULL::FLOAT8             AS pi95_hi,
    NULL::FLOAT8             AS dev_abs,
    NULL::FLOAT8             AS dev_pct,
    NULL::FLOAT8             AS z_score,
    NULL::FLOAT8             AS severity_0_100,
    NULL                     AS outside_95_band,
    c.roll_std_6             AS sigma_recent,
    c.regr_slope_12          AS regr_slope_12,
    c.lag12_balance          AS lag12_balance
  FROM calc_split c
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
   AND l.max_eom                = c.END_OF_MONTH_DATE
  WHERE c.is_synthetic = 1

  UNION ALL

  /* C) Historical error (t < latest) — non-synth */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual                        AS actual,
    b.forecast_val                  AS forecast_val,
    b.sigma_est                     AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                   AS sigma_recent,
    NULL::FLOAT8                   AS regr_slope_12,
    NULL::FLOAT8                   AS lag12_balance
  FROM backtest_split b
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
  WHERE b.is_synthetic = 0
    AND b.forecast_period < l.max_eom

  UNION ALL

  /* D) Historical error (t < latest) — synth */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual                         AS actual,
    b.forecast_val                   AS forecast_val,
    b.sigma_est                      AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                    AS sigma_recent,
    NULL::FLOAT8                    AS regr_slope_12,
    NULL::FLOAT8                    AS lag12_balance
  FROM backtest_split b
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
  WHERE b.is_synthetic = 1
    AND b.forecast_period < l.max_eom

  UNION ALL

  /* E) Latest close (t = latest) — anomalies (non-synth) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual                         AS actual,
    b.forecast_val                   AS forecast_val,
    b.sigma_est                      AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                    AS sigma_recent,
    NULL::FLOAT8                    AS regr_slope_12,
    NULL::FLOAT8                    AS lag12_balance
  FROM backtest_split b
  JOIN latest_join lj
    ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
   AND lj.max_eom                = b.forecast_period
  WHERE b.is_synthetic = 0

  UNION ALL

  /* F) Latest close (t = latest) — anomalies (synth) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual                          AS actual,
    b.forecast_val                    AS forecast_val,
    b.sigma_est                       AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                     AS sigma_recent,
    NULL::FLOAT8                     AS regr_slope_12,
    NULL::FLOAT8                     AS lag12_balance
  FROM backtest_split b
  JOIN latest_join lj
    ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
   AND lj.max_eom                = b.forecast_period
  WHERE b.is_synthetic = 1
) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;








/* ===============================================
   0) Clean up any prior run
   =============================================== */
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.RNG_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.SYNTHETIC_LIST_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BASE_MONTHLY_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.SYS_FLAGS_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_PER_SYS_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.CALC_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BACKTEST_12M_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BACKTEST_SPLIT_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.CALC_SPLIT_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_JOIN_WRK;

/* ===============================================
   1) Parameters / latest window
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.LATEST_WRK AS
SELECT MAX(END_OF_MONTH_DATE) AS MAX_EOM
FROM V_DPRT_CREDIT_INSTRUMENTS_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
DISTRIBUTE ON RANDOM;

CREATE TABLE CIDPR.DATAHUB.RNG_WRK AS
SELECT ADD_MONTHS(MAX_EOM, -30) AS START_EOM, MAX_EOM
FROM CIDPR.DATAHUB.LATEST_WRK
DISTRIBUTE ON RANDOM;

/* ===============================================
   2) Synthetic systems lookup
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.SYNTHETIC_LIST_WRK (CONTRACT_SOURCE_SYSTEM VARCHAR(200))
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM);

INSERT INTO CIDPR.DATAHUB.SYNTHETIC_LIST_WRK (CONTRACT_SOURCE_SYSTEM) VALUES
 ('ACAR01-EXCPTN'),('HUBFSV-EXCPTN'),('INFL05-EXCPTN'),('INFL10-EXCPTN'),
 ('LNIQ01-EXCPTN'),('SBO001-EXCPTN'),('STKY01-EXCPTN'),('STRAT1-EXCPTN'),
 ('ALL'),('GL'),('LJ'),('SYN'),('FRDS_EXCPTN'),('ADJ');

/* ===============================================
   3) BASE monthly aggregation (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.BASE_MONTHLY_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
CROSS JOIN CIDPR.DATAHUB.RNG_WRK r
WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
  AND t.END_OF_MONTH_DATE BETWEEN r.START_EOM AND r.MAX_EOM
  AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
;

GENERATE STATISTICS ON CIDPR.DATAHUB.BASE_MONTHLY_WRK;

/* Flag synthetic vs non-synthetic once and reuse */
CREATE TABLE CIDPR.DATAHUB.SYS_FLAGS_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT DISTINCT
       b.CONTRACT_SOURCE_SYSTEM,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.LATEST_PER_SYS_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM, MAX(b.END_OF_MONTH_DATE) AS MAX_EOM
FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
GROUP BY b.CONTRACT_SOURCE_SYSTEM
;

/* ===============================================
   4) CALC (windows on compact monthly table) (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.CALC_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
WITH idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS RN
  FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
),
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.RN,
    CAST(i.RN AS FLOAT8) AS RN_F
  FROM idx1 i
),
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.RN,
    x.RN_F,
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_Y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_Y2,
    SUM(x.RN_F) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_X,
    SUM(CAST(x.RN_F * x.RN_F AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_X2,
    SUM(CAST(x.RN_F * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_XY,
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS CNT_ALL,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS AVG_ALL,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS AVG2_ALL
  FROM idx2 x
),
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.RN,
    c.RN_F,
    c.CSUM_Y, c.CSUM_Y2, c.CSUM_X, c.CSUM_X2, c.CSUM_XY,
    c.CNT_ALL, c.AVG_ALL, c.AVG2_ALL,
    LEAST(c.RN, 6)  AS N6,
    LEAST(c.RN, 12) AS N12,
    (c.CSUM_Y  - COALESCE(LAG(c.CSUM_Y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM6_Y,
    (c.CSUM_Y2 - COALESCE(LAG(c.CSUM_Y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM6_Y2,
    (c.CSUM_X  - COALESCE(LAG(c.CSUM_X,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_X,
    (c.CSUM_Y  - COALESCE(LAG(c.CSUM_Y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_Y,
    (c.CSUM_X2 - COALESCE(LAG(c.CSUM_X2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_X2,
    (c.CSUM_XY - COALESCE(LAG(c.CSUM_XY, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_XY,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS LAG12_BALANCE
  FROM csum c
)
SELECT
  r.END_OF_MONTH_DATE,
  r.CONTRACT_SOURCE_SYSTEM,
  r.SOURCE_SYSTEM_BALANCE,
  r.RN, r.RN_F,
  r.CSUM_Y, r.CSUM_Y2, r.CSUM_X, r.CSUM_X2, r.CSUM_XY,
  r.CNT_ALL, r.AVG_ALL, r.AVG2_ALL,
  r.N6, r.N12,
  r.SUM6_Y, r.SUM6_Y2, r.SUM12_X, r.SUM12_Y, r.SUM12_X2, r.SUM12_XY,
  r.LAG12_BALANCE,
  CASE WHEN r.N6 > 0 THEN r.SUM6_Y / CAST(r.N6 AS FLOAT8) ELSE NULL END AS ROLL_MEAN_6,
  CASE
    WHEN r.N6 > 1 THEN
      SQRT( GREATEST( (r.SUM6_Y2 - ( (r.SUM6_Y * r.SUM6_Y) / CAST(r.N6 AS FLOAT8) )), 0.0 )
           / CAST(r.N6 - 1 AS FLOAT8) )
    ELSE NULL
  END AS ROLL_STD_6,
  CASE
    WHEN r.N12 >= 2 AND ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) ) <> 0.0
      THEN ( (CAST(r.N12 AS FLOAT8) * r.SUM12_XY) - (r.SUM12_X * r.SUM12_Y) )
           / ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) )
    ELSE NULL
  END AS REGR_SLOPE_12,
  CASE
    WHEN r.N12 >= 1 THEN
      ( r.SUM12_Y
        - ( COALESCE(
              CASE
                WHEN r.N12 >= 2 AND ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) ) <> 0.0
                  THEN ( (CAST(r.N12 AS FLOAT8) * r.SUM12_XY) - (r.SUM12_X * r.SUM12_Y) )
                       / ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) )
                ELSE NULL
              END, 0.0) * r.SUM12_X ) ) / CAST(r.N12 AS FLOAT8)
    ELSE NULL
  END AS REGR_INTERCEPT_12
FROM roll r
;

GENERATE STATISTICS ON CIDPR.DATAHUB.CALC_WRK;

/* ===============================================
   5) Backtest panel (t-1 -> t) (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.BACKTEST_12M_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  p.CONTRACT_SOURCE_SYSTEM,
  p.END_OF_MONTH_DATE                                   AS MODEL_ASOF_PERIOD,
  c.END_OF_MONTH_DATE                                   AS FORECAST_PERIOD,
  c.SOURCE_SYSTEM_BALANCE                               AS ACTUAL,
  COALESCE(
    CASE
      WHEN p.REGR_SLOPE_12 IS NOT NULL AND p.REGR_INTERCEPT_12 IS NOT NULL
        THEN p.REGR_INTERCEPT_12 + p.REGR_SLOPE_12 * CAST(p.RN + 1 AS FLOAT8)
      ELSE NULL
    END,
    p.LAG12_BALANCE,
    p.ROLL_MEAN_6
  )                                                     AS FORECAST_VAL,
  COALESCE(
    p.ROLL_STD_6,
    CASE WHEN p.CNT_ALL > 1
         THEN SQRT( GREATEST(p.AVG2_ALL - (p.AVG_ALL * p.AVG_ALL), 0.0)
                    * (CAST(p.CNT_ALL AS FLOAT8) / CAST(p.CNT_ALL - 1 AS FLOAT8)) )
         ELSE NULL
    END
  )                                                     AS SIGMA_EST,
  p.AVG_ALL                                             AS AVG_LEVEL_SYS
FROM CIDPR.DATAHUB.CALC_WRK p
JOIN CIDPR.DATAHUB.CALC_WRK c
  ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
 AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.MAX_EOM, -12)
  AND p.END_OF_MONTH_DATE <  l.MAX_EOM
;

GENERATE STATISTICS ON CIDPR.DATAHUB.BACKTEST_12M_WRK;

/* Split/join flags for final SELECTs */
CREATE TABLE CIDPR.DATAHUB.BACKTEST_SPLIT_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM,
       b.MODEL_ASOF_PERIOD,
       b.FORECAST_PERIOD,
       b.ACTUAL,
       b.FORECAST_VAL,
       b.SIGMA_EST,
       b.AVG_LEVEL_SYS,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.BACKTEST_12M_WRK b
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.CALC_SPLIT_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT c.CONTRACT_SOURCE_SYSTEM,
       c.END_OF_MONTH_DATE,
       c.SOURCE_SYSTEM_BALANCE,
       c.ROLL_STD_6,
       c.REGR_SLOPE_12,
       c.LAG12_BALANCE,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.CALC_WRK c
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.LATEST_JOIN_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT l.CONTRACT_SOURCE_SYSTEM, l.MAX_EOM
FROM CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
;

/* ===============================================
   6) FINAL OUTPUT (unified 16 columns)
   =============================================== */
SELECT * FROM (
/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.ROLL_STD_6               AS sigma_recent,
  c.REGR_SLOPE_12            AS regr_slope_12,
  c.LAG12_BALANCE            AS lag12_balance
FROM CIDPR.DATAHUB.CALC_SPLIT_WRK c
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.MAX_EOM                = c.END_OF_MONTH_DATE
WHERE c.IS_SYNTHETIC = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.ROLL_STD_6               AS sigma_recent,
  c.REGR_SLOPE_12            AS regr_slope_12,
  c.LAG12_BALANCE            AS lag12_balance
FROM CIDPR.DATAHUB.CALC_SPLIT_WRK c
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.MAX_EOM                = c.END_OF_MONTH_DATE
WHERE c.IS_SYNTHETIC = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD               AS period_date,
  b.ACTUAL                        AS actual,
  b.FORECAST_VAL                  AS forecast_val,
  b.SIGMA_EST                     AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                   AS sigma_recent,
  NULL::FLOAT8                   AS regr_slope_12,
  NULL::FLOAT8                   AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.IS_SYNTHETIC = 0
  AND b.FORECAST_PERIOD < l.MAX_EOM

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                AS period_date,
  b.ACTUAL                         AS actual,
  b.FORECAST_VAL                   AS forecast_val,
  b.SIGMA_EST                      AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.IS_SYNTHETIC = 1
  AND b.FORECAST_PERIOD < l.MAX_EOM

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                AS period_date,
  b.ACTUAL                         AS actual,
  b.FORECAST_VAL                   AS forecast_val,
  b.SIGMA_EST                      AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_JOIN_WRK lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.MAX_EOM                = b.FORECAST_PERIOD
WHERE b.IS_SYNTHETIC = 0

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                 AS period_date,
  b.ACTUAL                          AS actual,
  b.FORECAST_VAL                    AS forecast_val,
  b.SIGMA_EST                       AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                     AS sigma_recent,
  NULL::FLOAT8                     AS regr_slope_12,
  NULL::FLOAT8                     AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_JOIN_WRK lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.MAX_EOM                = b.FORECAST_PERIOD
WHERE b.IS_SYNTHETIC = 1
) final
ORDER BY 2, 3;





/* =========================================================
   0) Session knobs (optional but often helpful)
   ========================================================= */
-- SET ENABLE_COLUMNAR_OUTPUT TO TRUE;    -- harmless if not supported
-- SET ENABLE_PARAMETER_MARKERS TO FALSE; -- avoid plan issues in CTAS
-- You can also increase RESOURCE QUEUE if you have one for ETL

/* =========================================================
   1) Parameters / latest window
   ========================================================= */
CREATE TEMP TABLE latest AS
SELECT MAX(END_OF_MONTH_DATE) AS max_eom
FROM V_DPRT_CREDIT_INSTRUMENTS_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL;

CREATE TEMP TABLE rng AS
SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom
FROM latest;

/* =========================================================
   2) Synthetic systems lookup
   ========================================================= */
CREATE TEMP TABLE synthetic_list (CONTRACT_SOURCE_SYSTEM VARCHAR(200));
INSERT INTO synthetic_list (CONTRACT_SOURCE_SYSTEM) VALUES
 ('ACAR01-EXCPTN'),('HUBFSV-EXCPTN'),('INFL05-EXCPTN'),('INFL10-EXCPTN'),
 ('LNIQ01-EXCPTN'),('SBO001-EXCPTN'),('STKY01-EXCPTN'),('STRAT1-EXCPTN'),
 ('ALL'),('GL'),('LJ'),('SYN'),('FRDS_EXCPTN'),('ADJ');

/* =========================================================
   3) BASE monthly aggregation (CTAS)  << BIGGEST SPEEDUP
      - Distribute by system for window partitions later
   ========================================================= */
CREATE TEMP TABLE base_monthly
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
CROSS JOIN rng r
WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
  AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM;

GENERATE STATISTICS ON base_monthly;

/* Flag synthetic vs non-synthetic once and reuse */
CREATE TEMP TABLE sys_flags
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT DISTINCT
       b.CONTRACT_SOURCE_SYSTEM,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
FROM base_monthly b
LEFT JOIN synthetic_list s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM;

/* Latest month per system (temp) */
CREATE TEMP TABLE latest_per_sys
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM, MAX(b.END_OF_MONTH_DATE) AS max_eom
FROM base_monthly b
GROUP BY b.CONTRACT_SOURCE_SYSTEM;

/* =========================================================
   4) CALC (windows on compact monthly table) (CTAS)
      - row numbers, cumulative sums, rolling windows, regression
   ========================================================= */
CREATE TEMP TABLE calc
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
WITH idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base_monthly b
),
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,
    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y2,
    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x,
    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x2,
    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_xy,
    /* per-system overall stats */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y, c.csum_y2, c.csum_x, c.csum_x2, c.csum_xy,
    c.cnt_all, c.avg_all, c.avg2_all,
    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
)
SELECT
  r.END_OF_MONTH_DATE,
  r.CONTRACT_SOURCE_SYSTEM,
  r.SOURCE_SYSTEM_BALANCE,
  r.rn, r.rn_f,
  r.csum_y, r.csum_y2, r.csum_x, r.csum_x2, r.csum_xy,
  r.cnt_all, r.avg_all, r.avg2_all,
  r.n6, r.n12,
  r.sum6_y, r.sum6_y2, r.sum12_x, r.sum12_y, r.sum12_x2, r.sum12_xy,
  r.lag12_balance,
  /* rolling mean (6) */
  CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
  /* rolling sample std (6) */
  CASE
    WHEN r.n6 > 1 THEN
      SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
           / CAST(r.n6 - 1 AS FLOAT8) )
    ELSE NULL
  END AS roll_std_6,
  /* 12-row regression slope & intercept */
  CASE
    WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
      THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
           / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
    ELSE NULL
  END AS regr_slope_12,
  CASE
    WHEN r.n12 >= 1 THEN
      ( r.sum12_y
        - ( COALESCE(
              CASE
                WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                  THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                       / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                ELSE NULL
              END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
    ELSE NULL
  END AS regr_intercept_12
FROM roll r
;

GENERATE STATISTICS ON calc;

/* =========================================================
   5) Backtest panel (t-1 -> t) (CTAS)
   ========================================================= */
CREATE TEMP TABLE backtest_12m
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  p.CONTRACT_SOURCE_SYSTEM,
  p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t-1 */
  c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
  c.SOURCE_SYSTEM_BALANCE                               AS actual,
  /* forecast chooser: 12M linear -> lag12 -> 6M mean */
  COALESCE(
    CASE
      WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
        THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
      ELSE NULL
    END,
    p.lag12_balance,
    p.roll_mean_6
  )                                                     AS forecast_val,
  /* sigma estimate */
  COALESCE(
    p.roll_std_6,
    CASE WHEN p.cnt_all > 1
         THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                    * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
         ELSE NULL
    END
  )                                                     AS sigma_est,
  p.avg_all                                             AS avg_level_sys
FROM calc p
JOIN calc c
  ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
 AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
  AND p.END_OF_MONTH_DATE <  l.max_eom
;

GENERATE STATISTICS ON backtest_12m;

/* Split/join flags for final SELECTs (CTAS) */
CREATE TEMP TABLE backtest_split
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM,
       b.model_asof_period,
       b.forecast_period,
       b.actual,
       b.forecast_val,
       b.sigma_est,
       b.avg_level_sys,
       f.is_synthetic
FROM backtest_12m b
JOIN sys_flags f
  ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM;

CREATE TEMP TABLE calc_split
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT c.CONTRACT_SOURCE_SYSTEM,
       c.END_OF_MONTH_DATE,
       c.SOURCE_SYSTEM_BALANCE,
       c.roll_std_6,
       c.regr_slope_12,
       c.lag12_balance,
       f.is_synthetic
FROM calc c
JOIN sys_flags f
  ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM;

CREATE TEMP TABLE latest_join
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
FROM latest_per_sys l;

/* =========================================================
   6) FINAL OUTPUT (same unified 16 columns)
   ========================================================= */
-- You can SELECT * FROM ( ... ) AS final ORDER BY 2,3; if your tool needs one statement

(
/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12            AS regr_slope_12,
  c.lag12_balance            AS lag12_balance
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12            AS regr_slope_12,
  c.lag12_balance            AS lag12_balance
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period               AS period_date,
  b.actual                        AS actual,
  b.forecast_val                  AS forecast_val,
  b.sigma_est                     AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                   AS sigma_recent,
  NULL::FLOAT8                   AS regr_slope_12,
  NULL::FLOAT8                   AS lag12_balance
FROM backtest_12m b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.forecast_period < l.max_eom
  AND b.CONTRACT_SOURCE_SYSTEM NOT IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual                         AS actual,
  b.forecast_val                   AS forecast_val,
  b.sigma_est                      AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM backtest_12m b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.forecast_period < l.max_eom
  AND b.CONTRACT_SOURCE_SYSTEM IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual                         AS actual,
  b.forecast_val                   AS forecast_val,
  b.sigma_est                      AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM backtest_12m b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.CONTRACT_SOURCE_SYSTEM NOT IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual                          AS actual,
  b.forecast_val                    AS forecast_val,
  b.sigma_est                       AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                     AS sigma_recent,
  NULL::FLOAT8                     AS regr_slope_12,
  NULL::FLOAT8                     AS lag12_balance
FROM backtest_12m b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.CONTRACT_SOURCE_SYSTEM IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)
)
ORDER BY 2, 3;

/* =========================================================
   7) (Optional) Clean-up
   ========================================================= */
-- DROP TABLE IF EXISTS latest;
-- DROP TABLE IF EXISTS rng;
-- DROP TABLE IF EXISTS synthetic_list;
-- DROP TABLE IF EXISTS base_monthly;
-- DROP TABLE IF EXISTS sys_flags;
-- DROP TABLE IF EXISTS latest_per_sys;
-- DROP TABLE IF EXISTS calc;
-- DROP TABLE IF EXISTS backtest_12m;
-- DROP TABLE IF EXISTS backtest_split;
-- DROP TABLE IF EXISTS calc_split;
-- DROP TABLE IF EXISTS latest_join;





/* ================== PARAMETERS ================== */
/* Synthetic systems list (replace with ref table if you have one) */
WITH synthetic_list AS (
  SELECT 'ACAR01-EXCPTN'::VARCHAR(200) AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'HUBFSV-EXCPTN' UNION ALL
  SELECT 'INFL05-EXCPTN' UNION ALL
  SELECT 'INFL10-EXCPTN' UNION ALL
  SELECT 'LNIQ01-EXCPTN' UNION ALL
  SELECT 'SBO001-EXCPTN' UNION ALL
  SELECT 'STKY01-EXCPTN' UNION ALL
  SELECT 'STRAT1-EXCPTN' UNION ALL
  SELECT 'ALL'          UNION ALL
  SELECT 'GL'           UNION ALL
  SELECT 'LJ'           UNION ALL
  SELECT 'SYN'          UNION ALL
  SELECT 'FRDS_EXCPTN'  UNION ALL
  SELECT 'ADJ'
),

/* Latest close + 30-month window */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ========== 1) Monthly system totals (Total Loans) ========== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* Synthetic flag per system */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ========== 2) Row index per system ========== */
idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ========== 3) Float index (materialized) ========== */
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ========== 4) Cumulative sums (windows only) ========== */
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,

    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    /* per-system overall stats (for fallback sigma) */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ========== 5) Rolling windows from cumulative sums + lag12 ========== */
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y,
    c.csum_y2,
    c.csum_x,
    c.csum_x2,
    c.csum_xy,
    c.cnt_all,
    c.avg_all,
    c.avg2_all,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    /* 6-row rolling sums */
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    /* 12-row rolling sums (for regression) */
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    /* simple seasonal anchor */
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ========== 6) Per-row stats (no window here) ========== */
calc AS (
  SELECT
    r.END_OF_MONTH_DATE,
    r.CONTRACT_SOURCE_SYSTEM,
    r.SOURCE_SYSTEM_BALANCE,
    r.rn,
    r.rn_f,
    r.csum_y,
    r.csum_y2,
    r.csum_x,
    r.csum_x2,
    r.csum_xy,
    r.cnt_all,
    r.avg_all,
    r.avg2_all,
    r.n6,
    r.n12,
    r.sum6_y,
    r.sum6_y2,
    r.sum12_x,
    r.sum12_y,
    r.sum12_x2,
    r.sum12_xy,
    r.lag12_balance,

    /* rolling mean (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    /* rolling sample std (6) */
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-row regression slope & intercept */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ========== 7) Latest month per system ========== */
latest_per_sys AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM, MAX(c.END_OF_MONTH_DATE) AS max_eom
  FROM calc c
  GROUP BY c.CONTRACT_SOURCE_SYSTEM
),

/* ========== 8) 12-month rolling BACKTEST panel (t−1 → t) ========== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t−1 */
    c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    /* forecast from the t−1 row's params (linear → lag12 → mean) */
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    /* sigma from t−1 (rolling std → fallback long-run σ) */
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   /* last ~12 model origins */
    AND p.END_OF_MONTH_DATE <  l.max_eom                    /* up to month before latest */
),

/* Split backtest + calc with synthetic flag */
backtest_split AS (
  SELECT b.CONTRACT_SOURCE_SYSTEM,
         b.model_asof_period,
         b.forecast_period,
         b.actual,
         b.forecast_val,
         b.sigma_est,
         b.avg_level_sys,
         f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM,
         c.END_OF_MONTH_DATE,
         c.SOURCE_SYSTEM_BALANCE,
         c.roll_std_6,
         c.regr_slope_12,
         c.lag12_balance,
         f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* Helper for latest-month filter */
latest_join AS (
  SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
  FROM latest_per_sys l
)

/* ===================== FINAL OUTPUTS ===================== */

/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                        AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                        AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period               AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.is_synthetic = 0
  AND b.forecast_period < l.max_eom

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.is_synthetic = 1
  AND b.forecast_period < l.max_eom

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 0

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 1

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






ACAR01-EXCPTN
HUBFSV-EXCPTN
INFL05-EXCPTN
INFL10-EXCPTN
LNIQ01-EXCPTN
SBO001-EXCPTN
STKY01-EXCPTN
STRAT1-EXCPTN
ALL
GL
LJ
SYN
FRDS_EXCPTN
ADJ
SYN





/* ================== PARAMETERS ================== */
/* Maintain list of synthetic systems here (or replace with a SELECT from a reference table) */
WITH synthetic_list AS (
  SELECT 'SYS_SYNTH1'::VARCHAR(200) AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'SYS_SYNTH2'::VARCHAR(200) UNION ALL
  SELECT 'SYS_SYNTH3'::VARCHAR(200)
),

/* Latest close + 30-month window */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ========== 1) system × month (Total Loans) ========== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* Tag systems as synthetic/non-synthetic */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ========== 2) row index per system ========== */
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ========== 3) float index (materialized) ========== */
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ========== 4) cumulative sums (windows only) ========== */
csum AS (
  SELECT
    x.*,

    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    /* per-system overall stats (for fallback sigma) */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ========== 5) rolling windows from cumulative sums + lag12 ========== */
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    /* 6-row rolling sums */
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    /* 12-row rolling sums (for regression) */
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    /* simple seasonal anchor */
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ========== 6) per-row stats (no window here) ========== */
calc AS (
  SELECT
    r.*,

    /* rolling mean (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    /* rolling sample std (6) */
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-row regression slope & intercept */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ========== 7) latest month per system ========== */
latest_per_sys AS (
  SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* ========== 8) 12-month rolling BACKTEST panel (t−1 → t) ========== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t−1 */
    c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    /* forecast from the t−1 row's params (linear → lag12 → mean) */
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    /* sigma from t−1 (rolling std → fallback long-run σ) */
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   /* last ~12 model origins */
    AND p.END_OF_MONTH_DATE <  l.max_eom                    /* up to month before latest */
),

/* Split backtest into main vs synthetic; also tag calc rows for HISTORY_LITE */
backtest_split AS (
  SELECT b.*, f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.*, f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* Helper for latest-month filtering */
latest_join AS (
  SELECT ls.CONTRACT_SOURCE_SYSTEM, ls.max_eom
  FROM latest_per_sys ls
)

/* ===================== FINAL OUTPUTS ===================== */

/* A) HISTORY_LITE (latest-only diagnostics) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'    AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE    AS period_date,
  c.SOURCE_SYSTEM_BALANCE AS actual,
  c.roll_std_6           AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS sigma_est,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                    AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only diagnostics) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'   AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE    AS period_date,
  c.SOURCE_SYSTEM_BALANCE AS actual,
  c.roll_std_6           AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS sigma_est,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                    AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period                  AS period_date,
  actual,
  forecast_val,
  sigma_est,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = backtest_split.CONTRACT_SOURCE_SYSTEM
WHERE is_synthetic = 0
  AND forecast_period < l.max_eom

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period                   AS period_date,
  actual,
  forecast_val,
  sigma_est,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = backtest_split.CONTRACT_SOURCE_SYSTEM
WHERE is_synthetic = 1
  AND forecast_period < l.max_eom

UNION ALL

/* E) Latest close anomaly detection (t = latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 0

UNION ALL

/* F) Latest close anomaly detection (t = latest) — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 1

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month (Total Loans), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) float index (materialized)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows via (csum - lag(csum)); plus lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums (mean/std source)
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums (regression source)
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (no window here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - (sum y)^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7) latest month per system
latest_per_sys AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

-- 8) 12-month rolling BACKTEST panel:
--    for each system, take each month t-1 in the last up to 12 months,
#NAME?
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                   AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    -- forecast from the t-1 row's params
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    -- sigma estimated from t-1 window
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   -- last ~12 months of backtests
    AND p.END_OF_MONTH_DATE <  l.max_eom                    -- up to the month before latest
),

-- 9) latest row for forward forecast (optional)
last_latest AS (
  SELECT c.*
  FROM calc c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),

summary_next_fwd AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                 AS forecast_val,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                 AS sigma_est,

    l.avg_all                                         AS avg_level_sys
  FROM last_latest l
)

-- ===== FINAL OUTPUTS =====

-- A) Full HISTORY
SELECT
  'HISTORY'              AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE      AS period_date,
  SOURCE_SYSTEM_BALANCE  AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM calc

UNION ALL

-- B) Rolling 12-month BACKTEST panel (t-1 → t with actual)
SELECT
  'SUMMARY_BACKTEST_12M' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period         AS period_date,            -- month t
  actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m

UNION ALL

-- C) Forward forecast (latest → next month) — optional
SELECT
  'SUMMARY_NEXT_FWD'     AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period        AS period_date,            -- next month
  NULL::FLOAT8           AS actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM summary_next_fwd

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;








1. Executive Overview (for documentation)

Purpose:
This analysis detects unusual month-over-month changes in SOURCE_SYSTEM_BALANCE by CONTRACT_SOURCE_SYSTEM (system-level balances), using rolling statistics, regression trends, and seasonality adjustments.

Key Outputs:

	•	HISTORY: De-seasonalized series with rolling mean, rolling std, and regression parameters
	•	SUMMARY_BACKTEST_12M_SA: 12-month backtest comparing forecast vs. actual, with z-scores and severity ranking
	•	SUMMARY_NEXT_FWD_SA: Forward forecast for next month, with prediction intervals

How to Use:

	•	Analysts review SUMMARY_BACKTEST_12M_SA to investigate high-severity anomalies (sorted descending).
	•	Executives view the Power BI dashboard to understand portfolio stability, key drivers, and focus areas.







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* 1) Base monthly sums per system (Total Loans) */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* 🚫 Fix correlated subquery: precompute avg level once */
sys_level_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM,
         AVG(SOURCE_SYSTEM_BALANCE) AS avg_level_sys
  FROM base
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* 2) Row index per system */
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* 3) Month-of-year seasonal indices (normalized to avg=1) */
base_moy AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    EXTRACT(MONTH FROM b.END_OF_MONTH_DATE) AS moy,
    b.SOURCE_SYSTEM_BALANCE
  FROM base b
),
sys_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM, AVG(SOURCE_SYSTEM_BALANCE) AS avg_all_sys
  FROM base_moy
  GROUP BY CONTRACT_SOURCE_SYSTEM
),
season_raw AS (
  SELECT
    m.CONTRACT_SOURCE_SYSTEM,
    m.moy,
    AVG(m.SOURCE_SYSTEM_BALANCE) / a.avg_all_sys AS factor_raw
  FROM base_moy m
  JOIN sys_avg a
    ON a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
  GROUP BY m.CONTRACT_SOURCE_SYSTEM, m.moy, a.avg_all_sys
),
season_norm AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.moy,
    s.factor_raw / NULLIF(AVG(s.factor_raw) OVER (PARTITION BY s.CONTRACT_SOURCE_SYSTEM), 0.0) AS season_factor
  FROM season_raw s
),

/* 4) Join factors; de-seasonalize; materialize float index */
base_d AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f,
    EXTRACT(MONTH FROM i.END_OF_MONTH_DATE) AS moy,
    i.SOURCE_SYSTEM_BALANCE,
    COALESCE(f.season_factor, 1.0) AS season_factor,
    CAST(i.SOURCE_SYSTEM_BALANCE / NULLIF(f.season_factor, 0.0) AS FLOAT8) AS y_d
  FROM idx1 i
  LEFT JOIN season_norm f
    ON f.CONTRACT_SOURCE_SYSTEM = i.CONTRACT_SOURCE_SYSTEM
   AND f.moy = EXTRACT(MONTH FROM i.END_OF_MONTH_DATE)
),

/* 5) Cumulative sums on de-seasonalized series */
csum_d AS (
  SELECT
    b.*,
    SUM(b.y_d)  OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y_d,
    SUM(CAST(b.y_d * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y2_d,
    SUM(b.rn_f) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x_d,
    SUM(CAST(b.rn_f * b.rn_f AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x2_d,
    SUM(CAST(b.rn_f * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_xy_d
  FROM base_d b
),

/* 6) Rolling windows via (csum - lag(csum)) */
roll_d AS (
  SELECT
    c.*,
    LEAST(c.rn, 6)  AS n6_d,
    LEAST(c.rn, 12) AS n12_d,

    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y_d,
    (c.csum_y2_d - COALESCE(LAG(c.csum_y2_d, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2_d,

    (c.csum_x_d  - COALESCE(LAG(c.csum_x_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x_d,
    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y_d,
    (c.csum_x2_d - COALESCE(LAG(c.csum_x2_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2_d,
    (c.csum_xy_d - COALESCE(LAG(c.csum_xy_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy_d
  FROM csum_d c
),

/* 7) Per-row stats on de-seasonalized series */
calc_d AS (
  SELECT
    r.*,

    CASE WHEN r.n6_d > 0 THEN r.sum6_y_d / CAST(r.n6_d AS FLOAT8) ELSE NULL END AS roll_mean_6_d,

    CASE
      WHEN r.n6_d > 1 THEN
        SQRT( GREATEST( (r.sum6_y2_d - ( (r.sum6_y_d * r.sum6_y_d) / CAST(r.n6_d AS FLOAT8) )), 0.0 )
              / CAST(r.n6_d - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6_d,

    CASE
      WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
        THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
             / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
      ELSE NULL
    E