import pandas as pd

d = df.copy()
latest = d["month_end"].max()
top = (
    d[d["month_end"]==latest]
    .sort_values("severity_0_100", ascending=False)
    .loc[:, ["rc_code","rc_description","month_end","severity_0_100","outside_pi",
             "persistent_outlier_3of6","reason_code","z_resid","z_mom_abs","mom_abs"]]
    .head(25)
    .reset_index(drop=True)
)
top



import pandas as pd
import numpy as np

g = df.groupby("rc_code", as_index=False)

def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce"); b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3: return np.nan
    return m["a"].corr(m["b"])

diag = g.apply(lambda x: pd.Series({
    "corr_resid_momabs": _corr(x["absresid"], x["mom_abs"]) if "absresid" in x and "mom_abs" in x else np.nan,
    "corr_resid_mompct": _corr(x["absresid"], x["mom_pct_abs"]) if "mom_pct_abs" in x else np.nan
})).reset_index(drop=True)

# Drift signal: 3-mo MSE / prior 9-mo MSE
df_sorted = df.sort_values(["rc_code","month_end"]).copy()
df_sorted["se"] = (df_sorted["actual"] - df_sorted["forecast_selected"])**2
df_sorted["mse_curr3"] = df_sorted.groupby("rc_code")["se"].rolling(3, min_periods=2).mean().reset_index(level=0, drop=True)
df_sorted["mse_prev9"] = df_sorted.groupby("rc_code")["se"].rolling(12, min_periods=10).mean().reset_index(level=0, drop=True).shift(3)
drift = (df_sorted
         .assign(break_ratio=lambda x: np.where((x["mse_prev9"]>0)&np.isfinite(x["mse_prev9"]),
                                                x["mse_curr3"]/x["mse_prev9"], np.nan))
         .groupby("rc_code", as_index=False)
         .apply(lambda x: x.loc[x["month_end"].idxmax(), ["rc_code","break_ratio"]])
         .droplevel(0)
)
diag = diag.merge(drift, on="rc_code", how="left")
diag




import pandas as pd
import numpy as np

# If you created RC_Anom_Clean, read that; otherwise reuse df from above cell
try:
    df2 = xl("RC_Anom_Clean").copy()
    df2.columns = [str(c).strip().lower().replace(" ","_") for c in df2.columns]
    df2["month_end"] = pd.to_datetime(df2["month_end"], errors="coerce")
    df2["severity_0_100"] = pd.to_numeric(df2["severity_0_100"], errors="coerce")
    df2["outside_pi"] = df2["outside_pi"].astype(bool)
except:
    df2 = df.copy()

thresholds = list(range(55, 91, 5))  # 55,60,...,90
rows = []
for thr in thresholds:
    pred = df2["severity_0_100"] >= thr
    tp = int((pred & df2["outside_pi"]).sum())
    fp = int((pred & ~df2["outside_pi"]).sum())
    fn = int((~pred & df2["outside_pi"]).sum())
    alerts = int(pred.sum())
    prec = tp / (tp + fp) if (tp+fp) else np.nan
    rec  = tp / (tp + fn) if (tp+fn) else np.nan
    rows.append((thr, alerts, tp, fp, fn, prec, rec))

cal = pd.DataFrame(rows, columns=["threshold","alerts","true_pos","false_pos","false_neg","precision","recall"])

# Add avg alerts per latest month (how noisy will it be?)
latest = df2["month_end"].max()
latest_alerts = df2.loc[df2["month_end"]==latest, ["rc_code","severity_0_100"]]
cal["alerts_latest"] = cal["threshold"].map(lambda t: int((latest_alerts["severity_0_100"]>=t).sum()))

cal




import pandas as pd
import numpy as np

# Read the whole table (headers + data), then promote first row as headers
raw = xl("RC_Anomaly_all").copy()
hdr = raw.iloc[0].astype(str).tolist()
df  = raw.iloc[1:].copy()
df.columns = [h.strip().lower().replace(" ","_") for h in hdr]

# Types
num_cols = ["actual","forecast_selected","pi_lo","pi_hi","severity_0_100","absresid","mom_abs","z_resid","z_mom_abs"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")
df["month_end"] = pd.to_datetime(df["month_end"], errors="coerce")

# Helpful boolean: outside prediction interval
df["outside_pi"] = (df["actual"] < df["pi_lo"]) | (df["actual"] > df["pi_hi"])

# (Optional) persist back to Excel visually
df






/* Clean up temp tables */
IF OBJECT_ID('tempdb..#FLUX')   IS NOT NULL DROP TABLE #FLUX;
IF OBJECT_ID('tempdb..#CARDS')  IS NOT NULL DROP TABLE #CARDS;

/* Params */
DECLARE @system NVARCHAR(150);
DECLARE @current_period DATETIME = '2025-08-31';
DECLARE @prior_period   DATETIME = '2025-07-31';

/* Cards for system tagging */
SELECT DISTINCT LOADDT, CUST_LINE_NBR
INTO #CARDS
FROM CRDADMPRD.CRDADMPRD.dbo.CDM_CARDS_LOAN
WHERE CAST(LOADDT AS DATE) IN (@current_period, @prior_period);

/* === Latest row per table, per date & credit line === */
WITH CLM AS (
    SELECT
        CAST(a.LoadDate AS DATE) AS LoadDate,
        a.CreditLineNumber,
        a.NetUtilized,
        a.ApplID,
        a.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(a.LoadDate AS DATE), a.CreditLineNumber
            ORDER BY a.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    WHERE CAST(a.LoadDate AS DATE) IN (@current_period, @prior_period)
),
CLM_Latest AS (
    SELECT * FROM CLM WHERE rn = 1
),
UF AS (
    SELECT
        CAST(b.LoadDate AS DATE) AS LoadDate,
        b.CreditLineNumber,
        b.SecUnfunded,
        b.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(b.LoadDate AS DATE), b.CreditLineNumber
            ORDER BY b.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
    WHERE CAST(b.LoadDate AS DATE) IN (@current_period, @prior_period)
),
UF_Latest AS (
    SELECT * FROM UF WHERE rn = 1
)

/* Build flux set (one row per date & credit line) */
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    (c.NetUtilized + COALESCE(u.SecUnfunded, 0)) AS commitment,
    c.NetUtilized,
    COALESCE(u.SecUnfunded, 0) AS SecUnfunded,
    c.ApplID,
    @system AS [system]
INTO #FLUX
FROM CLM_Latest c
LEFT JOIN UF_Latest u
  ON u.LoadDate = c.LoadDate
 AND u.CreditLineNumber = c.CreditLineNumber;

/* System tagging (date-scoped) */
UPDATE f
SET    [system] = 'Cards'
FROM   #FLUX f
JOIN   #CARDS c
  ON   c.CUST_LINE_NBR = f.CreditLineNumber
 AND   CAST(c.LOADDT AS DATE) = f.LoadDate
WHERE  f.[system] IS NULL;

UPDATE #FLUX SET [system] = 'CFD'            WHERE ApplID IN ('CF')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Lines'    WHERE ApplID IN ('ML')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Mortgage' WHERE ApplID IN ('MO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'iMX'            WHERE CreditLineNumber LIKE '%iMX%' AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'CBS'            WHERE ApplID IN ('LN')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'UBS'            WHERE ApplID IN ('LO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'LJ'             WHERE ApplID IN ('LJ')         AND [system] IS NULL;

/* Results */
SELECT *
FROM #FLUX;




/* ================= RC_Code Anomaly Detection â€” PBI-safe (no views, no POWER) ================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages (then restrict) */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 5 PRECEDING AND CURRENT ROW)::FLOAT8  AS fc_ma6,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means/SST per window */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics */
metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM (SELECT DISTINCT RC_CODE FROM idx_tm) x
  LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
  LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) In-sample best model (fallback) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality (unchanged from your logic) */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT RC_CODE, AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT RC_CODE, qnum,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
         SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT RC_CODE,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE, q.qnum,
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE q.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q q
  LEFT JOIN seasonal_all a ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE, l.qnum,
    CASE WHEN l.lift_raw IS NULL THEN 1.0
         WHEN l.lift_raw < 0.85 THEN 0.85
         WHEN l.lift_raw > 1.15 THEN 1.15
         ELSE l.lift_raw END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE, f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0))::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36', fc_reg36
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6',   fc_ma6
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12',  fc_ma12
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Attach prev_bal and pos3_count */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residual/MoM stats per (RC,Model) */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,
    CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for PI */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) OOS MSE (last 3 months) */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
/* Pivot OOS to columns to avoid correlated subqueries */
oos_pivot AS (
  SELECT
    RC_CODE,
    MAX(CASE WHEN model='REG12' THEN mse_oos END) AS mse_reg12,
    MAX(CASE WHEN model='REG36' THEN mse_oos END) AS mse_reg36,
    MAX(CASE WHEN model='MA6'   THEN mse_oos END) AS mse_ma6,
    MAX(CASE WHEN model='MA12'  THEN mse_oos END) AS mse_ma12
  FROM oos
  GROUP BY RC_CODE
),
best_model_oos AS (
  SELECT
    m.RC_CODE,
    CASE
      /* prefer regressions only if their R2 gate passes */
      WHEN m.r2_reg12 >= 0.5 AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_reg36,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG12'
      WHEN m.r2_reg36 >= 0.5 AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG36'
      /* otherwise choose the better moving average */
      WHEN COALESCE(o.mse_ma6,9e99) <= COALESCE(o.mse_ma12,9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_OOS
  FROM metrics m
  LEFT JOIN oos_pivot o ON o.RC_CODE = m.RC_CODE
),

/* 18) Final model: OOS if present else in-sample */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows with PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    CASE WHEN z.prev_bal IS NULL THEN NULL ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid, z.Z_MoM_Abs, z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 via rank (no percentile func) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT RC_CODE, AbsResid,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT RC_CODE, MoM_Abs,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                    AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity (robust scaling) */
sev AS (
  SELECT
    f.*,
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - CASE WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0 ELSE s.Severity_Raw END )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier (3 of last 6 months, threshold 70) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code without GREATEST */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= CASE
                               WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0)) THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
                               ELSE ABS(COALESCE(p.MoM_Abs,0.0))
                             END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






/* ======================== RC_Code Anomaly Detection (Enhanced, single query) =========================
   - Models: REG12, REG36, MA6, MA12 with best model chosen by out-of-sample (last 3 months) RMSE,
             falling back to your original in-sample rule if needed.
   - Seasonality: Quarterly lifts from non-spike months, capped & shrunken, damped if recent spikes.
   - Residual / MoM metrics & Z-scores (per RC, per chosen model window).
   - Prediction Intervals: Â±1.96 * RMSE (per-RC, per-model).
   - Severity: uses per-RC P95 scale for AbsResid and MoM_Abs (no POWER; no percentile functions).
               P95 is computed via rank logic: the first value at or above 95th percentile.
   - Flags: Persistent outlier (3 of last 6) and Reason_Code for explainability.
   - No views; no POWER().
   ================================================================================================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (arithmetic only) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Original best-model rule (fallback if OOS cannot be computed) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT
    RC_CODE,
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT
    RC_CODE,
    qnum,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT
    RC_CODE,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE,
    q.qnum,
    CASE
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
      ELSE q.avg_q_nospike / a.avg_all_nospike
    END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q   q
  LEFT JOIN seasonal_all a
    ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts by model (limit rows to each model's window) */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift to forecast */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Add prev_bal & "active last 3 months" flag */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for prediction intervals */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) Out-of-sample (last 3 months of each model) selection */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
best_model_oos AS (
  /* Pick lowest OOS MSE, with R2 â‰¥ 0.5 gates for regressions; else fall back to MA6/MA12 */
  SELECT d.RC_CODE,
         CASE
           WHEN (SELECT r2_reg12 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o1.mse_oos,9e99) FROM oos o1 WHERE o1.RC_CODE=d.RC_CODE AND o1.model='REG12')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='REG36'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG12'

           WHEN (SELECT r2_reg36 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o2.mse_oos,9e99) FROM oos o2 WHERE o2.RC_CODE=d.RC_CODE AND o2.model='REG36')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG36'

           WHEN COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99)
                <= COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
           THEN 'MA6'
           ELSE 'MA12'
         END AS Best_Model_OOS
  FROM (SELECT DISTINCT RC_CODE FROM union_with_z) d
),

/* 18) Choose final best model: OOS if available else in-sample rule */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows for chosen model; attach RMSE and PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    /* MoM absolute & percent (already abs for pct) */
    CASE WHEN z.prev_bal IS NULL THEN NULL
         ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    /* 95% prediction interval (no POWER) */
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 scales for AbsResid and MoM_Abs (computed via rank, no percentile fn) */
p95_abs AS (
  SELECT RC_CODE,
         MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid)                      AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                         AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE,
         MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs)                        AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                          AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity using robust (per-RC) P95 scales */
sev AS (
  SELECT
    f.*,
    /* robust components: guard denominators with NULLIF */
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  /* Exponential squash to 0..100; no POWER used */
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - GREATEST(0.0, COALESCE(s.Severity_Raw,0.0)) )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier: 3 of last 6 months (threshold 70, adjust as needed) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code (simple dominance logic) */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= GREATEST(ABS(COALESCE(p.Z_MoM_Abs,0.0)), ABS(COALESCE(p.MoM_Abs,0.0))) THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






--QUERY 1										
/* ======================== RC_Code Anomaly Detection =========================										
   - Runs Seasonally Adjusted Regression (12mo, 36mo) and Moving Average (6mo, 12mo), selecting model w/ best fit										
   - Assigns severity score based on various Z-Scores and materiality										
   ============================================================================ */										
WITH										
/* 0) Base */										
base AS (										
  SELECT										
    RC_CODE,										
    RC_DESCRIPTION,										
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,										
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num										
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB										
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL										
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'										
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)										
),										
										
/* 1) Index and tmax; also prev_bal and Month/Quarter tags */										
idx AS (										
  SELECT										
    b.*,										
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t										
  FROM base b										
),										
idx_tm AS (										
  SELECT										
    i.*,										
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,										
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,										
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,										
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum										
  FROM idx i										
),										
										
/* 2) Evaluation windows */										
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),										
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),										
										
/* 3) Regression params (grouped) */										
reg12_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n12,										
    SUM(t)::FLOAT8           AS sumx12,										
    SUM(bal_num)::FLOAT8     AS sumy12,										
    SUM(t*bal_num)::FLOAT8   AS sumxy12,										
    SUM(t*t)::FLOAT8         AS sumx2_12										
  FROM last12										
  GROUP BY RC_CODE										
),										
reg36_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n36,										
    SUM(t)::FLOAT8           AS sumx36,										
    SUM(bal_num)::FLOAT8     AS sumy36,										
    SUM(t*bal_num)::FLOAT8   AS sumxy36,										
    SUM(t*t)::FLOAT8         AS sumx2_36										
  FROM last36										
  GROUP BY RC_CODE										
),										
										
/* 4) Regression fits over their windows */										
reg12_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0										
      THEN										
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t										
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg12										
  FROM last12 l										
  JOIN reg12_params p USING (RC_CODE)										
),										
reg36_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0										
      THEN										
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t										
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg36										
  FROM last36 l										
  JOIN reg36_params p USING (RC_CODE)										
),										
										
/* 5) Moving averages once, then restrict to windows */										
ma_all AS (										
  SELECT										
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma6,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma12										
  FROM idx_tm i										
),										
ma6_last12 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6										
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma6 IS NOT NULL										
),										
ma12_last36 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12										
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma12 IS NOT NULL										
),										
										
/* 6) Means and SST per window (grouped) */										
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),										
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),										
										
sst12 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12										
  FROM last12 l JOIN mean12 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
sst36 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36										
  FROM last36 l JOIN mean36 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
										
/* 7) SSE + counts per model/window (grouped) */										
agg_reg12 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,										
         COUNT(*) AS n_reg12										
  FROM reg12_fit f										
  WHERE f.fc_reg12 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_reg36 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,										
         COUNT(*) AS n_reg36										
  FROM reg36_fit f										
  WHERE f.fc_reg36 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_ma6_12 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,										
         COUNT(*) AS n_ma6										
  FROM ma6_last12 m										
  GROUP BY m.RC_CODE										
),										
agg_ma12_36 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,										
         COUNT(*) AS n_ma12										
  FROM ma12_last36 m										
  GROUP BY m.RC_CODE										
),										
										
/* 8) Metrics (arithmetic only) */										
metrics AS (										
  SELECT										
    x.RC_CODE,										
										
    s12.sst12,  s36.sst36,										
    ar12.sse_reg12, ar12.n_reg12,										
    ar36.sse_reg36, ar36.n_reg36,										
    am6.sse_ma6,    am6.n_ma6,										
    am12.sse_ma12,  am12.n_ma12,										
										
    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,										
										
    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,										
										
    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,										
										
    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12										
  FROM										
    (SELECT DISTINCT RC_CODE FROM idx_tm) x										
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE										
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE										
),										
										
/* 9) Best model pick (no aggregates) */										
best_model AS (										
  SELECT										
    m.RC_CODE,										
    CASE										
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG12'										
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG36'										
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'										
      ELSE 'MA12'										
    END AS Best_Model										
  FROM metrics m										
),										
										
/* 10) --- Robust seasonality: compute spike-aware quarterly lifts --- */										
										
/* 10a) Build MoM (on full series) and spike flags per RC */										
mom_base AS (										
  SELECT										
    t.*,										
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,										
    CASE										
      WHEN t.prev_bal IS NULL THEN NULL										
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0										
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)										
    END::FLOAT8 AS mom_pct										
  FROM idx_tm t										
),										
mom_stats AS (										
  SELECT										
    RC_CODE,										
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs										
  FROM mom_base										
  GROUP BY RC_CODE										
),										
mom_flag AS (										
  /* spike = big percentage change OR big absolute jump relative to typical */										
  SELECT										
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,										
    CASE										
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1										
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1										
      ELSE 0										
    END AS is_spike										
  FROM mom_base b										
  LEFT JOIN mom_stats s USING (RC_CODE)										
),										
/* 10b) recent spike signal (last 6 months relative to series max month) */										
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),										
recent_spike AS (										
  SELECT f.RC_CODE,										
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike										
  FROM mom_flag f										
  JOIN max_me m USING (RC_CODE)										
  GROUP BY f.RC_CODE										
),										
										
/* 10c) Seasonal lifts per RCÃ—Quarter using NON-spike months (revised) */										
seasonal_q AS (										
  SELECT										
    RC_CODE,										
    qnum,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,										
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q										
  FROM mom_flag										
  GROUP BY RC_CODE, qnum										
),										
seasonal_all AS (										
  SELECT										
    RC_CODE,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike										
  FROM mom_flag										
  GROUP BY RC_CODE										
),										
seasonal_lifts AS (										
  SELECT										
    q.RC_CODE,										
    q.qnum,										
    /* raw lift */										
    CASE										
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0										
      ELSE q.avg_q_nospike / a.avg_all_nospike										
    END::FLOAT8 AS lift_raw,										
    q.n_q										
  FROM seasonal_q   q										
  LEFT JOIN seasonal_all a										
    ON a.RC_CODE = q.RC_CODE										
),										
										
/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes (unchanged) */										
seasonal_final AS (										
  SELECT										
    l.RC_CODE,										
    l.qnum,										
    /* cap to [0.85, 1.15] */										
    CASE										
      WHEN l.lift_raw IS NULL THEN 1.0										
      WHEN l.lift_raw < 0.85 THEN 0.85										
      WHEN l.lift_raw > 1.15 THEN 1.15										
      ELSE l.lift_raw										
    END::FLOAT8 AS lift_capped,										
    /* history-based shrink 0..1 (min points to fully trust â‰ˆ 8) */										
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight										
  FROM seasonal_lifts l										
),										
seasonal_ready AS (										
  SELECT										
    f.RC_CODE,										
    f.qnum,										
    /* extra damp if recent spikes: halve the effect */										
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)										
          * f.hist_weight * (f.lift_capped - 1.0)										
    )::FLOAT8 AS lift_final										
  FROM seasonal_final f										
  LEFT JOIN recent_spike r USING (RC_CODE)										
),										
/* 11) Union forecasts by model (limit rows to each model's window) */										
fits_union AS (										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast										
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast										
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast										
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast										
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL										
),										
										
/* 12) Apply seasonal lift to forecast */										
fits_seasonal AS (										
  SELECT										
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,										
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj										
  FROM fits_union u										
  LEFT JOIN seasonal_ready s										
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum										
),										
										
/* 13) Add prev_bal & "active last 3 months" flag */										
union_with_prev AS (										
  SELECT										
    f.*,										
    t.prev_bal,										
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)										
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count										
  FROM fits_seasonal f										
  JOIN idx_tm t										
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end										
),										
										
/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */										
union_enriched AS (										
  SELECT										
    x.*,										
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,										
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,										
										
    CASE WHEN x.prev_bal IS NULL THEN NULL										
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,										
										
    CASE										
      WHEN x.prev_bal IS NULL THEN NULL										
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
    END::FLOAT8 AS mom_pct_abs,										
										
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,										
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,										
										
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,										
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,										
										
    AVG(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,										
    STDDEV_SAMP(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct										
  FROM union_with_prev x										
),										
										
/* 15) Z-scores */										
union_with_z AS (										
  SELECT										
    e.*,										
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0										
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,										
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0										
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,										
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0										
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct										
  FROM union_enriched e										
),										
										
/* 16) Portfolio-wide scales for severity */										
port_scales AS (										
  SELECT										
    MAX(abs_resid) AS max_abs_resid,										
    MAX(mom_abs)   AS max_mom_abs										
  FROM union_with_z										
),										
										
/* 17) Best model decided earlier; join and return FULL history inside chosen window */										
final AS (										
  SELECT										
    z.RC_CODE,										
    z.RC_DESCRIPTION,										
    z.month_end,										
    bm.Best_Model,										
    z.prev_bal,										
    z.forecast_adj       AS Forecast_Selected,										
    z.bal_num            AS Actual,										
    z.resid              AS Resid,										
    z.abs_resid          AS AbsResid,										
    z.mom_abs            AS MoM_Abs,										
    z.mom_pct_abs        AS MoM_Pct_Abs,										
    z.Z_Resid,										
    z.Z_MoM_Abs,										
    z.Z_MoM_Pct,										
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos										
  FROM union_with_z z										
  JOIN best_model bm										
    ON bm.RC_CODE = z.RC_CODE										
  WHERE z.model = bm.Best_Model										
)										
										
SELECT										
  f.*,										
  /* Severity emphasizing AbsResid and Z_Resid */										
  (										
    0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
  + 0.65 * ABS(f.Z_Resid)										
  + 0.07 * ABS(f.Z_MoM_Abs)										
  + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
  )::FLOAT8 AS Severity_Raw,										
										
  ROUND(										
    100.0 * (1.0 - EXP(										
      -(										
        0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
      + 0.65 * ABS(f.Z_Resid)										
      + 0.07 * ABS(f.Z_MoM_Abs)										
      + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
      )										
    )),										
0										
  )::INTEGER AS Severity_0_100										
FROM final f										
CROSS JOIN port_scales ps										
ORDER BY f.RC_CODE, f.month_end;										





import pandas as pd
import numpy as np

# Read the whole table (headers + data) via the named range
raw = xl("KDE_Clean_all").copy()

# Promote first row to headers
header = raw.iloc[0].astype(str).tolist()
df = raw.iloc[1:].copy()
df.columns = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header]

# Sanity check
print("rows:", len(df))
print("cols:", list(df.columns))

# Types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple slope
    t = np.arange(len(g), dtype=float); y = g["exp_changed"].astype(float).to_numpy()
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c, y_c = t - t.mean(), y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c*y_c).sum()/denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)
df_feat





import pandas as pd

df = xl("KDE_Clean").copy()
print("rows:", len(df))
print("columns:", list(df.columns))
df.head()



import pandas as pd
import numpy as np

df = xl("KDE_Clean").copy()
# normalize in case of variations
df.columns = [str(c).strip().lower().replace(" ", "_") for c in df.columns]

# required
for col in ["kde_name","this_eom","exp_changed"]:
    if col not in df.columns:
        raise KeyError(f"Missing column: {col}. Got: {list(df.columns)}")

# types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
df["exp_changed"] = pd.to_numeric(df["exp_changed"], errors="coerce")

# rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple OLS slope (no sklearn): slope = cov(t,y)/var(t)
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].to_numpy(dtype=float)
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c = t - t.mean()
        y_c = y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c * y_c).sum() / denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)

# return full table; convert to an Excel Table named KDE_Features after it renders
df_feat




import pandas as pd

# get data body
dat = xl("KDE_Summary3").copy()

# get header row from the new named range
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols
print("rows:", len(dat), "| cols:", cols)
dat




import pandas as pd

# data body (no headers) comes from the table name
dat = xl("KDE_Summary3").copy()

# headers come from the named range you just created
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols

print("rows:", len(dat), "| cols:", cols)
dat  # returns full table with proper headers




import pandas as pd

TBL = "KDE_Summary3"   # exact Table Name from Table Design

# Read the header row and the data body separately
hdr = xl(f"{TBL}[#Headers]").copy()
dat = xl(f"{TBL}[#Data]").copy()

# Convert the single header row to a list of strings, then clean the names
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

# Apply headers to the data body
dat.columns = cols

# Show a quick summary and the FULL dataframe (no .head/.tail)
print("rows:", len(dat), "cols:", cols)
dat





import pandas as pd
df = xl("KDE_Summary3").copy()
print(list(df.columns))
df.head(3)




tbl = "KDE_Summary3[#All]"   # note the [#All]
df = xl(tbl).copy()
print(df.shape, list(df.columns))


df = xl("KDE_Summary3").copy()




import pandas as pd

tbl = "KDE_Summary3"  # <-- make sure this matches Table Design > Table Name exactly
df = xl(tbl).copy()

print("shape:", df.shape)
print("columns (as Excel passes them):", list(df.columns))
df.head(3)



Error:Python
KeyError: "Couldn't find a KDE identifier column. Expected one of ['kde_name', 'kde', 'key_data_element', 'field_name', 'attribute_name', 'attribute']. Got: ['next_rate_change_date', '2025-09-30_00:00:00', '71809863129.06', '100970', '0.583402', '173071', '171867', '-1204', '-0.006957', '92887577678.95', '93253920099.4', '366342420.45', '0.003944', '-1085822458.44966', '70338547296.7333', '7053855244.00191', '0.208583218882717', '1']"





import pandas as pd
import numpy as np

df_raw = xl("KDE_Summary").copy()
print("raw rows:", len(df_raw))

# If headers came through as numbers, promote first row to headers
if all(isinstance(c, (int, float)) for c in df_raw.columns):
    header = df_raw.iloc[0].tolist()
    df = df_raw.iloc[1:].copy()
    df.columns = [str(x).strip() if pd.notna(x) else f"col_{i}" for i, x in enumerate(header)]
else:
    df = df_raw.copy()

# normalize headers
def norm(c): return str(c).replace("\n"," ").strip().lower().replace(" ", "_")
df.columns = [norm(c) for c in df.columns]
print("normalized columns:", list(df.columns))
print("rows after normalization:", len(df))

# find key columns
kde_candidates  = ["kde_name","kde","key_data_element","field_name","attribute_name","attribute"]
date_candidates = ["this_eom","end_of_month_date","end_of_month","month_end","eom","eom_date","as_of_eom","as_of_date"]

kde_col  = next((c for c in kde_candidates if c in df.columns), None)
date_col = next((c for c in date_candidates if c in df.columns), None)

if kde_col is None:
    raise KeyError(f"Couldn't find a KDE identifier column. Expected one of {kde_candidates}. Got: {list(df.columns)}")

if date_col is None:
    # try auto-detect a date-like column
    for c in df.columns:
        s = pd.to_datetime(df[c], errors="coerce")
        if s.notna().sum() >= max(3, int(0.5*len(s))):
            df["this_eom"] = s
            date_col = "this_eom"
            break
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

# type-cast numerics where present
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# sort for readability
df = df.sort_values([kde_col, "this_eom"]).reset_index(drop=True)

print("kde column:", kde_col, "| date column:", "this_eom")
print("final row count:", len(df))

# IMPORTANT: return the full DataFrame (no .head() / .tail())
df





import pandas as pd
import numpy as np

# ---- 1) Load the Excel table ----
# If your table name isn't KDE_Summary, change it here:
df = xl("KDE_Summary").copy()

# Show raw headers (helps debugging)
print("Raw columns:", list(df.columns))

# ---- 2) Normalize headers safely (handles non-string headers) ----
def to_str(x):
    try:
        return "_".join(map(str, x)).strip() if isinstance(x, tuple) else str(x).strip()
    except Exception:
        return str(x)

df.columns = [to_str(c) for c in df.columns]
df.columns = [c.replace("\n"," ") for c in df.columns]  # remove line breaks from header cells
df.columns = [c.lower().replace(" ", "_") for c in df.columns]

print("Normalized columns:", list(df.columns))

# ---- 3) Find the EOM/date column (handles THIS_EOM and common aliases) ----
aliases = [
    "this_eom","end_of_month_date","end_of_month","month_end",
    "eom","eom_date","as_of_eom","as_of_date","report_eom"
]
date_col = next((c for c in aliases if c in df.columns), None)

# If not found by name, try to detect a date-like column
if date_col is None:
    name_candidates = [c for c in df.columns if any(k in c for k in ["date","eom","month"])]
    parsed = []
    for c in name_candidates + list(df.columns):
        try:
            s = pd.to_datetime(df[c], errors="coerce")
            if s.notna().sum() >= max(3, int(0.5*len(s))):  # at least half the rows look like dates
                parsed.append((c, s))
        except Exception:
            pass
    if parsed:
        date_col, s = parsed[0]
        df["this_eom"] = s
    else:
        raise KeyError(f"Could not find a date column to use as 'this_eom'. "
                       f"Available columns: {list(df.columns)}")
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

print("Using date column as this_eom:", date_col)

# ---- 4) Make sure key numeric columns are numeric (skip if absent) ----
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ---- 5) Sort & preview ----
key_name = "kde_name" if "kde_name" in df.columns else (next((c for c in df.columns if "kde" in c and "name" in c), None))
if key_name is None:
    print("Warning: couldn't find KDE name column (expected 'KDE_NAME'). Continuing without it.")
    df = df.sort_values(["this_eom"]).reset_index(drop=True)
else:
    df = df.sort_values([key_name, "this_eom"]).reset_index(drop=True)

df.tail(10)



import pandas as pd
import numpy as np

df = xl("KDE_Summary").copy()

# convert all headers to lowercase
df.columns = [c.lower() for c in df.columns]

# now you can safely reference 'this_eom'
df['this_eom'] = pd.to_datetime(df['this_eom'], errors='coerce')

# continue with your numeric conversions, sorting, etc.
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct",
            "exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["kde_name","this_eom"]).reset_index(drop=True)
df.tail(10)




import pandas as pd
import numpy as np

# Pull the Excel table into pandas
df = xl("KDE_Summary").copy()

# Basic typing & ordering
df["this_eom"] = pd.to_datetime(df["this_eom"])
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["KDE_NAME","this_eom"]).reset_index(drop=True)

# Show a peek
df.tail(10)





import matplotlib.pyplot as plt

kde = xl("SelectedKDE") if "SelectedKDE" in dir() else None
if not kde:
    kde = df_feat["KDE_NAME"].iloc[0]

g = df_feat[df_feat["KDE_NAME"]==kde].sort_values("this_eom")

plt.figure()
plt.plot(g["this_eom"], g["exp_changed"], label="exp_changed")
if g["exp_changed_ma12"].notna().any():
    plt.plot(g["this_eom"], g["exp_changed_ma12"], linestyle=":", label="MA12")
# add a straight trend line from the slope if you want a visual guide
if len(g) >= 2 and np.isfinite(g["exp_changed"]).sum() >= 2:
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].astype(float).values
    # reconstruct fit using mean-centered form with the slope we computed
    slope = g["exp_changed_trend_slope"].iloc[-1]
    y_hat = (t - t.mean()) * slope + np.nanmean(y)
    plt.plot(g["this_eom"], y_hat, linestyle="--", label="trend")

plt.title(f"{kde} â€” exp_changed, MA12 & trend")
plt.xlabel("Month End")
plt.ylabel("Exposure changed")
plt.legend()
plt.tight_layout()





import pandas as pd
from sklearn.linear_model import LinearRegression

df = dataset
df = df.groupby('KDE_NAME', as_index=False)['exp_changed'].mean()
model = LinearRegression().fit(df.index.values.reshape(-1,1), df['exp_changed'])
df['trend'] = model.coef_[0]






-- HISTORY + TRENDS (Netezza-safe, no POWER(), no analytic REGR_*)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)

WITH
params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

/* Month index across the window and its prior month */
months AS (
  SELECT DISTINCT t.End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date) AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

/* Base pull: choose exposure and carry all KDEs */
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

/* UNPIVOT via UNION ALL, cast all KDEs to VARCHAR to align types */
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

/* Pair each current month with its previous month using months_seq */
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.End_of_Month_Date
),

/* Compare prev vs curr at (Account, KDE, month) grain */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

/* Row-level flags and attributions */
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,
    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,
    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,
    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

/* Monthly KDE rollups */
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom) AS this_eom,
    SUM(changed_flag) AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag) AS cnt_prev,
    SUM(curr_flag) AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END) AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END) AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

/* MoM metrics per KDE per month */
metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

/* Linear trend slope of exp_changed across the window (per KDE) â€” no POWER() */
trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
            - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION)))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION))) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

/* Rolling 12-means and stdev for exp_changed (uses multiplications, no POWER()) */
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - (
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          *
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - (
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            *
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),

/* Join trend + rolling stats back to monthly metrics */
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

/* Latest month only + ranking */
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  /* ranking keys */
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  /* MoM context */
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  /* trend context */
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;



base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'     -- ðŸ”¹ added filter
),






trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
            - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
          - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION)) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),




rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            CAST(2.0 AS DOUBLE PRECISION)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              CAST(2.0 AS DOUBLE PRECISION)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),




[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            2
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(NUMERIC, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






-- ***** REPLACE trend_all CTE *****
trend_all AS (
  /* slope = Cov(x,y) / Var(x)
     = ( n*Î£(xy) - Î£x*Î£y ) / ( n*Î£(x^2) - (Î£x)^2 ) */
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM( (t_idx*1.0) * (exp_changed*1.0) )
          - (SUM(t_idx*1.0) * SUM(exp_changed*1.0)) )
        /
        ( COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


-- ***** REPLACE rolling_stats CTE *****
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    /* rolling mean over last 12 (or fewer for early months) */
    AVG(exp_changed*1.0)
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    /* rolling stdev using sqrt(E[x^2] - (E[x])^2) */
    CASE
      WHEN
        ( AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        ) < 0
        THEN 0  -- guard against tiny negative from floating error
      ELSE
        SQRT(
          AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'REGR_SLOPE(NUMERIC, NUMERIC)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





-- KDE Changes-Only History + Trend (Netezza-safe, patched)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)
-- Window: set your start/end month-ends below

WITH params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

-- Distinct month-ends in range, and previous month for each
months AS (
  SELECT DISTINCT End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date)           AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

-- Base rows (exposure: Derived -> Amortized)
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,

    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

-- UNPIVOT via UNION ALL (cast to VARCHAR for type alignment)
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

-- Pair each month with its previous month
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.End_of_Month_Date
),

-- *** FIXED joined CTE (no GROUP BY; no stray attrs) ***
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

-- Row-level flags & attribution
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,

    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,

    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,

    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

-- Monthly KDE rollups
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom)                                             AS this_eom,
    SUM(changed_flag)                                         AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag)                                            AS cnt_prev,
    SUM(curr_flag)                                            AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END)   AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END)   AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

-- ***** FIX: compute regression as an aggregate (no OVER) *****
trend_all AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(exp_changed * 1.0, t_idx * 1.0) AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

-- Rolling 12-month stats (still analytic â€” supported in Netezza)
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(exp_changed)    OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    STDDEV_SAMP(exp_changed) OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_sd12
  FROM metrics_monthly
),

-- Join trend + rolling stats back to the monthly metrics
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

-- Latest month only + ranking by changes-only exposure, then by count %
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  -- changes-only (ranking keys)
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  -- MoM context
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  -- Trend features
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;
