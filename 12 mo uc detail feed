-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (fixed PREV_TOT_GL and RC_DESCRIPTION)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,
        0.40::FLOAT  AS w_zscore,
        0.30::FLOAT  AS w_pct,
        0.20::FLOAT  AS w_abs,
        0.10::FLOAT  AS w_share,
        2.00::FLOAT  AS z_cap,
        0.25::FLOAT  AS pct_cap,
        100000::FLOAT AS abs_cap,
        0.02::FLOAT  AS share_cap,
        2.00::FLOAT  AS z_thresh,
        0.25::FLOAT  AS pct_thresh,
        100000::FLOAT AS abs_thresh
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RC_DESCRIPTION,                          -- <-- renamed
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS & PRIOR-MONTH TOTAL AT MONTH GRAIN ======== */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),
tot_with_prev AS (
    SELECT
        EOM,
        TOT_GL AS CURR_TOT_GL,
        LAG(TOT_GL) OVER (ORDER BY EOM) AS PREV_TOT_GL
    FROM tot
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RC_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL
    FROM base b
),

/* ====== 5) ENRICH WITH MONTH TOTALS, Z-SCORE, SHARE METRICS ============== */
enriched AS (
    SELECT
        c.*,
        t.CURR_TOT_GL,
        t.PREV_TOT_GL,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN t.CURR_TOT_GL > 0 THEN c.GL_BALANCE / t.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN t.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN t.CURR_TOT_GL > 0 AND t.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / t.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
    JOIN tot_with_prev t
      ON t.EOM = c.EOM
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RC_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE WHEN Z_SCORE_12_EXCL IS NULL THEN 0 ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1) END AS z_norm,
        CASE WHEN MOM_PCT_CHANGE IS NULL THEN 0 ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1) END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE WHEN SHARE_DELTA IS NULL THEN 0 ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1) END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RC_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;






-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (Run as a single query)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,   -- months of history (e.g., 12)
        /* Severity weighting (roughly sum to 1.0) */
        0.40::FLOAT  AS w_zscore,          -- weight for Z-score
        0.30::FLOAT  AS w_pct,             -- weight for MoM % change
        0.20::FLOAT  AS w_abs,             -- weight for MoM $ change
        0.10::FLOAT  AS w_share,           -- weight for portfolio share shift
        /* Normalization caps for 0..1 scaling */
        2.00::FLOAT  AS z_cap,             -- cap for |Z| (e.g., 2σ)
        0.25::FLOAT  AS pct_cap,           -- cap for |MoM %| (e.g., 25%)
        100000::FLOAT AS abs_cap,          -- cap for |MoM $| (materiality)
        0.02::FLOAT  AS share_cap,         -- cap for |share delta| (2% of total)
        /* Anomaly trip wires for IS_ANOMALY */
        2.00::FLOAT  AS z_thresh,          -- flag if |Z| >= 2.0
        0.25::FLOAT  AS pct_thresh,        -- with $ threshold
        100000::FLOAT AS abs_thresh        -- with % threshold
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RV_DESCRIPTION,
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS BY MONTH (for share calculations) ========= */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RV_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL,

        t.TOT_GL AS CURR_TOT_GL,
        LAG(t.TOT_GL) OVER (ORDER BY b.EOM) AS PREV_TOT_GL
    FROM base b
    JOIN tot  t ON t.EOM = b.EOM
),

/* ====== 5) ENRICH WITH Z-SCORE & PORTFOLIO SHARE / SHARE DELTA ========== */
enriched AS (
    SELECT
        c.*,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN c.CURR_TOT_GL > 0 THEN c.GL_BALANCE / c.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN c.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN c.CURR_TOT_GL > 0 AND c.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / c.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RV_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE
            WHEN Z_SCORE_12_EXCL IS NULL THEN 0
            ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1)
        END AS z_norm,
        CASE
            WHEN MOM_PCT_CHANGE IS NULL THEN 0
            ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1)
        END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE
            WHEN SHARE_DELTA IS NULL THEN 0
            ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1)
        END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RV_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    /* Rounded/clipped severity for presentation */
    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    /* Rank within each month (highest score = rank 1) */
    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    /* Tiering */
    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;







/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)








/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;