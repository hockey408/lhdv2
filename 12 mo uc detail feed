Severity Weighted Pctl (Latest) =
VAR lm   = [Latest Month (Model)]
VAR curr =
    CALCULATE(
        AVERAGE( RC_Code_Model_Base[Severity_0_100] ),
        KEEPFILTERS( RC_Code_Model_Base[MONTH_END] = lm )
    )
VAR t =
    SUMMARIZE(
        ALL( Dim_RC[RC_DESCRIPTION] ),
        Dim_RC[RC_DESCRIPTION],
        "val",
            CALCULATE(
                AVERAGE( RC_Code_Model_Base[Severity_0_100] ),
                KEEPFILTERS( RC_Code_Model_Base[MONTH_END] = lm )
            )
    )
VAR n = COUNTROWS( t )
VAR rk = COUNTROWS( FILTER( t, [val] >= curr ) )
RETURN IF( n <= 1 || ISBLANK(curr), BLANK(), DIVIDE( rk - 1, n - 1 ) )

PSI Contrib Abs Pctl (Latest) =
VAR lm   = [Latest Month (PSI)]
VAR curr =
    CALCULATE(
        ABS( AVERAGE( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
        KEEPFILTERS( RC_PSI_ByDescription[MONTH_END] = lm )
    )
VAR t =
    SUMMARIZE(
        ALL( Dim_RC[RC_DESCRIPTION] ),
        Dim_RC[RC_DESCRIPTION],
        "val",
            CALCULATE(
                ABS( AVERAGE( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
                KEEPFILTERS( RC_PSI_ByDescription[MONTH_END] = lm )
            )
    )
VAR n = COUNTROWS( t )
VAR rk = COUNTROWS( FILTER( t, [val] >= curr ) )
RETURN IF( n <= 1 || ISBLANK(curr), BLANK(), DIVIDE( rk - 1, n - 1 ) )









Latest Month (ML) =
CALCULATE( MAX( RC_ML_Scored[MONTH_END] ), ALL( RC_ML_Scored ) )

Latest Month (Model) =
CALCULATE( MAX( RC_Code_Model_Base[MONTH_END] ), ALL( RC_Code_Model_Base ) )

Latest Month (PSI) =
CALCULATE( MAX( RC_PSI_ByDescription[MONTH_END] ), ALL( RC_PSI_ByDescription ) )

ML Anomaly Pctl (Latest) =
VAR lm   = [Latest Month (ML)]
VAR curr =
    CALCULATE(
        AVERAGE( RC_ML_Scored[Anomaly_Score_0_100] ),
        KEEPFILTERS( RC_ML_Scored[MONTH_END] = lm )
    )
VAR t =
    SUMMARIZE(
        ALL( Dim_RC[RC_DESCRIPTION] ),
        Dim_RC[RC_DESCRIPTION],
        "val",
            CALCULATE(
                AVERAGE( RC_ML_Scored[Anomaly_Score_0_100] ),
                KEEPFILTERS( RC_ML_Scored[MONTH_END] = lm )
            )
    )
VAR n = COUNTROWS( t )
VAR rk = COUNTROWS( FILTER( t, [val] >= curr ) )
RETURN IF( n <= 1 || ISBLANK(curr), BLANK(), DIVIDE( rk - 1, n - 1 ) )










-- Q2: MoM Bridge by Bank_Code (Source_System_Balance) — FIXED ORDER BY
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Prev_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Curr_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.GL_ACCOUNT_CODE,p.GL_ACCOUNT_CODE)       AS GL_ACCOUNT_CODE,
    COALESCE(p.Prev_Bal,0) AS Prev_Bal,
    COALESCE(c.Curr_Bal,0) AS Curr_Bal
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System='ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
totals AS (
  SELECT
    Bank_Code,
    SUM(CASE WHEN Prev_Bal>0 THEN Prev_Bal END)                 AS prev_total_bal,
    SUM(CASE WHEN Curr_Bal>0 THEN Curr_Bal END)                 AS curr_total_bal,
    COUNT(CASE WHEN Prev_Bal>0 THEN 1 END)                      AS prev_total_cnt,
    COUNT(CASE WHEN Curr_Bal>0 THEN 1 END)                      AS curr_total_cnt,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN Curr_Bal END),0)                    AS adds_bal,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN Prev_Bal END),0)                   AS drops_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal>0 AND Curr_Bal>0 THEN (Curr_Bal-Prev_Bal) END),0)         AS pers_delta_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN 1 END),0)                           AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN 1 END),0)                          AS drops_cnt
  FROM with_bank
  GROUP BY Bank_Code
)
SELECT Bank_Code, line, balance_val, count_val
FROM (
  SELECT Bank_Code, 'Prev Month Balance' AS line, prev_total_bal AS balance_val, NULL::BIGINT AS count_val, 0 AS seq FROM totals
  UNION ALL SELECT Bank_Code, 'Adds',                    adds_bal,               NULL,         1 FROM totals
  UNION ALL SELECT Bank_Code, 'Drops',                   drops_bal,              NULL,         2 FROM totals
  UNION ALL SELECT Bank_Code, 'Persisting Bal Changes',  pers_delta_bal,         NULL,         3 FROM totals
  UNION ALL SELECT Bank_Code, 'Current Month Balance',   curr_total_bal,         NULL,         4 FROM totals
  UNION ALL SELECT Bank_Code, 'Prev Month Count',        NULL::NUMERIC(18,2),    prev_total_cnt, 10 FROM totals
  UNION ALL SELECT Bank_Code, 'Adds',                    NULL,                   adds_cnt,       11 FROM totals
  UNION ALL SELECT Bank_Code, 'Drops',                   NULL,                   drops_cnt,      12 FROM totals
  UNION ALL SELECT Bank_Code, 'Current Month Count',     NULL,                   curr_total_cnt, 13 FROM totals
) u
ORDER BY Bank_Code, seq;




ML Anomaly Pctl (Latest) =
VAR lm = [Latest Month]
VAR r  =
    RANKX (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        CALCULATE (
            AVERAGE ( RC_ML_Scored[Anomaly_Score_0_100] ),
            KEEPFILTERS ( RC_ML_Scored[MONTH_END] = lm )
        ),
        ,
        DESC,
        DENSE
    )
VAR n = COUNTROWS ( VALUES ( Dim_RC[RC_DESCRIPTION] ) )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )






ML Anomaly Pctl (Latest) =
VAR lm = [Latest Month]
VAR t  =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "v",
            CALCULATE (
                AVERAGE ( RC_ML_Scored[Anomaly_Score_0_100] ),
                KEEPFILTERS ( RC_ML_Scored[MONTH_END] = lm )
            )
    )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK (), DIVIDE ( r - 1, n - 1 ) )






-- Raw (abs) PSI for the current RC at latest month
PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
)


-- Rank across RCs (no temp column)
PSI Contrib Rank (Latest) =
VAR lm = [Latest Month]
RETURN
RANKX (
    VALUES ( Dim_RC[RC_DESCRIPTION] ),
    CALCULATE (
        ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
        KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
    ),
    ,
    DESC,
    DENSE
)


-- Percentile 0..1 across RCs
PSI Contrib Pctl (Latest) =
VAR lm = [Latest Month]
VAR r =
    RANKX (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        CALCULATE (
            ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
            KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
        ),
        ,
        DESC,
        DENSE
    )
VAR n = COUNTROWS ( VALUES ( Dim_RC[RC_DESCRIPTION] ) )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )





PSI Contrib Rank (Latest) =
VAR lm = [Latest Month]
VAR t =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "__psi",
            CALCULATE (
                ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
                KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
            )
    )
RETURN
RANKX ( t, [__psi], , DESC, DENSE )


PSI Contrib Pctl (Latest) =
VAR lm = [Latest Month]
VAR t =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "__psi",
            CALCULATE (
                ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
                KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
            )
    )
VAR r = RANKX ( t, [__psi], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )








PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
)





PSI Contrib Rank (Latest) =
VAR lm      = [Latest Month]
VAR rcTable = VALUES ( Dim_RC[RC_DESCRIPTION] )
VAR t =
    ADDCOLUMNS (
        rcTable,
        "psi",
            VAR rc = [RC_DESCRIPTION]
            RETURN
                CALCULATE (
                    AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
                    KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
                    TREATAS ( ROW ( "rc", rc ), RC_PSI_ByDescription[RC_DESCRIPTION] )
                )
    )
RETURN
RANKX ( t, [psi], , DESC, DENSE )



PSI Contrib Pctl (Latest) =
VAR lm      = [Latest Month]
VAR rcTable = VALUES ( Dim_RC[RC_DESCRIPTION] )
VAR t =
    ADDCOLUMNS (
        rcTable,
        "psi",
            VAR rc = [RC_DESCRIPTION]
            RETURN
                CALCULATE (
                    AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
                    KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
                    TREATAS ( ROW ( "rc", rc ), RC_PSI_ByDescription[RC_DESCRIPTION] )
                )
    )
VAR r = RANKX ( t, [psi], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )





PSI Contrib % of Total (Latest) =
VAR lm = [Latest Month]
VAR rc_val =
    CALCULATE (
        AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
        KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
        KEEPFILTERS ( RC_PSI_ByDescription[RC_DESCRIPTION] = SELECTEDVALUE ( Dim_RC[RC_DESCRIPTION] ) )
    )
VAR tot_val =
    CALCULATE (
        SUM ( RC_PSI_ByDescription[PSI_CONTRIB] ),
        KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm )
    )
RETURN DIVIDE ( rc_val, tot_val )

PSI Contrib (bps, Latest) =
VAR lm = [Latest Month]
VAR v =
    CALCULATE (
        AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
        KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
        KEEPFILTERS ( RC_PSI_ByDescription[RC_DESCRIPTION] = SELECTEDVALUE ( Dim_RC[RC_DESCRIPTION] ) )
    )
RETURN v * 10000   -- 1 PSI unit = 10,000 bps for display only


PSI Contrib Rank (Latest) =
VAR lm = [Latest Month]
VAR t =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "psi",
            CALCULATE (
                AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
                KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
                KEEPFILTERS ( RC_PSI_ByDescription[RC_DESCRIPTION] = Dim_RC[RC_DESCRIPTION] )
            )
    )
RETURN RANKX ( t, [psi], , DESC, DENSE )

PSI Contrib Pctl (Latest) =
VAR lm = [Latest Month]
VAR t =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "psi",
            CALCULATE (
                AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ),
                KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
                KEEPFILTERS ( RC_PSI_ByDescription[RC_DESCRIPTION] = Dim_RC[RC_DESCRIPTION] )
            )
    )
VAR r = RANKX ( t, [psi], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )


Triage Score 0-100 (Latest) =
VAR elig = [Is Triage Eligible]
VAR ml   = [ML Anomaly Pctl (Latest)]
VAR sev  = [Severity Weighted Pctl (Latest)]
VAR psi  = [PSI Contrib Pctl (Latest)]
VAR score01 = 0.45*ml + 0.35*sev + 0.20*psi
RETURN IF ( elig <> 1, BLANK(), ROUND ( 100 * score01, 1 ) )








_DEBUG PSI =
SUMMARIZECOLUMNS (
    RC_PSI_ByDescription[RC_DESCRIPTION],
    RC_PSI_ByDescription[MONTH_END],
    "PSI_CONTRIB", AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] )
)





PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
VAR thisRC = SELECTEDVALUE ( Dim_RC[RC_DESCRIPTION] )
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    KEEPFILTERS ( RC_PSI_ByDescription[MONTH_END] = lm ),
    KEEPFILTERS ( RC_PSI_ByDescription[RC_DESCRIPTION] = thisRC )
)





PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
    -- If you renamed RC_DESC -> RC_DESCRIPTION in PQ, swap the target column below.
    TREATAS ( ROW ( "rc", SELECTEDVALUE ( Dim_RC[RC_DESCRIPTION] ) ), RC_PSI_ByDescription[RC_DESC] )
)


PSI Contrib Abs Pctl (Latest) =
VAR lm      = [Latest Month]
VAR rcTable = VALUES ( Dim_RC[RC_DESCRIPTION] )
VAR t =
    ADDCOLUMNS (
        rcTable,
        "v",
            CALCULATE (
                ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
                TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
                TREATAS ( ROW ( "rc", Dim_RC[RC_DESCRIPTION] ), RC_PSI_ByDescription[RC_DESC] )  -- or ...[RC_DESCRIPTION]
            )
    )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )


Triage Score 0-100 (Latest) =
VAR elig = [Is Triage Eligible]
VAR ml   = [ML Anomaly Pctl (Latest)]
VAR sev  = [Severity Weighted Pctl (Latest)]
VAR psi  = [PSI Contrib Abs Pctl (Latest)]
VAR score01 = 0.45 * ml + 0.35 * sev + 0.20 * psi
RETURN IF ( elig <> 1, BLANK(), ROUND ( 100 * score01, 1 ) )









-- 2) Percentile across RCs (compute PSI per RC inside ADDCOLUMNS)
PSI Contrib Abs Pctl (Latest) =
VAR lm = [Latest Month]
VAR rcTable = VALUES ( Dim_RC[RC_DESCRIPTION] )
VAR t =
    ADDCOLUMNS (
        rcTable,
        "v",
            VAR rc = [RC_DESCRIPTION]
            RETURN
                CALCULATE (
                    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
                    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
                    TREATAS ( { rc }, RC_PSI_ByDescription[RC_DESC] )  -- or RC_PSI_ByDescription[RC_DESCRIPTION]
                )
    )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )





-- 1) PSI (Abs) at latest month for the current RC in context
PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
    -- If you renamed RC_DESC -> RC_DESCRIPTION in PQ, swap the last TREATAS mapping accordingly.
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_PSI_ByDescription[RC_DESC] )
)





PSI Contrib Abs (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    ABS ( AVERAGE ( RC_PSI_ByDescription[PSI_CONTRIB] ) ),
    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_PSI_ByDescription[RC_DESC] )
)


PSI Contrib Abs Pctl (Latest) =
VAR t =
    ADDCOLUMNS (
        VALUES ( Dim_RC[RC_DESCRIPTION] ),
        "v", [PSI Contrib Abs (Latest)]
    )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )

Triage Score 0-100 (Latest) =
VAR elig = [Is Triage Eligible]
VAR ml   = [ML Anomaly Pctl (Latest)]
VAR sev  = [Severity Weighted Pctl (Latest)]
VAR psi  = [PSI Contrib Abs Pctl (Latest)]
VAR score01 = 0.45 * ml + 0.35 * sev + 0.20 * psi
RETURN IF ( elig <> 1, BLANK(), ROUND ( 100 * score01, 1 ) )






PSI Abs (Latest, Bound) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    MAX ( RC_PSI_ByDescription[PSI_CONTRIB_ABS] ),
    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_PSI_ByDescription[RC_DESCRIPTION] )
)

Exposure (Latest by RC) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( RC_PSI_ByDescription[EXP_SUM] ),
    TREATAS ( ROW ( "d", lm ), RC_PSI_ByDescription[MONTH_END] ),
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_PSI_ByDescription[RC_DESCRIPTION] )
)


Is Triage Eligible =
VAR ok_mon = IF ( [Monitorable Flag (Measure)] = 1, 1, 0 )
VAR ok_flo = IF ( [Exposure (Latest by RC)] >= 1000000, 1, 0 )
RETURN IF ( ok_mon = 1 && ok_flo = 1, 1, 0 )


-- ML anomaly from RC_ML_Scored
ML Anomaly (Latest, Bound) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( RC_ML_Scored[Anomaly_Score_0_100] ),
    TREATAS ( ROW ( "d", lm ), RC_ML_Scored[MONTH_END] ),
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_ML_Scored[RC_DESCRIPTION] )
)

-- Severity from RC_Code_Model_Base
Severity (Weighted, Latest, Bound) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( RC_Code_Model_Base[Severity_0_100] ),
    TREATAS ( ROW ( "d", lm ), RC_Code_Model_Base[MONTH_END] ),
    TREATAS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), RC_Code_Model_Base[RC_DESCRIPTION] )
)


ML Anomaly Pctl (Latest) =
VAR t = ADDCOLUMNS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), "v", [ML Anomaly (Latest, Bound)] )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )

Severity Weighted Pctl (Latest) =
VAR t = ADDCOLUMNS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), "v", [Severity (Weighted, Latest, Bound)] )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )

PSI Abs Pctl (Latest) =
VAR t = ADDCOLUMNS ( VALUES ( Dim_RC[RC_DESCRIPTION] ), "v", [PSI Abs (Latest, Bound)] )
VAR r = RANKX ( t, [v], , DESC, DENSE )
VAR n = COUNTROWS ( t )
RETURN IF ( n <= 1, BLANK(), DIVIDE ( r - 1, n - 1 ) )


Triage Score 0-100 (Latest) =
VAR elig = [Is Triage Eligible]
VAR ml   = [ML Anomaly Pctl (Latest)]
VAR sev  = [Severity Weighted Pctl (Latest)]
VAR psi  = [PSI Abs Pctl (Latest)]
VAR score01 = 0.45 * ml + 0.35 * sev + 0.20 * psi
RETURN IF ( elig <> 1, BLANK(), ROUND ( 100 * score01, 1 ) )

Triage Rank (Latest) =
RANKX (
    ALLSELECTED ( Dim_RC[RC_DESCRIPTION] ),
    [Triage Score 0-100 (Latest)],
    ,
    DESC,
    DENSE
)







import pandas as pd, numpy as np

def robust_z(s: pd.Series) -> pd.Series:
    s = pd.to_numeric(s, errors="coerce")
    med = s.median()
    s2 = s.fillna(med)
    mad = (s2 - med).abs().median()
    if not mad or mad == 0:
        std = s2.std(ddof=0)
        return (s2 - s2.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s2 - med) / (1.4826 * mad)

# --- Feature selection ---
features = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(features) < 2:
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    features = numcols[:2]

df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

# --- Standardize via robust Z and weighted composite ---
Z = pd.DataFrame({c: robust_z(df[c]) for c in features})
weights = {"SEVERITY_0_100":1.5,"PSI_CONTRIB_ABS":1.0,"Z_RESID":1.2,"Z_MOM_ABS":1.0,"Z_MOM_PCT":0.8}
comp = sum(weights.get(c,1.0)*Z[c].abs() for c in features)

grp = df["MONTH_END"].dt.to_period("M")
pct = comp.groupby(grp).rank(pct=True)
df["Anomaly_Score_0_100"] = (pct*100).round(1)

# --- Cluster by anomaly quartile ---
def q4(s):
    s = pd.to_numeric(s, errors="coerce")
    if s.notna().sum() < 4: return pd.Series([0]*len(s), index=s.index)
    try:
        return pd.qcut(s, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)
    except Exception:
        r = s.rank(pct=True)
        return pd.cut(r, bins=[0,.25,.5,.75,1.0], labels=[0,1,2,3], include_lowest=True).astype(int)

clusters = []
for m, idx in grp.groupby(grp).groups.items():
    clusters.append(q4(pct.loc[idx]))
df["Cluster_ID"] = pd.concat(clusters).sort_index().astype(int)

# --- Final tidy output ---
keep = [c for c in ["RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","RMSE",
                    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
                    "Cluster_ID","Anomaly_Score_0_100"] if c in df.columns]
scored_full = df[keep].sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[True,False])

scored_full





import pandas as pd, numpy as np

TABLE_NAME = "RC_ML_Features"  # exact Excel Table name

def load_excel_table(table: str) -> pd.DataFrame:
    # Try canonical structured refs
    try:
        hdr = xl(f"{table}[#Headers]")
        dat = xl(f"{table}[#Data]")
    except Exception as e:
        # Fallback: try [#All] and infer headers from the first row
        try:
            allrng = xl(f"{table}[#All]")
            arr = np.array(allrng)
            if arr.ndim == 1:
                arr = arr.reshape(1, -1)
            hdr_list = [str(x) for x in arr[0, :]]
            body = arr[1:, :]
            return pd.DataFrame(body, columns=hdr_list)
        except Exception as e2:
            return pd.DataFrame({"ERROR":[f"Failed to read table '{table}' via xl()."], 
                                 "Detail":[str(e)], "Fallback":[str(e2)]})

    # Normalize to arrays
    hdr_list = [str(x) for x in np.array(hdr).ravel()]
    arr = dat.values if hasattr(dat, "values") else np.array(dat)
    if arr.ndim == 1:
        arr = arr.reshape(1, -1)

    # Repair common header/data width mismatches
    if arr.shape[1] != len(hdr_list):
        # If [#Headers] came back with 1 col (sometimes happens), try [#All]
        try:
            allrng = xl(f"{table}[#All]")
            arr2 = np.array(allrng)
            if arr2.ndim == 1:
                arr2 = arr2.reshape(1, -1)
            hdr_list2 = [str(x) for x in arr2[0, :]]
            body2 = arr2[1:, :]
            return pd.DataFrame(body2, columns=hdr_list2)
        except:
            return pd.DataFrame({"ERROR":[f"Header/Data columns mismatch for '{table}'."],
                                 "Headers_Count":[len(hdr_list)], "Data_Cols":[arr.shape[1]]})

    # Build DF
    df_ = pd.DataFrame(arr, columns=hdr_list)

    # Clean up header issues (empty/dup names)
    if any(h=="" for h in hdr_list):
        df_.columns = [f"col_{i}" if (h is None or h=="") else str(h) for i,h in enumerate(df_.columns)]
    if len(set(df_.columns)) != len(df_.columns):
        # de-duplicate columns with suffixes
        counts = {}
        newcols = []
        for c in df_.columns:
            counts[c] = counts.get(c, 0) + 1
            new = c if counts[c]==1 else f"{c}_{counts[c]}"
            newcols.append(new)
        df_.columns = newcols

    return df_

# ---- Use existing df if already created upstream; else load from Excel
try:
    df  # exists already
    if not isinstance(df, pd.DataFrame) or df.empty:
        raise NameError("df exists but is empty; reloading.")
except NameError:
    df = load_excel_table(TABLE_NAME)

# Quick sanity printouts
print("Columns detected:", list(df.columns)[:20])
print("Shape:", df.shape)





import pandas as pd, numpy as np

# ===================== CONFIG =====================
TABLE_NAME = "RC_ML_Features2"   # Excel Table name that holds your merged features
DATE_COL_CANDIDATES = ["MONTH_END", "Month_End", "month_end"]
RC_COL_CANDIDATES   = ["RC_DESCRIPTION","RC_DESC","rc_description","rc_desc"]

# Features to use (will auto-shrink to what's present)
FEATURES_PREF = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"]

# Optional weights (set all to 1.0 for equal weighting)
FEATURE_WEIGHTS = {
    "SEVERITY_0_100": 1.5,
    "PSI_CONTRIB_ABS": 1.0,
    "Z_RESID": 1.2,
    "Z_MOM_ABS": 1.0,
    "Z_MOM_PCT": 0.8
}

# Columns you'd like in the final scored output (kept if present)
KEEP_COLS = [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","RMSE",
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
]

# ============== HELPERS (robust z, IO, safe ops) ==============
def get_table_df(name: str) -> pd.DataFrame:
    hdr = xl(f"{name}[#Headers]")
    dat = xl(f"{name}[#Data]")
    hdr_list = [str(x) for x in np.array(hdr).ravel()]
    arr = dat.values if hasattr(dat, "values") else np.array(dat)
    return pd.DataFrame(arr, columns=hdr_list)

def find_first_col(df: pd.DataFrame, cands) -> str:
    for c in cands:
        if c in df.columns:
            return c
    raise ValueError(f"Could not find any of columns: {cands}. Got: {list(df.columns)}")

def robust_z(s: pd.Series) -> pd.Series:
    # robust z using median & MAD; fall back to std if MAD==0
    s = pd.to_numeric(s, errors="coerce")
    med = s.median()
    s2 = s.fillna(med)
    mad = (s2 - med).abs().median()
    if not mad or mad == 0:
        std = s2.std(ddof=0)
        return (s2 - s2.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s2 - med) / (1.4826 * mad)

def monthwise_percentile(values: pd.Series, grp: pd.Series) -> pd.Series:
    # percentile rank within each month (group)
    return values.groupby(grp).rank(pct=True)

def safe_qcut_quartiles(s: pd.Series) -> pd.Series:
    # Return quartile labels 0..3; if too few rows, assign zeros
    s = pd.to_numeric(s, errors="coerce")
    n = s.notna().sum()
    if n < 4 or s.nunique(dropna=True) < 2:
        return pd.Series([0]*len(s), index=s.index).astype(int)
    # duplicates='drop' to avoid bin-edge issues when many ties
    try:
        return pd.qcut(s, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3], duplicates="drop").astype(int)
    except Exception:
        # if qcut fails due to duplicates, fallback to rank-based bins
        r = s.rank(pct=True)
        return pd.cut(r, bins=[0,.25,.5,.75,1.0], labels=[0,1,2,3], include_lowest=True).astype(int)

# ===================== LOAD & CLEAN =====================
df = get_table_df(TABLE_NAME)

# Identify key columns
DATE_COL = find_first_col(df, DATE_COL_CANDIDATES)
RC_COL   = find_first_col(df, RC_COL_CANDIDATES)

# Coerce types
df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce")

# Ensure numeric types for preferred features (if present)
for c in FEATURES_PREF:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Ensure KEEP_COLS compatibility (some may be missing)
keep_cols_present = [c for c in KEEP_COLS if c in df.columns]
# Make sure standard names exist in output even if variants were present
if "RC_DESCRIPTION" not in keep_cols_present and RC_COL in df.columns:
    df["RC_DESCRIPTION"] = df[RC_COL]
    if "RC_DESCRIPTION" not in keep_cols_present:
        keep_cols_present = ["RC_DESCRIPTION"] + keep_cols_present
if "MONTH_END" not in keep_cols_present and DATE_COL in df.columns:
    df["MONTH_END"] = df[DATE_COL].dt.date  # keep date part for display
    keep_cols_present = ["MONTH_END"] + keep_cols_present

# ===================== FEATURE SELECTION =====================
features = [c for c in FEATURES_PREF if c in df.columns]
if len(features) < 2:
    # fallback: take first two numeric columns in df
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    features = numcols[:2]
    if len(features) < 2:
        raise ValueError("Not enough numeric columns found to compute an anomaly score.")

# ===================== ROBUST Z & COMPOSITE =====================
# Robust Z with median imputation baked in
Z = pd.DataFrame({c: robust_z(df[c]) for c in features})

# Weighted L1 distance from robust center
weights = {c: FEATURE_WEIGHTS.get(c, 1.0) for c in features}
comp = sum(weights[c] * Z[c].abs() for c in features)

# ===================== MONTH-WISE PERCENTILES & CLUSTERS =====================
me_series = df[DATE_COL].dt.to_period("M")  # group by calendar month
pct = monthwise_percentile(comp, me_series)  # 0..1 within each month

# Anomaly score 0..100 within each month
df["Anomaly_Score_0_100"] = (pct * 100).round(1)

# Per-month quartiles 0..3
# Do it groupwise so each month has its own quartile cut
clusters = []
for m, idx in me_series.groupby(me_series).groups.items():
    s = pct.loc[idx]
    clusters.append(pd.Series(safe_qcut_quartiles(s), index=idx))
df["Cluster_ID"] = pd.concat(clusters).sort_index().astype(int)

# ===================== OUTPUT TABLES =====================
scored_cols = list(dict.fromkeys(keep_cols_present + ["Cluster_ID","Anomaly_Score_0_100"]))
scored_full = df[scored_cols].copy()

# Latest month subset
if df[DATE_COL].notna().any():
    latest_me = df[DATE_COL].max()
    scored_latest = scored_full[df[DATE_COL] == latest_me].copy()
else:
    scored_latest = scored_full.copy()

# Cluster summary (per month, per cluster)
num_cols_for_summary = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","Anomaly_Score_0_100"] if c in scored_full.columns]
cluster_summary = (
    df.assign(__ME=df[DATE_COL].dt.to_period("M"))
      .groupby(["__ME","Cluster_ID"])[num_cols_for_summary]
      .mean(numeric_only=True)
      .round(3)
      .assign(Count=df.assign(__ME=df[DATE_COL].dt.to_period("M")).groupby(["__ME","Cluster_ID"]).size())
      .reset_index()
)
cluster_summary["MONTH_END"] = cluster_summary["__ME"].dt.to_timestamp("M").dt.date
cluster_summary = cluster_summary.drop(columns="__ME")

# Migration (last 2 months only)
if df[DATE_COL].notna().any():
    months_sorted = sorted(df[DATE_COL].dt.to_period("M").dropna().unique())
    if len(months_sorted) >= 2:
        last2 = months_sorted[-2:]
        t2 = df[df[DATE_COL].dt.to_period("M").isin(last2)][[RC_COL, DATE_COL, "Cluster_ID"]].copy()
        t2["__ME"] = t2[DATE_COL].dt.to_period("M")
        mig = t2.pivot_table(index=RC_COL, columns="__ME", values="Cluster_ID", aggfunc="last")
        # Rename columns as readable dates
        mig.columns = [f"Cluster_{pd.Period(c, freq='M').to_timestamp('M').date()}" for c in mig.columns]
        migration_last2 = mig.reset_index().rename(columns={RC_COL: "RC_DESCRIPTION"})
    else:
        migration_last2 = pd.DataFrame({"Info": ["Need at least 2 months for migration."], "MonthsFound": [list(map(str, months_sorted))]})
else:
    migration_last2 = pd.DataFrame({"Info": ["No valid dates found in data."]})

# ===================== WHAT TO DISPLAY =====================
# By default, show the full scored dataset (all months).
# Change the last line to: cluster_summary / scored_latest / migration_last2 if you want those instead.
scored_full.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[True, False])






# After computing `comp`
pct = (comp.groupby(df["MONTH_END"])
           .rank(pct=True))  # percentile within each month
df["Anomaly_Score_0_100"] = (pct*100).round(1)
df["Cluster_ID"] = (pct.groupby(df["MONTH_END"])
                      .transform(lambda s: pd.qcut(s, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]))
                      .astype(int))


Z = pd.DataFrame({c: robust_z(df[c].fillna(df[c].median())) for c in feat})


weights = {"SEVERITY_0_100": 1.5, "PSI_CONTRIB_ABS": 1.0, "Z_RESID": 1.2, "Z_MOM_ABS": 1.0, "Z_MOM_PCT": 0.8}
comp = sum(weights.get(c,1.0) * Z[c].abs() for c in feat)




import pandas as pd, numpy as np

# Expect df from cell A
def robust_z(s: pd.Series) -> pd.Series:
    med = s.median()
    mad = (s - med).abs().median()
    if not mad or mad == 0:
        std = s.std(ddof=0)
        return (s - s.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s - med) / (1.4826 * mad)

# Pick features (use what exists; need at least two numeric columns)
feat = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feat) < 2:
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    feat = numcols[:2]

# Fallback (no sklearn dependency): MAD-based composite → percentile → score
Z = pd.DataFrame({c: robust_z(df[c].fillna(0)) for c in feat})
comp = Z.abs().sum(axis=1)
pct  = comp.rank(pct=True)
df["Anomaly_Score_0_100"] = (pct*100).round(1)
df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# Keep tidy scored view
scored_cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]
scored = df[scored_cols].copy()

# Return a preview
scored.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[False, False])





Latest Month =
CALCULATE ( MAX ( 'Date'[MonthEnd] ), ALL ( 'Date' ) )

Exposure (Latest by RC) =
VAR lm = [Latest Month]
RETURN
CALCULATE ( SUM ( RC_PSI_ByDescription[EXP_SUM] ), 'Date'[MonthEnd] = lm )

-- Your existing flag:
-- Monitorable Flag (Measure)  // already in your model





WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Prev_Account_Key,
    MAX(Account_Name)            AS Prev_Account_Name,
    MAX(CIS_Customer_Number)     AS Prev_CIS_Customer_Number,
    MAX(Facility_ID)             AS Prev_Facility_ID,
    MAX(Contract_Source_System)  AS Prev_Contract_Source_System,
    MAX(Status_Code_Description) AS Prev_Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS Prev_GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Prev_Source_System_Balance,
    SUM(GL_Balance)              AS Prev_GL_Balance,
    MAX(Available_Balance)       AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Prev_Borrower_Risk_Rating,
    MAX(PD_Grade)                AS Prev_PD_Grade,
    MAX(Days_Past_Due)           AS Prev_Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Prev_Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS Prev_PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS Prev_RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS Prev_GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,

    /* current fields (explicit, no c.*) */
    c.Account_Key,
    c.Account_Name,
    c.CIS_Customer_Number,
    c.Facility_ID,
    c.Contract_Source_System,
    c.Status_Code_Description,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.Source_System_Balance,
    c.GL_Balance,
    c.Available_Balance,
    c.Borrower_Risk_Rating,
    c.PD_Grade,
    c.Days_Past_Due,
    c.Non_Accrual_Flag,
    c.PROD_HIER_LEVEL_5,
    c.RBC_Code,
    c.GL_ACCOUNT_CODE,

    /* prev snapshot fields */
    p.Prev_Source_System_Balance,
    p.Prev_GL_Balance,
    p.Prev_Account_Key,
    p.Prev_Account_Name,
    p.Prev_CIS_Customer_Number,
    p.Prev_Facility_ID,
    p.Prev_Contract_Source_System,
    p.Prev_Status_Code_Description,
    p.Prev_GL_ACCOUNT_HIER_LEVEL_4,
    p.Prev_Available_Balance,
    p.Prev_Borrower_Risk_Rating,
    p.Prev_PD_Grade,
    p.Prev_Days_Past_Due,
    p.Prev_Non_Accrual_Flag,
    p.Prev_PROD_HIER_LEVEL_5,
    p.Prev_RBC_Code,
    p.Prev_GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
)
SELECT
  (SELECT curr_eom FROM params) AS End_of_Month_Date,

  /* classification on Source_System_Balance */
  CASE
    WHEN COALESCE(Prev_Source_System_Balance,0)=0 AND COALESCE(Source_System_Balance,0)>0 THEN 'ADD'
    WHEN COALESCE(Source_System_Balance,0)=0 AND COALESCE(Prev_Source_System_Balance,0)>0 THEN 'DROP'
    WHEN COALESCE(Source_System_Balance,0)<>COALESCE(Prev_Source_System_Balance,0)         THEN 'BAL_CHANGE'
    ELSE 'NO_CHANGE'
  END AS Change_Type,

  /* Bank_Code from current (fallback to prev if current is null) */
  CASE
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) = 'ALL'
         AND COALESCE(GL_ACCOUNT_CODE, Prev_GL_ACCOUNT_CODE) IN
             ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
              '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
              '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
          'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,

  /* detail fields (current snapshot) */
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,

  /* helpful exposure deltas */
  COALESCE(Prev_Source_System_Balance,0) AS Prev_Source_System_Balance,
  COALESCE(Source_System_Balance,0)      AS Curr_Source_System_Balance,
  COALESCE(Source_System_Balance,0) - COALESCE(Prev_Source_System_Balance,0) AS Exposure_Delta

FROM joined
ORDER BY Change_Type, Bank_Code, Account_Identifier;





Anomaly Score (Avg by Month) =
CALCULATE (
    AVERAGE ( RC_ML_Scored_Hist[Anomaly_Score_0_100] )
)





Corr (ML vs Severity) =
VAR t =
    ADDCOLUMNS (
        RC_ML_Scored_Latest,
        "X", RC_ML_Scored_Latest[Anomaly_Score_0_100],
        "Y", RELATED ( RC_Code_Model_Base[Severity_0_100] )
    )
VAR mx = AVERAGEX ( t, [X] )
VAR my = AVERAGEX ( t, [Y] )
VAR num = SUMX ( t, ([X]-mx)*([Y]-my) )
VAR den = SQRT ( SUMX ( t, ([X]-mx)^2 ) * SUMX ( t, ([Y]-my)^2 ) )
RETURN DIVIDE ( num, den )






Anomaly Score (Latest) =
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( RC_ML_Scored_Latest[Anomaly_Score_0_100] ),
    RC_ML_Scored_Latest[MONTH_END] = lm
)





High-Anomaly RCs (Latest) =
VAR lm =
    CALCULATE ( MAX ( 'Date'[MonthEnd] ), ALL ( 'Date' ) )
VAR threshold = 80
RETURN
CALCULATE (
    DISTINCTCOUNT ( RC_ML_Scored_Latest[RC_DESCRIPTION] ),
    FILTER (
        RC_ML_Scored_Latest,
        RC_ML_Scored_Latest[MONTH_END] = lm &&
        RC_ML_Scored_Latest[Anomaly_Score_0_100] >= threshold
    )
)





Dim_RC =
DISTINCT (
    UNION (
        SELECTCOLUMNS ( RC_Code_Model_Base,  "RC_DESCRIPTION", RC_Code_Model_Base[RC_DESCRIPTION] ),
        SELECTCOLUMNS ( RC_ML_Scored_Latest, "RC_DESCRIPTION", RC_ML_Scored_Latest[RC_DESCRIPTION] )
    )
)




Date =
VAR MinDate =
    MINX (
        UNION (
            SELECTCOLUMNS ( RC_Code_Model_Base, "d", RC_Code_Model_Base[MONTH_END] ),
            SELECTCOLUMNS ( RC_ML_Scored_Latest, "d", RC_ML_Scored_Latest[MONTH_END] )
        ),
        [d]
    )
VAR MaxDate =
    MAXX (
        UNION (
            SELECTCOLUMNS ( RC_Code_Model_Base, "d", RC_Code_Model_Base[MONTH_END] ),
            SELECTCOLUMNS ( RC_ML_Scored_Latest, "d", RC_ML_Scored_Latest[MONTH_END] )
        ),
        [d]
    )
RETURN
ADDCOLUMNS (
    CALENDAR ( MinDate, MaxDate ),
    "Year",            YEAR ( [Date] ),
    "MonthNum",        MONTH ( [Date] ),
    "Month",           FORMAT ( [Date], "MMMM" ),
    "MonthShort",      FORMAT ( [Date], "MMM" ),
    "YearMonth",       FORMAT ( [Date], "YYYY-MM" ),
    "Quarter",         "Q" & FORMAT ( [Date], "Q" ),
    "YearQuarter",     FORMAT ( [Date], "YYYY" ) & "-Q" & FORMAT ( [Date], "Q" ),
    "MonthStart",      DATE ( YEAR ( [Date] ), MONTH ( [Date] ), 1 ),
    "MonthEnd",        EOMONTH ( [Date], 0 ),
    "IsMonthEnd",      IF ( [Date] = EOMONTH ( [Date], 0 ), 1, 0 ),
    // Relative index vs current month (0 = current month, -1 = prior, etc.)
    "RelMonthIndex",   DATEDIFF ( EOMONTH ( [Date], 0 ), EOMONTH ( TODAY (), 0 ), MONTH )
)






import pandas as pd, numpy as np
import matplotlib.pyplot as plt

dfp = scored.copy()

# Limit to latest month if available
if "MONTH_END" in dfp.columns:
    me = pd.to_datetime(dfp["MONTH_END"], errors="coerce")
    if me.notna().any():
        latest = me.max()
        dfp = dfp[me == latest].copy()

# Needed columns
need = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"]
missing = [c for c in need if c not in dfp.columns]

if missing:
    output = pd.DataFrame({"Info": [f"Missing columns for plot: {missing}"], "Found": [list(dfp.columns)]})
else:
    x = pd.to_numeric(dfp["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(dfp["PSI_CONTRIB_ABS"], errors="coerce")
    c = pd.to_numeric(dfp["Cluster_ID"], errors="coerce")

    finite = np.isfinite(x) & np.isfinite(y) & np.isfinite(c)
    pts = pd.DataFrame({"x": x[finite], "y": y[finite], "c": c[finite]}).dropna().drop_duplicates()

    if len(pts) < 3:
        output = pd.DataFrame({"Info": [f"Not enough valid points ({len(pts)}) to plot."], 
                               "ValidPoints": [len(pts)]})
    else:
        fig, ax = plt.subplots()
        sc = ax.scatter(pts["x"], pts["y"], s=30, c=pts["c"], cmap="viridis")
        ax.set_xlabel("Severity (0–100)")
        ax.set_ylabel("PSI_Contrib_Abs")
        ax.set_title("RCs by Severity vs PSI (colored by Cluster)")
        fig.colorbar(sc, ax=ax, label="Cluster_ID")
        fig.tight_layout()
        fig






import pandas as pd

s2 = scored.copy()

# Validate structure
if "MONTH_END" not in s2.columns:
    output = pd.DataFrame({"Info": ["MONTH_END column not found."], "Columns_Found": [list(s2.columns)]})
else:
    s2["__ME"] = pd.to_datetime(s2["MONTH_END"], errors="coerce")
    months = sorted(s2["__ME"].dropna().unique())

    if len(months) < 2:
        output = pd.DataFrame({
            "Info": ["Need ≥2 distinct MONTH_END values to show migration."],
            "Months_Available": [[str(x) for x in months]]
        })
    else:
        last2 = months[-2:]
        mig = (s2[s2["__ME"].isin(last2)]
               .pivot_table(index="RC_DESCRIPTION", columns="__ME", values="Cluster_ID", aggfunc="last"))
        mig.columns = [f"Cluster_{pd.to_datetime(c).date()}" for c in mig.columns]
        mig = mig.reset_index().sort_values("RC_DESCRIPTION")
        output = mig

output






import pandas as pd, numpy as np

# Pull headers & data explicitly from the Excel Table
hdr = xl("RC_ML_Features2[#Headers]")
dat = xl("RC_ML_Features2[#Data]")

# Build DataFrame with forced headers
hdr_list = [str(x) for x in np.array(hdr).ravel()]
df = pd.DataFrame(dat if not hasattr(dat, "values") else dat.values, columns=hdr_list)

# Types
if "MONTH_END" in df.columns:
    df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
          "RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Preview (ensures a visible output)
df.head(10)


import pandas as pd, numpy as np

# Expect df from cell A
def robust_z(s: pd.Series) -> pd.Series:
    med = s.median()
    mad = (s - med).abs().median()
    if not mad or mad == 0:
        std = s.std(ddof=0)
        return (s - s.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s - med) / (1.4826 * mad)

# Pick features (use what exists; need at least two numeric columns)
feat = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feat) < 2:
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    feat = numcols[:2]

# Fallback (no sklearn dependency): MAD-based composite → percentile → score
Z = pd.DataFrame({c: robust_z(df[c].fillna(0)) for c in feat})
comp = Z.abs().sum(axis=1)
pct  = comp.rank(pct=True)
df["Anomaly_Score_0_100"] = (pct*100).round(1)
df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# Keep tidy scored view
scored_cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]
scored = df[scored_cols].copy()

# Return a preview
scored.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[False, False]).head(20)


import pandas as pd

s = scored.copy()
if "MONTH_END" in s.columns:
    lm = pd.to_datetime(s["MONTH_END"], errors="coerce").max()
    latest = s[pd.to_datetime(s["MONTH_END"], errors="coerce") == lm].copy()
else:
    latest = s.copy()

latest = latest.sort_values("Anomaly_Score_0_100", ascending=False).reset_index(drop=True)
latest.head(100)


import pandas as pd

cols = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","Anomaly_Score_0_100"] if c in scored.columns]
cluster_summary = (
    scored.groupby("Cluster_ID")[cols]
          .mean(numeric_only=True)
          .round(3)
          .assign(Count=scored.groupby("Cluster_ID").size())
          .reset_index()
          .sort_values("Cluster_ID")
)
cluster_summary



import pandas as pd

s2 = scored.copy()
if "MONTH_END" not in s2.columns:
    pd.DataFrame({"Info":["MONTH_END column not found in 'scored'."], "Columns_Found":[list(s2.columns)]})
else:
    s2["__ME"] = pd.to_datetime(s2["MONTH_END"], errors="coerce")
    months = sorted(s2["__ME"].dropna().unique())
    if len(months) < 2:
        pd.DataFrame({
            "Info": ["Need at least 2 distinct MONTH_END values to show migration."],
            "Months_Available": [[str(x) for x in months]]
        })
    else:
        last2 = months[-2:]
        mig = (s2[s2["__ME"].isin(last2)]
               .pivot_table(index="RC_DESCRIPTION", columns="__ME", values="Cluster_ID", aggfunc="last"))
        mig.columns = [f"Cluster_{pd.to_datetime(c).date()}" for c in mig.columns]
        mig.reset_index().sort_values("RC_DESCRIPTION")


import pandas as pd, numpy as np
import matplotlib.pyplot as plt

dfp = scored.copy()

# Focus on latest month for clarity (comment this block to plot all months)
if "MONTH_END" in dfp.columns:
    me = pd.to_datetime(dfp["MONTH_END"], errors="coerce")
    if me.notna().any():
        latest = me.max()
        dfp = dfp[me == latest].copy()

need = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"]
missing = [c for c in need if c not in dfp.columns]
if missing:
    pd.DataFrame({"Info":[f"Missing columns for plot: {missing}"], "Found":[list(dfp.columns)]})
else:
    x = pd.to_numeric(dfp["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(dfp["PSI_CONTRIB_ABS"],  errors="coerce")
    c = pd.to_numeric(dfp["Cluster_ID"],       errors="coerce")

    finite = np.isfinite(x) & np.isfinite(y) & np.isfinite(c)
    pts = pd.DataFrame({"x": x[finite], "y": y[finite], "c": c[finite]}).dropna().drop_duplicates()

    if len(pts) < 2:
        pd.DataFrame({"Info":["Not enough valid points to plot after cleaning."], "ValidPoints":[int(len(pts))]})
    else:
        fig, ax = plt.subplots()
        ax.scatter(pts["x"], pts["y"], s=30, c=pts["c"])
        ax.set_xlabel("Severity (0–100)")
        ax.set_ylabel("PSI_Contrib_Abs")
        ax.set_title("RCs by Severity vs PSI (colored by Cluster)")

        def pad(vmin, vmax, pad_ratio=0.05):
            if pd.isna(vmin) or pd.isna(vmax) or vmin == vmax:
                return vmin, vmax
            span = vmax - vmin
            return vmin - span*pad_ratio, vmax + span*pad_ratio

        ax.set_xlim(*pad(pts["x"].min(), pts["x"].max()))
        ax.set_ylim(*pad(pts["y"].min(), pts["y"].max()))
        fig.tight_layout()
        fig  # return the figure so Excel renders it







import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ----- 1) Start from 'scored' and focus on the latest month (toggle this off if you want all months) -----
dfp = scored.copy()

if "MONTH_END" in dfp.columns:
    me = pd.to_datetime(dfp["MONTH_END"], errors="coerce")
    if me.notna().any():
        latest = me.max()
        dfp = dfp[me == latest].copy()

# ----- 2) Ensure required columns exist -----
need = ["SEVERITY_0_100", "PSI_CONTRIB_ABS", "Cluster_ID"]
missing = [c for c in need if c not in dfp.columns]
if missing:
    pd.DataFrame({"Info":[f"Missing columns for plot: {missing}"], "Found":[list(dfp.columns)]})
else:
    # ----- 3) Coerce to numeric and drop non-finite -----
    x = pd.to_numeric(dfp["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(dfp["PSI_CONTRIB_ABS"],  errors="coerce")
    c = pd.to_numeric(dfp["Cluster_ID"],       errors="coerce")

    finite = np.isfinite(x) & np.isfinite(y) & np.isfinite(c)
    x, y, c = x[finite], y[finite], c[finite]

    # Optional: drop exact duplicates so a single point doesn’t hide overlaps
    pts = pd.DataFrame({"x": x, "y": y, "c": c}).dropna().drop_duplicates()

    if len(pts) < 2:
        # Return a small diagnostic instead of 'None'
        pd.DataFrame({
            "Info": ["Not enough valid points to plot after cleaning."],
            "ValidPoints": [int(len(pts))],
            "Hint": ["Check that SEVERITY_0_100 and PSI_CONTRIB_ABS are numeric for the latest month."]
        })
    else:
        # ----- 4) Create one figure and return it as the last expression -----
        fig, ax = plt.subplots()   # one plot only (Python in Excel best practice)
        ax.scatter(pts["x"], pts["y"], s=30, c=pts["c"])
        ax.set_xlabel("Severity (0–100)")
        ax.set_ylabel("PSI_Contrib_Abs")
        ax.set_title("RCs by Severity vs PSI (colored by Cluster)")

        # Improve readability and avoid autoscale edge-clipping
        def pad(vmin, vmax, pad_ratio=0.05):
            if pd.isna(vmin) or pd.isna(vmax) or vmin == vmax:
                return vmin, vmax
            span = vmax - vmin
            return vmin - span*pad_ratio, vmax + span*pad_ratio

        xmin, xmax = pts["x"].min(), pts["x"].max()
        ymin, ymax = pts["y"].min(), pts["y"].max()
        ax.set_xlim(*pad(xmin, xmax))
        ax.set_ylim(*pad(ymin, ymax))

        fig.tight_layout()
        fig  # ← IMPORTANT: return the figure object (no plt.show()) 





import pandas as pd
import matplotlib.pyplot as plt

# ---- choose data to plot (latest month is usually clearest) ----
dfp = scored.copy()
if "MONTH_END" in dfp.columns:
    me = pd.to_datetime(dfp["MONTH_END"], errors="coerce")
    if me.notna().any():
        latest = me.max()
        dfp = dfp[me == latest].copy()

# ---- verify required columns exist and have numeric data ----
need = ["SEVERITY_0_100", "PSI_CONTRIB_ABS", "Cluster_ID"]
missing = [c for c in need if c not in dfp.columns]
if missing:
    pd.DataFrame({"Info":[f"Missing columns: {missing}"], "Found":[list(dfp.columns)]})
else:
    x = pd.to_numeric(dfp["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(dfp["PSI_CONTRIB_ABS"],  errors="coerce")
    c = pd.to_numeric(dfp["Cluster_ID"],       errors="coerce")

    mask = x.notna() & y.notna() & c.notna()
    x, y, c = x[mask], y[mask], c[mask]

    if len(x) < 2:
        pd.DataFrame({"Info":["Not enough valid points to plot"], "Count":[int(len(x))]})
    else:
        fig, ax = plt.subplots()              # <- create a figure
        ax.scatter(x, y, s=30, c=c)           # <- matplotlib only, single plot
        ax.set_xlabel("Severity (0–100)")
        ax.set_ylabel("PSI_Contrib_Abs")
        ax.set_title("RCs by Severity vs PSI (colored by Cluster)")
        fig.tight_layout()

        fig  # <-- IMPORTANT: return the figure object as the LAST expression





import pandas as pd

if "MONTH_END" in scored.columns:
    lm = pd.to_datetime(scored["MONTH_END"], errors="coerce").max()
    out_latest = (scored[pd.to_datetime(scored["MONTH_END"], errors="coerce")==lm]
                  .sort_values("Anomaly_Score_0_100", ascending=False)
                  .reset_index(drop=True))
else:
    out_latest = scored.sort_values("Anomaly_Score_0_100", ascending=False).reset_index(drop=True)

out_latest.head(100)  # <- last expression returns a table


import pandas as pd

if "MONTH_END" in scored.columns:
    s2 = scored.copy()
    s2["__ME"] = pd.to_datetime(s2["MONTH_END"], errors="coerce")
    months = sorted(s2["__ME"].dropna().unique())
    if len(months) >= 2:
        last2 = months[-2:]
        mig = (s2[s2["__ME"].isin(last2)]
               .pivot_table(index="RC_DESCRIPTION", columns="__ME", values="Cluster_ID", aggfunc="last"))
        mig.columns = [f"Cluster_{pd.to_datetime(c).date()}" for c in mig.columns]
        out_mig = mig.reset_index().sort_values("RC_DESCRIPTION")
    else:
        out_mig = pd.DataFrame({
            "Info": ["Need at least 2 distinct MONTH_END values to show migration."],
            "Months_Available": [[str(x) for x in months]]
        })
else:
    out_mig = pd.DataFrame({
        "Info": ["MONTH_END column not found in 'scored'."],
        "Columns_Found": [list(scored.columns)]
    })

out_mig  # <- last expression returns a table


import pandas as pd
import matplotlib.pyplot as plt

need = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"]
if all(c in scored.columns for c in need):
    x = pd.to_numeric(scored["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(scored["PSI_CONTRIB_ABS"], errors="coerce")
    c = pd.to_numeric(scored["Cluster_ID"], errors="coerce")

    plt.figure()
    plt.scatter(x, y, s=30, c=c)
    plt.xlabel("Severity (0–100)")
    plt.ylabel("PSI_Contrib_Abs")
    plt.title("RCs by Severity vs PSI (colored by Cluster)")
    plt.tight_layout()
    plt.show()  # <- force plot render
else:
    pd.DataFrame({"Info":["Missing columns for chart"], "Required":[need], "Found":[list(scored.columns)]})




import pandas as pd, numpy as np

# --- Read headers + data explicitly from the Table ---
hdr = xl("RC_ML_Features2[#Headers]")
dat = xl("RC_ML_Features2[#Data]")

hdr_list = [str(x) for x in np.array(hdr).ravel()]
df = pd.DataFrame(dat if not hasattr(dat, "values") else dat.values, columns=hdr_list)

# Types
if "MONTH_END" in df.columns:
    df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

num_cols = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# --- Minimal anomaly score without sklearn (robust fallback) ---
def robust_z(s: pd.Series) -> pd.Series:
    med = s.median()
    mad = (s - med).abs().median()
    if not mad or mad == 0:
        std = s.std(ddof=0)
        return (s - s.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s - med) / (1.4826 * mad)

feat = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feat) < 2:
    # fallback to any two numeric columns
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    feat = numcols[:2]

Z = pd.DataFrame({c: robust_z(df[c].fillna(0)) for c in feat})
comp = Z.abs().sum(axis=1)
pct  = comp.rank(pct=True)
df["Anomaly_Score_0_100"] = (pct*100).round(1)
df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# Keep tidy scored view
cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]
scored = df[cols].copy()

# ---- RETURN a preview (ensures cell displays something) ----
scored.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[False, False]).head(10)





import pandas as pd

# Expecting 'scored' from step 2; if not, replace with your table var
df_sc = scored.copy()

# Ensure MONTH_END exists and is datetime
if "MONTH_END" in df_sc.columns:
    me = pd.to_datetime(df_sc["MONTH_END"], errors="coerce")
    df_sc = df_sc.assign(__ME=me)
    uniq = sorted(df_sc["__ME"].dropna().unique())
    if len(uniq) >= 2:
        last2 = uniq[-2:]
        mig = (
            df_sc[df_sc["__ME"].isin(last2)]
            .pivot_table(
                index="RC_DESCRIPTION",
                columns="__ME",
                values="Cluster_ID",
                aggfunc="last"
            )
        )
        # Friendlier column names
        mig.columns = [f"Cluster_{pd.to_datetime(c).date()}" for c in mig.columns]
        mig = mig.reset_index().sort_values("RC_DESCRIPTION")
        mig  # <-- last expression: renders the table
    else:
        pd.DataFrame({
            "Info": ["Need at least 2 distinct MONTH_END values to show migration."],
            "Months_Available": [ [str(x) for x in uniq] ]
        })  # <-- renders a diagnostic table
else:
    pd.DataFrame({
        "Info": ["MONTH_END column not found in 'scored'."],
        "Columns_Found": [list(df_sc.columns)]
    })


import pandas as pd
import matplotlib.pyplot as plt

df_plot = scored.copy()  # from step 2

have_cols = all(c in df_plot.columns for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"])
if have_cols:
    x = pd.to_numeric(df_plot["SEVERITY_0_100"], errors="coerce")
    y = pd.to_numeric(df_plot["PSI_CONTRIB_ABS"], errors="coerce")
    c = pd.to_numeric(df_plot["Cluster_ID"], errors="coerce")

    plt.figure()
    plt.scatter(x, y, s=30, c=c)
    plt.xlabel("Severity (0–100)")
    plt.ylabel("PSI_Contrib_Abs")
    plt.title("RCs by Severity vs PSI (colored by Cluster)")
    plt.tight_layout()
    plt.show()  # <-- force render in Python-in-Excel
else:
    pd.DataFrame({
        "Info": ["Missing one or more required columns for the chart."],
        "Required": [["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"]],
        "Found": [list(df_plot.columns)]
    })







import re, pandas as pd, numpy as np

# ---- Pull headers & data explicitly from the Excel table ----
hdr = xl("RC_ML_Features2[#Headers]")
dat = xl("RC_ML_Features2[#Data]")

# Header row -> list; Data -> DataFrame
hdr_list = [str(x) for x in np.array(hdr).ravel()]
df = pd.DataFrame(dat if not hasattr(dat, "values") else dat.values, columns=hdr_list)

# Coerce date
if "MONTH_END" in df.columns:
    df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

# Coerce numerics we’ll use (ignore if missing)
for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Basic sanity peek
df.head(5)


import pandas as pd, numpy as np

def robust_z(s: pd.Series) -> pd.Series:
    med = s.median()
    mad = (s - med).abs().median()
    if not mad or mad == 0:
        std = s.std(ddof=0)
        return (s - s.mean())/std if std else pd.Series(0.0, index=s.index)
    return (s - med) / (1.4826 * mad)

# Feature set (use what exists)
feat = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feat) < 2:
    # fallback: pick any two numeric columns
    numcols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
    feat = numcols[:2]

X = df[feat].fillna(0.0).astype(float)

# Try sklearn; else robust MAD-based composite
try:
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans
    Xs = StandardScaler().fit_transform(X.values)
    km = KMeans(n_clusters=4, n_init=10, random_state=42)
    labels = km.fit_predict(Xs)
    centers = km.cluster_centers_
    dists = np.sqrt(((Xs - centers[labels])**2).sum(axis=1))
    score = (pd.Series(dists).rank(pct=True)*100).round(1)
    df["Cluster_ID"] = labels
    df["Anomaly_Score_0_100"] = score
except Exception:
    Z = pd.DataFrame({c: robust_z(X[c]) for c in X.columns})
    comp = Z.abs().sum(axis=1)
    pct = comp.rank(pct=True)
    df["Anomaly_Score_0_100"] = (pct*100).round(1)
    df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# Keep a clean scored view
scored_cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]
scored = df[scored_cols].copy()

# Show a few
scored.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[False, False]).head(20)


sc = scored.copy()
lm = sc["MONTH_END"].max() if "MONTH_END" in sc.columns else None
if lm is not None:
    sc = sc[sc["MONTH_END"] == lm].copy()

latest_anomalies = sc.sort_values("Anomaly_Score_0_100", ascending=False).reset_index(drop=True)
latest_anomalies.head(100)


summ_cols = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","Anomaly_Score_0_100"] if c in scored.columns]
cluster_summary = (scored.groupby("Cluster_ID")[summ_cols]
                   .mean(numeric_only=True).round(3)
                   .assign(Count=scored.groupby("Cluster_ID").size()))
cluster_summary.reset_index()


if "MONTH_END" in scored.columns:
    # last 2 months present in data
    last2 = sorted(scored["MONTH_END"].dropna().unique())[-2:]
    mig = (scored[scored["MONTH_END"].isin(last2)]
           .pivot_table(index=["RC_DESCRIPTION"],
                        columns="MONTH_END",
                        values="Cluster_ID",
                        aggfunc="last")
           .reset_index())
    # name columns nicer
    if len(last2)==2:
        mig.columns = ["RC_DESCRIPTION", f"Cluster_{last2[0].date()}", f"Cluster_{last2[1].date()}"]
    mig.head(50)
else:
    pd.DataFrame({"Info":["MONTH_END not available"]})


import matplotlib.pyplot as plt

if all(c in scored.columns for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Cluster_ID"]):
    x = scored["SEVERITY_0_100"].astype(float)
    y = scored["PSI_CONTRIB_ABS"].astype(float)
    c = scored["Cluster_ID"].astype(int)

    plt.figure()
    plt.scatter(x, y, s=30, c=c)  # Excel will assign default colors
    plt.xlabel("Severity (0–100)")
    plt.ylabel("PSI_Contrib_Abs")
    plt.title("RCs by Severity vs PSI (colored by Cluster)")
    plt.tight_layout()
else:
    pd.DataFrame({"Info":["Need SEVERITY_0_100, PSI_CONTRIB_ABS, Cluster_ID"]})









# Build a compact, PBI-friendly scored table (latest month only)
df_scored = df.copy()

# Try to detect MONTH_END column (already parsed earlier). If missing, skip filtering.
month_col = None
for c in ["MONTH_END","Month_End","month_end"]:
    if c in df_scored.columns:
        month_col = c; break

if month_col:
    lm = pd.to_datetime(df_scored[month_col], errors="coerce").max()
    scored_latest = df_scored[pd.to_datetime(df_scored[month_col], errors="coerce") == lm].copy()
else:
    scored_latest = df_scored.copy()

# Choose tidy columns (keep what exists)
keep = [c for c in [
    "RC_CODE","RC_DESCRIPTION", month_col,
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c and c in df_scored.columns]

# Sort by anomaly desc
scored_latest = scored_latest[keep].sort_values("Anomaly_Score_0_100", ascending=False)

# Return for copy/paste into a new sheet (or turn into an Excel Table)
scored_latest.head(300)   # adjust row count as you likep





from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# Coerce numerics you need (adjust as needed)
for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"]:
    if c in df.columns: df[c] = pd.to_numeric(df[c], errors="coerce")

X = df[[c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]].fillna(0.0)
X_scaled = StandardScaler().fit_transform(X)
kmeans = KMeans(n_clusters=4, n_init=10, random_state=42).fit(X_scaled)

df["Cluster_ID"] = kmeans.labels_
centers = kmeans.cluster_centers_
dists = ((X_scaled - centers[kmeans.labels_])**2).sum(axis=1)**0.5
df["Anomaly_Score_0_100"] = (pd.Series(dists).rank(pct=True)*100).round(1)

df.head(10)





import pandas as pd
import numpy as np

# 1) Pull headers (1 row) and data (all rows) explicitly from the Excel Table
hdr = xl("RC_ML_Features2[#Headers]")
dat = xl("RC_ML_Features2[#Data]")

# 2) Normalize both into Python objects
# Header row → list of strings
if hasattr(hdr, "values"):
    hdr_list = [str(x) for x in list(np.array(hdr).ravel())]
else:
    # Fallback for DataFrame-like
    hdr_list = [str(x) for x in hdr.iloc[0].tolist()]

# Data → DataFrame
if hasattr(dat, "columns"):
    dat_df = pd.DataFrame(dat.values)  # strip any phantom headers
else:
    dat_df = pd.DataFrame(dat)

# 3) Build the final DataFrame with **forced headers**
df = pd.DataFrame(dat_df.values, columns=hdr_list)

# (Optional) Quick check:
df.head(3)
df.columns.tolist()





import re, pandas as pd, numpy as np

# ---------- Load & header-fix ----------
raw = xl("RC_ML_Features2")
df = pd.DataFrame(raw)

# Promote first row to headers if Excel sent 0..N column labels
def looks_like_no_headers(cols):
    try:
        nums = [int(c) for c in cols]
        return list(range(len(cols))) == nums
    except Exception:
        return False

if looks_like_no_headers(df.columns):
    cols = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = cols

# ---------- Normalize column names (case/spacing/punctuation agnostic) ----------
def slug(s):
    s = str(s).strip().lower()
    s = re.sub(r'[\s\-/]+', '_', s)           # spaces, hyphens -> underscores
    s = re.sub(r'[^a-z0-9_]', '', s)          # drop other punctuation
    s = re.sub(r'_+', '_', s).strip('_')      # collapse repeats
    return s

slug_map = {c: slug(c) for c in df.columns}
inv_slug = {}
for orig, sl in slug_map.items():
    inv_slug.setdefault(sl, orig)  # first occurrence wins

print("Detected columns (normalized):")
print(sorted(slug_map.values()))

# ---------- Flexible alias lookup ----------
def find_col(*aliases):
    for a in aliases:
        a = slug(a)
        if a in inv_slug:
            return inv_slug[a]
    # try contains-based fallback
    for a in aliases:
        a = slug(a)
        candidates = [orig for orig, sl in slug_map.items() if a in sl]
        if candidates:
            return candidates[0]
    return None

# Common alternates you might have used in PBI
c_rcdesc   = find_col("rc_description","rc_desc","rc")
c_rccode   = find_col("rc_code","rc")
c_month    = find_col("month_end","monthend","as_of_date","eom","date")
c_bestmdl  = find_col("best_model","bestmodel")
c_sev      = find_col("severity_0_100","severity_weighted_latest","composite_score","severity")
c_psi_abs  = find_col("psi_contrib_abs","psi_abs","psi_contrib_abs_of_total")
c_psi      = find_col("psi_contrib","psi")
c_zresid   = find_col("z_resid","zresid")
c_zmomabs  = find_col("z_mom_abs","zmomabs")
c_zmompct  = find_col("z_mom_pct","zmompct","mom_pct_abs")
c_rmse     = find_col("rmse")
c_absresid = find_col("absresid","abs_resid")
c_momabs   = find_col("mom_abs")
c_mompct   = find_col("mom_pct_abs","mom_pct")

# ---------- Build/repair key signals if originals are missing ----------
# Coerce numerics when found
for cn in [c_sev, c_psi_abs, c_psi, c_zresid, c_zmomabs, c_zmompct, c_rmse, c_absresid, c_momabs, c_mompct]:
    if cn and cn in df.columns:
        df[cn] = pd.to_numeric(df[cn], errors="coerce")

# If PSI_ABS missing, derive from PSI_CONTRIB (absolute)
if c_psi_abs is None and c_psi is not None:
    c_psi_abs = "__psi_abs_derived__"
    df[c_psi_abs] = df[c_psi].abs()

# If severity missing, create a proxy from available anomalies
if c_sev is None:
    parts = []
    if c_absresid: parts.append(df[c_absresid].abs())
    if c_zresid:   parts.append(df[c_zresid].abs())
    if c_zmomabs:  parts.append(df[c_zmomabs].abs())
    if c_momabs:   parts.append(df[c_momabs].abs())
    if parts:
        sev_proxy = pd.concat(parts, axis=1).fillna(0).sum(axis=1)
        # percentile 0..100
        c_sev = "__severity_proxy__"
        df[c_sev] = (sev_proxy.rank(pct=True) * 100).round(1)

# If Z_MOM_PCT missing, try MOM_PCT
if c_zmompct is None and c_mompct is not None:
    c_zmompct = c_mompct  # use raw pct change if z not available

# ---------- Build feature set from what's available ----------
feature_candidates = [(c_sev, "severity"),
                      (c_psi_abs, "psi_abs"),
                      (c_zresid, "z_resid"),
                      (c_zmomabs, "z_mom_abs"),
                      (c_zmompct, "z_mom_pct")]

chosen = [cn for cn, _ in feature_candidates if cn is not None]
chosen = [cn for cn in chosen if cn in df.columns]

print("\nChosen feature columns (original names):", chosen)

if len(chosen) < 2:
    raise ValueError(
        "Not enough usable feature columns. "
        "Please ensure at least two of these exist in the Excel table: "
        "Severity (or proxy), PSI_CONTRIB_ABS (or PSI_CONTRIB), Z_RESID, Z_MOM_ABS, Z_MOM_PCT/MOM_PCT."
    )

X = df[chosen].astype(float).fillna(0.0)

# ---------- Cluster & anomaly (with sklearn if available, robust fallback otherwise) ----------
def robust_z(s: pd.Series) -> pd.Series:
    med = s.median()
    mad = (s - med).abs().median()
    if not mad or mad == 0:
        std = s.std(ddof=0)
        return (s - s.mean())/std if std and std != 0 else pd.Series(0.0, index=s.index)
    return (s - med) / (1.4826 * mad)

try:
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans
    Xs = StandardScaler().fit_transform(X.values)
    kmeans = KMeans(n_clusters=4, n_init=10, random_state=42)
    labels = kmeans.fit_predict(Xs)
    centers = kmeans.cluster_centers_
    dists = np.sqrt(((Xs - centers[labels])**2).sum(axis=1))
    anomaly = (pd.Series(dists).rank(pct=True) * 100).round(1)
    df["Cluster_ID"] = labels
    df["Anomaly_Score_0_100"] = anomaly
except Exception:
    Z = pd.DataFrame({c: robust_z(X[c]) for c in X.columns})
    comp = Z.abs().sum(axis=1)
    pct  = comp.rank(pct=True)
    df["Anomaly_Score_0_100"] = (pct * 100).round(1)
    df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# ---------- Tidy output ----------
if c_month and c_month in df.columns:
    try:
        df[c_month] = pd.to_datetime(df[c_month], errors="coerce")
    except Exception:
        pass

cols_out = [c for c in [
    c_rccode, c_rcdesc, c_month, c_bestmdl,
    c_sev, c_psi_abs, c_zresid, c_zmomabs, c_zmompct, c_rmse,
    "Cluster_ID", "Anomaly_Score_0_100"
] if c and c in df.columns]

if c_month and c_month in df.columns:
    out = df.sort_values([c_month, "Anomaly_Score_0_100"], ascending=[False, False])[cols_out]
else:
    out = df.sort_values("Anomaly_Score_0_100", ascending=False)[cols_out]

# Show the first 50 scored rows
out.head(50)





ValueError: Not enough feature columns. Need ≥2 from ['SEVERITY_0_100', 'PSI_CONTRIB_ABS', 'Z_RESID', 'Z_MOM_ABS', 'Z_MOM_PCT']. Found: []







import pandas as pd
import numpy as np

# ========= 1) Load table; auto-fix headers if needed =========
raw = xl("RC_ML_Features2")
df = pd.DataFrame(raw)

# If Python saw generic 0..N column labels, promote first row to headers
def looks_like_no_headers(cols):
    try:
        nums = [int(c) for c in cols]
        return list(range(len(cols))) == nums
    except Exception:
        return False

if looks_like_no_headers(df.columns):
    cols = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = cols

# Standardize column name cases for robust lookup (but keep original df as-is)
lc = {c: str(c).strip().lower() for c in df.columns}
inv = {v: k for k, v in lc.items()}

def colname(*alts):
    for a in alts:
        key = a.lower()
        if key in inv: return inv[key]
    return None

# ========= 2) Parse date & coerce numeric fields (only if present) =========
c_month   = colname("MONTH_END","monthend","as_of_date","eom")
if c_month:
    df[c_month] = pd.to_datetime(df[c_month], errors="coerce")

num_candidates = [
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
    "RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"
]
for nc in num_candidates:
    cn = colname(nc)
    if cn:
        df[cn] = pd.to_numeric(df[cn], errors="coerce")

# ========= 3) Build feature matrix (need ≥2 available) =========
feat_wishlist = ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"]
feature_cols = [colname(x) for x in feat_wishlist]
feature_cols = [c for c in feature_cols if c is not None]

if len(feature_cols) < 2:
    raise ValueError(f"Not enough feature columns. Need ≥2 from {feat_wishlist}. Found: {feature_cols}")

X = df[feature_cols].astype(float).fillna(0.0)

# ========= 4) Try sklearn KMeans; else robust fallback =========
def robust_z(x: pd.Series) -> pd.Series:
    med = x.median()
    mad = (x - med).abs().median()
    if mad is None or mad == 0:
        std = x.std(ddof=0)
        return (x - x.mean())/std if std and std != 0 else pd.Series(0.0, index=x.index)
    return (x - med) / (1.4826 * mad)

try:
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans

    X_scaled = StandardScaler().fit_transform(X.values)
    kmeans = KMeans(n_clusters=4, n_init=10, random_state=42)
    labels = kmeans.fit_predict(X_scaled)
    centers = kmeans.cluster_centers_
    dists = np.sqrt(((X_scaled - centers[labels])**2).sum(axis=1))
    anomaly = (pd.Series(dists).rank(pct=True) * 100).round(1)

    df["Cluster_ID"] = labels
    df["Anomaly_Score_0_100"] = anomaly

except Exception:
    # Fallback: robust z per feature, sum |z|, percentile → score; quartile bins → pseudo-clusters
    Z = pd.DataFrame({c: robust_z(X[c]) for c in X.columns})
    composite = Z.abs().sum(axis=1)
    pct = composite.rank(pct=True)
    df["Anomaly_Score_0_100"] = (pct * 100).round(1)
    df["Cluster_ID"] = pd.qcut(pct, q=[0,.25,.5,.75,1.0], labels=[0,1,2,3]).astype(int)

# ========= 5) Return one tidy table (avoid #CALC) =========
c_rcdesc = colname("RC_DESCRIPTION","rc_desc","rc")
c_rccode = colname("RC_CODE","rc_code")
cols_out = [c for c in [
    c_rccode, c_rcdesc, c_month,
    colname("BEST_MODEL"),
    colname("SEVERITY_0_100"),
    colname("PSI_CONTRIB_ABS"),
    colname("Z_RESID"),
    colname("Z_MOM_ABS"),
    colname("Z_MOM_PCT"),
    colname("RMSE"),
    "Cluster_ID", "Anomaly_Score_0_100"
] if c is not None]

# Sort latest month first (if we have dates), then anomaly desc
if c_month:
    out = df.sort_values([c_month, "Anomaly_Score_0_100"], ascending=[False, False])[cols_out]
else:
    out = df.sort_values("Anomaly_Score_0_100", ascending=False)[cols_out]

out.head(50)






import pandas as pd
import numpy as np

# ========= 1) Load from Excel table & assign headers robustly =========
raw = xl("RC_ML_Features2")
df = pd.DataFrame(raw)

expected_headers = [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","FORECAST_SELECTED",
    "ACTUAL","RESID","ABSRESID","MOM_ABS","MOM_PCT_ABS","Z_RESID","Z_MOM_ABS",
    "Z_MOM_PCT","RMSE","PI_LO","PI_HI","SEVERITY_0_100","PERSISTENT_OUTLIER_3OF6",
    "REASON_CODE","EXP_SUM","PREV_EXP_SUM","DELTA_EXP","PCT_SHARE","PREV_PCT",
    "DELTA_PCT","PSI_CONTRIB","PSI_TOTAL","PSI_CONTRIB_PCT_OF_TOTAL","RC_PSI_CLASS",
    "RC_PSI_ALERT_FLAG","PSI_CONTRIB_ABS"
]
df.columns = expected_headers[: len(df.columns)]

# Parse dates if present
if "MONTH_END" in df.columns:
    df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

# Numeric coercion (only for columns that exist)
num_cols_wanted = [
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
    "RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"
]
for c in num_cols_wanted:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ========= 2) Feature matrix (pick what exists; need ≥2) =========
feature_cols = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feature_cols) < 2:
    raise ValueError(f"Not enough feature columns. Need ≥2 from "
                     f"{['SEVERITY_0_100','PSI_CONTRIB_ABS','Z_RESID','Z_MOM_ABS','Z_MOM_PCT']}. Got: {feature_cols}")

X = df[feature_cols].copy()

# ========= 3) Try sklearn KMeans; else robust fallback =========
def robust_z(x: pd.Series) -> pd.Series:
    med = x.median()
    mad = (x - med).abs().median()
    # Avoid divide-by-zero: if MAD==0, fallback to std; if still 0, return 0s
    if mad is None or mad == 0:
        std = x.std(ddof=0)
        return (x - x.mean())/std if std and std != 0 else pd.Series(0.0, index=x.index)
    return (x - med) / (1.4826 * mad)

try:
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans

    X_scaled = StandardScaler().fit_transform(X.fillna(0.0).values)
    kmeans = KMeans(n_clusters=4, n_init=10, random_state=42)
    labels = kmeans.fit_predict(X_scaled)

    centers = kmeans.cluster_centers_
    dists = np.sqrt(((X_scaled - centers[labels])**2).sum(axis=1))
    anomaly = pd.Series(dists).rank(pct=True)*100

    df["Cluster_ID"] = labels
    df["Anomaly_Score_0_100"] = anomaly.round(1)

except Exception:
    # --------- Fallback (no sklearn) ----------
    # Robustly standardize each feature with MAD, then sum absolute z's
    Z = pd.DataFrame({c: robust_z(X[c].fillna(X[c].median())) for c in feature_cols})
    composite = Z.abs().sum(axis=1)
    # Use quantiles to assign 4 "clusters" purely for segmentation purposes
    # (not true clustering but keeps the UX similar)
    q = composite.rank(pct=True)
    df["Cluster_ID"] = pd.qcut(q, q=[0, .25, .5, .75, 1.0], labels=[0,1,2,3]).astype(int)
    df["Anomaly_Score_0_100"] = (q*100).round(1)

# ========= 4) Single output (avoid #CALC by returning ONE object) =========
keep_cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]

# Sort latest month first (if MONTH_END exists), then by anomaly desc
if "MONTH_END" in df.columns:
    out = df.sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[False, False])[keep_cols]
else:
    out = df.sort_values(["Anomaly_Score_0_100"], ascending=[False])[keep_cols]

# Show top 50 rows (you can change this)
out.head(50)






import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# ========= 1) Load from Excel table & assign headers robustly =========
raw = xl("RC_ML_Features2")
df = pd.DataFrame(raw)

# Your expected headers (full superset).
expected_headers = [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","FORECAST_SELECTED",
    "ACTUAL","RESID","ABSRESID","MOM_ABS","MOM_PCT_ABS","Z_RESID","Z_MOM_ABS",
    "Z_MOM_PCT","RMSE","PI_LO","PI_HI","SEVERITY_0_100","PERSISTENT_OUTLIER_3OF6",
    "REASON_CODE","EXP_SUM","PREV_EXP_SUM","DELTA_EXP","PCT_SHARE","PREV_PCT",
    "DELTA_PCT","PSI_CONTRIB","PSI_TOTAL","PSI_CONTRIB_PCT_OF_TOTAL","RC_PSI_CLASS",
    "RC_PSI_ALERT_FLAG","PSI_CONTRIB_ABS"
]

# Align header list to the actual number of columns coming from Excel
df.columns = expected_headers[: len(df.columns)]

# ========= 2) Clean types =========
# Parse dates if present
if "MONTH_END" in df.columns:
    df["MONTH_END"] = pd.to_datetime(df["MONTH_END"], errors="coerce")

# Coerce numeric fields that are useful for ML (only those that exist)
num_candidates = [
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
    "RMSE","EXP_SUM","DELTA_EXP","MOM_ABS","MOM_PCT_ABS","PSI_CONTRIB"
]
for c in num_candidates:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ========= 3) Build feature matrix (only existing cols) =========
feature_cols = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"] if c in df.columns]
if len(feature_cols) < 2:
    raise ValueError(f"Not enough feature columns found. Need ≥2 from {['SEVERITY_0_100','PSI_CONTRIB_ABS','Z_RESID','Z_MOM_ABS','Z_MOM_PCT']}. Got: {feature_cols}")

X = df[feature_cols].fillna(0.0).astype(float)

# ========= 4) Scale + KMeans cluster =========
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

k = 4  # tune if needed
kmeans = KMeans(n_clusters=k, n_init=10, random_state=42)
labels = kmeans.fit_predict(X_scaled)
df["Cluster_ID"] = labels

# ========= 5) Anomaly score (distance to assigned centroid) =========
centers = kmeans.cluster_centers_
dists = np.sqrt(((X_scaled - centers[labels])**2).sum(axis=1))
df["Anomaly_Score_0_100"] = (pd.Series(dists).rank(pct=True) * 100).round(1)

# ========= 6) Helpful views =========
# Scored rows (keep key fields)
keep_cols = [c for c in [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","SEVERITY_0_100",
    "PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE",
    "Cluster_ID","Anomaly_Score_0_100"
] if c in df.columns]

scored = df[keep_cols].sort_values(["MONTH_END","Anomaly_Score_0_100"], ascending=[True, False])

# Cluster summary (how each cluster behaves on average)
summary_cols = [c for c in ["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT","RMSE","Anomaly_Score_0_100"] if c in df.columns]
cluster_summary = (
    df.groupby("Cluster_ID")[summary_cols]
      .mean(numeric_only=True)
      .round(3)
      .assign(Count=df.groupby("Cluster_ID").size().values)
      .reset_index()
      .sort_values("Cluster_ID")
)

# Return two outputs: (1) top anomalous recent rows, (2) cluster summary
# If your sheet only renders one object, comment out one of the two.
scored.head(50), cluster_summary










import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# === Step 1: Load and assign headers manually ===
raw = xl("RC_ML_Features2")
df = pd.DataFrame(raw)

df.columns = [
    "RC_CODE","RC_DESCRIPTION","MONTH_END","BEST_MODEL","FORECAST_SELECTED",
    "ACTUAL","RESID","ABSRESID","MOM_ABS","MOM_PCT_ABS","Z_RESID","Z_MOM_ABS",
    "Z_MOM_PCT","RMSE","PI_LO","PI_HI","SEVERITY_0_100","PERSISTENT_OUTLIER_3OF6",
    "REASON_CODE","EXP_SUM","PREV_EXP_SUM","DELTA_EXP","PCT_SHARE","PREV_PCT",
    "DELTA_PCT","PSI_CONTRIB","PSI_TOTAL","PSI_CONTRIB_PCT_OF_TOTAL","RC_PSI_CLASS",
    "RC_PSI_ALERT_FLAG","PSI_CONTRIB_ABS"
]

# === Step 2: Convert key numeric columns ===
num_cols = [
    "SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT",
    "RMSE","EXP_SUM","DELTA_EXP"
]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce").fillna(0)

# === Step 3: Normalize features for clustering ===
X = df[["SEVERITY_0_100","PSI_CONTRIB_ABS","Z_RESID","Z_MOM_ABS","Z_MOM_PCT"]]
X_scaled = StandardScaler().fit_transform(X)

# === Step 4: K-Means Clustering (RC similarity groups) ===
kmeans = KMeans(n_clusters=4, n_init=10, random_state=42)
df["Cluster_ID"] = kmeans.fit_predict(X_scaled)

# === Step 5: Compute anomaly distance (distance to cluster centroid) ===
centers = kmeans.cluster_centers_
dists = np.sqrt(((X_scaled - centers[kmeans.labels_]) ** 2).sum(axis=1))
df["Anomaly_Score_0_100"] = (pd.Series(dists).rank(pct=True) * 100).round(1)

# === Step 6: Output the most anomalous RCs ===
result = df[[
    "RC_DESCRIPTION","MONTH_END","SEVERITY_0_100","PSI_CONTRIB_ABS",
    "Z_RESID","Z_MOM_ABS","Z_MOM_PCT","Cluster_ID","Anomaly_Score_0_100"
]].sort_values("Anomaly_Score_0_100", ascending=False)

result.head(10)





import pandas as pd

# Pull the table from Excel (replace with your table name if different)
raw = xl("RC_ML_Features2")

# Convert to DataFrame if needed
if not hasattr(raw, "columns"):
    raw = pd.DataFrame(raw)

# Promote first row to headers
cols = raw.iloc[0].astype(str).tolist()
df = raw.iloc[1:].reset_index(drop=True)
df.columns = cols

# Optional: convert numeric fields to numbers
num_cols = ["SEVERITY_0_100", "PSI_CONTRIB_ABS", "Z_RESID", "Z_MOM_ABS", "Z_MOM_PCT"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df.head()





=PY("
import pandas as pd

raw = xlargs[0]                      # the table (headers+data) as a 2D array/df
# If raw is a numpy array, convert to DataFrame
if not hasattr(raw, 'columns'):
    raw = pd.DataFrame(raw)

# First row is headers
cols = raw.iloc[0].astype(str).tolist()
df   = raw.iloc[1:].reset_index(drop=True)
df.columns = cols

# Make numeric columns numeric (ignore if missing)
num_cols = ['SEVERITY_0_100','PSI_CONTRIB_ABS','Z_RESID','Z_MOM_ABS','Z_MOM_PCT']
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors='coerce')

df
", RC_ML_Features2[#All])





import pandas as pd

# 👉 update the path/filename to where you saved it
df = pd.read_csv(r"C:\YourPath\RC_ML_Features.csv")   # or: pd.read_excel(r"C:\YourPath\RC_ML_Features.xlsx")
df.head(3)







# Python in Excel: RC clustering + anomaly score from an Excel Table
import pandas as pd
import numpy as np

# Excel table access
from excel import xl

# ---- Load ----
df = xl("RC_ML_Features")  # <-- Excel Table name

# ---- Normalize column names (robust to case/underscores) ----
def norm(s): return str(s).strip().lower()
df.columns = [norm(c) for c in df.columns]

# ---- Required columns (adjust if your names differ) ----
need = {
    "rc_description": ["rc_description","rc_desc","rc"],
    "month_end": ["month_end","monthend","as_of_date","eom"],
    "severity": ["severity_0_100","composite_score","severity"],
    "psi_abs": ["psi_contrib_abs","psi_abs","psi_contrib"],
    "z_resid": ["z_resid","z_residual"],
    "z_mom_abs": ["z_mom_abs","z_mom_abs_chg","zmomabs"],
    "mom_pct": ["z_mom_pct","mom_pct_abs","mom_pct"]
}

def pick(colalts):
    for a in colalts:
        if a in df.columns: return a
    return None

colmap = {k: pick(v) for k,v in need.items()}
missing = [k for k,v in colmap.items() if v is None]
if missing:
    raise ValueError(f"Missing columns for: {missing}. Found columns: {list(df.columns)}")

# ---- Feature frame (fill NaNs with 0 for modeling) ----
feat = pd.DataFrame({
    "severity":   df[colmap["severity"]].astype(float),
    "psi_abs":    df[colmap["psi_abs"]].astype(float),
    "z_resid":    df[colmap["z_resid"]].astype(float),
    "z_mom_abs":  df[colmap["z_mom_abs"]].astype(float),
    "mom_pct":    df[colmap["mom_pct"]].astype(float)
}).fillna(0.0)

# ---- Scaling ----
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(feat.values)

# ---- Clustering (KMeans) with a small k by default; tune if needed ----
from sklearn.cluster import KMeans
k = 4
kmeans = KMeans(n_clusters=k, n_init=10, random_state=42)
cluster_id = kmeans.fit_predict(X)

# ---- Simple anomaly score (distance to cluster center; higher = more anomalous) ----
# Distances to the assigned centroid in scaled space
centers = kmeans.cluster_centers_
dists = np.sqrt(((X - centers[cluster_id])**2).sum(axis=1))
# Normalize 0..100 (robust scaling)
p = pd.Series(dists).rank(pct=True)
anomaly_score_0_100 = (p*100).round(1)

# ---- Output result: per row add Cluster_ID and Anomaly_Score ----
out = df.copy()
out["cluster_id"] = cluster_id
out["anomaly_score_0_100"] = anomaly_score_0_100

# (optional) Latest-month only view (uncomment):
# lm = pd.to_datetime(out[colmap["month_end"]]).max()
# out = out[pd.to_datetime(out[colmap["month_end"]]) == lm]

# Return to Excel grid
out







SELECT *
FROM (
    SELECT * FROM snapshot
    WHERE (SELECT p_section FROM params) IN ('SNAPSHOT_TREND','ALL')
    UNION ALL
    SELECT * FROM trend
    WHERE (SELECT p_section FROM params) IN ('SNAPSHOT_TREND','ALL')
    UNION ALL
    SELECT * FROM mom_decomp
    WHERE (SELECT p_section FROM params) IN ('MOM_DECOMP','ALL')
    UNION ALL
    SELECT * FROM mom_waterfall
    WHERE (SELECT p_section FROM params) IN ('MOM_WATERFALL','ALL')
    UNION ALL
    SELECT * FROM top_movers
    WHERE (SELECT p_section FROM params) IN ('TOP_MOVERS','ALL')
    UNION ALL
    SELECT * FROM volatility
    WHERE (SELECT p_section FROM params) IN ('VOLATILITY','ALL')
) u
ORDER BY
  1,        -- section
  2 DESC,   -- month_end
  3,        -- synthetic_category ('BAL' or 'COUNT' here)
  4,        -- contract_source_system
  5,        -- gl_account_code
  32 DESC;  -- sort_key






/* ---------- MOM_WATERFALL (balances & counts) ---------- */
-- prev synthetic universe & curr synthetic universe exist as cur_syn / prev_syn in your script
paired AS (
  SELECT
    COALESCE(c.account_identifier, p.account_identifier)             AS account_identifier,
    -- prev side
    p.contract_source_system AS prev_css,
    p.gl_account_code        AS prev_gl,
    p.gl_account_description AS prev_gl_desc,
    p.exposure               AS prev_exp,
    CASE WHEN p.account_identifier IS NOT NULL THEN 1 ELSE 0 END    AS prev_is_synth,
    -- curr side
    c.contract_source_system AS cur_css,
    c.gl_account_code        AS cur_gl,
    c.gl_account_description AS cur_gl_desc,
    c.exposure               AS cur_exp,
    CASE WHEN c.account_identifier IS NOT NULL THEN 1 ELSE 0 END    AS cur_is_synth
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.account_identifier = p.account_identifier
),

-- Per-bucket contributions (balances)
wb AS (
  -- Prev balance (by previous bucket)
  SELECT prev_css AS css, prev_gl AS gl, MAX(prev_gl_desc) AS gl_desc,
         SUM(prev_exp) AS prev_bal,
         0.0::FLOAT8 AS adds_bal, 0.0::FLOAT8 AS drops_bal,
         0.0::FLOAT8 AS transfers_in_bal, 0.0::FLOAT8 AS transfers_out_bal,
         0.0::FLOAT8 AS persist_bal,
         0::INT AS prev_cnt, 0::INT AS adds_cnt, 0::INT AS drops_cnt,
         0::INT AS transfers_in_cnt, 0::INT AS transfers_out_cnt, 0::INT AS persist_cnt
  FROM paired
  WHERE prev_is_synth=1
  GROUP BY prev_css, prev_gl

  UNION ALL
  -- Curr balance (by current bucket)
  SELECT cur_css, cur_gl, MAX(cur_gl_desc),
         0.0, 0.0, 0.0, 0.0, 0.0,
         0.0,
         0,0,0,0,0,0
  FROM paired
  WHERE cur_is_synth=1
  GROUP BY cur_css, cur_gl

  UNION ALL
  -- Adds: non-synth prev -> synth now in this bucket
  SELECT cur_css, cur_gl, MAX(cur_gl_desc),
         0.0, SUM(cur_exp), 0.0, 0.0, 0.0, 0.0,
         0, SUM(1), 0, 0, 0, 0
  FROM paired
  WHERE prev_is_synth=0 AND cur_is_synth=1
  GROUP BY cur_css, cur_gl

  UNION ALL
  -- Drops: synth prev in this bucket -> non-synth now
  SELECT prev_css, prev_gl, MAX(prev_gl_desc),
         0.0, 0.0, SUM(prev_exp), 0.0, 0.0, 0.0,
         0, 0, SUM(1), 0, 0, 0
  FROM paired
  WHERE prev_is_synth=1 AND cur_is_synth=0
  GROUP BY prev_css, prev_gl

  UNION ALL
  -- Transfers IN: synth prev elsewhere -> synth now in this bucket
  SELECT cur_css, cur_gl, MAX(cur_gl_desc),
         0.0, 0.0, 0.0, SUM(cur_exp), 0.0, 0.0,
         0, 0, 0, SUM(1), 0, 0
  FROM paired
  WHERE prev_is_synth=1 AND cur_is_synth=1
    AND (prev_css<>cur_css OR prev_gl<>cur_gl)
  GROUP BY cur_css, cur_gl

  UNION ALL
  -- Transfers OUT: synth prev in this bucket -> synth now elsewhere
  SELECT prev_css, prev_gl, MAX(prev_gl_desc),
         0.0, 0.0, 0.0, 0.0, SUM(prev_exp)*(-1.0), 0.0,
         0, 0, 0, 0, SUM(1), 0
  FROM paired
  WHERE prev_is_synth=1 AND cur_is_synth=1
    AND (prev_css<>cur_css OR prev_gl<>cur_gl)
  GROUP BY prev_css, prev_gl

  UNION ALL
  -- Persisting balance change: stayed in same bucket (cur - prev)
  SELECT cur_css, cur_gl, MAX(cur_gl_desc),
         0.0, 0.0, 0.0, 0.0, 0.0, SUM(cur_exp - prev_exp),
         0, 0, 0, 0, 0, SUM(1)
  FROM paired
  WHERE prev_is_synth=1 AND cur_is_synth=1
    AND prev_css=cur_css AND prev_gl=cur_gl
  GROUP BY cur_css, cur_gl
),

waterfall AS (
  SELECT
    CAST('MOM_WATERFALL' AS VARCHAR(20)) AS section,
    (SELECT latest_me FROM latest)        AS month_end,
    -- BALANCE rows
    CAST('BAL' AS VARCHAR(12))           AS synthetic_category,
    CAST(css AS VARCHAR(128))            AS contract_source_system,
    CAST(gl AS INTEGER)                  AS gl_account_code,
    CAST(MAX(gl_desc) AS VARCHAR(256))   AS gl_account_description,
    CAST(NULL AS VARCHAR(128))           AS account_identifier,

    -- Balances mapped to existing columns
    SUM(prev_bal)                        AS exposure_prev,
    -- Cur is computed at the end; we still keep it here in case you want to inspect
    SUM(0.0)::FLOAT8                     AS exposure_cur,

    -- For the visual, the steps are: Adds, Drops, Transfers (net), Persisting
    CAST(NULL AS FLOAT8)                 AS delta_total,
    SUM(persist_bal)                     AS cont_growth,         -- Persisting balance change
    SUM(adds_bal)                        AS adds,
    SUM(drops_bal)*(-1.0)                AS drops,               -- make Drops negative for clarity
    -- Snapshot columns (not used here)
    CAST(NULL AS INTEGER)                AS rows_flagged,
    CAST(NULL AS INTEGER)                AS accounts_flagged,
    CAST(NULL AS FLOAT8)                 AS exposure_sum,
    CAST(NULL AS FLOAT8)                 AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                 AS exposure_abs_avg,
    (SELECT prior_me FROM prior)         AS prev_month_end,
    CAST(NULL AS FLOAT8)                 AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                 AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                AS hist_months,
    CAST(NULL AS FLOAT8)                 AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                 AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                 AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                 AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                 AS zscore_abs,
    CAST(NULL AS FLOAT8)                 AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                 AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                 AS volatility_cv_abs,

    -- We’ll carry Transfers Net in exposure_delta, and compute Curr & Sort last
    (SUM(transfers_in_bal) + SUM(transfers_out_bal))  AS exposure_delta,
    -- sort_key
    ABS( (SUM(adds_bal) - SUM(drops_bal)) + (SUM(transfers_in_bal)+SUM(transfers_out_bal)) + SUM(persist_bal) )
      ::FLOAT8 AS sort_key

  FROM wb
  GROUP BY css, gl

  UNION ALL

  -- COUNT rows: reuse the same numeric columns but filled with counts
  SELECT
    CAST('MOM_WATERFALL' AS VARCHAR(20)) AS section,
    (SELECT latest_me FROM latest)        AS month_end,
    CAST('COUNT' AS VARCHAR(12))          AS synthetic_category,
    CAST(css AS VARCHAR(128))             AS contract_source_system,
    CAST(gl AS INTEGER)                   AS gl_account_code,
    CAST(MAX(gl_desc) AS VARCHAR(256))    AS gl_account_description,
    CAST(NULL AS VARCHAR(128))            AS account_identifier,

    -- Counts mapped into the same fields
    SUM(prev_cnt)::FLOAT8                 AS exposure_prev,      -- prev count
    SUM(0)::FLOAT8                        AS exposure_cur,       -- (computed in outer SELECT if needed)
    CAST(NULL AS FLOAT8)                  AS delta_total,
    SUM(persist_cnt)::FLOAT8              AS cont_growth,        -- persisting count (informational)
    SUM(adds_cnt)::FLOAT8                 AS adds,               -- adds count
    (SUM(drops_cnt) * 1.0)::FLOAT8        AS drops,              -- drops count (positive)
    CAST(NULL AS INTEGER)                 AS rows_flagged,
    CAST(NULL AS INTEGER)                 AS accounts_flagged,
    CAST(NULL AS FLOAT8)                  AS exposure_sum,
    CAST(NULL AS FLOAT8)                  AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                  AS exposure_abs_avg,
    (SELECT prior_me FROM prior)          AS prev_month_end,
    CAST(NULL AS FLOAT8)                  AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                  AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                 AS hist_months,
    CAST(NULL AS FLOAT8)                  AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                  AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                  AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                  AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                  AS zscore_abs,
    CAST(NULL AS FLOAT8)                  AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                  AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                  AS volatility_cv_abs,

    -- Transfers Net count (In – Out) into exposure_delta
    (SUM(transfers_in_cnt) - SUM(transfers_out_cnt))::FLOAT8  AS exposure_delta,
    -- sort_key by absolute net change in count
    ABS( (SUM(adds_cnt) - SUM(drops_cnt)) + (SUM(transfers_in_cnt) - SUM(transfers_out_cnt)) )
      ::FLOAT8 AS sort_key
  FROM wb
  GROUP BY css, gl
),

-- Finalize current values for both BAL and COUNT rows (recompute curr from prev + steps)
mom_waterfall AS (
  SELECT
    w.section, w.month_end, w.synthetic_category,
    w.contract_source_system, w.gl_account_code, w.gl_account_description,
    w.account_identifier,
    w.exposure_prev,
    /* exposure_cur / curr_count reconstructed for clarity in visuals */
    (w.exposure_prev
      + w.adds
      + (-w.drops)               -- drops is positive; subtract it
      + w.exposure_delta         -- transfers net
      + w.cont_growth            -- persisting balance change
    ) AS exposure_cur,
    w.delta_total, w.cont_growth, w.adds, w.drops,
    w.rows_flagged, w.accounts_flagged,
    w.exposure_sum, w.exposure_abs_sum, w.exposure_abs_avg,
    w.prev_month_end, w.prev_exposure_sum, w.pct_delta_exposure,
    w.hist_months, w.hist_avg_abs_exposure, w.hist_std_abs_exposure,
    w.hist_min_abs_exposure, w.hist_max_abs_exposure, w.zscore_abs,
    w.volatility_avg_abs, w.volatility_std_abs, w.volatility_cv_abs,
    w.exposure_delta,
    w.sort_key
  FROM waterfall w
)






/* ===== RC MoM Movement with Transfers (Netezza-safe; RC_CODE exact) =====
   Categories (adjacent months, active if exposure > active_floor):
     - NEW_ACCOUNT     : prev<=floor or NULL -> curr>floor in THIS RC
     - CLOSED_ACCOUNT  : prev>floor in THIS RC -> next<=floor or NULL (attributed to next month)
     - TRANSFER_IN     : prev>floor in DIFFERENT RC -> curr>floor in THIS RC
     - TRANSFER_OUT    : prev>floor in THIS RC -> curr>floor in DIFFERENT RC
   Outputs (all with same 17 columns for UNION ALL):
     row_type, month_end, rc_code, rc_description,
     prev_total_exposure, new_acct_amt, transfer_in_amt, transfer_out_amt, closed_amt, curr_total_exposure,
     movement_type, acct_count, from_rc_code, to_rc_code, amount, step_label, step_value
========================================================================== */

WITH
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    0.0::FLOAT8 AS active_floor   -- set to e.g. 10000.0 to require a $ floor
),

/* 1) Base rows */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    RC_CODE,
    RC_DESCRIPTION,
    Account_Identifier,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) One row per account×month (highest exposure RC if dupes) */
acct_month AS (
  SELECT
      month_end,
      Account_Identifier,
      RC_CODE        AS rc_code,
      RC_DESCRIPTION AS rc_description,
      exposure
  FROM (
      SELECT
          month_end,
          Account_Identifier,
          RC_CODE,
          RC_DESCRIPTION,
          exposure,
          ROW_NUMBER() OVER (
              PARTITION BY month_end, Account_Identifier
              ORDER BY exposure DESC, RC_CODE
          ) AS rn
      FROM base
  ) s
  WHERE rn = 1
),

/* 3) Add prev/next month info per account */
seq AS (
  SELECT
    a.month_end,
    a.Account_Identifier,
    a.rc_code         AS curr_rc,
    a.rc_description  AS curr_rc_desc,
    a.exposure        AS curr_exp,

    LAG(a.month_end)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_me,
    LAG(a.rc_code)        OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc,
    LAG(a.rc_description) OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc_desc,
    LAG(a.exposure)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_exp,

    LEAD(a.month_end)     OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_me,
    LEAD(a.rc_code)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_rc,
    LEAD(a.exposure)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_exp
  FROM acct_month a
),

/* 4) Inbound to current RC (this month) */
inbound AS (
  SELECT
    s.month_end,
    s.curr_rc        AS rc_code,
    s.curr_rc_desc   AS rc_description,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN 'NEW_ACCOUNT'
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp >  (SELECT active_floor FROM params)
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN 'TRANSFER_IN'
      ELSE NULL
    END AS movement_type,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN s.curr_exp
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp >  (SELECT active_floor FROM params)
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN s.curr_exp
      ELSE 0 END AS amount,
    1 AS acct_count,
    s.prev_rc      AS from_rc_code,
    s.curr_rc      AS to_rc_code
  FROM seq s
  WHERE
    s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.curr_exp > (SELECT active_floor FROM params)
    AND (
          (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
       OR (s.prev_exp >  (SELECT active_floor FROM params) AND s.prev_rc <> s.curr_rc)
    )
),

/* 5) Outbound from previous RC (this month) */
outbound AS (
  -- TRANSFER_OUT: prev>floor in prev_rc -> curr>floor in different rc
  SELECT
    s.month_end,
    s.prev_rc         AS rc_code,
    s.prev_rc_desc    AS rc_description,
    'TRANSFER_OUT'    AS movement_type,
    -s.prev_exp       AS amount,               -- negative
    1                 AS acct_count,
    s.prev_rc         AS from_rc_code,
    s.curr_rc         AS to_rc_code
  FROM seq s
  WHERE s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.prev_exp >  (SELECT active_floor FROM params)
    AND s.curr_exp >  (SELECT active_floor FROM params)
    AND s.prev_rc <> s.curr_rc

  UNION ALL

  -- CLOSED_ACCOUNT: prev>floor and next month <=floor or missing anywhere
  SELECT
    s.next_me         AS month_end,            -- attribute closure to the next month
    s.curr_rc         AS rc_code,
    s.curr_rc_desc    AS rc_description,
    'CLOSED_ACCOUNT'  AS movement_type,
    -s.curr_exp       AS amount,               -- negative
    1                 AS acct_count,
    s.curr_rc         AS from_rc_code,
    NULL              AS to_rc_code
  FROM seq s
  WHERE s.next_me = ADD_MONTHS(s.month_end, 1)
    AND s.curr_exp >  (SELECT active_floor FROM params)
    AND (s.next_exp IS NULL OR s.next_exp <= (SELECT active_floor FROM params))
),

/* 6) Combine movements */
movements AS (
  SELECT * FROM inbound WHERE movement_type IS NOT NULL
  UNION ALL
  SELECT * FROM outbound
),

/* 7) RC-month totals for endpoints */
rc_totals AS (
  SELECT
    month_end,
    curr_rc AS rc_code,
    MAX(curr_rc_desc) AS rc_description,
    SUM(curr_exp)     AS curr_total_exposure
  FROM seq
  GROUP BY month_end, curr_rc
),
rc_totals_with_prev AS (
  SELECT
    t.month_end,
    t.rc_code,
    t.rc_description,
    t.curr_total_exposure,
    LAG(t.curr_total_exposure) OVER (PARTITION BY t.rc_code ORDER BY t.month_end) AS prev_total_exposure
  FROM rc_totals t
),

/* 8) Aggregate movements per RC×Month×Type */
rc_movement_agg AS (
  SELECT
    m.month_end,
    m.rc_code,
    MAX(m.rc_description) AS rc_description,
    m.movement_type,
    SUM(m.amount)         AS amount,
    SUM(m.acct_count)     AS acct_count
  FROM movements m
  GROUP BY m.month_end, m.rc_code, m.movement_type
),

/* 9) Pivot-ish summary per RC×Month */
rc_movement_pivot AS (
  SELECT
    a.month_end,
    a.rc_code,
    MAX(a.rc_description) AS rc_description,
    SUM(CASE WHEN a.movement_type='NEW_ACCOUNT'    THEN a.amount ELSE 0 END) AS new_acct_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_IN'    THEN a.amount ELSE 0 END) AS transfer_in_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_OUT'   THEN a.amount ELSE 0 END) AS transfer_out_amt,  -- negative
    SUM(CASE WHEN a.movement_type='CLOSED_ACCOUNT' THEN a.amount ELSE 0 END) AS closed_amt         -- negative
  FROM rc_movement_agg a
  GROUP BY a.month_end, a.rc_code
),

/* 10) Final summary per RC×Month */
summary AS (
  SELECT
    p.month_end,
    p.rc_code,
    p.rc_description,
    COALESCE(t.prev_total_exposure,0) AS prev_total_exposure,
    COALESCE(p.new_acct_amt,0)        AS new_acct_amt,
    COALESCE(p.transfer_in_amt,0)     AS transfer_in_amt,
    COALESCE(p.transfer_out_amt,0)    AS transfer_out_amt,
    COALESCE(p.closed_amt,0)          AS closed_amt,
    COALESCE(t.curr_total_exposure,0) AS curr_total_exposure
  FROM rc_movement_pivot p
  JOIN rc_totals_with_prev t
    ON t.month_end = p.month_end AND t.rc_code = p.rc_code
),

/* 11) Waterfall rows */
waterfall AS (
  SELECT month_end, rc_code, rc_description, 'Prev Total'     AS step_label, prev_total_exposure   AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'New Accounts'   AS step_label, new_acct_amt          AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer In'    AS step_label, transfer_in_amt       AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer Out'   AS step_label, transfer_out_amt      AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Closed'         AS step_label, closed_amt            AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Curr Total'     AS step_label, curr_total_exposure   AS step_value FROM summary
)

/* =================== FINAL OUTPUT (aligned columns) =================== */
SELECT
  'SUMMARY'::VARCHAR(8)                              AS row_type,
  s.month_end                                        AS month_end,
  CAST(s.rc_code AS VARCHAR(64))                     AS rc_code,
  s.rc_description                                   AS rc_description,
  s.prev_total_exposure                              AS prev_total_exposure,
  s.new_acct_amt                                     AS new_acct_amt,
  s.transfer_in_amt                                  AS transfer_in_amt,
  s.transfer_out_amt                                 AS transfer_out_amt,
  s.closed_amt                                       AS closed_amt,
  s.curr_total_exposure                              AS curr_total_exposure,
  CAST(NULL AS VARCHAR(16))                          AS movement_type,
  CAST(NULL AS INTEGER)                              AS acct_count,
  CAST(NULL AS VARCHAR(64))                          AS from_rc_code,
  CAST(NULL AS VARCHAR(64))                          AS to_rc_code,
  CAST(NULL AS FLOAT8)                               AS amount,
  CAST(NULL AS VARCHAR(32))                          AS step_label,
  CAST(NULL AS FLOAT8)                               AS step_value
FROM summary s

UNION ALL

SELECT
  'DETAIL'::VARCHAR(8)                               AS row_type,
  m.month_end                                        AS month_end,
  CAST(m.rc_code AS VARCHAR(64))                     AS rc_code,
  m.rc_description                                   AS rc_description,
  CAST(NULL AS FLOAT8)                               AS prev_total_exposure,
  CAST(NULL AS FLOAT8)                               AS new_acct_amt,
  CAST(NULL AS FLOAT8)                               AS transfer_in_amt,
  CAST(NULL AS FLOAT8)                               AS transfer_out_amt,
  CAST(NULL AS FLOAT8)                               AS closed_amt,
  CAST(NULL AS FLOAT8)                               AS curr_total_exposure,
  m.movement_type                                    AS movement_type,
  m.acct_count                                       AS acct_count,
  CAST(NULL AS VARCHAR(64))                          AS from_rc_code,   -- counterpart RC available at raw 'movements' if needed
  CAST(NULL AS VARCHAR(64))                          AS to_rc_code,
  m.amount                                           AS amount,
  CAST(NULL AS VARCHAR(32))                          AS step_label,
  CAST(NULL AS FLOAT8)                               AS step_value
FROM rc_movement_agg m

UNION ALL

SELECT
  'WATERFALL'::VARCHAR(8)                            AS row_type,
  w.month_end                                        AS month_end,
  CAST(w.rc_code AS VARCHAR(64))                     AS rc_code,
  w.rc_description                                   AS rc_description,
  CAST(NULL AS FLOAT8)                               AS prev_total_exposure,
  CAST(NULL AS FLOAT8)                               AS new_acct_amt,
  CAST(NULL AS FLOAT8)                               AS transfer_in_amt,
  CAST(NULL AS FLOAT8)                               AS transfer_out_amt,
  CAST(NULL AS FLOAT8)                               AS closed_amt,
  CAST(NULL AS FLOAT8)                               AS curr_total_exposure,
  CAST(NULL AS VARCHAR(16))                          AS movement_type,
  CAST(NULL AS INTEGER)                              AS acct_count,
  CAST(NULL AS VARCHAR(64))                          AS from_rc_code,
  CAST(NULL AS VARCHAR(64))                          AS to_rc_code,
  CAST(NULL AS FLOAT8)                               AS amount,
  w.step_label                                       AS step_label,
  w.step_value                                       AS step_value
FROM waterfall w

ORDER BY rc_code, month_end, row_type, step_label;






/* ===== RC MoM Movement with Transfers (Netezza-safe; uses RC_CODE exactly) =====
   Grain: RC_CODE x RC_DESCRIPTION x MONTH_END
   Categories (adjacent months only, exposure>0 considered active):
     - NEW_ACCOUNT     : prev_exp<=0 or NULL (any RC) -> curr_exp>0 in THIS RC
     - CLOSED_ACCOUNT  : prev_exp>0 in THIS RC -> next_exp<=0 or NULL (any RC)  (attributed to next month)
     - TRANSFER_IN     : prev_exp>0 in DIFFERENT RC -> curr_exp>0 in THIS RC
     - TRANSFER_OUT    : prev_exp>0 in THIS RC -> curr_exp>0 in DIFFERENT RC
   Waterfall order: Prev Total → New Accounts → Transfer In → Transfer Out → Closed → Curr Total
=============================================================================== */

WITH
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    0.0::FLOAT8 AS active_floor   -- set to e.g. 10000.0 to use a dollar floor instead of >0
),

/* 1) Base rows (recent window, Total Loans) */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    RC_CODE,
    RC_DESCRIPTION,
    Account_Identifier,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) One row per account×month (pick RC row with highest exposure if dupes) */
acct_month AS (
  SELECT
      month_end,
      Account_Identifier,
      RC_CODE        AS rc_code,
      RC_DESCRIPTION AS rc_description,
      exposure
  FROM (
      SELECT
          month_end,
          Account_Identifier,
          RC_CODE,
          RC_DESCRIPTION,
          exposure,
          ROW_NUMBER() OVER (
              PARTITION BY month_end, Account_Identifier
              ORDER BY exposure DESC, RC_CODE
          ) AS rn
      FROM base
  ) s
  WHERE rn = 1
),

/* 3) Add prev/next month info per account */
seq AS (
  SELECT
    a.month_end,
    a.Account_Identifier,
    a.rc_code         AS curr_rc,
    a.rc_description  AS curr_rc_desc,
    a.exposure        AS curr_exp,

    LAG(a.month_end)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_me,
    LAG(a.rc_code)        OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc,
    LAG(a.rc_description) OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc_desc,
    LAG(a.exposure)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_exp,

    LEAD(a.month_end)     OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_me,
    LEAD(a.rc_code)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_rc,
    LEAD(a.exposure)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_exp
  FROM acct_month a
),

/* 4) Inbound to current RC (this month) */
inbound AS (
  SELECT
    s.month_end,
    s.curr_rc        AS rc_code,
    s.curr_rc_desc   AS rc_description,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN 'NEW_ACCOUNT'
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp >  (SELECT active_floor FROM params)
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN 'TRANSFER_IN'
      ELSE NULL
    END AS movement_type,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN s.curr_exp
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp >  (SELECT active_floor FROM params)
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp >  (SELECT active_floor FROM params)
        THEN s.curr_exp
      ELSE 0 END AS amount,
    1 AS acct_count,
    s.prev_rc      AS from_rc_code,
    s.curr_rc      AS to_rc_code
  FROM seq s
  WHERE
    s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.curr_exp > (SELECT active_floor FROM params)
    AND (
          (s.prev_exp IS NULL OR s.prev_exp <= (SELECT active_floor FROM params))
       OR (s.prev_exp >  (SELECT active_floor FROM params) AND s.prev_rc <> s.curr_rc)
    )
),

/* 5) Outbound from previous RC (this month) */
outbound AS (
  -- TRANSFER_OUT: prev>floor in prev_rc -> curr>floor in DIFFERENT rc
  SELECT
    s.month_end,
    s.prev_rc         AS rc_code,
    s.prev_rc_desc    AS rc_description,
    'TRANSFER_OUT'    AS movement_type,
    -s.prev_exp       AS amount,               -- negative
    1                 AS acct_count,
    s.prev_rc         AS from_rc_code,
    s.curr_rc         AS to_rc_code
  FROM seq s
  WHERE s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.prev_exp >  (SELECT active_floor FROM params)
    AND s.curr_exp >  (SELECT active_floor FROM params)
    AND s.prev_rc <> s.curr_rc

  UNION ALL

  -- CLOSED_ACCOUNT: prev>floor and next month <=floor or missing anywhere
  SELECT
    s.next_me         AS month_end,            -- attribute closure to the next month
    s.curr_rc         AS rc_code,
    s.curr_rc_desc    AS rc_description,
    'CLOSED_ACCOUNT'  AS movement_type,
    -s.curr_exp       AS amount,               -- negative
    1                 AS acct_count,
    s.curr_rc         AS from_rc_code,
    NULL              AS to_rc_code
  FROM seq s
  WHERE s.next_me = ADD_MONTHS(s.month_end, 1)
    AND s.curr_exp >  (SELECT active_floor FROM params)
    AND (s.next_exp IS NULL OR s.next_exp <= (SELECT active_floor FROM params))
),

/* 6) Combine movements */
movements AS (
  SELECT * FROM inbound WHERE movement_type IS NOT NULL
  UNION ALL
  SELECT * FROM outbound
),

/* 7) RC-month totals for endpoints */
rc_totals AS (
  SELECT
    month_end,
    curr_rc AS rc_code,
    MAX(curr_rc_desc) AS rc_description,
    SUM(curr_exp)     AS curr_total_exposure
  FROM seq
  GROUP BY month_end, curr_rc
),
rc_totals_with_prev AS (
  SELECT
    t.month_end,
    t.rc_code,
    t.rc_description,
    t.curr_total_exposure,
    LAG(t.curr_total_exposure) OVER (PARTITION BY t.rc_code ORDER BY t.month_end) AS prev_total_exposure
  FROM rc_totals t
),

/* 8) Aggregate movements per RC×Month×Type */
rc_movement_agg AS (
  SELECT
    m.month_end,
    m.rc_code,
    MAX(m.rc_description) AS rc_description,
    m.movement_type,
    SUM(m.amount)         AS amount,
    SUM(m.acct_count)     AS acct_count,
    -- optional: counterpart RCs at detail grain (omit in agg; available from detail table below)
    MIN(m.from_rc_code)   AS example_from_rc,
    MIN(m.to_rc_code)     AS example_to_rc
  FROM movements m
  GROUP BY m.month_end, m.rc_code, m.movement_type
),

/* 9) Pivot-ish summary */
rc_movement_pivot AS (
  SELECT
    a.month_end,
    a.rc_code,
    MAX(a.rc_description) AS rc_description,
    SUM(CASE WHEN a.movement_type='NEW_ACCOUNT'    THEN a.amount ELSE 0 END) AS new_acct_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_IN'    THEN a.amount ELSE 0 END) AS transfer_in_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_OUT'   THEN a.amount ELSE 0 END) AS transfer_out_amt,  -- negative
    SUM(CASE WHEN a.movement_type='CLOSED_ACCOUNT' THEN a.amount ELSE 0 END) AS closed_amt         -- negative
  FROM rc_movement_agg a
  GROUP BY a.month_end, a.rc_code
),

/* 10) Final summary per RC×Month */
summary AS (
  SELECT
    p.month_end,
    p.rc_code,
    p.rc_description,
    COALESCE(t.prev_total_exposure,0) AS prev_total_exposure,
    COALESCE(p.new_acct_amt,0)        AS new_acct_amt,
    COALESCE(p.transfer_in_amt,0)     AS transfer_in_amt,
    COALESCE(p.transfer_out_amt,0)    AS transfer_out_amt,
    COALESCE(p.closed_amt,0)          AS closed_amt,
    COALESCE(t.curr_total_exposure,0) AS curr_total_exposure
  FROM rc_movement_pivot p
  JOIN rc_totals_with_prev t
    ON t.month_end = p.month_end AND t.rc_code = p.rc_code
),

/* 11) Waterfall rows */
waterfall AS (
  SELECT month_end, rc_code, rc_description, 'Prev Total'     AS step_label, prev_total_exposure   AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'New Accounts'   AS step_label, new_acct_amt          AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer In'    AS step_label, transfer_in_amt       AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer Out'   AS step_label, transfer_out_amt      AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Closed'         AS step_label, closed_amt            AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Curr Total'     AS step_label, curr_total_exposure   AS step_value FROM summary
)

-- =================== OUTPUTS ===================
-- 1) SUMMARY: per RC×Month totals by movement type
-- 2) DETAIL : per RC×Month×movement type (counts & amounts)
-- 3) WATERFALL: pre-baked steps for PBI waterfall
SELECT
  'SUMMARY'::VARCHAR(8) AS row_type,
  s.month_end, s.rc_code, s.rc_description,
  s.prev_total_exposure, s.new_acct_amt, s.transfer_in_amt, s.transfer_out_amt, s.closed_amt, s.curr_total_exposure,
  NULL::VARCHAR(16) AS movement_type, NULL::INTEGER AS acct_count,
  NULL::VARCHAR(32) AS from_rc_code, NULL::VARCHAR(32) AS to_rc_code, NULL::FLOAT8 AS amount,
  NULL::VARCHAR(32) AS step_label, NULL::FLOAT8 AS step_value
FROM summary s

UNION ALL

SELECT
  'DETAIL'::VARCHAR(8) AS row_type,
  m.month_end, m.rc_code, m.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  m.movement_type, m.acct_count,
  NULL::VARCHAR(32) AS from_rc_code, NULL::VARCHAR(32) AS to_rc_code, m.amount,
  NULL::VARCHAR(32) AS step_label, NULL::FLOAT8 AS step_value
FROM rc_movement_agg m

UNION ALL

SELECT
  'WATERFALL'::VARCHAR(8) AS row_type,
  w.month_end, w.rc_code, w.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL,
  w.step_label, w.step_value
FROM waterfall w

ORDER BY rc_code, month_end, row_type, step_label;





/* =============== RC MoM Movement with Transfers (Adds/Drops/Transfers) =================
   Grain: RC_CODE x RC_DESCRIPTION x MONTH_END
   Categories (account-level, adjacent months only):
     - NEW_ACCOUNT     : prev_exp<=0 or NULL (any RC), curr_exp>0 in this RC
     - CLOSED_ACCOUNT  : prev>0 in this RC, and next month <=0 or NULL (any RC)
     - TRANSFER_IN     : prev>0 in different RC -> curr>0 in this RC  (from_rc_code populated)
     - TRANSFER_OUT    : prev>0 in this RC -> curr>0 in different RC  (to_rc_code populated)
   ======================================================================================= */

WITH
/* 0) Window control (tweak months_back as needed) */
params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me
),

/* 1) Base, recent window, only Total Loans */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    RC_CODE,
    RC_DESCRIPTION,
    Account_Identifier,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) One row per account×month: pick the RC row with the highest exposure */
acct_month AS (
  SELECT
      month_end,
      Account_Identifier,
      RC_CODE        AS rc_code,
      RC_DESCRIPTION AS rc_description,
      exposure
  FROM (
      SELECT
          month_end,
          Account_Identifier,
          RC_CODE,
          RC_DESCRIPTION,
          exposure,
          ROW_NUMBER() OVER (
              PARTITION BY month_end, Account_Identifier
              ORDER BY exposure DESC, RC_CODE
          ) AS rn
      FROM base
  ) sub
  WHERE rn = 1
),

/* 3) Add prev/next month info per account (for transfer/close detection) */
seq AS (
  SELECT
    a.month_end,
    a.Account_Identifier,
    a.rc_code         AS curr_rc,
    a.rc_description  AS curr_rc_desc,
    a.exposure        AS curr_exp,

    LAG(a.month_end)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_me,
    LAG(a.rc_code)        OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc,
    LAG(a.rc_description) OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc_desc,
    LAG(a.exposure)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_exp,

    LEAD(a.month_end)     OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_me,
    LEAD(a.rc_code)       OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_rc,
    LEAD(a.exposure)      OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_exp
  FROM acct_month a
),

/* 4) Inbound movements (attributed to CURRENT RC in CURRENT month) */
inbound AS (
  SELECT
    s.month_end,
    s.curr_rc        AS rc_code,
    s.curr_rc_desc   AS rc_description,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= 0)
           AND s.curr_exp > 0
        THEN 'NEW_ACCOUNT'
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp > 0
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp > 0
        THEN 'TRANSFER_IN'
      ELSE NULL
    END AS movement_type,
    CASE
      WHEN (s.prev_me = ADD_MONTHS(s.month_end, -1) AND (s.prev_exp IS NULL OR s.prev_exp <= 0) AND s.curr_exp > 0)
        THEN s.curr_exp
      WHEN (s.prev_me = ADD_MONTHS(s.month_end, -1) AND s.prev_exp > 0 AND s.prev_rc <> s.curr_rc AND s.curr_exp > 0)
        THEN s.curr_exp
      ELSE 0 END AS amount,
    1 AS acct_count,
    s.prev_rc      AS from_rc_code,
    s.curr_rc      AS to_rc_code
  FROM seq s
  WHERE
    (s.prev_me = ADD_MONTHS(s.month_end, -1) AND s.curr_exp > 0 AND
      (
        (s.prev_exp IS NULL OR s.prev_exp <= 0)          -- NEW_ACCOUNT
        OR (s.prev_exp > 0 AND s.prev_rc <> s.curr_rc)   -- TRANSFER_IN
      )
    )
),

/* 5) Outbound movements (attributed to PREVIOUS RC in CURRENT month) */
outbound AS (
  -- TRANSFER_OUT: prev>0 in PREV RC -> curr>0 in DIFFERENT RC
  SELECT
    s.month_end,                               -- current month
    s.prev_rc         AS rc_code,              -- losing RC
    s.prev_rc_desc    AS rc_description,
    'TRANSFER_OUT'    AS movement_type,
    -s.prev_exp       AS amount,               -- negative contribution
    1                 AS acct_count,
    s.prev_rc         AS from_rc_code,
    s.curr_rc         AS to_rc_code
  FROM seq s
  WHERE s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.prev_exp > 0
    AND s.curr_exp > 0
    AND s.prev_rc <> s.curr_rc

  UNION ALL

  -- CLOSED_ACCOUNT: prev>0 and next month has <=0 or missing exposure anywhere
  SELECT
    s.next_me         AS month_end,            -- attribute closure to the next month
    s.curr_rc         AS rc_code,              -- losing RC is current RC at prior month
    s.curr_rc_desc    AS rc_description,
    'CLOSED_ACCOUNT'  AS movement_type,
    -s.curr_exp       AS amount,               -- negative contribution
    1                 AS acct_count,
    s.curr_rc         AS from_rc_code,
    NULL              AS to_rc_code
  FROM seq s
  WHERE s.next_me = ADD_MONTHS(s.month_end, 1)
    AND s.curr_exp > 0
    AND (s.next_exp IS NULL OR s.next_exp <= 0)
),

/* 6) Combine movements and drop NULL rows */
movements AS (
  SELECT * FROM inbound WHERE movement_type IS NOT NULL
  UNION ALL
  SELECT * FROM outbound
),

/* 7) RC monthly totals for reconciliation and waterfall endpoints */
rc_totals AS (
  SELECT
    month_end,
    rc_code,
    MAX(rc_description) AS rc_description,
    SUM(curr_exp)       AS curr_total_exposure
  FROM seq
  GROUP BY month_end, rc_code
),
rc_totals_with_prev AS (
  SELECT
    t.month_end,
    t.rc_code,
    t.rc_description,
    t.curr_total_exposure,
    LAG(t.curr_total_exposure) OVER (PARTITION BY t.rc_code ORDER BY t.month_end) AS prev_total_exposure
  FROM rc_totals t
),

/* 8) Aggregate movements by RC×Month×Type & prep waterfall steps */
rc_movement_agg AS (
  SELECT
    m.month_end,
    m.rc_code,
    MAX(m.rc_description) AS rc_description,
    m.movement_type,
    SUM(m.amount)         AS amount,
    SUM(m.acct_count)     AS acct_count
  FROM movements m
  GROUP BY m.month_end, m.rc_code, m.movement_type
),

-- Pivot-ish helpers (coalesce missing types to 0 for summary)
rc_movement_pivot AS (
  SELECT
    a.month_end,
    a.rc_code,
    MAX(a.rc_description) AS rc_description,
    SUM(CASE WHEN a.movement_type='NEW_ACCOUNT'    THEN a.amount ELSE 0 END) AS new_acct_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_IN'    THEN a.amount ELSE 0 END) AS transfer_in_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_OUT'   THEN a.amount ELSE 0 END) AS transfer_out_amt,  -- negative
    SUM(CASE WHEN a.movement_type='CLOSED_ACCOUNT' THEN a.amount ELSE 0 END) AS closed_amt         -- negative
  FROM rc_movement_agg a
  GROUP BY a.month_end, a.rc_code
),

/* 9) Final summary per RC×Month */
summary AS (
  SELECT
    p.month_end,
    p.rc_code,
    p.rc_description,
    COALESCE(t.prev_total_exposure,0) AS prev_total_exposure,
    COALESCE(p.new_acct_amt,0)        AS new_acct_amt,
    COALESCE(p.transfer_in_amt,0)     AS transfer_in_amt,
    COALESCE(p.transfer_out_amt,0)    AS transfer_out_amt,
    COALESCE(p.closed_amt,0)          AS closed_amt,
    COALESCE(t.curr_total_exposure,0) AS curr_total_exposure
  FROM rc_movement_pivot p
  JOIN rc_totals_with_prev t
    ON t.month_end = p.month_end AND t.rc_code = p.rc_code
),

/* 10) Waterfall rows per RC×Month */
waterfall AS (
  SELECT month_end, rc_code, rc_description, 'Prev Total'     AS step_label, prev_total_exposure   AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'New Accounts'    AS step_label, new_acct_amt          AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer In'     AS step_label, transfer_in_amt       AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer Out'    AS step_label, transfer_out_amt      AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Closed'          AS step_label, closed_amt            AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Curr Total'      AS step_label, curr_total_exposure   AS step_value FROM summary
)

-- ======= OUTPUTS =======
-- 1) Summary (per RC×Month), 2) Movement details with counterpart RCs, 3) Waterfall steps
SELECT
  'SUMMARY'::VARCHAR(8) AS row_type,
  s.month_end, s.rc_code, s.rc_description,
  s.prev_total_exposure, s.new_acct_amt, s.transfer_in_amt, s.transfer_out_amt, s.closed_amt, s.curr_total_exposure,
  NULL::VARCHAR(16) AS movement_type,
  NULL::INTEGER     AS acct_count,
  NULL::VARCHAR(32) AS from_rc_code,
  NULL::VARCHAR(32) AS to_rc_code,
  NULL::FLOAT8      AS amount,
  NULL::VARCHAR(32) AS step_label,
  NULL::FLOAT8      AS step_value
FROM summary s

UNION ALL

SELECT
  'DETAIL'::VARCHAR(8) AS row_type,
  m.month_end, m.rc_code, m.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  m.movement_type, m.acct_count, m.from_rc_code, m.to_rc_code, m.amount,
  NULL, NULL
FROM rc_movement_agg m

UNION ALL

SELECT
  'WATERFALL'::VARCHAR(8) AS row_type,
  w.month_end, w.rc_code, w.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL,
  w.step_label, w.step_value
FROM waterfall w

ORDER BY rc_code, month_end, row_type, step_label;






acct_month AS (
  SELECT
      month_end,
      Account_Identifier,
      RC_CODE AS rc_code,
      RC_DESCRIPTION AS rc_description,
      exposure
  FROM (
      SELECT
          month_end,
          Account_Identifier,
          RC_CODE,
          RC_DESCRIPTION,
          exposure,
          ROW_NUMBER() OVER (
              PARTITION BY month_end, Account_Identifier
              ORDER BY exposure DESC, RC_CODE
          ) AS rn
      FROM base
  ) sub
  WHERE rn = 1
),






[Code: 1100, SQL State: HY000]  ERROR:  Function 'MAX_BY(VARCHAR, FLOAT8)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






/* =============== RC MoM Movement with Transfers (Adds/Drops/Transfers) =================
   Grain: RC_CODE x RC_DESCRIPTION x MONTH_END
   Categories (account-level, adjacent months only):
     - NEW_ACCOUNT     : prev_exp<=0 or NULL (any RC), curr_exp>0 in this RC
     - CLOSED_ACCOUNT  : prev_exp>0 in this RC, and next_exp<=0 or NULL (any RC)
     - TRANSFER_IN     : prev_exp>0 in different RC -> curr_exp>0 in this RC
     - TRANSFER_OUT    : prev_exp>0 in this RC -> curr_exp>0 in different RC
   Also returns RC totals for waterfall reconciliation.
   Filtered to GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' and recent window.
   ======================================================================================= */

WITH
/* 0) Window control (tweak months_back as needed) */
params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me
),

/* 1) Base, recent window, only Total Loans */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    RC_CODE,
    RC_DESCRIPTION,
    Account_Identifier,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) One row per account×month (in case of duplicates keep max exposure/first RC) */
acct_month AS (
  SELECT
    month_end,
    Account_Identifier,
    MAX_BY(RC_CODE,      exposure) AS rc_code,        -- choose RC with max exposure
    MAX_BY(RC_DESCRIPTION, exposure) AS rc_description,
    MAX(exposure)                   AS exposure
  FROM base
  GROUP BY month_end, Account_Identifier
),

/* 3) Add prev/next month info per account (for transfer/close detection) */
seq AS (
  SELECT
    a.month_end,
    a.Account_Identifier,
    a.rc_code      AS curr_rc,
    a.rc_description AS curr_rc_desc,
    a.exposure     AS curr_exp,

    LAG(a.month_end)   OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_me,
    LAG(a.rc_code)     OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc,
    LAG(a.rc_description) OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_rc_desc,
    LAG(a.exposure)    OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS prev_exp,

    LEAD(a.month_end)  OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_me,
    LEAD(a.rc_code)    OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_rc,
    LEAD(a.exposure)   OVER (PARTITION BY a.Account_Identifier ORDER BY a.month_end) AS next_exp
  FROM acct_month a
),

/* 4) Inbound movements (attributed to CURRENT RC in CURRENT month) */
inbound AS (
  SELECT
    s.month_end,
    s.curr_rc        AS rc_code,
    s.curr_rc_desc   AS rc_description,
    CASE
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND (s.prev_exp IS NULL OR s.prev_exp <= 0)
           AND s.curr_exp > 0
        THEN 'NEW_ACCOUNT'
      WHEN s.prev_me = ADD_MONTHS(s.month_end, -1)
           AND s.prev_exp > 0
           AND s.prev_rc <> s.curr_rc
           AND s.curr_exp > 0
        THEN 'TRANSFER_IN'
      ELSE NULL
    END AS movement_type,
    -- amount and counterpart
    CASE
      WHEN (s.prev_me = ADD_MONTHS(s.month_end, -1) AND (s.prev_exp IS NULL OR s.prev_exp <= 0) AND s.curr_exp > 0)
        THEN s.curr_exp
      WHEN (s.prev_me = ADD_MONTHS(s.month_end, -1) AND s.prev_exp > 0 AND s.prev_rc <> s.curr_rc AND s.curr_exp > 0)
        THEN s.curr_exp
      ELSE 0 END AS amount,
    1 AS acct_count,
    s.prev_rc      AS from_rc_code,
    s.curr_rc      AS to_rc_code
  FROM seq s
  WHERE
    (s.prev_me = ADD_MONTHS(s.month_end, -1) AND s.curr_exp > 0 AND
      (
        (s.prev_exp IS NULL OR s.prev_exp <= 0)      -- NEW_ACCOUNT
        OR (s.prev_exp > 0 AND s.prev_rc <> s.curr_rc) -- TRANSFER_IN
      )
    )
),

/* 5) Outbound movements (attributed to PREVIOUS RC in CURRENT month) */
outbound AS (
  -- TRANSFER_OUT: prev>0 in PREV RC -> curr>0 in DIFFERENT RC
  SELECT
    s.month_end,                               -- current month
    s.prev_rc         AS rc_code,              -- losing RC
    s.prev_rc_desc    AS rc_description,
    'TRANSFER_OUT'    AS movement_type,
    -s.prev_exp       AS amount,               -- negative contribution
    1                 AS acct_count,
    s.prev_rc         AS from_rc_code,
    s.curr_rc         AS to_rc_code
  FROM seq s
  WHERE s.prev_me = ADD_MONTHS(s.month_end, -1)
    AND s.prev_exp > 0
    AND s.curr_exp > 0
    AND s.prev_rc <> s.curr_rc

  UNION ALL

  -- CLOSED_ACCOUNT: prev>0 and next month has <=0 or missing exposure anywhere
  SELECT
    s.next_me         AS month_end,            -- attribute closure to the next month
    s.curr_rc         AS rc_code,              -- losing RC is current RC at prior month
    s.curr_rc_desc    AS rc_description,
    'CLOSED_ACCOUNT'  AS movement_type,
    -s.curr_exp       AS amount,               -- negative contribution
    1                 AS acct_count,
    s.curr_rc         AS from_rc_code,
    NULL              AS to_rc_code
  FROM seq s
  WHERE s.next_me = ADD_MONTHS(s.month_end, 1)
    AND s.curr_exp > 0
    AND (s.next_exp IS NULL OR s.next_exp <= 0)
),

/* 6) Combine movements and drop NULL rows */
movements AS (
  SELECT * FROM inbound WHERE movement_type IS NOT NULL
  UNION ALL
  SELECT * FROM outbound
),

/* 7) RC monthly totals for reconciliation and waterfall endpoints */
rc_totals AS (
  SELECT
    month_end,
    rc_code,
    MAX(rc_description) AS rc_description,
    SUM(curr_exp)       AS curr_total_exposure
  FROM seq
  GROUP BY month_end, rc_code
),
rc_totals_with_prev AS (
  SELECT
    t.month_end,
    t.rc_code,
    t.rc_description,
    t.curr_total_exposure,
    LAG(t.curr_total_exposure) OVER (PARTITION BY t.rc_code ORDER BY t.month_end) AS prev_total_exposure
  FROM rc_totals t
),

/* 8) Aggregate movements by RC×Month×Type & prep waterfall steps */
rc_movement_agg AS (
  SELECT
    m.month_end,
    m.rc_code,
    MAX(m.rc_description) AS rc_description,
    m.movement_type,
    SUM(m.amount)         AS amount,
    SUM(m.acct_count)     AS acct_count
  FROM movements m
  GROUP BY m.month_end, m.rc_code, m.movement_type
),

-- Pivot-ish helpers (coalesce missing types to 0 for summary)
rc_movement_pivot AS (
  SELECT
    a.month_end,
    a.rc_code,
    MAX(a.rc_description) AS rc_description,
    SUM(CASE WHEN a.movement_type='NEW_ACCOUNT'    THEN a.amount ELSE 0 END) AS new_acct_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_IN'    THEN a.amount ELSE 0 END) AS transfer_in_amt,
    SUM(CASE WHEN a.movement_type='TRANSFER_OUT'   THEN a.amount ELSE 0 END) AS transfer_out_amt,  -- negative
    SUM(CASE WHEN a.movement_type='CLOSED_ACCOUNT' THEN a.amount ELSE 0 END) AS closed_amt         -- negative
  FROM rc_movement_agg a
  GROUP BY a.month_end, a.rc_code
),

/* 9) Final summary per RC×Month */
summary AS (
  SELECT
    p.month_end,
    p.rc_code,
    p.rc_description,
    COALESCE(t.prev_total_exposure,0) AS prev_total_exposure,
    COALESCE(p.new_acct_amt,0)        AS new_acct_amt,
    COALESCE(p.transfer_in_amt,0)     AS transfer_in_amt,
    COALESCE(p.transfer_out_amt,0)    AS transfer_out_amt,
    COALESCE(p.closed_amt,0)          AS closed_amt,
    COALESCE(t.curr_total_exposure,0) AS curr_total_exposure
  FROM rc_movement_pivot p
  JOIN rc_totals_with_prev t
    ON t.month_end = p.month_end AND t.rc_code = p.rc_code
),

/* 10) Waterfall rows per RC×Month */
waterfall AS (
  SELECT month_end, rc_code, rc_description, 'Prev Total'        AS step_label, prev_total_exposure   AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'New Accounts'       AS step_label, new_acct_amt          AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer In'        AS step_label, transfer_in_amt       AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Transfer Out'       AS step_label, transfer_out_amt      AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Closed'             AS step_label, closed_amt            AS step_value FROM summary
  UNION ALL
  SELECT month_end, rc_code, rc_description, 'Curr Total'         AS step_label, curr_total_exposure   AS step_value FROM summary
)

-- ======= OUTPUTS =======
-- 1) Summary (per RC×Month), 2) Movement details with counterpart RCs, 3) Waterfall steps
SELECT
  'SUMMARY'::VARCHAR(8) AS row_type,
  s.month_end, s.rc_code, s.rc_description,
  s.prev_total_exposure, s.new_acct_amt, s.transfer_in_amt, s.transfer_out_amt, s.closed_amt, s.curr_total_exposure,
  NULL::VARCHAR(16) AS movement_type,
  NULL::INTEGER     AS acct_count,
  NULL::VARCHAR(32) AS from_rc_code,
  NULL::VARCHAR(32) AS to_rc_code,
  NULL::FLOAT8      AS amount,
  NULL::VARCHAR(32) AS step_label,
  NULL::FLOAT8      AS step_value
FROM summary s

UNION ALL

SELECT
  'DETAIL'::VARCHAR(8) AS row_type,
  m.month_end, m.rc_code, m.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  m.movement_type, m.acct_count, m.from_rc_code, m.to_rc_code, m.amount,
  NULL, NULL
FROM rc_movement_agg m

UNION ALL

SELECT
  'WATERFALL'::VARCHAR(8) AS row_type,
  w.month_end, w.rc_code, w.rc_description,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL,
  w.step_label, w.step_value
FROM waterfall w

ORDER BY rc_code, month_end, row_type, step_label;





/*=========================================================================
  Unified Synthetic Analytics (LOANHUB) — Param-Driven Sections (Netezza)
  Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  Set params.p_section to: 'ALL' | 'SNAPSHOT_TREND' | 'MOM_DECOMP' | 'TOP_MOVERS' | 'VOLATILITY'
 *=========================================================================*/

WITH
/* ---------- Parameters ---------- */
params AS (
  SELECT
    24::INT                               AS lookback_months,   -- history window
    1000::INT                             AS topN_movers,       -- for TOP_MOVERS
    CAST('ALL' AS VARCHAR(20))            AS p_section          -- << default: return all sections
),

/* ---------- Base (Total Loans only) ---------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    CAST(ACCOUNT_IDENTIFIER AS VARCHAR(128))      AS account_identifier,
    CAST(CONTRACT_SOURCE_SYSTEM AS VARCHAR(128))  AS contract_source_system,
    CAST(GL_ACCOUNT_CODE AS INTEGER)              AS gl_account_code,
    CAST(GL_ACCOUNT_DESCRIPTION AS VARCHAR(256))  AS gl_account_description,
    CAST(GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(64))  AS gl_hl4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---------- Latest & Prior Month ---------- */
latest AS (
  SELECT MAX(month_end) AS latest_me
  FROM (SELECT DISTINCT month_end FROM base) d
),
prior AS (
  SELECT MAX(month_end) AS prior_me
  FROM (SELECT DISTINCT month_end FROM base) d
  WHERE month_end < (SELECT latest_me FROM latest)
),

/* ---------- Window for history/volatility ---------- */
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_me, -((SELECT lookback_months FROM params) - 1))
),

/* ---------- Synthetic tagging (Cat1 / Cat2) ---------- */
tagged AS (
  SELECT
    w.*,
    CASE
      WHEN UPPER(w.contract_source_system) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(w.contract_source_system) LIKE '%EXCPTN%' THEN 1
      WHEN w.contract_source_system = 'ALL' AND w.gl_account_code IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364) THEN 1
      ELSE 0
    END AS is_synth,
    CASE
      WHEN (UPPER(w.contract_source_system) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(w.contract_source_system) LIKE '%EXCPTN%')
           AND (w.contract_source_system = 'ALL' AND w.gl_account_code IN
              (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
               1043008,1142048,1051872,1061833,1041211,1041344,1041364))
      THEN CAST('Cat1+Cat2' AS VARCHAR(12))
      WHEN (UPPER(w.contract_source_system) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(w.contract_source_system) LIKE '%EXCPTN%')
      THEN CAST('Cat1' AS VARCHAR(12))
      WHEN w.contract_source_system='ALL' AND w.gl_account_code IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364)
      THEN CAST('Cat2' AS VARCHAR(12))
      ELSE CAST(NULL AS VARCHAR(12))
    END AS synthetic_category
  FROM windowed w
),

/* ---------- Monthly aggregates for SNAPSHOT/TREND ---------- */
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description)                   AS gl_account_description,
    COUNT(*)                                      AS rows_flagged,
    COUNT(DISTINCT account_identifier)            AS accounts_flagged,
    SUM(exposure)                                 AS exposure_sum,
    SUM(ABS(exposure))                            AS exposure_abs_sum,
    AVG(ABS(exposure))                            AS exposure_abs_avg
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, synthetic_category, contract_source_system, gl_account_code
),
m_latest AS (SELECT MAX(month_end) AS month_end FROM monthly_group),
m_prior2 AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),
latest_per_group AS (SELECT g.* FROM monthly_group g JOIN m_latest ml ON g.month_end = ml.month_end),
prior_per_group  AS (SELECT g.* FROM monthly_group g JOIN m_prior2 mp ON g.month_end = mp.month_end),

history_stats AS (
  SELECT
    synthetic_category,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description)             AS gl_account_description,
    COUNT(*)                                AS hist_months,
    AVG(ABS(exposure_sum))                  AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))          AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))                  AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))                  AS hist_max_abs_exposure
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, contract_source_system, gl_account_code
),

/* ---------- SNAPSHOT rows ---------- */
snapshot AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20))         AS section,
    lp.month_end                                   AS month_end,
    CAST(lp.synthetic_category AS VARCHAR(12))     AS synthetic_category,
    CAST(lp.contract_source_system AS VARCHAR(128))AS contract_source_system,
    CAST(lp.gl_account_code AS INTEGER)            AS gl_account_code,
    CAST(lp.gl_account_description AS VARCHAR(256))AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                     AS account_identifier,
    CAST(NULL AS FLOAT8)                           AS exposure_prev,
    CAST(NULL AS FLOAT8)                           AS exposure_cur,
    CAST(NULL AS FLOAT8)                           AS delta_total,
    CAST(NULL AS FLOAT8)                           AS cont_growth,
    CAST(NULL AS FLOAT8)                           AS adds,
    CAST(NULL AS FLOAT8)                           AS drops,
    lp.rows_flagged                                AS rows_flagged,
    lp.accounts_flagged                            AS accounts_flagged,
    lp.exposure_sum                                AS exposure_sum,
    lp.exposure_abs_sum                            AS exposure_abs_sum,
    lp.exposure_abs_avg                            AS exposure_abs_avg,
    (SELECT month_end FROM m_prior2)               AS prev_month_end,
    COALESCE(pp.exposure_sum,0.0)                  AS prev_exposure_sum,
    CASE WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN NULL
         ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum,0.0) END AS pct_delta_exposure,
    hs.hist_months                                 AS hist_months,
    hs.hist_avg_abs_exposure                       AS hist_avg_abs_exposure,
    hs.hist_std_abs_exposure                       AS hist_std_abs_exposure,
    hs.hist_min_abs_exposure                       AS hist_min_abs_exposure,
    hs.hist_max_abs_exposure                       AS hist_max_abs_exposure,
    CASE WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
         ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure END AS zscore_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                           AS exposure_delta,
    CASE 
      WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN ABS(lp.exposure_sum)
      ELSE ABS(lp.exposure_sum - pp.exposure_sum)
    END::FLOAT8                                    AS sort_key
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category=lp.synthetic_category
   AND pp.contract_source_system=lp.contract_source_system
   AND pp.gl_account_code=lp.gl_account_code
  LEFT JOIN history_stats hs
    ON hs.synthetic_category=lp.synthetic_category
   AND hs.contract_source_system=lp.contract_source_system
   AND hs.gl_account_code=lp.gl_account_code
),

/* ---------- TREND rows ---------- */
trend AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20))          AS section,
    g.month_end                                     AS month_end,
    CAST(g.synthetic_category AS VARCHAR(12))       AS synthetic_category,
    CAST(g.contract_source_system AS VARCHAR(128))  AS contract_source_system,
    CAST(g.gl_account_code AS INTEGER)              AS gl_account_code,
    CAST(g.gl_account_description AS VARCHAR(256))  AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                      AS account_identifier,
    CAST(NULL AS FLOAT8)                            AS exposure_prev,
    CAST(NULL AS FLOAT8)                            AS exposure_cur,
    CAST(NULL AS FLOAT8)                            AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    g.rows_flagged                                  AS rows_flagged,
    g.accounts_flagged                              AS accounts_flagged,
    g.exposure_sum                                  AS exposure_sum,
    g.exposure_abs_sum                              AS exposure_abs_sum,
    g.exposure_abs_avg                              AS exposure_abs_avg,
    CAST(NULL AS DATE)                              AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                            AS exposure_delta,
    CAST(ABS(g.exposure_sum) AS FLOAT8)             AS sort_key
  FROM monthly_group g
),

/* ---------- MoM Decomposition (synthetic only) ---------- */
cur_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT latest_me FROM latest)),
prev_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT prior_me  FROM prior)),

aligned_mom AS (
  SELECT
    COALESCE(c.account_identifier, p.account_identifier)           AS account_identifier,
    COALESCE(c.contract_source_system, p.contract_source_system)   AS css_key,
    COALESCE(c.gl_account_code,        p.gl_account_code)          AS gl_key,
    COALESCE(c.gl_account_description, p.gl_account_description)   AS gl_desc,
    p.exposure AS prev_exp,
    c.exposure AS cur_exp
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.account_identifier = p.account_identifier
),
rolled_mom AS (
  SELECT
    css_key  AS contract_source_system,
    gl_key   AS gl_account_code,
    MAX(gl_desc) AS gl_account_description,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NOT NULL THEN cur_exp - prev_exp ELSE 0 END) AS cont_growth,
    SUM(CASE WHEN prev_exp IS NULL  AND cur_exp IS NOT NULL THEN cur_exp ELSE 0 END)               AS adds,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NULL THEN -prev_exp ELSE 0 END)              AS drops,
    SUM(COALESCE(prev_exp,0.0)) AS exposure_prev,
    SUM(COALESCE(cur_exp,0.0))  AS exposure_cur
  FROM aligned_mom
  GROUP BY css_key, gl_key
),
mom_decomp AS (
  SELECT
    CAST('MOM_DECOMP' AS VARCHAR(20))              AS section,
    (SELECT latest_me FROM latest)                 AS month_end,
    CAST(NULL AS VARCHAR(12))                      AS synthetic_category,
    CAST(r.contract_source_system AS VARCHAR(128)) AS contract_source_system,
    CAST(r.gl_account_code AS INTEGER)             AS gl_account_code,
    CAST(r.gl_account_description AS VARCHAR(256)) AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                     AS account_identifier,
    r.exposure_prev                                AS exposure_prev,
    r.exposure_cur                                 AS exposure_cur,
    (r.exposure_cur - r.exposure_prev)             AS delta_total,
    r.cont_growth                                  AS cont_growth,
    r.adds                                         AS adds,
    r.drops                                        AS drops,
    CAST(NULL AS INTEGER)                          AS rows_flagged,
    CAST(NULL AS INTEGER)                          AS accounts_flagged,
    CAST(NULL AS FLOAT8)                           AS exposure_sum,
    CAST(NULL AS FLOAT8)                           AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                           AS exposure_abs_avg,
    (SELECT prior_me FROM prior)                   AS prev_month_end,
    CAST(NULL AS FLOAT8)                           AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                           AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                          AS hist_months,
    CAST(NULL AS FLOAT8)                           AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS zscore_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                           AS exposure_delta,
    CAST(ABS(r.exposure_cur - r.exposure_prev) AS FLOAT8) AS sort_key
  FROM rolled_mom r
),

/* ---------- Top Movers (account-level, latest vs prior) ---------- */
aligned_movers AS (
  SELECT
    COALESCE(c.account_identifier, p.account_identifier)           AS account_identifier,
    COALESCE(c.contract_source_system, p.contract_source_system)   AS contract_source_system,
    COALESCE(c.gl_account_code,        p.gl_account_code)          AS gl_account_code,
    COALESCE(c.gl_account_description, p.gl_account_description)   AS gl_account_description,
    COALESCE(p.exposure,0.0) AS exposure_prev,
    COALESCE(c.exposure,0.0) AS exposure_cur
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.account_identifier = p.account_identifier
),
ranked_movers AS (
  SELECT
    am.*,
    (exposure_cur - exposure_prev) AS exposure_delta,
    ROW_NUMBER() OVER (ORDER BY ABS(exposure_cur - exposure_prev) DESC) AS rn
  FROM aligned_movers am
),
top_movers AS (
  SELECT
    CAST('TOP_MOVERS' AS VARCHAR(20))               AS section,
    (SELECT latest_me FROM latest)                  AS month_end,
    CAST(NULL AS VARCHAR(12))                       AS synthetic_category,
    CAST(rm.contract_source_system AS VARCHAR(128)) AS contract_source_system,
    CAST(rm.gl_account_code AS INTEGER)             AS gl_account_code,
    CAST(rm.gl_account_description AS VARCHAR(256)) AS gl_account_description,
    CAST(rm.account_identifier AS VARCHAR(128))     AS account_identifier,
    rm.exposure_prev                                AS exposure_prev,
    rm.exposure_cur                                 AS exposure_cur,
    rm.exposure_cur - rm.exposure_prev              AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    CAST(NULL AS INTEGER)                           AS rows_flagged,
    CAST(NULL AS INTEGER)                           AS accounts_flagged,
    CAST(NULL AS FLOAT8)                            AS exposure_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_avg,
    (SELECT prior_me FROM prior)                    AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_cv_abs,
    (exposure_cur - exposure_prev)                  AS exposure_delta,
    CAST(ABS(exposure_cur - exposure_prev) AS FLOAT8) AS sort_key
  FROM ranked_movers rm
  WHERE rn <= (SELECT topN_movers FROM params)
),

/* ---------- Volatility (window) ---------- */
bucket_month AS (
  SELECT
    month_end,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description) AS gl_account_description,
    SUM(exposure)               AS exposure_sum
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, contract_source_system, gl_account_code
),
volatility AS (
  SELECT
    CAST('VOLATILITY' AS VARCHAR(20))               AS section,
    MAX(month_end)                                  AS month_end,
    CAST(NULL AS VARCHAR(12))                       AS synthetic_category,
    CAST(contract_source_system AS VARCHAR(128))    AS contract_source_system,
    CAST(gl_account_code AS INTEGER)                AS gl_account_code,
    CAST(MAX(gl_account_description) AS VARCHAR(256)) AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                      AS account_identifier,
    CAST(NULL AS FLOAT8)                            AS exposure_prev,
    CAST(NULL AS FLOAT8)                            AS exposure_cur,
    CAST(NULL AS FLOAT8)                            AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    CAST(NULL AS INTEGER)                           AS rows_flagged,
    CAST(NULL AS INTEGER)                           AS accounts_flagged,
    CAST(NULL AS FLOAT8)                            AS exposure_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_avg,
    CAST(NULL AS DATE)                              AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    AVG(ABS(exposure_sum))                          AS volatility_avg_abs,
    STDDEV_SAMP(ABS(exposure_sum))                  AS volatility_std_abs,
    CASE WHEN AVG(ABS(exposure_sum))=0 THEN NULL
         ELSE (STDDEV_SAMP(ABS(exposure_sum)) / AVG(ABS(exposure_sum))) END AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                            AS exposure_delta,
    CAST(ABS(STDDEV_SAMP(ABS(exposure_sum))) AS FLOAT8) AS sort_key
  FROM bucket_month
  GROUP BY contract_source_system, gl_account_code
)

/* ---------- Final selector (one result set) ---------- */
SELECT *
FROM (
    SELECT * FROM snapshot
    WHERE (SELECT p_section FROM params) IN ('SNAPSHOT_TREND','ALL')
    UNION ALL
    SELECT * FROM trend
    WHERE (SELECT p_section FROM params) IN ('SNAPSHOT_TREND','ALL')
    UNION ALL
    SELECT * FROM mom_decomp
    WHERE (SELECT p_section FROM params) IN ('MOM_DECOMP','ALL')
    UNION ALL
    SELECT * FROM top_movers
    WHERE (SELECT p_section FROM params) IN ('TOP_MOVERS','ALL')
    UNION ALL
    SELECT * FROM volatility
    WHERE (SELECT p_section FROM params) IN ('VOLATILITY','ALL')
) u
-- Use ordinal positions; Netezza requires ORDER BY columns to be in the result set.
-- 1=section, 2=month_end, 3=synthetic_category, 4=contract_source_system, 5=gl_account_code, 32=sort_key
ORDER BY
  1,       -- section
  2 DESC,  -- month_end
  3,       -- synthetic_category
  4,       -- contract_source_system
  5,       -- gl_account_code
  32 DESC; -- sort_key







WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Prev_Account_Key,
    MAX(Account_Name)            AS Prev_Account_Name,
    MAX(CIS_Customer_Number)     AS Prev_CIS_Customer_Number,
    MAX(Facility_ID)             AS Prev_Facility_ID,
    MAX(Contract_Source_System)  AS Prev_Contract_Source_System,
    MAX(Status_Code_Description) AS Prev_Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS Prev_GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Prev_Source_System_Balance,
    SUM(GL_Balance)              AS Prev_GL_Balance,
    MAX(Available_Balance)       AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Prev_Borrower_Risk_Rating,
    MAX(PD_Grade)                AS Prev_PD_Grade,
    MAX(Days_Past_Due)           AS Prev_Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Prev_Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS Prev_PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS Prev_RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS Prev_GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,

    /* current fields (explicit, no c.*) */
    c.Account_Key,
    c.Account_Name,
    c.CIS_Customer_Number,
    c.Facility_ID,
    c.Contract_Source_System,
    c.Status_Code_Description,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.Source_System_Balance,
    c.GL_Balance,
    c.Available_Balance,
    c.Borrower_Risk_Rating,
    c.PD_Grade,
    c.Days_Past_Due,
    c.Non_Accrual_Flag,
    c.PROD_HIER_LEVEL_5,
    c.RBC_Code,
    c.GL_ACCOUNT_CODE,

    /* prev snapshot fields */
    p.Prev_Source_System_Balance,
    p.Prev_GL_Balance,
    p.Prev_Account_Key,
    p.Prev_Account_Name,
    p.Prev_CIS_Customer_Number,
    p.Prev_Facility_ID,
    p.Prev_Contract_Source_System,
    p.Prev_Status_Code_Description,
    p.Prev_GL_ACCOUNT_HIER_LEVEL_4,
    p.Prev_Available_Balance,
    p.Prev_Borrower_Risk_Rating,
    p.Prev_PD_Grade,
    p.Prev_Days_Past_Due,
    p.Prev_Non_Accrual_Flag,
    p.Prev_PROD_HIER_LEVEL_5,
    p.Prev_RBC_Code,
    p.Prev_GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
)
SELECT
  (SELECT curr_eom FROM params) AS End_of_Month_Date,

  /* classification on Source_System_Balance */
  CASE
    WHEN COALESCE(Prev_Source_System_Balance,0)=0 AND COALESCE(Source_System_Balance,0)>0 THEN 'ADD'
    WHEN COALESCE(Source_System_Balance,0)=0 AND COALESCE(Prev_Source_System_Balance,0)>0 THEN 'DROP'
    WHEN COALESCE(Source_System_Balance,0)<>COALESCE(Prev_Source_System_Balance,0)         THEN 'BAL_CHANGE'
    ELSE 'NO_CHANGE'
  END AS Change_Type,

  /* Bank_Code from current (fallback to prev if current is null) */
  CASE
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) = 'ALL'
         AND COALESCE(GL_ACCOUNT_CODE, Prev_GL_ACCOUNT_CODE) IN
             ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
              '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
              '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN
         ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
          'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,

  /* detail fields (current snapshot) */
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,

  /* helpful exposure deltas */
  COALESCE(Prev_Source_System_Balance,0) AS Prev_Source_System_Balance,
  COALESCE(Source_System_Balance,0)      AS Curr_Source_System_Balance,
  COALESCE(Source_System_Balance,0) - COALESCE(Prev_Source_System_Balance,0) AS Exposure_Delta

FROM joined
ORDER BY Change_Type, Bank_Code, Account_Identifier;







WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Prev_Account_Key,
    MAX(Account_Name)            AS Prev_Account_Name,
    MAX(CIS_Customer_Number)     AS Prev_CIS_Customer_Number,
    MAX(Facility_ID)             AS Prev_Facility_ID,
    MAX(Contract_Source_System)  AS Prev_Contract_Source_System,
    MAX(Status_Code_Description) AS Prev_Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS Prev_GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Prev_Source_System_Balance,
    SUM(GL_Balance)              AS Prev_GL_Balance,
    MAX(Available_Balance)       AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Prev_Borrower_Risk_Rating,
    MAX(PD_Grade)                AS Prev_PD_Grade,
    MAX(Days_Past_Due)           AS Prev_Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Prev_Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS Prev_PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS Prev_RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS Prev_GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    c.*,  -- current fields
    p.Prev_Source_System_Balance,
    p.Prev_GL_Balance,
    p.Prev_Account_Key,
    p.Prev_Account_Name,
    p.Prev_CIS_Customer_Number,
    p.Prev_Facility_ID,
    p.Prev_Contract_Source_System,
    p.Prev_Status_Code_Description,
    p.Prev_GL_ACCOUNT_HIER_LEVEL_4,
    p.Prev_Available_Balance,
    p.Prev_Borrower_Risk_Rating,
    p.Prev_PD_Grade,
    p.Prev_Days_Past_Due,
    p.Prev_Non_Accrual_Flag,
    p.Prev_PROD_HIER_LEVEL_5,
    p.Prev_RBC_Code,
    p.Prev_GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
)
SELECT
  (SELECT curr_eom FROM params) AS End_of_Month_Date,
  /* classification on Source_System_Balance */
  CASE
    WHEN COALESCE(Prev_Source_System_Balance,0)=0 AND COALESCE(Source_System_Balance,0)>0 THEN 'ADD'
    WHEN COALESCE(Source_System_Balance,0)=0 AND COALESCE(Prev_Source_System_Balance,0)>0 THEN 'DROP'
    WHEN COALESCE(Source_System_Balance,0)<>COALESCE(Prev_Source_System_Balance,0)         THEN 'BAL_CHANGE'
    ELSE 'NO_CHANGE'
  END AS Change_Type,
  /* Bank_Code from current (fallback to prev if current is null) */
  CASE
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
      THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System)='ALL'
         AND COALESCE(GL_ACCOUNT_CODE, Prev_GL_ACCOUNT_CODE) IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                                                 '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                                                 '1100001','1142067','1042886','1043008')
      THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
      THEN 'L-FCB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                                                          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                                                          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                                                          'STRAT1','STRAT1-EXCPTN')
      THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,
  /* detail fields (current snapshot) */
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  /* helpful deltas on exposure */
  COALESCE(Prev_Source_System_Balance,0) AS Prev_Source_System_Balance,
  COALESCE(Source_System_Balance,0)      AS Curr_Source_System_Balance,
  COALESCE(Source_System_Balance,0) - COALESCE(Prev_Source_System_Balance,0) AS Exposure_Delta
FROM joined
ORDER BY Change_Type, Bank_Code, Account_Identifier;






WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  GROUP BY Account_Identifier
)
SELECT
  (SELECT prev_eom FROM params) AS End_of_Month_Date,
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  CASE
    WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN Contract_Source_System='ALL'
         AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                 '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                 '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                    'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                    'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                    'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code
FROM prev_norm
ORDER BY Account_Identifier;






-- Q2: MoM Bridge by Bank_Code (Source_System_Balance) — FIXED ORDER BY
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Prev_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Curr_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.GL_ACCOUNT_CODE,p.GL_ACCOUNT_CODE)       AS GL_ACCOUNT_CODE,
    COALESCE(p.Prev_Bal,0) AS Prev_Bal,
    COALESCE(c.Curr_Bal,0) AS Curr_Bal
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System='ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
totals AS (
  SELECT
    Bank_Code,
    SUM(CASE WHEN Prev_Bal>0 THEN Prev_Bal END)                 AS prev_total_bal,
    SUM(CASE WHEN Curr_Bal>0 THEN Curr_Bal END)                 AS curr_total_bal,
    COUNT(CASE WHEN Prev_Bal>0 THEN 1 END)                      AS prev_total_cnt,
    COUNT(CASE WHEN Curr_Bal>0 THEN 1 END)                      AS curr_total_cnt,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN Curr_Bal END),0)                    AS adds_bal,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN Prev_Bal END),0)                   AS drops_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal>0 AND Curr_Bal>0 THEN (Curr_Bal-Prev_Bal) END),0)         AS pers_delta_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN 1 END),0)                           AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN 1 END),0)                          AS drops_cnt
  FROM with_bank
  GROUP BY Bank_Code
)
SELECT Bank_Code, line, balance_val, count_val
FROM (
  SELECT Bank_Code, 'Prev Month Balance' AS line, prev_total_bal AS balance_val, NULL::BIGINT AS count_val, 0 AS seq FROM totals
  UNION ALL SELECT Bank_Code, 'Adds',                    adds_bal,               NULL,         1 FROM totals
  UNION ALL SELECT Bank_Code, 'Drops',                   drops_bal,              NULL,         2 FROM totals
  UNION ALL SELECT Bank_Code, 'Persisting Bal Changes',  pers_delta_bal,         NULL,         3 FROM totals
  UNION ALL SELECT Bank_Code, 'Current Month Balance',   curr_total_bal,         NULL,         4 FROM totals
  UNION ALL SELECT Bank_Code, 'Prev Month Count',        NULL::NUMERIC(18,2),    prev_total_cnt, 10 FROM totals
  UNION ALL SELECT Bank_Code, 'Adds',                    NULL,                   adds_cnt,       11 FROM totals
  UNION ALL SELECT Bank_Code, 'Drops',                   NULL,                   drops_cnt,      12 FROM totals
  UNION ALL SELECT Bank_Code, 'Current Month Count',     NULL,                   curr_total_cnt, 13 FROM totals
) u
ORDER BY Bank_Code, seq;







WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT Account_Identifier, SUM(Source_System_Balance) AS Prev_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT Account_Identifier, SUM(Source_System_Balance) AS Curr_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    COALESCE(p.Prev_Bal,0) AS Prev_Bal,
    COALESCE(c.Curr_Bal,0) AS Curr_Bal
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
),
overall_prev AS (
  SELECT SUM(Prev_Bal) AS prev_total_bal,
         COUNT(*)      AS prev_total_cnt
  FROM joined
  WHERE Prev_Bal>0
),
overall_curr AS (
  SELECT SUM(Curr_Bal) AS curr_total_bal,
         COUNT(*)      AS curr_total_cnt
  FROM joined
  WHERE Curr_Bal>0
),
pieces AS (
  SELECT
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN Curr_Bal END),0)                   AS adds_bal,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN Prev_Bal END),0)                  AS drops_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal>0 AND Curr_Bal>0 THEN (Curr_Bal-Prev_Bal) END),0)        AS pers_delta_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN 1 END),0)                          AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN 1 END),0)                         AS drops_cnt
  FROM joined
)
SELECT 'Prev Month Balance'      AS bridge_line, (SELECT prev_total_bal FROM overall_prev) AS balance_val, NULL::BIGINT AS count_val
UNION ALL SELECT 'Adds',                   (SELECT adds_bal        FROM pieces),           NULL
UNION ALL SELECT 'Drops',                  (SELECT drops_bal       FROM pieces),           NULL
UNION ALL SELECT 'Persisting Bal Changes', (SELECT pers_delta_bal  FROM pieces),           NULL
UNION ALL SELECT 'Current Month Balance',  (SELECT curr_total_bal  FROM overall_curr),     NULL
UNION ALL SELECT 'Prev Month Count',       NULL::NUMERIC(18,2),    (SELECT prev_total_cnt FROM overall_prev)
UNION ALL SELECT 'Adds',                   NULL,                   (SELECT adds_cnt        FROM pieces)
UNION ALL SELECT 'Drops',                  NULL,                   (SELECT drops_cnt       FROM pieces)
UNION ALL SELECT 'Current Month Count',    NULL,                   (SELECT curr_total_cnt FROM overall_curr);



WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
-- normalize month + carry source fields to map Bank_Code
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Prev_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    SUM(Source_System_Balance)  AS Curr_Bal
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Contract_Source_System,p.Contract_Source_System) AS Contract_Source_System,
    COALESCE(c.GL_ACCOUNT_CODE,p.GL_ACCOUNT_CODE)       AS GL_ACCOUNT_CODE,
    COALESCE(p.Prev_Bal,0) AS Prev_Bal,
    COALESCE(c.Curr_Bal,0) AS Curr_Bal
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System='ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
totals AS (
  SELECT
    Bank_Code,
    SUM(CASE WHEN Prev_Bal>0 THEN Prev_Bal END)                 AS prev_total_bal,
    SUM(CASE WHEN Curr_Bal>0 THEN Curr_Bal END)                 AS curr_total_bal,
    COUNT(CASE WHEN Prev_Bal>0 THEN 1 END)                      AS prev_total_cnt,
    COUNT(CASE WHEN Curr_Bal>0 THEN 1 END)                      AS curr_total_cnt,
    /* bridge pieces */
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN Curr_Bal END),0)                    AS adds_bal,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN Prev_Bal END),0)                   AS drops_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal>0 AND Curr_Bal>0 THEN (Curr_Bal-Prev_Bal) END),0)         AS pers_delta_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal=0 AND Curr_Bal>0 THEN 1 END),0)                           AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_Bal=0 AND Prev_Bal>0 THEN 1 END),0)                          AS drops_cnt
  FROM with_bank
  GROUP BY Bank_Code
)
-- Emit 9 lines per bank (5 balance rows + 4 count rows)
SELECT Bank_Code, 'Prev Month Balance' AS line, prev_total_bal AS balance_val, NULL::BIGINT AS count_val FROM totals
UNION ALL SELECT Bank_Code, 'Adds',                    adds_bal,               NULL FROM totals
UNION ALL SELECT Bank_Code, 'Drops',                   drops_bal,              NULL FROM totals
UNION ALL SELECT Bank_Code, 'Persisting Bal Changes',  pers_delta_bal,         NULL FROM totals
UNION ALL SELECT Bank_Code, 'Current Month Balance',   curr_total_bal,         NULL FROM totals
UNION ALL SELECT Bank_Code, 'Prev Month Count',        NULL::NUMERIC(18,2),    prev_total_cnt FROM totals
UNION ALL SELECT Bank_Code, 'Adds',                    NULL,                   adds_cnt        FROM totals
UNION ALL SELECT Bank_Code, 'Drops',                   NULL,                   drops_cnt       FROM totals
UNION ALL SELECT Bank_Code, 'Current Month Count',     NULL,                   curr_total_cnt  FROM totals
ORDER BY Bank_Code, CASE line
  WHEN 'Prev Month Balance' THEN 0
  WHEN 'Adds' THEN 1
  WHEN 'Drops' THEN 2
  WHEN 'Persisting Bal Changes' THEN 3
  WHEN 'Current Month Balance' THEN 4
  WHEN 'Prev Month Count' THEN 10
  WHEN 'Adds' THEN 11
  WHEN 'Drops' THEN 12
  WHEN 'Current Month Count' THEN 13
END;


WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  GROUP BY Account_Identifier
)
SELECT
  (SELECT prev_eom FROM params) AS End_of_Month_Date,
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  CASE
    WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN Contract_Source_System='ALL'
         AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                 '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                 '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                    'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                    'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                    'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code
FROM prev_norm
ORDER BY Account_Identifier;


WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier)='' THEN '§NULL§' ELSE TRIM(Account_Identifier) END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Prev_Account_Key,
    MAX(Account_Name)            AS Prev_Account_Name,
    MAX(CIS_Customer_Number)     AS Prev_CIS_Customer_Number,
    MAX(Facility_ID)             AS Prev_Facility_ID,
    MAX(Contract_Source_System)  AS Prev_Contract_Source_System,
    MAX(Status_Code_Description) AS Prev_Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS Prev_GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Prev_Source_System_Balance,
    SUM(GL_Balance)              AS Prev_GL_Balance,
    MAX(Available_Balance)       AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Prev_Borrower_Risk_Rating,
    MAX(PD_Grade)                AS Prev_PD_Grade,
    MAX(Days_Past_Due)           AS Prev_Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Prev_Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS Prev_PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS Prev_RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS Prev_GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT prev_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM pop
  WHERE End_of_Month_Date=(SELECT curr_eom FROM params)
    AND Non_Accrual_Flag='Y'
    AND Source_System_Balance>0
  GROUP BY Account_Identifier
),
joined AS (
  SELECT
    COALESCE(c.Account_Identifier,p.Account_Identifier) AS Account_Identifier,
    c.*,  -- current fields
    p.Prev_Source_System_Balance,
    p.Prev_GL_Balance,
    p.Prev_Account_Key,
    p.Prev_Account_Name,
    p.Prev_CIS_Customer_Number,
    p.Prev_Facility_ID,
    p.Prev_Contract_Source_System,
    p.Prev_Status_Code_Description,
    p.Prev_GL_ACCOUNT_HIER_LEVEL_4,
    p.Prev_Available_Balance,
    p.Prev_Borrower_Risk_Rating,
    p.Prev_PD_Grade,
    p.Prev_Days_Past_Due,
    p.Prev_Non_Accrual_Flag,
    p.Prev_PROD_HIER_LEVEL_5,
    p.Prev_RBC_Code,
    p.Prev_GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier=p.Account_Identifier
)
SELECT
  (SELECT curr_eom FROM params) AS End_of_Month_Date,
  /* classification on Source_System_Balance */
  CASE
    WHEN COALESCE(Prev_Source_System_Balance,0)=0 AND COALESCE(Source_System_Balance,0)>0 THEN 'ADD'
    WHEN COALESCE(Source_System_Balance,0)=0 AND COALESCE(Prev_Source_System_Balance,0)>0 THEN 'DROP'
    WHEN COALESCE(Source_System_Balance,0)<>COALESCE(Prev_Source_System_Balance,0)         THEN 'BAL_CHANGE'
    ELSE 'NO_CHANGE'
  END AS Change_Type,
  /* Bank_Code from current (fallback to prev if current is null) */
  CASE
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
      THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System)='ALL'
         AND COALESCE(GL_ACCOUNT_CODE, Prev_GL_ACCOUNT_CODE) IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                                                 '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                                                 '1100001','1142067','1042886','1043008')
      THEN 'L-SVB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
      THEN 'L-FCB'
    WHEN COALESCE(Contract_Source_System, Prev_Contract_Source_System) IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                                                          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                                                          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                                                          'STRAT1','STRAT1-EXCPTN')
      THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,
  /* detail fields (current snapshot) */
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  /* helpful deltas on exposure */
  COALESCE(Prev_Source_System_Balance,0) AS Prev_Source_System_Balance,
  COALESCE(Source_System_Balance,0)      AS Curr_Source_System_Balance,
  COALESCE(Source_System_Balance,0) - COALESCE(Prev_Source_System_Balance,0) AS Exposure_Delta
FROM joined
ORDER BY Change_Type, Bank_Code, Account_Identifier;











-- ============================================================
-- MoM Non-Accrual Bridge (using Source_System_Balance)
-- ============================================================
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
-- Base pull (same filters)
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE
        WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier) = '' THEN '§NULL§'
        ELSE TRIM(Account_Identifier)
      END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- Normalize: one row per account per month
curr_norm AS (
  SELECT
    Account_Identifier,
    SUM(Source_System_Balance) AS Source_System_Balance
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    SUM(Source_System_Balance) AS Source_System_Balance
  FROM prev_raw
  GROUP BY Account_Identifier
),

-- Combine months
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(p.Source_System_Balance, 0) AS Prev_Bal,
    COALESCE(c.Source_System_Balance, 0) AS Curr_Bal
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),

-- Compute bridge pieces
overall_prev AS (
  SELECT SUM(Source_System_Balance) AS prev_total_bal,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(Source_System_Balance) AS curr_total_bal,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),
overall_bridge AS (
  SELECT
    (SELECT prev_total_bal FROM overall_prev) AS prev_total_bal,
    (SELECT curr_total_bal FROM overall_curr) AS curr_total_bal,

    /* Adds, Drops, Persisting Changes */
    COALESCE(SUM(CASE WHEN Prev_Bal = 0  AND Curr_Bal > 0 THEN Curr_Bal END),0)                         AS adds_bal,
    -COALESCE(SUM(CASE WHEN Curr_Bal = 0  AND Prev_Bal > 0 THEN Prev_Bal END),0)                         AS drops_bal,
    COALESCE(SUM(CASE WHEN Prev_Bal > 0 AND Curr_Bal > 0 AND Curr_Bal <> Prev_Bal
                      THEN (Curr_Bal - Prev_Bal) END),0)                                                 AS pers_delta_bal,

    /* Counts */
    COALESCE(SUM(CASE WHEN Prev_Bal = 0  AND Curr_Bal > 0 THEN 1 END),0)                                 AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_Bal = 0  AND Prev_Bal > 0 THEN 1 END),0)                                AS drops_cnt
  FROM joined
)

-- ============================================================
-- FINAL OUTPUT: simple 2-part bridge (balance + count)
-- ============================================================
SELECT 'Prev Month Balance'      AS bridge_line, (SELECT prev_total_bal FROM overall_prev) AS balance_val, NULL AS count_val
UNION ALL
SELECT 'Adds',                   (SELECT adds_bal FROM overall_bridge),                    NULL
UNION ALL
SELECT 'Drops',                  (SELECT drops_bal FROM overall_bridge),                   NULL
UNION ALL
SELECT 'Persisting Bal Changes', (SELECT pers_delta_bal FROM overall_bridge),               NULL
UNION ALL
SELECT 'Current Month Balance',  (SELECT curr_total_bal FROM overall_curr),                 NULL
UNION ALL
SELECT 'Prev Month Count',       NULL, (SELECT prev_total_cnt FROM overall_prev)
UNION ALL
SELECT 'Adds',                   NULL, (SELECT adds_cnt FROM overall_bridge)
UNION ALL
SELECT 'Drops',                  NULL, (SELECT drops_cnt FROM overall_bridge)
UNION ALL
SELECT 'Current Month Count',    NULL, (SELECT curr_total_cnt FROM overall_curr);







-- ============================================================
-- Combined Output: Normalized POP (Prev & Curr) + Overall BRIDGE
-- (UNION-safe: all branches have identical columns & types)
-- ============================================================
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
-- Base two-month pull (filters) + normalized key
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      CASE
        WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier) = '' THEN '§NULL§'
        ELSE TRIM(Account_Identifier)
      END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- Normalize to one row per account per month
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)             AS Account_Key,
    MAX(Account_Name)            AS Account_Name,
    MAX(CIS_Customer_Number)     AS CIS_Customer_Number,
    MAX(Facility_ID)             AS Facility_ID,
    MAX(Contract_Source_System)  AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)   AS Source_System_Balance,
    SUM(GL_Balance)              AS GL_Balance,
    MAX(Available_Balance)       AS Available_Balance,
    MAX(Borrower_Risk_Rating)    AS Borrower_Risk_Rating,
    MAX(PD_Grade)                AS PD_Grade,
    MAX(Days_Past_Due)           AS Days_Past_Due,
    MAX(Non_Accrual_Flag)        AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

-- For the bridge (overall)
overall_prev AS (
  SELECT SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),
bridge_parts AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
overall_bridge AS (
  SELECT
    (SELECT prev_total_gl  FROM overall_prev)            AS prev_total_gl,
    (SELECT curr_total_gl  FROM overall_curr)            AS curr_total_gl,
    COALESCE(SUM(CASE WHEN Prev_GL_Balance = 0 AND Curr_GL_Balance > 0 THEN Curr_GL_Balance END),0)                          AS adds_gl,
    -COALESCE(SUM(CASE WHEN Curr_GL_Balance = 0 AND Prev_GL_Balance > 0 THEN Prev_GL_Balance END),0)                         AS drops_gl,
    COALESCE(SUM(CASE WHEN Prev_GL_Balance > 0 AND Curr_GL_Balance > 0 AND Curr_GL_Balance <> Prev_GL_Balance
                      THEN (Curr_GL_Balance - Prev_GL_Balance) END),0)                                                       AS pers_delta_gl,
    COALESCE(SUM(CASE WHEN Prev_GL_Balance = 0 AND Curr_GL_Balance > 0 THEN 1 END),0)                                        AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Curr_GL_Balance = 0 AND Prev_GL_Balance > 0 THEN 1 END),0)                                       AS drops_cnt,
    (SELECT prev_total_cnt FROM overall_prev) AS prev_cnt,
    (SELECT curr_total_cnt FROM overall_curr) AS curr_cnt
  FROM bridge_parts
)

-- ============================================================
-- FINAL OUTPUT: POP rows + BRIDGE rows (same columns/types)
-- ============================================================
/* ---------- POP: PREV ---------- */
SELECT
  CAST('POP' AS VARCHAR(16))                            AS section,
  CAST('PREV' AS VARCHAR(16))                           AS sub_section,
  CAST(NULL AS VARCHAR(64))                             AS line_label,
  (SELECT prev_eom FROM params)                         AS end_of_month_date,
  pn.Account_Identifier,
  pn.Account_Key,
  pn.Account_Name,
  pn.CIS_Customer_Number,
  pn.Facility_ID,
  pn.Contract_Source_System,
  pn.Status_Code_Description,
  pn.GL_ACCOUNT_HIER_LEVEL_4,
  pn.PROD_HIER_LEVEL_5,
  pn.RBC_Code,
  pn.GL_ACCOUNT_CODE,
  /* Bank_Code */
  CASE
    WHEN pn.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN pn.Contract_Source_System = 'ALL'
         AND pn.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                    '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                    '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN pn.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN pn.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                       'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                       'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                       'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END                                                   AS Bank_Code,
  pn.Source_System_Balance                              AS Source_System_Balance,
  pn.GL_Balance                                         AS GL_Balance,
  pn.Available_Balance                                  AS Available_Balance,
  pn.Borrower_Risk_Rating                                AS Borrower_Risk_Rating,
  pn.PD_Grade                                           AS PD_Grade,
  pn.Days_Past_Due                                      AS Days_Past_Due,
  pn.Non_Accrual_Flag                                   AS Non_Accrual_Flag,
  CAST(NULL AS NUMERIC(18,2))                           AS metric_value,
  CAST(NULL AS BIGINT)                                  AS metric_count
FROM prev_norm pn

UNION ALL

/* ---------- POP: CURR ---------- */
SELECT
  CAST('POP' AS VARCHAR(16))                            AS section,
  CAST('CURR' AS VARCHAR(16))                           AS sub_section,
  CAST(NULL AS VARCHAR(64))                             AS line_label,
  (SELECT curr_eom FROM params)                         AS end_of_month_date,
  cn.Account_Identifier,
  cn.Account_Key,
  cn.Account_Name,
  cn.CIS_Customer_Number,
  cn.Facility_ID,
  cn.Contract_Source_System,
  cn.Status_Code_Description,
  cn.GL_ACCOUNT_HIER_LEVEL_4,
  cn.PROD_HIER_LEVEL_5,
  cn.RBC_Code,
  cn.GL_ACCOUNT_CODE,
  CASE
    WHEN cn.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN cn.Contract_Source_System = 'ALL'
         AND cn.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                    '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                    '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN cn.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN cn.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                       'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                       'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                       'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END                                                   AS Bank_Code,
  cn.Source_System_Balance                              AS Source_System_Balance,
  cn.GL_Balance                                         AS GL_Balance,
  cn.Available_Balance                                  AS Available_Balance,
  cn.Borrower_Risk_Rating                                AS Borrower_Risk_Rating,
  cn.PD_Grade                                           AS PD_Grade,
  cn.Days_Past_Due                                      AS Days_Past_Due,
  cn.Non_Accrual_Flag                                   AS Non_Accrual_Flag,
  CAST(NULL AS NUMERIC(18,2))                           AS metric_value,
  CAST(NULL AS BIGINT)                                  AS metric_count
FROM curr_norm cn

UNION ALL

/* ---------- BRIDGE: BALANCE (5 rows) ---------- */
SELECT
  CAST('BRIDGE' AS VARCHAR(16))                         AS section,
  CAST('BALANCE' AS VARCHAR(16))                        AS sub_section,
  label                                                 AS line_label,
  CAST(NULL AS DATE)                                    AS end_of_month_date,
  CAST(NULL AS VARCHAR(64))                             AS Account_Identifier,
  CAST(NULL AS VARCHAR(64))                             AS Account_Key,
  CAST(NULL AS VARCHAR(256))                            AS Account_Name,
  CAST(NULL AS VARCHAR(64))                             AS CIS_Customer_Number,
  CAST(NULL AS VARCHAR(64))                             AS Facility_ID,
  CAST(NULL AS VARCHAR(64))                             AS Contract_Source_System,
  CAST(NULL AS VARCHAR(128))                            AS Status_Code_Description,
  CAST(NULL AS VARCHAR(64))                             AS GL_ACCOUNT_HIER_LEVEL_4,
  CAST(NULL AS VARCHAR(128))                            AS PROD_HIER_LEVEL_5,
  CAST(NULL AS VARCHAR(64))                             AS RBC_Code,
  CAST(NULL AS VARCHAR(64))                             AS GL_ACCOUNT_CODE,
  CAST(NULL AS VARCHAR(20))                             AS Bank_Code,
  CAST(NULL AS NUMERIC(18,2))                           AS Source_System_Balance,
  CAST(NULL AS NUMERIC(18,2))                           AS GL_Balance,
  CAST(NULL AS NUMERIC(18,2))                           AS Available_Balance,
  CAST(NULL AS VARCHAR(64))                             AS Borrower_Risk_Rating,
  CAST(NULL AS VARCHAR(64))                             AS PD_Grade,
  CAST(NULL AS INTEGER)                                 AS Days_Past_Due,
  CAST(NULL AS CHAR(1))                                 AS Non_Accrual_Flag,
  val                                                  AS metric_value,
  CAST(NULL AS BIGINT)                                  AS metric_count
FROM (
  SELECT 'Prev Month Balance'      AS label, (SELECT prev_total_gl  FROM overall_prev)   AS val
  UNION ALL SELECT 'Adds',                              (SELECT adds_gl      FROM overall_bridge)
  UNION ALL SELECT 'Drops',                             (SELECT drops_gl     FROM overall_bridge)
  UNION ALL SELECT 'Persisting Bal Changes',            (SELECT pers_delta_gl FROM overall_bridge)
  UNION ALL SELECT 'Current Month Balance',             (SELECT curr_total_gl FROM overall_curr)
) b

UNION ALL

/* ---------- BRIDGE: COUNT (4 rows) ---------- */
SELECT
  CAST('BRIDGE' AS VARCHAR(16))                         AS section,
  CAST('COUNT' AS VARCHAR(16))                          AS sub_section,
  label                                                 AS line_label,
  CAST(NULL AS DATE)                                    AS end_of_month_date,
  CAST(NULL AS VARCHAR(64))                             AS Account_Identifier,
  CAST(NULL AS VARCHAR(64))                             AS Account_Key,
  CAST(NULL AS VARCHAR(256))                            AS Account_Name,
  CAST(NULL AS VARCHAR(64))                             AS CIS_Customer_Number,
  CAST(NULL AS VARCHAR(64))                             AS Facility_ID,
  CAST(NULL AS VARCHAR(64))                             AS Contract_Source_System,
  CAST(NULL AS VARCHAR(128))                            AS Status_Code_Description,
  CAST(NULL AS VARCHAR(64))                             AS GL_ACCOUNT_HIER_LEVEL_4,
  CAST(NULL AS VARCHAR(128))                            AS PROD_HIER_LEVEL_5,
  CAST(NULL AS VARCHAR(64))                             AS RBC_Code,
  CAST(NULL AS VARCHAR(64))                             AS GL_ACCOUNT_CODE,
  CAST(NULL AS VARCHAR(20))                             AS Bank_Code,
  CAST(NULL AS NUMERIC(18,2))                           AS Source_System_Balance,
  CAST(NULL AS NUMERIC(18,2))                           AS GL_Balance,
  CAST(NULL AS NUMERIC(18,2))                           AS Available_Balance,
  CAST(NULL AS VARCHAR(64))                             AS Borrower_Risk_Rating,
  CAST(NULL AS VARCHAR(64))                             AS PD_Grade,
  CAST(NULL AS INTEGER)                                 AS Days_Past_Due,
  CAST(NULL AS CHAR(1))                                 AS Non_Accrual_Flag,
  CAST(NULL AS NUMERIC(18,2))                           AS metric_value,
  cnt                                                   AS metric_count
FROM (
  SELECT 'Prev Month Count'       AS label, (SELECT prev_cnt FROM overall_bridge) AS cnt
  UNION ALL SELECT 'Adds',                            (SELECT adds_cnt FROM overall_bridge)
  UNION ALL SELECT 'Drops',                           (SELECT drops_cnt FROM overall_bridge)
  UNION ALL SELECT 'Current Month Count',             (SELECT curr_cnt FROM overall_bridge)
) c

ORDER BY
  section, sub_section, line_label, end_of_month_date, Account_Identifier;





-- ============================================================
-- Combined Output: Normalized POP (Prev & Curr) + Overall BRIDGE
--   * POP rows include your original fields + Bank_Code
--   * Bridge computed from the same normalized sets (ties exactly)
--   * Normalizes Account_Identifier (trim + NULL bucket) so joins/aggregations align
-- ============================================================
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
-- Base two-month pull (your filters) + normalized key
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      /* normalize the identifier to avoid NULL / padding drift */
      CASE
        WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier) = '' THEN '§NULL§'
        ELSE TRIM(Account_Identifier)
      END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
-- Month filters (no temp tables; still lightweight)
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

/* Normalize to ONE ROW per Account_Identifier per month
   - SUM balances to account-level
   - MAX() other attributes (deterministic pick) */
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                    AS Account_Key,
    MAX(Account_Name)                   AS Account_Name,
    MAX(CIS_Customer_Number)            AS CIS_Customer_Number,
    MAX(Facility_ID)                    AS Facility_ID,
    MAX(Contract_Source_System)         AS Contract_Source_System,
    MAX(Status_Code_Description)        AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)        AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)          AS Source_System_Balance,
    SUM(GL_Balance)                     AS GL_Balance,
    MAX(Available_Balance)              AS Available_Balance,
    MAX(Borrower_Risk_Rating)           AS Borrower_Risk_Rating,
    MAX(PD_Grade)                       AS PD_Grade,
    MAX(Days_Past_Due)                  AS Days_Past_Due,
    MAX(Non_Accrual_Flag)               AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)              AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                       AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)                AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                    AS Account_Key,
    MAX(Account_Name)                   AS Account_Name,
    MAX(CIS_Customer_Number)            AS CIS_Customer_Number,
    MAX(Facility_ID)                    AS Facility_ID,
    MAX(Contract_Source_System)         AS Contract_Source_System,
    MAX(Status_Code_Description)        AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)        AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)          AS Source_System_Balance,
    SUM(GL_Balance)                     AS GL_Balance,
    MAX(Available_Balance)              AS Available_Balance,
    MAX(Borrower_Risk_Rating)           AS Borrower_Risk_Rating,
    MAX(PD_Grade)                       AS PD_Grade,
    MAX(Days_Past_Due)                  AS Days_Past_Due,
    MAX(Non_Accrual_Flag)               AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)              AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                       AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)                AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

-- Joined accounts (normalized), just what we need for the bridge
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,
    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(COALESCE(c.Contract_Source_System, p.Contract_Source_System),'') AS Contract_Source_System,
    COALESCE(COALESCE(c.GL_ACCOUNT_CODE, p.GL_ACCOUNT_CODE),'') AS GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),

-- BRIDGE components (overall)
overall_prev AS (
  SELECT SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),
overall_bridge AS (
  SELECT
    (SELECT prev_total_gl FROM overall_prev) AS prev_total_gl,
    (SELECT curr_total_gl FROM overall_curr) AS curr_total_gl,
    COALESCE(SUM(CASE WHEN (Prev_GL_Balance = 0  AND Curr_GL_Balance > 0) THEN Curr_GL_Balance END),0) AS adds_gl,
    -COALESCE(SUM(CASE WHEN (Curr_GL_Balance = 0  AND Prev_GL_Balance > 0) THEN Prev_GL_Balance END),0) AS drops_gl,
    COALESCE(SUM(CASE WHEN (Prev_GL_Balance > 0 AND Curr_GL_Balance > 0 AND Curr_GL_Balance <> Prev_GL_Balance)
                      THEN (Curr_GL_Balance - Prev_GL_Balance) END),0) AS bal_delta,
    COALESCE(SUM(CASE WHEN (Prev_GL_Balance = 0  AND Curr_GL_Balance > 0) THEN 1 END),0) AS adds_cnt,
    -COALESCE(SUM(CASE WHEN (Curr_GL_Balance = 0  AND Prev_GL_Balance > 0) THEN 1 END),0) AS drops_cnt
  FROM with_bank
)

-- ============================================================
-- FINAL OUTPUT
--   Section 1: POP rows (Prev + Curr), normalized, with Bank_Code
--   Section 2: Bridge (Balance + Count) - overall (ties exactly)
-- ============================================================
/* ---------- Section 1: POP rows ---------- */
SELECT
  'POP' AS section,
  CASE WHEN End_of_Month_Date = (SELECT prev_eom FROM params) THEN 'PREV' ELSE 'CURR' END AS month_flag,
  /* POP fields (same as your original pop + Bank_Code) */
  End_of_Month_Date,
  Account_Name,
  Contract_Source_System,
  CIS_Customer_Number,
  Facility_ID,
  Account_Identifier,
  Account_Key,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  Source_System_Balance,
  GL_Balance,
  Available_Balance,
  Borrower_Risk_Rating,
  PD_Grade,
  Days_Past_Due,
  Non_Accrual_Flag,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  /* Bank_Code mapping (repeat here so POP rows carry it) */
  CASE
    WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
    WHEN Contract_Source_System = 'ALL'
         AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                 '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                 '1100001','1142067','1042886','1043008') THEN 'L-SVB'
    WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
    WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                    'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                    'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                    'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code
FROM (
  -- PREV POP (normalized, account-level)
  SELECT
    (SELECT prev_eom FROM params) AS End_of_Month_Date,
    pn.Account_Name,
    pn.Contract_Source_System,
    pn.CIS_Customer_Number,
    pn.Facility_ID,
    pn.Account_Identifier,
    pn.Account_Key,
    pn.Status_Code_Description,
    pn.GL_ACCOUNT_HIER_LEVEL_4,
    pn.Source_System_Balance,
    pn.GL_Balance,
    pn.Available_Balance,
    pn.Borrower_Risk_Rating,
    pn.PD_Grade,
    pn.Days_Past_Due,
    pn.Non_Accrual_Flag,
    pn.PROD_HIER_LEVEL_5,
    pn.RBC_Code,
    pn.GL_ACCOUNT_CODE
  FROM prev_norm pn

  UNION ALL

  -- CURR POP (normalized, account-level)
  SELECT
    (SELECT curr_eom FROM params) AS End_of_Month_Date,
    cn.Account_Name,
    cn.Contract_Source_System,
    cn.CIS_Customer_Number,
    cn.Facility_ID,
    cn.Account_Identifier,
    cn.Account_Key,
    cn.Status_Code_Description,
    cn.GL_ACCOUNT_HIER_LEVEL_4,
    cn.Source_System_Balance,
    cn.GL_Balance,
    cn.Available_Balance,
    cn.Borrower_Risk_Rating,
    cn.PD_Grade,
    cn.Days_Past_Due,
    cn.Non_Accrual_Flag,
    cn.PROD_HIER_LEVEL_5,
    cn.RBC_Code,
    cn.GL_ACCOUNT_CODE
  FROM curr_norm cn
) pop_norm

UNION ALL

/* ---------- Section 2: BRIDGE (overall) ---------- */
-- BALANCE bridge (5 rows)
SELECT 'BRIDGE' AS section, 'BALANCE' AS month_flag, NULL::DATE,
       NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
       CASE label
         WHEN 'Prev Month Balance'      THEN 'L-SUMMARY'  -- placeholder so column count matches; ignored
         WHEN 'Adds'                    THEN 'L-SUMMARY'
         WHEN 'Drops'                   THEN 'L-SUMMARY'
         WHEN 'Persisting Bal Changes'  THEN 'L-SUMMARY'
         WHEN 'Current Month Balance'   THEN 'L-SUMMARY'
       END AS Bank_Code
FROM (
  SELECT 'Prev Month Balance' AS label, (SELECT prev_total_gl FROM overall_prev) AS val
  UNION ALL SELECT 'Adds',                   (SELECT adds_gl FROM overall_bridge)
  UNION ALL SELECT 'Drops',                  (SELECT drops_gl FROM overall_bridge)
  UNION ALL SELECT 'Persisting Bal Changes', (SELECT bal_delta FROM overall_bridge)
  UNION ALL SELECT 'Current Month Balance',  (SELECT curr_total_gl FROM overall_curr)
) b

UNION ALL

-- COUNT bridge (4 rows)
SELECT 'BRIDGE' AS section, 'COUNT' AS month_flag, NULL::DATE,
       NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
       'L-SUMMARY' AS Bank_Code
FROM (
  SELECT 'Prev Month Count' AS label, (SELECT prev_total_cnt FROM overall_prev) AS val
  UNION ALL SELECT 'Adds',               (SELECT adds_cnt FROM overall_bridge)
  UNION ALL SELECT 'Drops',              (SELECT drops_cnt FROM overall_bridge)
  UNION ALL SELECT 'Current Month Count',(SELECT curr_total_cnt FROM overall_curr)
) c

ORDER BY
  section, month_flag, End_of_Month_Date, Account_Identifier;






-- ============================================
-- Query A (v2): AUDIT + BRIDGES + POP/SUMMARY (no DETAIL)
-- Uses normalized account key to eliminate tiny deltas
-- ============================================
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
-- Base pull for two months (same filters)
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      /* normalize ID once */
      CASE
        WHEN Account_Identifier IS NULL OR TRIM(Account_Identifier) = ''
          THEN '§NULL§'
        ELSE TRIM(Account_Identifier)
      END AS Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- Normalize to 1 row per normalized account per month
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key) AS Account_Key,
    MAX(Account_Name) AS Account_Name,
    MAX(CIS_Customer_Number) AS CIS_Customer_Number,
    MAX(Facility_ID) AS Facility_ID,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance) AS Source_System_Balance,
    SUM(GL_Balance) AS GL_Balance,
    MAX(Available_Balance) AS Available_Balance,
    MAX(Borrower_Risk_Rating) AS Borrower_Risk_Rating,
    MAX(PD_Grade) AS PD_Grade,
    MAX(Days_Past_Due) AS Days_Past_Due,
    MAX(Non_Accrual_Flag) AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5) AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code) AS RBC_Code,
    MAX(GL_ACCOUNT_CODE) AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key) AS Account_Key,
    MAX(Account_Name) AS Account_Name,
    MAX(CIS_Customer_Number) AS CIS_Customer_Number,
    MAX(Facility_ID) AS Facility_ID,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance) AS Source_System_Balance,
    SUM(GL_Balance) AS GL_Balance,
    MAX(Available_Balance) AS Available_Balance,
    MAX(Borrower_Risk_Rating) AS Borrower_Risk_Rating,
    MAX(PD_Grade) AS PD_Grade,
    MAX(Days_Past_Due) AS Days_Past_Due,
    MAX(Non_Accrual_Flag) AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5) AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code) AS RBC_Code,
    MAX(GL_ACCOUNT_CODE) AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

-- Joined + Change_Type (no detail output here)
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,
    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(COALESCE(c.Contract_Source_System, p.Contract_Source_System),'') AS Contract_Source_System,
    COALESCE(COALESCE(c.GL_ACCOUNT_CODE, p.GL_ACCOUNT_CODE),'') AS GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    Bank_Code,
    Prev_GL_Balance,
    Curr_GL_Balance,
    (Curr_GL_Balance - Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN Prev_GL_Balance = 0  AND Curr_GL_Balance > 0 THEN 'ADD'
      WHEN Curr_GL_Balance = 0  AND Prev_GL_Balance > 0 THEN 'DROP'
      WHEN Curr_GL_Balance <> Prev_GL_Balance           THEN 'BAL_CHANGE'
      ELSE 'NO_CHANGE'
    END AS Change_Type
  FROM with_bank
),

-- Overall POP totals (normalized)
overall_prev AS (
  SELECT SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),

-- Bridge pieces (overall)
overall_bridge AS (
  SELECT
    (SELECT prev_total_gl FROM overall_prev) AS prev_total_gl,
    (SELECT curr_total_gl FROM overall_curr) AS curr_total_gl,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0) AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0) AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)        AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)               AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)               AS drops_cnt
  FROM classified
),

-- By-bank POP totals (normalized)
by_bank_prev AS (
  SELECT Bank_Code,
         SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS Bank_Code,
      GL_Balance,
      Account_Identifier
    FROM prev_norm
  ) p
  GROUP BY Bank_Code
),
by_bank_curr AS (
  SELECT Bank_Code,
         SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS Bank_Code,
      GL_Balance,
      Account_Identifier
    FROM curr_norm
  ) c
  GROUP BY Bank_Code
),
by_bank_bridge_pieces AS (
  SELECT
    Bank_Code,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0) AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0) AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)        AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)               AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)               AS drops_cnt
  FROM classified
  GROUP BY Bank_Code
),
by_bank_bridge AS (
  SELECT
    COALESCE(p.Bank_Code, c.Bank_Code) AS Bank_Code,
    COALESCE(p.prev_total_gl, 0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl, 0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt,
    COALESCE(x.adds_gl, 0)  AS adds_gl,
    COALESCE(x.drops_gl, 0) AS drops_gl,
    COALESCE(x.bal_delta,0) AS bal_delta,
    COALESCE(x.adds_cnt,0)  AS adds_cnt,
    COALESCE(x.drops_cnt,0) AS drops_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.Bank_Code = c.Bank_Code
  LEFT JOIN by_bank_bridge_pieces x
    ON COALESCE(p.Bank_Code, c.Bank_Code) = x.Bank_Code
),

-- AUDIT: simple vs normalized AND null bucket exposure
simple_prev AS (
  SELECT SUM(GL_Balance) AS simple_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_prev_cnt
  FROM prev_raw
),
simple_curr AS (
  SELECT SUM(GL_Balance) AS simple_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_curr_cnt
  FROM curr_raw
),
norm_prev AS (
  SELECT SUM(GL_Balance) AS norm_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_prev_cnt
  FROM prev_norm
),
norm_curr AS (
  SELECT SUM(GL_Balance) AS norm_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_curr_cnt
  FROM curr_norm
),
null_bucket AS (
  SELECT
    SUM(CASE WHEN End_of_Month_Date = (SELECT prev_eom FROM params)
             AND Account_Identifier = '§NULL§' THEN GL_Balance END) AS prev_null_gl,
    COUNT(DISTINCT CASE WHEN End_of_Month_Date = (SELECT prev_eom FROM params)
                        AND Account_Identifier = '§NULL§' THEN Account_Identifier END) AS prev_null_cnt,
    SUM(CASE WHEN End_of_Month_Date = (SELECT curr_eom FROM params)
             AND Account_Identifier = '§NULL§' THEN GL_Balance END) AS curr_null_gl,
    COUNT(DISTINCT CASE WHEN End_of_Month_Date = (SELECT curr_eom FROM params)
                        AND Account_Identifier = '§NULL§' THEN Account_Identifier END) AS curr_null_cnt
  FROM pop
)

-- ====================== OUTPUT (compact) ======================
-- A1) AUDIT rows (4)
SELECT
  'AUDIT' AS level, 'GL' AS Bank_Code, 'PREV_GL' AS Change_Type,
  (SELECT simple_prev_gl FROM simple_prev) AS simple_val,
  (SELECT norm_prev_gl   FROM norm_prev)   AS norm_val,
  (SELECT norm_prev_gl FROM norm_prev) - (SELECT simple_prev_gl FROM simple_prev) AS delta_val
UNION ALL
SELECT 'AUDIT','GL','CURR_GL',
       (SELECT simple_curr_gl FROM simple_curr),
       (SELECT norm_curr_gl   FROM norm_curr),
       (SELECT norm_curr_gl FROM norm_curr) - (SELECT simple_curr_gl FROM simple_curr)
UNION ALL
SELECT 'AUDIT','GL','PREV_CNT',
       (SELECT simple_prev_cnt FROM simple_prev),
       (SELECT norm_prev_cnt   FROM norm_prev),
       (SELECT norm_prev_cnt FROM norm_prev) - (SELECT simple_prev_cnt FROM simple_prev)
UNION ALL
SELECT 'AUDIT','GL','CURR_CNT',
       (SELECT simple_curr_cnt FROM simple_curr),
       (SELECT norm_curr_cnt   FROM norm_curr),
       (SELECT norm_curr_cnt FROM norm_curr) - (SELECT simple_curr_cnt FROM simple_curr)

-- A1b) AUDIT — Null-bucket contribution (helps explain mismatches)
UNION ALL
SELECT 'AUDIT','NULL_BUCKET','PREV_NULL_GL',
       (SELECT prev_null_gl FROM null_bucket), NULL, NULL
UNION ALL
SELECT 'AUDIT','NULL_BUCKET','CURR_NULL_GL',
       (SELECT curr_null_gl FROM null_bucket), NULL, NULL
UNION ALL
SELECT 'AUDIT','NULL_BUCKET','PREV_NULL_CNT',
       (SELECT prev_null_cnt FROM null_bucket), NULL, NULL
UNION ALL
SELECT 'AUDIT','NULL_BUCKET','CURR_NULL_CNT',
       (SELECT curr_null_cnt FROM null_bucket), NULL, NULL

-- A2) BRIDGE (overall) — BALANCE (5 rows)
UNION ALL SELECT 'BRIDGE','BALANCE','Prev Month Balance',
  NULL, (SELECT prev_total_gl FROM overall_prev), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Adds',
  NULL, (SELECT adds_gl FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Drops',
  NULL, (SELECT drops_gl FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
  NULL, (SELECT bal_delta FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Current Month Balance',
  NULL, (SELECT curr_total_gl FROM overall_curr), NULL

-- A3) BRIDGE (overall) — COUNT (4 rows)
UNION ALL SELECT 'BRIDGE','COUNT','Prev Month Count',
  (SELECT prev_total_cnt FROM overall_prev), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Adds',
  (SELECT adds_cnt FROM overall_bridge), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Drops',
  (SELECT drops_cnt FROM overall_bridge), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Current Month Count',
  (SELECT curr_total_cnt FROM overall_curr), NULL, NULL

-- A4) BRIDGE_BY_BANK — BALANCE (5 rows per bank)
UNION ALL
SELECT 'BRIDGE_BY_BANK','BALANCE', label,
       NULL,
       CASE label
         WHEN 'Prev Month Balance'      THEN b.prev_total_gl
         WHEN 'Adds'                    THEN b.adds_gl
         WHEN 'Drops'                   THEN b.drops_gl
         WHEN 'Persisting Bal Changes'  THEN b.bal_delta
         WHEN 'Current Month Balance'   THEN b.curr_total_gl
       END,
       NULL
FROM by_bank_bridge b
CROSS JOIN (SELECT 'Prev Month Balance' AS label
            UNION ALL SELECT 'Adds'
            UNION ALL SELECT 'Drops'
            UNION ALL SELECT 'Persisting Bal Changes'
            UNION ALL SELECT 'Current Month Balance') labels

-- A5) BRIDGE_BY_BANK — COUNT (4 rows per bank)
UNION ALL
SELECT 'BRIDGE_BY_BANK','COUNT', label,
       CASE label
         WHEN 'Prev Month Count'   THEN b.prev_total_cnt
         WHEN 'Adds'               THEN b.adds_cnt
         WHEN 'Drops'              THEN b.drops_cnt
         WHEN 'Current Month Count'THEN b.curr_total_cnt
       END,
       NULL,
       NULL
FROM by_bank_bridge b
CROSS JOIN (SELECT 'Prev Month Count' AS label
            UNION ALL SELECT 'Adds'
            UNION ALL SELECT 'Drops'
            UNION ALL SELECT 'Current Month Count') labels
;





-- ============================================
-- Query A: AUDIT + BRIDGES + POP/SUMMARY (no DETAIL)
-- Keeps the plan small and avoids channel overflow
-- ============================================
WITH params AS (
  SELECT DATE '2025-09-30' AS curr_eom,
         ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
-- Base pull for two months (same filters)
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
    AND Account_Identifier IS NOT NULL
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
    AND Account_Identifier IS NOT NULL
),

-- Normalize to 1 row per account per month
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key) AS Account_Key,
    MAX(Account_Name) AS Account_Name,
    MAX(CIS_Customer_Number) AS CIS_Customer_Number,
    MAX(Facility_ID) AS Facility_ID,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance) AS Source_System_Balance,
    SUM(GL_Balance) AS GL_Balance,
    MAX(Available_Balance) AS Available_Balance,
    MAX(Borrower_Risk_Rating) AS Borrower_Risk_Rating,
    MAX(PD_Grade) AS PD_Grade,
    MAX(Days_Past_Due) AS Days_Past_Due,
    MAX(Non_Accrual_Flag) AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5) AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code) AS RBC_Code,
    MAX(GL_ACCOUNT_CODE) AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key) AS Account_Key,
    MAX(Account_Name) AS Account_Name,
    MAX(CIS_Customer_Number) AS CIS_Customer_Number,
    MAX(Facility_ID) AS Facility_ID,
    MAX(Contract_Source_System) AS Contract_Source_System,
    MAX(Status_Code_Description) AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance) AS Source_System_Balance,
    SUM(GL_Balance) AS GL_Balance,
    MAX(Available_Balance) AS Available_Balance,
    MAX(Borrower_Risk_Rating) AS Borrower_Risk_Rating,
    MAX(PD_Grade) AS PD_Grade,
    MAX(Days_Past_Due) AS Days_Past_Due,
    MAX(Non_Accrual_Flag) AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5) AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code) AS RBC_Code,
    MAX(GL_ACCOUNT_CODE) AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

-- Joined + Change_Type (no detail output here)
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,
    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(COALESCE(c.Contract_Source_System, p.Contract_Source_System),'') AS Contract_Source_System,
    COALESCE(COALESCE(c.GL_ACCOUNT_CODE, p.GL_ACCOUNT_CODE),'') AS GL_ACCOUNT_CODE
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    Bank_Code,
    Prev_GL_Balance,
    Curr_GL_Balance,
    (Curr_GL_Balance - Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN Prev_GL_Balance = 0  AND Curr_GL_Balance > 0 THEN 'ADD'
      WHEN Curr_GL_Balance = 0  AND Prev_GL_Balance > 0 THEN 'DROP'
      WHEN Curr_GL_Balance <> Prev_GL_Balance           THEN 'BAL_CHANGE'
      ELSE 'NO_CHANGE'
    END AS Change_Type
  FROM with_bank
),

-- Overall POP totals (normalized)
overall_prev AS (
  SELECT SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),

-- Bridge pieces (overall)
overall_bridge AS (
  SELECT
    (SELECT prev_total_gl FROM overall_prev) AS prev_total_gl,
    (SELECT curr_total_gl FROM overall_curr) AS curr_total_gl,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0) AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0) AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)        AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)               AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)               AS drops_cnt
  FROM classified
),

-- By-bank POP totals (normalized)
by_bank_prev AS (
  SELECT Bank_Code,
         SUM(p.GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT p.Account_Identifier) AS prev_total_cnt
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS Bank_Code,
      GL_Balance,
      Account_Identifier
    FROM prev_norm
  ) p
  GROUP BY Bank_Code
),
by_bank_curr AS (
  SELECT Bank_Code,
         SUM(c.GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT c.Account_Identifier) AS curr_total_cnt
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS Bank_Code,
      GL_Balance,
      Account_Identifier
    FROM curr_norm
  ) c
  GROUP BY Bank_Code
),
by_bank_bridge_pieces AS (
  SELECT
    b.Bank_Code,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0) AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0) AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)        AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)               AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)               AS drops_cnt
  FROM classified b
  GROUP BY b.Bank_Code
),
by_bank_bridge AS (
  SELECT
    COALESCE(p.Bank_Code, c.Bank_Code) AS Bank_Code,
    COALESCE(p.prev_total_gl, 0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl, 0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt,
    COALESCE(x.adds_gl, 0)  AS adds_gl,
    COALESCE(x.drops_gl, 0) AS drops_gl,
    COALESCE(x.bal_delta,0) AS bal_delta,
    COALESCE(x.adds_cnt,0)  AS adds_cnt,
    COALESCE(x.drops_cnt,0) AS drops_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.Bank_Code = c.Bank_Code
  LEFT JOIN by_bank_bridge_pieces x
    ON COALESCE(p.Bank_Code, c.Bank_Code) = x.Bank_Code
),

-- AUDIT: simple vs normalized totals
simple_prev AS (
  SELECT SUM(GL_Balance) AS simple_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_prev_cnt
  FROM prev_raw
),
simple_curr AS (
  SELECT SUM(GL_Balance) AS simple_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_curr_cnt
  FROM curr_raw
),
norm_prev AS (
  SELECT SUM(GL_Balance) AS norm_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_prev_cnt
  FROM prev_norm
),
norm_curr AS (
  SELECT SUM(GL_Balance) AS norm_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_curr_cnt
  FROM curr_norm
)

-- ====================== OUTPUT (compact) ======================
-- A1) AUDIT rows (4)
SELECT
  'AUDIT' AS level, 'GL' AS Bank_Code, 'PREV_GL' AS Change_Type,
  (SELECT simple_prev_gl FROM simple_prev) AS simple_val,
  (SELECT norm_prev_gl   FROM norm_prev)   AS norm_val,
  (SELECT norm_prev_gl FROM norm_prev) - (SELECT simple_prev_gl FROM simple_prev) AS delta_val
UNION ALL
SELECT 'AUDIT','GL','CURR_GL',
       (SELECT simple_curr_gl FROM simple_curr),
       (SELECT norm_curr_gl   FROM norm_curr),
       (SELECT norm_curr_gl FROM norm_curr) - (SELECT simple_curr_gl FROM simple_curr)
UNION ALL
SELECT 'AUDIT','GL','PREV_CNT',
       (SELECT simple_prev_cnt FROM simple_prev),
       (SELECT norm_prev_cnt   FROM norm_prev),
       (SELECT norm_prev_cnt FROM norm_prev) - (SELECT simple_prev_cnt FROM simple_prev)
UNION ALL
SELECT 'AUDIT','GL','CURR_CNT',
       (SELECT simple_curr_cnt FROM simple_curr),
       (SELECT norm_curr_cnt   FROM norm_curr),
       (SELECT norm_curr_cnt FROM norm_curr) - (SELECT simple_curr_cnt FROM simple_curr)

-- A2) BRIDGE (overall) — BALANCE (5 rows)
UNION ALL SELECT 'BRIDGE','BALANCE','Prev Month Balance',
  NULL, (SELECT prev_total_gl FROM overall_prev), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Adds',
  NULL, (SELECT adds_gl FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Drops',
  NULL, (SELECT drops_gl FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
  NULL, (SELECT bal_delta FROM overall_bridge), NULL
UNION ALL SELECT 'BRIDGE','BALANCE','Current Month Balance',
  NULL, (SELECT curr_total_gl FROM overall_curr), NULL

-- A3) BRIDGE (overall) — COUNT (4 rows)
UNION ALL SELECT 'BRIDGE','COUNT','Prev Month Count',
  (SELECT prev_total_cnt FROM overall_prev), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Adds',
  (SELECT adds_cnt FROM overall_bridge), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Drops',
  (SELECT drops_cnt FROM overall_bridge), NULL, NULL
UNION ALL SELECT 'BRIDGE','COUNT','Current Month Count',
  (SELECT curr_total_cnt FROM overall_curr), NULL, NULL

-- A4) BRIDGE_BY_BANK — BALANCE (5 rows per bank; generated via VALUES)
UNION ALL
SELECT 'BRIDGE_BY_BANK','BALANCE', label,
       NULL,
       CASE label
         WHEN 'Prev Month Balance'      THEN b.prev_total_gl
         WHEN 'Adds'                    THEN b.adds_gl
         WHEN 'Drops'                   THEN b.drops_gl
         WHEN 'Persisting Bal Changes'  THEN b.bal_delta
         WHEN 'Current Month Balance'   THEN b.curr_total_gl
       END,
       NULL
FROM by_bank_bridge b
CROSS JOIN (SELECT 'Prev Month Balance' AS label
            UNION ALL SELECT 'Adds'
            UNION ALL SELECT 'Drops'
            UNION ALL SELECT 'Persisting Bal Changes'
            UNION ALL SELECT 'Current Month Balance') labels

-- A5) BRIDGE_BY_BANK — COUNT (4 rows per bank; generated via VALUES)
UNION ALL
SELECT 'BRIDGE_BY_BANK','COUNT', label,
       CASE label
         WHEN 'Prev Month Count' THEN b.prev_total_cnt
         WHEN 'Adds'             THEN b.adds_cnt
         WHEN 'Drops'            THEN b.drops_cnt
         WHEN 'Current Month Count' THEN b.curr_total_cnt
       END,
       NULL,
       NULL
FROM by_bank_bridge b
CROSS JOIN (SELECT 'Prev Month Count' AS label
            UNION ALL SELECT 'Adds'
            UNION ALL SELECT 'Drops'
            UNION ALL SELECT 'Current Month Count') labels

-- A6) POP_TOTAL (2 rows: prev & curr totals) — optional quick view
UNION ALL
SELECT 'POP_TOTAL','GL','Prev Total',
       (SELECT prev_total_gl FROM overall_prev), NULL, NULL
UNION ALL
SELECT 'POP_TOTAL','GL','Curr Total',
       (SELECT curr_total_gl FROM overall_curr), NULL, NULL
;






-- =============================================================================
-- MoM Non-Accrual Portfolio Movement (Ties Exactly) + AUDIT
--  - Normalizes to 1 row per Account_Identifier per month
--  - BRIDGEs (overall & by Bank_Code) for BALANCE and COUNT
--  - Pop totals, summaries, detail
--  - AUDIT rows verifying simple vs normalized populations match
-- =============================================================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),

/* Base population (two months; base filters) */
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),

/* Per-month filtered NA sets (raw) -- exclude NULL IDs to prevent collapse */
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
    AND Account_Identifier IS NOT NULL
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
    AND Account_Identifier IS NOT NULL
),

/* Normalize to 1 row per Account_Identifier per month */
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                 AS Account_Key,
    MAX(Account_Name)                AS Account_Name,
    MAX(CIS_Customer_Number)         AS CIS_Customer_Number,
    MAX(Facility_ID)                 AS Facility_ID,
    MAX(Contract_Source_System)      AS Contract_Source_System,
    MAX(Status_Code_Description)     AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)     AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)       AS Source_System_Balance,
    SUM(GL_Balance)                  AS GL_Balance,
    MAX(Available_Balance)           AS Available_Balance,
    MAX(Borrower_Risk_Rating)        AS Borrower_Risk_Rating,
    MAX(PD_Grade)                    AS PD_Grade,
    MAX(Days_Past_Due)               AS Days_Past_Due,
    MAX(Non_Accrual_Flag)            AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)           AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                    AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)             AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                 AS Account_Key,
    MAX(Account_Name)                AS Account_Name,
    MAX(CIS_Customer_Number)         AS CIS_Customer_Number,
    MAX(Facility_ID)                 AS Facility_ID,
    MAX(Contract_Source_System)      AS Contract_Source_System,
    MAX(Status_Code_Description)     AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)     AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)       AS Source_System_Balance,
    SUM(GL_Balance)                  AS GL_Balance,
    MAX(Available_Balance)           AS Available_Balance,
    MAX(Borrower_Risk_Rating)        AS Borrower_Risk_Rating,
    MAX(PD_Grade)                    AS PD_Grade,
    MAX(Days_Past_Due)               AS Days_Past_Due,
    MAX(Non_Accrual_Flag)            AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)           AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                    AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)             AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

/* Join normalized sets + Bank_Code + classification */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

    COALESCE(c.Contract_Source_System,  p.Contract_Source_System)  AS Contract_Source_System,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.PROD_HIER_LEVEL_5,       p.PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    COALESCE(c.RBC_Code,                p.RBC_Code)                AS RBC_Code,
    COALESCE(c.GL_ACCOUNT_CODE,         p.GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE,

    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,

    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Persist
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    wb.*,
    (wb.Curr_GL_Balance - wb.Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN wb.Is_Add = 1  THEN 'ADD'
      WHEN wb.Is_Drop = 1 THEN 'DROP'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance <> wb.Prev_GL_Balance THEN 'BAL_CHANGE'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance  = wb.Prev_GL_Balance THEN 'NO_CHANGE'
      ELSE 'UNCLASSIFIED'
    END AS Change_Type
  FROM with_bank wb
),

/* POP totals (overall & by bank) from normalized sets */
pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl)                        AS prev_gl_sum,
    SUM(curr_gl)                        AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))         AS delta_gl_sum,
    CAST(NULL AS BIGINT)                AS acct_count,
    SUM(prev_cnt)                       AS prev_acct_count,
    SUM(curr_cnt)                       AS curr_acct_count
  FROM (
    SELECT SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev_norm
    UNION ALL
    SELECT CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr_norm
  ) u
),
pop_by_bank AS (
  SELECT
    'POP_BY_BANK' AS level,
    bank_code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    SUM(prev_cnt) AS prev_acct_count,
    SUM(curr_cnt) AS curr_acct_count
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS bank_code,
      SUM(GL_Balance) AS prev_gl,
      COUNT(DISTINCT Account_Identifier) AS prev_cnt,
      CAST(0 AS NUMERIC(18,2)) AS curr_gl,
      CAST(0 AS BIGINT)        AS curr_cnt
    FROM prev_norm
    GROUP BY 1

    UNION ALL

    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS bank_code,
      CAST(0 AS NUMERIC(18,2)) AS prev_gl,
      CAST(0 AS BIGINT)        AS prev_cnt,
      SUM(GL_Balance)          AS curr_gl,
      COUNT(DISTINCT Account_Identifier) AS curr_cnt
    FROM curr_norm
    GROUP BY 1
  ) u
  GROUP BY bank_code
),

/* Summaries (ADD / DROP / BAL_CHANGE) from normalized join */
summary_total AS (
  SELECT
    'SUMMARY_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Change_Type
),
summary_by_bank AS (
  SELECT
    'SUMMARY_BY_BANK' AS level,
    Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Bank_Code, Change_Type
),

/* Aggregates for Bridges (overall & by bank) */
overall_prev AS (
  SELECT SUM(GL_Balance) AS prev_total_gl,
         COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT SUM(GL_Balance) AS curr_total_gl,
         COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),
agg_overall_prev_curr AS (
  SELECT p.prev_total_gl, p.prev_total_cnt, c.curr_total_gl, c.curr_total_cnt
  FROM overall_prev p CROSS JOIN overall_curr c
),
agg_overall_add_drop_bal AS (
  SELECT
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0)  AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0)  AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)         AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)                AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)                AS drops_cnt
  FROM classified
),
by_bank_prev AS (
  SELECT
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS bank_code,
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
  GROUP BY 1
),
by_bank_curr AS (
  SELECT
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS bank_code,
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
  GROUP BY 1
),
agg_by_bank_prev_curr AS (
  SELECT
    COALESCE(p.bank_code, c.bank_code) AS bank_code,
    COALESCE(p.prev_total_gl,  0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl,  0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.bank_code = c.bank_code
),
agg_by_bank_add_drop_bal AS (
  SELECT
    bank_code,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0)     AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0)     AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)            AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)                   AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)                   AS drops_cnt
  FROM classified
  GROUP BY bank_code
),

/* =======================
   AUDIT: simple vs normalized
   ======================= */
simple_prev AS (
  SELECT SUM(GL_Balance) AS simple_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_prev_cnt
  FROM prev_raw
),
simple_curr AS (
  SELECT SUM(GL_Balance) AS simple_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS simple_curr_cnt
  FROM curr_raw
),
norm_prev AS (
  SELECT SUM(GL_Balance) AS norm_prev_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_prev_cnt
  FROM prev_norm
),
norm_curr AS (
  SELECT SUM(GL_Balance) AS norm_curr_gl,
         COUNT(DISTINCT Account_Identifier) AS norm_curr_cnt
  FROM curr_norm
),
audit_totals AS (
  SELECT 'PREV_GL' AS metric,
         s.simple_prev_gl::NUMERIC(18,2) AS simple_val,
         n.norm_prev_gl::NUMERIC(18,2)   AS norm_val,
         (n.norm_prev_gl - s.simple_prev_gl)::NUMERIC(18,2) AS delta_val
  FROM simple_prev s CROSS JOIN norm_prev n
  UNION ALL
  SELECT 'CURR_GL',
         s.simple_curr_gl::NUMERIC(18,2),
         n.norm_curr_gl::NUMERIC(18,2),
         (n.norm_curr_gl - s.simple_curr_gl)::NUMERIC(18,2)
  FROM simple_curr s CROSS JOIN norm_curr n
  UNION ALL
  SELECT 'PREV_CNT',
         s.simple_prev_cnt::NUMERIC(18,2),
         n.norm_prev_cnt::NUMERIC(18,2),
         (n.norm_prev_cnt - s.simple_prev_cnt)::NUMERIC(18,2)
  FROM simple_prev s CROSS JOIN norm_prev n
  UNION ALL
  SELECT 'CURR_CNT',
         s.simple_curr_cnt::NUMERIC(18,2),
         n.norm_curr_cnt::NUMERIC(18,2),
         (n.norm_curr_cnt - s.simple_curr_cnt)::NUMERIC(18,2)
  FROM simple_curr s CROSS JOIN norm_curr n
)

-- ============================================================================
-- FINAL OUTPUT (AUDIT + BRIDGEs + POP/SUMMARY/DETAIL), ordered for readability
-- ============================================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- detail cols
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  level_order,
  change_order
FROM (

  /* -------- AUDIT rows (4) -------- */
  SELECT
    'AUDIT'                                AS level,
    'GL'                                   AS Bank_Code,
    metric                                 AS Change_Type,      -- PREV_GL / CURR_GL / PREV_CNT / CURR_CNT
    CASE WHEN metric IN ('PREV_GL','CURR_GL') THEN simple_val ELSE NULL END AS prev_gl_sum,
    CASE WHEN metric IN ('PREV_GL','CURR_GL') THEN norm_val   ELSE NULL END AS curr_gl_sum,
    CASE WHEN metric IN ('PREV_GL','CURR_GL') THEN delta_val  ELSE NULL END AS delta_gl_sum,
    CASE WHEN metric IN ('PREV_CNT','CURR_CNT') THEN norm_val::BIGINT ELSE NULL END AS acct_count, -- norm in acct_count
    CASE WHEN metric IN ('PREV_CNT','CURR_CNT') THEN simple_val::BIGINT ELSE NULL END AS prev_acct_count, -- simple in prev_acct_count
    CASE WHEN metric IN ('PREV_CNT','CURR_CNT') THEN (norm_val - simple_val)::BIGINT ELSE NULL END AS curr_acct_count, -- delta in curr_acct_count
    CAST(NULL AS VARCHAR(64)) AS Account_Identifier,
    CAST(NULL AS VARCHAR(64)) AS Account_Key,
    CAST(NULL AS VARCHAR(256))AS Account_Name,
    CAST(NULL AS VARCHAR(64)) AS CIS_Customer_Number,
    CAST(NULL AS VARCHAR(64)) AS Facility_ID,
    CAST(NULL AS VARCHAR(64)) AS Contract_Source_System,
    CAST(NULL AS VARCHAR(128))AS Status_Code_Description,
    CAST(NULL AS VARCHAR(64)) AS GL_ACCOUNT_HIER_LEVEL_4,
    CAST(NULL AS VARCHAR(128))AS PROD_HIER_LEVEL_5,
    CAST(NULL AS VARCHAR(64)) AS RBC_Code,
    CAST(NULL AS VARCHAR(64)) AS GL_ACCOUNT_CODE,
    CAST(NULL AS NUMERIC(18,2)) AS Prev_GL_Balance,
    CAST(NULL AS NUMERIC(18,2)) AS Curr_GL_Balance,
    CAST(NULL AS NUMERIC(18,2)) AS GL_Delta,
    -1 AS level_order,
    CASE metric WHEN 'PREV_GL' THEN 0 WHEN 'CURR_GL' THEN 1 WHEN 'PREV_CNT' THEN 2 WHEN 'CURR_CNT' THEN 3 ELSE 99 END AS change_order
  FROM audit_totals

  /* -------- BRIDGE (BALANCE) — overall -------- */
  UNION ALL
  SELECT
    'BRIDGE','BALANCE','Prev Month Balance',
    CAST(NULL AS NUMERIC(18,2)), o.prev_total_gl, CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    0, 0
  FROM agg_overall_prev_curr o
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 1
  FROM agg_overall_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 2
  FROM agg_overall_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 3
  FROM agg_overall_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), o.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 4
  FROM agg_overall_prev_curr o

  /* -------- BRIDGE (COUNT) — overall -------- */
  UNION ALL
  SELECT 'BRIDGE','COUNT','Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 10
  FROM agg_overall_prev_curr o
  UNION ALL
  SELECT 'BRIDGE','COUNT','Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 11
  FROM agg_overall_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE','COUNT','Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 12
  FROM agg_overall_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE','COUNT','Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 13
  FROM agg_overall_prev_curr o

  /* -------- BRIDGE_BY_BANK (BALANCE) -------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Prev Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.prev_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 0
  FROM agg_by_bank_prev_curr b
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 1
  FROM agg_by_bank_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 2
  FROM agg_by_bank_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 3
  FROM agg_by_bank_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 4
  FROM agg_by_bank_prev_curr b

  /* -------- BRIDGE_BY_BANK (COUNT) -------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 10
  FROM agg_by_bank_prev_curr b
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 11
  FROM agg_by_bank_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 12
  FROM agg_by_bank_add_drop_bal a
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 13
  FROM agg_by_bank_prev_curr b

  /* -------- POP/SUMMARY/DETAIL -------- */
  UNION ALL
  SELECT 'POP_TOTAL', CAST(NULL AS VARCHAR(20)), CAST(NULL AS VARCHAR(20)),
         prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         2, 0
  FROM pop_total
  UNION ALL
  SELECT 'POP_BY_BANK', Bank_Code, CAST(NULL AS VARCHAR(20)),
         prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         3, 0
  FROM pop_by_bank
  UNION ALL
  SELECT 'SUMMARY_TOTAL', CAST(NULL AS VARCHAR(20)), Change_Type,
         prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         4,
         CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_total
  UNION ALL
  SELECT 'SUMMARY_BY_BANK', Bank_Code, Change_Type,
         prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         5,
         CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_by_bank
  UNION ALL
  SELECT 'DETAIL',
         Bank_Code,
         Change_Type,
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         Account_Identifier, Account_Key, Account_Name, CIS_Customer_Number, Facility_ID,
         Contract_Source_System, Status_Code_Description, GL_ACCOUNT_HIER_LEVEL_4,
         PROD_HIER_LEVEL_5, RBC_Code, GL_ACCOUNT_CODE, Prev_GL_Balance, Curr_GL_Balance, GL_Delta,
         6,
         CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM classified

) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code,'~'),
  z.change_order,
  z.Change_Type,
  z.Account_Identifier;







-- ==========================================================
-- MoM Non-Accrual Portfolio Movement (Ties Exactly)
--  - Normalizes per month to 1 row per Account_Identifier
--  - POP totals (overall & by Bank_Code)
--  - ADD / DROP / BAL_CHANGE summaries
--  - BRIDGE (overall & by Bank_Code) for BALANCE and COUNT
--  - Row-level DETAIL
-- ==========================================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),

/* Base population (two months, base filters that never change) */
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),

/* Per-month filtered NA sets (can have multiple rows per account) */
curr_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev_raw AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

/* ==========================================================
   NORMALIZE per month to 1 row per Account_Identifier
   ========================================================== */
curr_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                 AS Account_Key,
    MAX(Account_Name)                AS Account_Name,
    MAX(CIS_Customer_Number)         AS CIS_Customer_Number,
    MAX(Facility_ID)                 AS Facility_ID,
    MAX(Contract_Source_System)      AS Contract_Source_System,
    MAX(Status_Code_Description)     AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)     AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)       AS Source_System_Balance,
    SUM(GL_Balance)                  AS GL_Balance,
    MAX(Available_Balance)           AS Available_Balance,
    MAX(Borrower_Risk_Rating)        AS Borrower_Risk_Rating,
    MAX(PD_Grade)                    AS PD_Grade,
    MAX(Days_Past_Due)               AS Days_Past_Due,
    MAX(Non_Accrual_Flag)            AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)           AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                    AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)             AS GL_ACCOUNT_CODE
  FROM curr_raw
  GROUP BY Account_Identifier
),
prev_norm AS (
  SELECT
    Account_Identifier,
    MAX(Account_Key)                 AS Account_Key,
    MAX(Account_Name)                AS Account_Name,
    MAX(CIS_Customer_Number)         AS CIS_Customer_Number,
    MAX(Facility_ID)                 AS Facility_ID,
    MAX(Contract_Source_System)      AS Contract_Source_System,
    MAX(Status_Code_Description)     AS Status_Code_Description,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)     AS GL_ACCOUNT_HIER_LEVEL_4,
    SUM(Source_System_Balance)       AS Source_System_Balance,
    SUM(GL_Balance)                  AS GL_Balance,
    MAX(Available_Balance)           AS Available_Balance,
    MAX(Borrower_Risk_Rating)        AS Borrower_Risk_Rating,
    MAX(PD_Grade)                    AS PD_Grade,
    MAX(Days_Past_Due)               AS Days_Past_Due,
    MAX(Non_Accrual_Flag)            AS Non_Accrual_Flag,
    MAX(PROD_HIER_LEVEL_5)           AS PROD_HIER_LEVEL_5,
    MAX(RBC_Code)                    AS RBC_Code,
    MAX(GL_ACCOUNT_CODE)             AS GL_ACCOUNT_CODE
  FROM prev_raw
  GROUP BY Account_Identifier
),

/* ==========================================================
   Join normalized sets + Bank_Code + classification
   ========================================================== */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

    COALESCE(c.Contract_Source_System,  p.Contract_Source_System)  AS Contract_Source_System,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.PROD_HIER_LEVEL_5,       p.PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    COALESCE(c.RBC_Code,                p.RBC_Code)                AS RBC_Code,
    COALESCE(c.GL_ACCOUNT_CODE,         p.GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE,

    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,

    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Persist
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    wb.*,
    (wb.Curr_GL_Balance - wb.Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN wb.Is_Add = 1  THEN 'ADD'
      WHEN wb.Is_Drop = 1 THEN 'DROP'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance <> wb.Prev_GL_Balance THEN 'BAL_CHANGE'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance  = wb.Prev_GL_Balance THEN 'NO_CHANGE'
      ELSE 'UNCLASSIFIED'
    END AS Change_Type
  FROM with_bank wb
),

/* ==========================================================
   POP totals (overall & by bank) from normalized sets
   ========================================================== */
pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl)                        AS prev_gl_sum,
    SUM(curr_gl)                        AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))         AS delta_gl_sum,
    CAST(NULL AS BIGINT)                AS acct_count,
    SUM(prev_cnt)                       AS prev_acct_count,
    SUM(curr_cnt)                       AS curr_acct_count
  FROM (
    SELECT SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev_norm
    UNION ALL
    SELECT CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr_norm
  ) u
),
pop_by_bank AS (
  SELECT
    'POP_BY_BANK' AS level,
    bank_code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    SUM(prev_cnt) AS prev_acct_count,
    SUM(curr_cnt) AS curr_acct_count
  FROM (
    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS bank_code,
      SUM(GL_Balance) AS prev_gl,
      COUNT(DISTINCT Account_Identifier) AS prev_cnt,
      CAST(0 AS NUMERIC(18,2)) AS curr_gl,
      CAST(0 AS BIGINT)        AS curr_cnt
    FROM prev_norm
    GROUP BY 1

    UNION ALL

    SELECT
      CASE
        WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN Contract_Source_System = 'ALL'
             AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                     '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                     '1100001','1142067','1042886','1043008') THEN 'L-SVB'
        WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
        WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research'
      END AS bank_code,
      CAST(0 AS NUMERIC(18,2)) AS prev_gl,
      CAST(0 AS BIGINT)        AS prev_cnt,
      SUM(GL_Balance)          AS curr_gl,
      COUNT(DISTINCT Account_Identifier) AS curr_cnt
    FROM curr_norm
    GROUP BY 1
  ) u
  GROUP BY bank_code
),

/* ==========================================================
   SUMMARY (ADD / DROP / BAL_CHANGE) from normalized join
   ========================================================== */
summary_total AS (
  SELECT
    'SUMMARY_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Change_Type
),
summary_by_bank AS (
  SELECT
    'SUMMARY_BY_BANK' AS level,
    Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Bank_Code, Change_Type
),

/* ==========================================================
   Aggregates for BRIDGEs (overall & by bank) — from normalized sets
   ========================================================== */
overall_prev AS (
  SELECT
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
),
overall_curr AS (
  SELECT
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
),
agg_overall_prev_curr AS (
  SELECT
    p.prev_total_gl,
    p.prev_total_cnt,
    c.curr_total_gl,
    c.curr_total_cnt
  FROM overall_prev p
  CROSS JOIN overall_curr c
),
agg_overall_add_drop_bal AS (
  SELECT
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0)  AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0)  AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)         AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)                AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)                AS drops_cnt
  FROM classified
),
by_bank_prev AS (
  SELECT
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS bank_code,
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_norm
  GROUP BY 1
),
by_bank_curr AS (
  SELECT
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
                                   '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
                                   '1100001','1142067','1042886','1043008') THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO') THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                      'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                      'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                      'STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS bank_code,
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_norm
  GROUP BY 1
),
agg_by_bank_prev_curr AS (
  SELECT
    COALESCE(p.bank_code, c.bank_code) AS bank_code,
    COALESCE(p.prev_total_gl,  0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl,  0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.bank_code = c.bank_code
),
agg_by_bank_add_drop_bal AS (
  SELECT
    bank_code,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0)     AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0)     AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)            AS bal_delta,
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)                   AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)                   AS drops_cnt
  FROM classified
  GROUP BY bank_code
)

/* ==========================================================
   FINAL OUTPUT (all sections in one ordered result set)
   ========================================================== */
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- Detail columns (NULL for non-detail rows)
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  -- sort helpers
  level_order,
  change_order
FROM (

  /* ---------------------------
     BRIDGE (BALANCE) — overall
     --------------------------- */
  SELECT
    'BRIDGE'                                    AS level,
    'BALANCE'                                   AS Bank_Code,
    'Prev Month Balance'                        AS Change_Type,
    CAST(NULL AS NUMERIC(18,2))                 AS prev_gl_sum,
    o.prev_total_gl                             AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))                 AS delta_gl_sum,
    CAST(NULL AS BIGINT)                        AS acct_count,
    CAST(NULL AS BIGINT)                        AS prev_acct_count,
    CAST(NULL AS BIGINT)                        AS curr_acct_count,
    CAST(NULL AS VARCHAR(64))                   AS Account_Identifier,
    CAST(NULL AS VARCHAR(64))                   AS Account_Key,
    CAST(NULL AS VARCHAR(256))                  AS Account_Name,
    CAST(NULL AS VARCHAR(64))                   AS CIS_Customer_Number,
    CAST(NULL AS VARCHAR(64))                   AS Facility_ID,
    CAST(NULL AS VARCHAR(64))                   AS Contract_Source_System,
    CAST(NULL AS VARCHAR(128))                  AS Status_Code_Description,
    CAST(NULL AS VARCHAR(64))                   AS GL_ACCOUNT_HIER_LEVEL_4,
    CAST(NULL AS VARCHAR(128))                  AS PROD_HIER_LEVEL_5,
    CAST(NULL AS VARCHAR(64))                   AS RBC_Code,
    CAST(NULL AS VARCHAR(64))                   AS GL_ACCOUNT_CODE,
    CAST(NULL AS NUMERIC(18,2))                 AS Prev_GL_Balance,
    CAST(NULL AS NUMERIC(18,2))                 AS Curr_GL_Balance,
    CAST(NULL AS NUMERIC(18,2))                 AS GL_Delta,
    0                                           AS level_order,
    0                                           AS change_order
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 1
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 2
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 3
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), o.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 4
  FROM agg_overall_prev_curr o

  /* ------------------------
     BRIDGE (COUNT) — overall
     ------------------------ */
  UNION ALL
  SELECT 'BRIDGE','COUNT','Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 10
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','COUNT','Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 11
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 12
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 13
  FROM agg_overall_prev_curr o

  /* ---------------------------------------
     BRIDGE_BY_BANK (BALANCE) — per bank
     --------------------------------------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Prev Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.prev_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 0
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 1
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 2
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 3
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 4
  FROM agg_by_bank_prev_curr b

  /* ------------------------------------
     BRIDGE_BY_BANK (COUNT) — per bank
     ------------------------------------ */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 10
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 11
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 12
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 13
  FROM agg_by_bank_prev_curr b

  /* -----------------------------------------
     POP_* , SUMMARY_* , and DETAIL rows
     ----------------------------------------- */
  UNION ALL
  SELECT
    'POP_TOTAL', CAST(NULL AS VARCHAR(20)), CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    2, 0
  FROM pop_total

  UNION ALL
  SELECT
    'POP_BY_BANK', Bank_Code, CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    3, 0
  FROM pop_by_bank

  UNION ALL
  SELECT
    'SUMMARY_TOTAL', CAST(NULL AS VARCHAR(20)), Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    4,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_total

  UNION ALL
  SELECT
    'SUMMARY_BY_BANK', Bank_Code, Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    5,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_by_bank

  UNION ALL
  SELECT
    'DETAIL' AS level,
    Bank_Code,
    Change_Type,
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    Account_Identifier, Account_Key, Account_Name, CIS_Customer_Number, Facility_ID,
    Contract_Source_System, Status_Code_Description, GL_ACCOUNT_HIER_LEVEL_4,
    PROD_HIER_LEVEL_5, RBC_Code, GL_ACCOUNT_CODE, Prev_GL_Balance, Curr_GL_Balance, GL_Delta,
    6,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM classified
) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code,'~'),
  z.change_order,
  z.Change_Type,
  z.Account_Identifier;





-- ============================================
-- Simple Non-Accrual Population Pull (Prev & Curr Month)
-- Includes Bank_Code logic
-- ============================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
)
SELECT
    End_of_Month_Date,
    Account_Name,
    Contract_Source_System,
    CIS_Customer_Number,
    Facility_ID,
    Account_Identifier,
    Account_Key,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    Non_Accrual_Flag,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    GL_ACCOUNT_CODE,
    CASE
      WHEN Contract_Source_System IN
           ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN
           ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN
           ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
            'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
            'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
            'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
            'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
  AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                            (SELECT prev_eom FROM params))
  AND Non_Accrual_Flag = 'Y'
  AND Source_System_Balance > 0
ORDER BY
  End_of_Month_Date,
  Bank_Code,
  Account_Identifier;







-- ============================================
-- Simple pull: Non-Accrual populations for prev & curr EOM
-- (same filters, same fields as your original pop CTE)
-- ============================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
)
SELECT *
FROM pop
WHERE Non_Accrual_Flag = 'Y'
  AND Source_System_Balance > 0
ORDER BY
  End_of_Month_Date,
  Account_Identifier;






by_bank_prev AS (
  SELECT
    bank_code,
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_with_bank
  GROUP BY bank_code
),
by_bank_curr AS (
  SELECT
    bank_code,
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_with_bank
  GROUP BY bank_code
),
agg_by_bank_prev_curr AS (
  SELECT
    COALESCE(p.bank_code, c.bank_code) AS bank_code,
    COALESCE(p.prev_total_gl,  0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl,  0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.bank_code = c.bank_code
),







overall_prev AS (
  SELECT
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev
),
overall_curr AS (
  SELECT
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr
),
agg_overall_prev_curr AS (
  SELECT
    p.prev_total_gl,
    p.prev_total_cnt,
    c.curr_total_gl,
    c.curr_total_cnt
  FROM overall_prev p
  CROSS JOIN overall_curr c   -- safe 1x1 join (no blow-up)
),


by_bank_prev AS (
  SELECT
    bank_code,
    SUM(GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT Account_Identifier) AS prev_total_cnt
  FROM prev_with_bank
  GROUP BY bank_code
),
by_bank_curr AS (
  SELECT
    bank_code,
    SUM(GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT Account_Identifier) AS curr_total_cnt
  FROM curr_with_bank
  GROUP BY bank_code
),
agg_by_bank_prev_curr AS (
  SELECT
    COALESCE(p.bank_code, c.bank_code) AS bank_code,
    COALESCE(p.prev_total_gl,  0) AS prev_total_gl,
    COALESCE(p.prev_total_cnt, 0) AS prev_total_cnt,
    COALESCE(c.curr_total_gl,  0) AS curr_total_gl,
    COALESCE(c.curr_total_cnt, 0) AS curr_total_cnt
  FROM by_bank_prev p
  FULL OUTER JOIN by_bank_curr c
    ON p.bank_code = c.bank_code
),







-- ==========================================================
-- FINAL OUTPUT (fixed: first UNION SELECT aliases every column)
-- ==========================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- Detail columns (NULL for non-detail rows)
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  -- sort helpers
  level_order,
  change_order
FROM (

  /* ---------------------------
     BRIDGE (BALANCE) — overall
     --------------------------- */
  SELECT
    'BRIDGE'                                    AS level,
    'BALANCE'                                   AS Bank_Code,
    'Prev Month Balance'                        AS Change_Type,
    CAST(NULL AS NUMERIC(18,2))                 AS prev_gl_sum,
    o.prev_total_gl                             AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))                 AS delta_gl_sum,
    CAST(NULL AS BIGINT)                        AS acct_count,
    CAST(NULL AS BIGINT)                        AS prev_acct_count,
    CAST(NULL AS BIGINT)                        AS curr_acct_count,
    CAST(NULL AS VARCHAR(64))                   AS Account_Identifier,
    CAST(NULL AS VARCHAR(64))                   AS Account_Key,
    CAST(NULL AS VARCHAR(256))                  AS Account_Name,
    CAST(NULL AS VARCHAR(64))                   AS CIS_Customer_Number,
    CAST(NULL AS VARCHAR(64))                   AS Facility_ID,
    CAST(NULL AS VARCHAR(64))                   AS Contract_Source_System,
    CAST(NULL AS VARCHAR(128))                  AS Status_Code_Description,
    CAST(NULL AS VARCHAR(64))                   AS GL_ACCOUNT_HIER_LEVEL_4,
    CAST(NULL AS VARCHAR(128))                  AS PROD_HIER_LEVEL_5,
    CAST(NULL AS VARCHAR(64))                   AS RBC_Code,
    CAST(NULL AS VARCHAR(64))                   AS GL_ACCOUNT_CODE,
    CAST(NULL AS NUMERIC(18,2))                 AS Prev_GL_Balance,
    CAST(NULL AS NUMERIC(18,2))                 AS Curr_GL_Balance,
    CAST(NULL AS NUMERIC(18,2))                 AS GL_Delta,
    0                                           AS level_order,
    0                                           AS change_order
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 1
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 2
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 3
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), o.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 4
  FROM agg_overall_prev_curr o

  /* ------------------------
     BRIDGE (COUNT) — overall
     ------------------------ */
  UNION ALL
  SELECT 'BRIDGE','COUNT','Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 10
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','COUNT','Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 11
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 12
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 13
  FROM agg_overall_prev_curr o

  /* ---------------------------------------
     BRIDGE_BY_BANK (BALANCE) — per bank
     --------------------------------------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Prev Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.prev_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 0
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 1
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 2
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 3
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 4
  FROM agg_by_bank_prev_curr b

  /* ------------------------------------
     BRIDGE_BY_BANK (COUNT) — per bank
     ------------------------------------ */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 10
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 11
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 12
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 13
  FROM agg_by_bank_prev_curr b

  /* -----------------------------------------
     existing POP_*, SUMMARY_*, and DETAIL rows
     ----------------------------------------- */
  UNION ALL
  SELECT
    'POP_TOTAL', CAST(NULL AS VARCHAR(20)), CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    2, 0
  FROM pop_total

  UNION ALL
  SELECT
    'POP_BY_BANK', Bank_Code, CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    3, 0
  FROM pop_by_bank

  UNION ALL
  SELECT
    'SUMMARY_TOTAL', CAST(NULL AS VARCHAR(20)), Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    4,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_total

  UNION ALL
  SELECT
    'SUMMARY_BY_BANK', Bank_Code, Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    5,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_by_bank

  UNION ALL
  SELECT
    'DETAIL' AS level,
    Bank_Code,
    Change_Type,
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    Account_Identifier, Account_Key, Account_Name, CIS_Customer_Number, Facility_ID,
    Contract_Source_System, Status_Code_Description, GL_ACCOUNT_HIER_LEVEL_4,
    PROD_HIER_LEVEL_5, RBC_Code, GL_ACCOUNT_CODE, Prev_GL_Balance, Curr_GL_Balance, GL_Delta,
    6,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM classified
) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code,'~'),
  z.change_order,
  z.Change_Type,
  z.Account_Identifier;







-- ==========================================================
-- MoM Non-Accrual Portfolio Movement: Pop totals, Summaries,
-- Bridges (overall & by Bank_Code), and Detail
-- Netezza-safe: avoids scalar subqueries to CTE columns.
-- ==========================================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- Current EOM NA (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- Prior EOM NA (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- =========================
-- JOIN + CLASSIFICATION
-- =========================
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

    COALESCE(c.Contract_Source_System,  p.Contract_Source_System)  AS Contract_Source_System,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.PROD_HIER_LEVEL_5,       p.PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    COALESCE(c.RBC_Code,                p.RBC_Code)                AS RBC_Code,
    COALESCE(c.GL_ACCOUNT_CODE,         p.GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE,

    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,

    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Persist
  FROM curr c
  FULL OUTER JOIN prev p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    wb.*,
    (wb.Curr_GL_Balance - wb.Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN wb.Is_Add = 1  THEN 'ADD'
      WHEN wb.Is_Drop = 1 THEN 'DROP'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance <> wb.Prev_GL_Balance THEN 'BAL_CHANGE'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance  = wb.Prev_GL_Balance THEN 'NO_CHANGE'
      ELSE 'UNCLASSIFIED'
    END AS Change_Type
  FROM with_bank wb
),

-- =========================
-- POPULATION TOTALS (overall & by bank)
-- =========================
curr_with_bank AS (
  SELECT
    c.*,
    CASE
      WHEN c.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System = 'ALL'
           AND c.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN c.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM curr c
),
prev_with_bank AS (
  SELECT
    p.*,
    CASE
      WHEN p.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System = 'ALL'
           AND p.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN p.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM prev p
),
-- Overall totals
pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl)                        AS prev_gl_sum,
    SUM(curr_gl)                        AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))         AS delta_gl_sum,
    CAST(NULL AS BIGINT)                AS acct_count,
    SUM(prev_cnt)                       AS prev_acct_count,
    SUM(curr_cnt)                       AS curr_acct_count
  FROM (
    SELECT SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev
    UNION ALL
    SELECT CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr
  ) u
),
-- Per-bank totals
pop_by_bank AS (
  SELECT
    'POP_BY_BANK' AS level,
    bank_code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    SUM(prev_cnt) AS prev_acct_count,
    SUM(curr_cnt) AS curr_acct_count
  FROM (
    SELECT bank_code, SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev_with_bank
    GROUP BY bank_code
    UNION ALL
    SELECT bank_code, CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr_with_bank
    GROUP BY bank_code
  ) u
  GROUP BY bank_code
),

-- =========================
-- SUMMARY (ADD/DROP/BAL_CHANGE)
-- =========================
summary_total AS (
  SELECT
    'SUMMARY_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Change_Type
),
summary_by_bank AS (
  SELECT
    'SUMMARY_BY_BANK' AS level,
    Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Bank_Code, Change_Type
),

-- ==========================================================
-- AGGREGATES for BRIDGE (avoid scalar CTE column refs)
-- ==========================================================
-- Overall (single-row) aggregates for bridge values
agg_overall_prev_curr AS (
  SELECT
    SUM(p.GL_Balance) AS prev_total_gl,
    COUNT(DISTINCT p.Account_Identifier) AS prev_total_cnt,
    SUM(c.GL_Balance) AS curr_total_gl,
    COUNT(DISTINCT c.Account_Identifier) AS curr_total_cnt
  FROM prev p, curr c
  -- Cartesian used just to create a single row; sums/counts are independent
),
agg_overall_add_drop_bal AS (
  SELECT
    -- Adds: use current GL of added accounts
    COALESCE(SUM(CASE WHEN Change_Type='ADD' THEN Curr_GL_Balance END),0)       AS adds_gl,
    -- Drops: negative of prior GL of dropped accounts
    -COALESCE(SUM(CASE WHEN Change_Type='DROP' THEN Prev_GL_Balance END),0)     AS drops_gl,
    -- Persisting balance delta
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)       AS bal_delta,
    -- Counts
    COALESCE(SUM(CASE WHEN Change_Type='ADD'  THEN 1 END),0)                    AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP' THEN 1 END),0)                   AS drops_cnt
  FROM classified
),
-- Per-bank aggregates for bridge_by_bank
agg_by_bank_prev_curr AS (
  SELECT
    bank_code,
    SUM(CASE WHEN src='PREV' THEN gl ELSE 0 END)  AS prev_total_gl,
    SUM(CASE WHEN src='PREV' THEN cnt ELSE 0 END) AS prev_total_cnt,
    SUM(CASE WHEN src='CURR' THEN gl ELSE 0 END)  AS curr_total_gl,
    SUM(CASE WHEN src='CURR' THEN cnt ELSE 0 END) AS curr_total_cnt
  FROM (
    SELECT bank_code, SUM(GL_Balance) AS gl, COUNT(DISTINCT Account_Identifier) AS cnt, 'PREV' AS src
    FROM prev_with_bank GROUP BY bank_code
    UNION ALL
    SELECT bank_code, SUM(GL_Balance), COUNT(DISTINCT Account_Identifier), 'CURR'
    FROM curr_with_bank GROUP BY bank_code
  ) u
  GROUP BY bank_code
),
agg_by_bank_add_drop_bal AS (
  SELECT
    bank_code,
    -- Balance pieces
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN Curr_GL_Balance END),0)     AS adds_gl,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN Prev_GL_Balance END),0)     AS drops_gl,
    COALESCE(SUM(CASE WHEN Change_Type='BAL_CHANGE' THEN GL_Delta END),0)            AS bal_delta,
    -- Count pieces
    COALESCE(SUM(CASE WHEN Change_Type='ADD'        THEN 1 END),0)                   AS adds_cnt,
    -COALESCE(SUM(CASE WHEN Change_Type='DROP'      THEN 1 END),0)                   AS drops_cnt
  FROM classified
  GROUP BY bank_code
)

-- ==========================================================
-- FINAL OUTPUT:
--   - BRIDGE (BALANCE & COUNT) overall (4+1 / 3+1 rows)
--   - BRIDGE_BY_BANK (BALANCE & COUNT) per bank
--   - POP_* , SUMMARY_* , DETAIL
-- ==========================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- Detail columns (NULL for non-detail rows)
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  -- sort helpers
  level_order,
  change_order
FROM (

  /* ---------------------------
     BRIDGE (BALANCE) — overall
     --------------------------- */
  SELECT
    'BRIDGE' AS level,
    'BALANCE' AS Bank_Code,
    'Prev Month Balance' AS Change_Type,
    CAST(NULL AS NUMERIC(18,2)) AS prev_gl_sum,
    o.prev_total_gl              AS curr_gl_sum,         -- carry value in curr_gl_sum
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    CAST(NULL AS BIGINT)        AS prev_acct_count,
    CAST(NULL AS BIGINT)        AS curr_acct_count,
    -- detail nulls
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    0 AS level_order, 0 AS change_order
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 1
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 2
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 3
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','BALANCE','Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), o.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 4
  FROM agg_overall_prev_curr o

  /* ------------------------
     BRIDGE (COUNT) — overall
     ------------------------ */
  UNION ALL
  SELECT 'BRIDGE','COUNT','Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 10
  FROM agg_overall_prev_curr o

  UNION ALL
  SELECT 'BRIDGE','COUNT','Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 11
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 12
  FROM agg_overall_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE','COUNT','Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         o.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 13
  FROM agg_overall_prev_curr o

  /* ---------------------------------------
     BRIDGE_BY_BANK (BALANCE) — per bank
     --------------------------------------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Prev Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.prev_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1 AS level_order, 0 AS change_order
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), a.adds_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 1
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), a.drops_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 2
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', a.bank_code, 'Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)), a.bal_delta, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 3
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', b.bank_code, 'Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), b.curr_total_gl, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 4
  FROM agg_by_bank_prev_curr b

  /* ------------------------------------
     BRIDGE_BY_BANK (COUNT) — per bank
     ------------------------------------ */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.prev_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 10
  FROM agg_by_bank_prev_curr b

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.adds_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 11
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || a.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         a.drops_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 12
  FROM agg_by_bank_add_drop_bal a

  UNION ALL
  SELECT 'BRIDGE_BY_BANK', 'COUNT:' || b.bank_code, 'Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         b.curr_total_cnt, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 13
  FROM agg_by_bank_prev_curr b

  /* -----------------------------------------
     existing POP_*, SUMMARY_*, and DETAIL rows
     ----------------------------------------- */
  UNION ALL
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    2 AS level_order, 0 AS change_order
  FROM pop_total

  UNION ALL
  SELECT
    'POP_BY_BANK', Bank_Code, CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    3, 0
  FROM pop_by_bank

  UNION ALL
  SELECT
    'SUMMARY_TOTAL', CAST(NULL AS VARCHAR(20)), Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    4,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_total

  UNION ALL
  SELECT
    'SUMMARY_BY_BANK', Bank_Code, Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    5,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_by_bank

  UNION ALL
  SELECT
    'DETAIL' AS level,
    Bank_Code,
    Change_Type,
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    Account_Identifier, Account_Key, Account_Name, CIS_Customer_Number, Facility_ID,
    Contract_Source_System, Status_Code_Description, GL_ACCOUNT_HIER_LEVEL_4,
    PROD_HIER_LEVEL_5, RBC_Code, GL_ACCOUNT_CODE, Prev_GL_Balance, Curr_GL_Balance, GL_Delta,
    6 AS level_order,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM classified

) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code,'~'),
  z.change_order,
  z.Change_Type,
  z.Account_Identifier;






-- ==========================================================
-- MoM Non-Accrual Portfolio Movement: Pop totals, Summaries,
-- Bridges (overall & by Bank_Code), and Detail
-- ==========================================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- Current EOM NA (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- Prior EOM NA (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- =========================
-- JOIN + CLASSIFICATION
-- =========================
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

    COALESCE(c.Contract_Source_System,  p.Contract_Source_System)  AS Contract_Source_System,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.PROD_HIER_LEVEL_5,       p.PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    COALESCE(c.RBC_Code,                p.RBC_Code)                AS RBC_Code,
    COALESCE(c.GL_ACCOUNT_CODE,         p.GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE,

    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,

    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Persist
  FROM curr c
  FULL OUTER JOIN prev p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    wb.*,
    (wb.Curr_GL_Balance - wb.Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN wb.Is_Add = 1  THEN 'ADD'
      WHEN wb.Is_Drop = 1 THEN 'DROP'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance <> wb.Prev_GL_Balance THEN 'BAL_CHANGE'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance  = wb.Prev_GL_Balance THEN 'NO_CHANGE'
      ELSE 'UNCLASSIFIED'
    END AS Change_Type
  FROM with_bank wb
),

-- =========================
-- POPULATION TOTALS (curr/prev) — overall and by bank
-- =========================
curr_with_bank AS (
  SELECT
    c.*,
    CASE
      WHEN c.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System = 'ALL'
           AND c.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN c.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM curr c
),
prev_with_bank AS (
  SELECT
    p.*,
    CASE
      WHEN p.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System = 'ALL'
           AND p.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN p.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM prev p
),
pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl)                        AS prev_gl_sum,
    SUM(curr_gl)                        AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))         AS delta_gl_sum,
    CAST(NULL AS BIGINT)                AS acct_count,
    SUM(prev_cnt)                       AS prev_acct_count,
    SUM(curr_cnt)                       AS curr_acct_count
  FROM (
    SELECT SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev
    UNION ALL
    SELECT CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr
  ) u
),
pop_by_bank AS (
  SELECT
    'POP_BY_BANK' AS level,
    bank_code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    SUM(prev_cnt) AS prev_acct_count,
    SUM(curr_cnt) AS curr_acct_count
  FROM (
    SELECT bank_code, SUM(GL_Balance) AS prev_gl, CAST(0 AS NUMERIC(18,2)) AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, CAST(0 AS BIGINT) AS curr_cnt
    FROM prev_with_bank
    GROUP BY bank_code
    UNION ALL
    SELECT bank_code, CAST(0 AS NUMERIC(18,2)), SUM(GL_Balance),
           CAST(0 AS BIGINT), COUNT(DISTINCT Account_Identifier)
    FROM curr_with_bank
    GROUP BY bank_code
  ) u
  GROUP BY bank_code
),

-- =========================
-- SUMMARY (ADD/DROP/BAL_CHANGE)
-- =========================
summary_total AS (
  SELECT
    'SUMMARY_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Change_Type
),
summary_by_bank AS (
  SELECT
    'SUMMARY_BY_BANK' AS level,
    Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Bank_Code, Change_Type
)

-- ==========================================================
-- FINAL OUTPUT:
--   - BRIDGE (BALANCE & COUNT)
--   - BRIDGE_BY_BANK (BALANCE & COUNT)
--   - POP_* , SUMMARY_* , DETAIL
-- ==========================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- Detail columns (NULL for non-detail rows)
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  -- sort helpers
  level_order,
  change_order
FROM (

  /* ---------------------------
     BRIDGE (BALANCE) — overall
     --------------------------- */
  SELECT
    'BRIDGE' AS level,
    'BALANCE' AS Bank_Code,
    'Prev Month Balance' AS Change_Type,
    CAST(NULL AS NUMERIC(18,2)),
    (SELECT prev_gl_sum FROM pop_total),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    -- detail nulls
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    0 AS level_order, 0 AS change_order
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Adds',
         CAST(NULL AS NUMERIC(18,2)),
         COALESCE((SELECT curr_gl_sum FROM summary_total WHERE Change_Type='ADD'),0),
         CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 1
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Drops',
         CAST(NULL AS NUMERIC(18,2)),
         -COALESCE((SELECT prev_gl_sum FROM summary_total WHERE Change_Type='DROP'),0),
         CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 2
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)),
         COALESCE((SELECT delta_gl_sum FROM summary_total WHERE Change_Type='BAL_CHANGE'),0),
         CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 3
  UNION ALL
  SELECT 'BRIDGE','BALANCE','Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)),
         (SELECT curr_gl_sum FROM pop_total),
         CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 4

  /* ------------------------
     BRIDGE (COUNT) — overall
     ------------------------ */
  UNION ALL
  SELECT 'BRIDGE','COUNT','Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         (SELECT prev_acct_count FROM pop_total),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 10
  UNION ALL
  SELECT 'BRIDGE','COUNT','Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         COALESCE((SELECT acct_count FROM summary_total WHERE Change_Type='ADD'),0),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 11
  UNION ALL
  SELECT 'BRIDGE','COUNT','Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         -COALESCE((SELECT acct_count FROM summary_total WHERE Change_Type='DROP'),0),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 12
  UNION ALL
  SELECT 'BRIDGE','COUNT','Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         (SELECT curr_acct_count FROM pop_total),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         0, 13

  /* ---------------------------------------
     BRIDGE_BY_BANK (BALANCE) — per bank
     --------------------------------------- */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', pbb.bank_code, 'Prev Month Balance',
         CAST(NULL AS NUMERIC(18,2)), pbb.prev_gl_sum, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1 AS level_order, 0 AS change_order
  FROM pop_by_bank pbb
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', sbb.bank_code, 'Adds',
         CAST(NULL AS NUMERIC(18,2)),
         sbb.curr_gl_sum, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 1
  FROM summary_by_bank sbb
  WHERE sbb.Change_Type = 'ADD'
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', sbb.bank_code, 'Drops',
         CAST(NULL AS NUMERIC(18,2)),
         -sbb.prev_gl_sum, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 2
  FROM summary_by_bank sbb
  WHERE sbb.Change_Type = 'DROP'
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', sbb.bank_code, 'Persisting Bal Changes',
         CAST(NULL AS NUMERIC(18,2)),
         sbb.delta_gl_sum, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 3
  FROM summary_by_bank sbb
  WHERE sbb.Change_Type = 'BAL_CHANGE'
  UNION ALL
  SELECT 'BRIDGE_BY_BANK', pbb.bank_code, 'Current Month Balance',
         CAST(NULL AS NUMERIC(18,2)), pbb.curr_gl_sum, CAST(NULL AS NUMERIC(18,2)),
         CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 4
  FROM pop_by_bank pbb

  /* ------------------------------------
     BRIDGE_BY_BANK (COUNT) — per bank
     ------------------------------------ */
  UNION ALL
  SELECT 'BRIDGE_BY_BANK','COUNT:' || pbb.bank_code,'Prev Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         pbb.prev_acct_count, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 10
  FROM pop_by_bank pbb
  UNION ALL
  SELECT 'BRIDGE_BY_BANK','COUNT:' || sbb.bank_code,'Adds',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         sbb.acct_count, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 11
  FROM summary_by_bank sbb
  WHERE sbb.Change_Type = 'ADD'
  UNION ALL
  SELECT 'BRIDGE_BY_BANK','COUNT:' || sbb.bank_code,'Drops',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         -sbb.acct_count, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 12
  FROM summary_by_bank sbb
  WHERE sbb.Change_Type = 'DROP'
  UNION ALL
  SELECT 'BRIDGE_BY_BANK','COUNT:' || pbb.bank_code,'Current Month Count',
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         pbb.curr_acct_count, CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
         CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
         CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
         1, 13
  FROM pop_by_bank pbb

  /* -----------------------------------------
     existing POP_*, SUMMARY_*, and DETAIL rows
     ----------------------------------------- */
  UNION ALL
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    2 AS level_order, 0 AS change_order
  FROM pop_total

  UNION ALL
  SELECT
    'POP_BY_BANK', Bank_Code, CAST(NULL AS VARCHAR(20)),
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    3, 0
  FROM pop_by_bank

  UNION ALL
  SELECT
    'SUMMARY_TOTAL', CAST(NULL AS VARCHAR(20)), Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    4,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_total

  UNION ALL
  SELECT
    'SUMMARY_BY_BANK', Bank_Code, Change_Type,
    prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    5,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM summary_by_bank

  UNION ALL
  SELECT
    'DETAIL' AS level,
    Bank_Code,
    Change_Type,
    CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS BIGINT), CAST(NULL AS BIGINT), CAST(NULL AS BIGINT),
    Account_Identifier, Account_Key, Account_Name, CIS_Customer_Number, Facility_ID,
    Contract_Source_System, Status_Code_Description, GL_ACCOUNT_HIER_LEVEL_4,
    PROD_HIER_LEVEL_5, RBC_Code, GL_ACCOUNT_CODE, Prev_GL_Balance, Curr_GL_Balance, GL_Delta,
    6 AS level_order,
    CASE Change_Type WHEN 'ADD' THEN 1 WHEN 'DROP' THEN 2 WHEN 'BAL_CHANGE' THEN 3 WHEN 'NO_CHANGE' THEN 4 ELSE 99 END
  FROM classified

) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code,'~'),
  z.change_order,
  z.Change_Type,
  z.Account_Identifier;







-- ==========================================================
-- FINAL OUTPUT (adds sort helper columns to satisfy Netezza)
-- ==========================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,
  -- Detail columns (NULL on non-detail rows)
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta,
  -- sort helpers (safe to hide in PBI)
  level_order,
  change_order
FROM (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    prev_gl_sum,
    curr_gl_sum,
    delta_gl_sum,
    acct_count,
    prev_acct_count,
    curr_acct_count,
    -- detail NULLs
    CAST(NULL AS VARCHAR(64))  AS Account_Identifier,
    CAST(NULL AS VARCHAR(64))  AS Account_Key,
    CAST(NULL AS VARCHAR(256)) AS Account_Name,
    CAST(NULL AS VARCHAR(64))  AS CIS_Customer_Number,
    CAST(NULL AS VARCHAR(64))  AS Facility_ID,
    CAST(NULL AS VARCHAR(64))  AS Contract_Source_System,
    CAST(NULL AS VARCHAR(128)) AS Status_Code_Description,
    CAST(NULL AS VARCHAR(64))  AS GL_ACCOUNT_HIER_LEVEL_4,
    CAST(NULL AS VARCHAR(128)) AS PROD_HIER_LEVEL_5,
    CAST(NULL AS VARCHAR(64))  AS RBC_Code,
    CAST(NULL AS VARCHAR(64))  AS GL_ACCOUNT_CODE,
    CAST(NULL AS NUMERIC(18,2)) AS Prev_GL_Balance,
    CAST(NULL AS NUMERIC(18,2)) AS Curr_GL_Balance,
    CAST(NULL AS NUMERIC(18,2)) AS GL_Delta,
    0 AS level_order,
    0 AS change_order
  FROM pop_total

  UNION ALL

  SELECT
    'POP_BY_BANK',
    Bank_Code,
    CAST(NULL AS VARCHAR(20)),
    prev_gl_sum,
    curr_gl_sum,
    delta_gl_sum,
    acct_count,
    prev_acct_count,
    curr_acct_count,
    -- detail NULLs
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    1 AS level_order,
    0 AS change_order
  FROM pop_by_bank

  UNION ALL

  SELECT
    'SUMMARY_TOTAL',
    CAST(NULL AS VARCHAR(20)),
    Change_Type,
    prev_gl_sum,
    curr_gl_sum,
    delta_gl_sum,
    acct_count,
    prev_acct_count,
    curr_acct_count,
    -- detail NULLs
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    2 AS level_order,
    CASE Change_Type
      WHEN 'ADD'        THEN 1
      WHEN 'DROP'       THEN 2
      WHEN 'BAL_CHANGE' THEN 3
      WHEN 'NO_CHANGE'  THEN 4
      ELSE 99
    END AS change_order
  FROM summary_total

  UNION ALL

  SELECT
    'SUMMARY_BY_BANK',
    Bank_Code,
    Change_Type,
    prev_gl_sum,
    curr_gl_sum,
    delta_gl_sum,
    acct_count,
    prev_acct_count,
    curr_acct_count,
    -- detail NULLs
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(256)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(128)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS VARCHAR(64)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    CAST(NULL AS NUMERIC(18,2)),
    3 AS level_order,
    CASE Change_Type
      WHEN 'ADD'        THEN 1
      WHEN 'DROP'       THEN 2
      WHEN 'BAL_CHANGE' THEN 3
      WHEN 'NO_CHANGE'  THEN 4
      ELSE 99
    END AS change_order
  FROM summary_by_bank

  UNION ALL

  SELECT
    'DETAIL' AS level,
    Bank_Code,
    Change_Type,
    CAST(NULL AS NUMERIC(18,2)) AS prev_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    CAST(NULL AS BIGINT)        AS prev_acct_count,
    CAST(NULL AS BIGINT)        AS curr_acct_count,
    Account_Identifier,
    Account_Key,
    Account_Name,
    CIS_Customer_Number,
    Facility_ID,
    Contract_Source_System,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    GL_ACCOUNT_CODE,
    Prev_GL_Balance,
    Curr_GL_Balance,
    GL_Delta,
    4 AS level_order,
    CASE Change_Type
      WHEN 'ADD'        THEN 1
      WHEN 'DROP'       THEN 2
      WHEN 'BAL_CHANGE' THEN 3
      WHEN 'NO_CHANGE'  THEN 4
      ELSE 99
    END AS change_order
  FROM classified
) z
ORDER BY
  z.level_order,
  COALESCE(z.Bank_Code, '~'),
  z.change_order,
  z.Account_Identifier;








pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    -- GL sums (both months)
    SUM(prev_gl)                               AS prev_gl_sum,
    SUM(curr_gl)                               AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2))                AS delta_gl_sum,
    CAST(NULL AS BIGINT)                       AS acct_count,
    -- month-specific counts (AGGREGATED — this fixes the error)
    SUM(prev_cnt)                              AS prev_acct_count,
    SUM(curr_cnt)                              AS curr_acct_count
  FROM (
    SELECT
      SUM(GL_Balance)                              AS prev_gl,
      CAST(0 AS NUMERIC(18,2))                     AS curr_gl,
      COUNT(DISTINCT Account_Identifier)           AS prev_cnt,
      CAST(0 AS BIGINT)                            AS curr_cnt
    FROM prev

    UNION ALL

    SELECT
      CAST(0 AS NUMERIC(18,2))                     AS prev_gl,
      SUM(GL_Balance)                              AS curr_gl,
      CAST(0 AS BIGINT)                            AS prev_cnt,
      COUNT(DISTINCT Account_Identifier)           AS curr_cnt
    FROM curr
  ) u
)




-- ==========================================================
-- MoM Non-Accrual: Summary (Totals & By Bank) + Population Totals + Detail
-- ==========================================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- Current EOM NA (must have positive exposure in month)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- Prior EOM NA (must have positive exposure in month)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),

-- =========================
-- JOIN + CLASSIFICATION
-- =========================
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

    -- descriptors / hierarchy
    COALESCE(c.Contract_Source_System,  p.Contract_Source_System)  AS Contract_Source_System,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.PROD_HIER_LEVEL_5,       p.PROD_HIER_LEVEL_5)       AS PROD_HIER_LEVEL_5,
    COALESCE(c.RBC_Code,                p.RBC_Code)                AS RBC_Code,
    COALESCE(c.GL_ACCOUNT_CODE,         p.GL_ACCOUNT_CODE)         AS GL_ACCOUNT_CODE,

    -- balances for recon
    COALESCE(p.GL_Balance, 0) AS Prev_GL_Balance,
    COALESCE(c.GL_Balance, 0) AS Curr_GL_Balance,

    -- presence flags
    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS Is_Persist
  FROM curr c
  FULL OUTER JOIN prev p
    ON c.Account_Identifier = p.Account_Identifier
),
with_bank AS (
  SELECT
    j.*,
    CASE
      WHEN j.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System = 'ALL'
           AND j.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN j.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN j.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM joined j
),
classified AS (
  SELECT
    wb.*,
    (wb.Curr_GL_Balance - wb.Prev_GL_Balance) AS GL_Delta,
    CASE
      WHEN wb.Is_Add = 1  THEN 'ADD'
      WHEN wb.Is_Drop = 1 THEN 'DROP'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance <> wb.Prev_GL_Balance THEN 'BAL_CHANGE'
      WHEN wb.Is_Persist = 1 AND wb.Curr_GL_Balance  = wb.Prev_GL_Balance THEN 'NO_CHANGE'
      ELSE 'UNCLASSIFIED'
    END AS Change_Type
  FROM with_bank wb
),

-- =========================
-- POPULATION TOTALS (curr/prev) — overall and by bank
-- =========================
curr_with_bank AS (
  SELECT
    c.*,
    CASE
      WHEN c.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System = 'ALL'
           AND c.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN c.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN c.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM curr c
),
prev_with_bank AS (
  SELECT
    p.*,
    CASE
      WHEN p.Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System = 'ALL'
           AND p.GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN p.Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN p.Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                                        'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                                        'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                                        'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM prev p
),
pop_total AS (
  SELECT
    'POP_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    -- GL sums (both months)
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    -- month-specific counts
    prev_cnt AS prev_acct_count,
    curr_cnt AS curr_acct_count
  FROM (
    SELECT SUM(GL_Balance) AS prev_gl, 0 AS curr_gl, COUNT(DISTINCT Account_Identifier) AS prev_cnt, 0 AS curr_cnt
    FROM prev
    UNION ALL
    SELECT 0, SUM(GL_Balance), 0, COUNT(DISTINCT Account_Identifier)
    FROM curr
  ) u
),
pop_by_bank AS (
  SELECT
    'POP_BY_BANK' AS level,
    bank_code,
    CAST(NULL AS VARCHAR(20)) AS Change_Type,
    -- GL sums by bank (both months)
    SUM(prev_gl) AS prev_gl_sum,
    SUM(curr_gl) AS curr_gl_sum,
    CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
    CAST(NULL AS BIGINT)        AS acct_count,
    -- month-specific counts
    SUM(prev_cnt) AS prev_acct_count,
    SUM(curr_cnt) AS curr_acct_count
  FROM (
    SELECT bank_code, SUM(GL_Balance) AS prev_gl, 0 AS curr_gl,
           COUNT(DISTINCT Account_Identifier) AS prev_cnt, 0 AS curr_cnt
    FROM prev_with_bank
    GROUP BY bank_code
    UNION ALL
    SELECT bank_code, 0, SUM(GL_Balance),
           0, COUNT(DISTINCT Account_Identifier)
    FROM curr_with_bank
    GROUP BY bank_code
  ) u
  GROUP BY bank_code
),

-- =========================
-- SUMMARY (ADD/DROP/BAL_CHANGE)
-- =========================
summary_total AS (
  SELECT
    'SUMMARY_TOTAL' AS level,
    CAST(NULL AS VARCHAR(20)) AS Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Change_Type
),
summary_by_bank AS (
  SELECT
    'SUMMARY_BY_BANK' AS level,
    Bank_Code,
    Change_Type,
    SUM(Prev_GL_Balance)         AS prev_gl_sum,
    SUM(Curr_GL_Balance)         AS curr_gl_sum,
    SUM(GL_Delta)                AS delta_gl_sum,
    COUNT(DISTINCT Account_Identifier) AS acct_count,
    CAST(NULL AS BIGINT) AS prev_acct_count,
    CAST(NULL AS BIGINT) AS curr_acct_count
  FROM classified
  WHERE Change_Type IN ('ADD','DROP','BAL_CHANGE')
  GROUP BY Bank_Code, Change_Type
)

-- ==========================================================
-- FINAL OUTPUT: POP totals + Summary rows + Detail
-- ==========================================================
SELECT
  level,
  Bank_Code,
  Change_Type,
  prev_gl_sum,
  curr_gl_sum,
  delta_gl_sum,
  acct_count,
  prev_acct_count,
  curr_acct_count,

  -- Detail columns NULL on non-detail rows
  CAST(NULL AS VARCHAR(64))  AS Account_Identifier,
  CAST(NULL AS VARCHAR(64))  AS Account_Key,
  CAST(NULL AS VARCHAR(256)) AS Account_Name,
  CAST(NULL AS VARCHAR(64))  AS CIS_Customer_Number,
  CAST(NULL AS VARCHAR(64))  AS Facility_ID,
  CAST(NULL AS VARCHAR(64))  AS Contract_Source_System,
  CAST(NULL AS VARCHAR(128)) AS Status_Code_Description,
  CAST(NULL AS VARCHAR(64))  AS GL_ACCOUNT_HIER_LEVEL_4,
  CAST(NULL AS VARCHAR(128)) AS PROD_HIER_LEVEL_5,
  CAST(NULL AS VARCHAR(64))  AS RBC_Code,
  CAST(NULL AS VARCHAR(64))  AS GL_ACCOUNT_CODE,
  CAST(NULL AS NUMERIC(18,2)) AS Prev_GL_Balance,
  CAST(NULL AS NUMERIC(18,2)) AS Curr_GL_Balance,
  CAST(NULL AS NUMERIC(18,2)) AS GL_Delta
FROM pop_total

UNION ALL
SELECT
  level, Bank_Code, Change_Type,
  prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2))
FROM pop_by_bank

UNION ALL
SELECT
  level, Bank_Code, Change_Type,
  prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2))
FROM summary_total

UNION ALL
SELECT
  level, Bank_Code, Change_Type,
  prev_gl_sum, curr_gl_sum, delta_gl_sum, acct_count, prev_acct_count, curr_acct_count,
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(256)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS VARCHAR(128)), CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(128)),
  CAST(NULL AS VARCHAR(64)), CAST(NULL AS VARCHAR(64)),
  CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2)), CAST(NULL AS NUMERIC(18,2))
FROM summary_by_bank

UNION ALL
SELECT
  'DETAIL' AS level,
  Bank_Code,
  Change_Type,
  CAST(NULL AS NUMERIC(18,2)) AS prev_gl_sum,
  CAST(NULL AS NUMERIC(18,2)) AS curr_gl_sum,
  CAST(NULL AS NUMERIC(18,2)) AS delta_gl_sum,
  CAST(NULL AS BIGINT)        AS acct_count,
  CAST(NULL AS BIGINT)        AS prev_acct_count,
  CAST(NULL AS BIGINT)        AS curr_acct_count,
  Account_Identifier,
  Account_Key,
  Account_Name,
  CIS_Customer_Number,
  Facility_ID,
  Contract_Source_System,
  Status_Code_Description,
  GL_ACCOUNT_HIER_LEVEL_4,
  PROD_HIER_LEVEL_5,
  RBC_Code,
  GL_ACCOUNT_CODE,
  Prev_GL_Balance,
  Curr_GL_Balance,
  GL_Delta
FROM classified
ORDER BY
  CASE level
    WHEN 'POP_TOTAL'       THEN 0
    WHEN 'POP_BY_BANK'     THEN 1
    WHEN 'SUMMARY_TOTAL'   THEN 2
    WHEN 'SUMMARY_BY_BANK' THEN 3
    WHEN 'DETAIL'          THEN 4
    ELSE 99
  END,
  Bank_Code NULLS FIRST,
  CASE Change_Type
    WHEN 'ADD'        THEN 1
    WHEN 'DROP'       THEN 2
    WHEN 'BAL_CHANGE' THEN 3
    WHEN 'NO_CHANGE'  THEN 4
    ELSE 99
  END,
  Account_Identifier;






-- ============================================
-- MoM Non-Accrual Summary (Adds, Drops, Persisting GL changes)
-- Returns totals and by-Bank_Code rollups with balances & distinct account counts
-- ============================================
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- current EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- prior EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
base AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS acct_id,
    COALESCE(c.Account_Key,        p.Account_Key)        AS acct_key,
    COALESCE(c.Account_Name,       p.Account_Name)       AS account_name,
    COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS cis_customer_number,
    COALESCE(c.Facility_ID,        p.Facility_ID)        AS facility_id,

    -- for Bank_Code mapping & descriptors
    COALESCE(c.Contract_Source_System, p.Contract_Source_System)  AS css,
    COALESCE(c.Status_Code_Description, p.Status_Code_Description)AS status_code_description,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4)AS gl_hier_lvl4,
    COALESCE(c.PROD_HIER_LEVEL_5, p.PROD_HIER_LEVEL_5)            AS prod_hier_lvl5,
    COALESCE(c.RBC_Code,         p.RBC_Code)                      AS rbc_code,
    COALESCE(c.GL_ACCOUNT_CODE,  p.GL_ACCOUNT_CODE)               AS gl_account_code,

    -- balances
    NVL(p.GL_Balance, 0) AS prev_gl,
    NVL(c.GL_Balance, 0) AS curr_gl,

    -- presence flags
    CASE WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS is_add,
    CASE WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS is_drop,
    CASE WHEN p.Account_Identifier IS NOT NULL AND c.Account_Identifier IS NOT NULL THEN 1 ELSE 0 END AS is_persist
  FROM curr c
  FULL OUTER JOIN prev p
    ON c.Account_Identifier = p.Account_Identifier
),
tagged AS (
  SELECT
    b.*,
    -- Bank_Code mapping per your logic
    CASE
      WHEN b.css IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN b.css = 'ALL'
           AND b.gl_account_code IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN b.css IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN b.css IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
                     'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
                     'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
                     'STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS bank_code,

    -- assign change type; only include persisting if GL changed
    CASE
      WHEN is_add = 1  THEN 'ADD'
      WHEN is_drop = 1 THEN 'DROP'
      WHEN is_persist = 1 AND curr_gl <> prev_gl THEN 'PERSISTING_CHANGE'
      ELSE NULL
    END AS change_type
  FROM base b
),
filtered AS (
  -- keep only the three categories (exclude persisting with no GL change)
  SELECT *
  FROM tagged
  WHERE change_type IS NOT NULL
),
totals AS (
  SELECT
    'TOTAL'      AS level,
    CAST(NULL AS VARCHAR(20)) AS bank_code,
    change_type,
    SUM(prev_gl)                         AS prev_gl_sum,
    SUM(curr_gl)                         AS curr_gl_sum,
    SUM(curr_gl - prev_gl)               AS delta_gl_sum,
    COUNT(DISTINCT acct_id)              AS acct_count
  FROM filtered
  GROUP BY change_type
),
by_bank AS (
  SELECT
    'BY_BANK'    AS level,
    bank_code,
    change_type,
    SUM(prev_gl)                         AS prev_gl_sum,
    SUM(curr_gl)                         AS curr_gl_sum,
    SUM(curr_gl - prev_gl)               AS delta_gl_sum,
    COUNT(DISTINCT acct_id)              AS acct_count
  FROM filtered
  GROUP BY bank_code, change_type
)
SELECT *
FROM (
  SELECT * FROM totals
  UNION ALL
  SELECT * FROM by_bank
) z
ORDER BY
  level,
  bank_code NULLS FIRST,
  CASE change_type
    WHEN 'ADD' THEN 1
    WHEN 'DROP' THEN 2
    WHEN 'PERSISTING_CHANGE' THEN 3
    ELSE 99
  END;






-- MoM Non-Accrual Adds & Drops Only
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- current EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- prior EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
)
SELECT
  /* Identity / keys */
  COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
  COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
  COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
  COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
  COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

  /* Source / hierarchy / descriptors */
  COALESCE(c.Contract_Source_System, p.Contract_Source_System)  AS Contract_Source_System,
  COALESCE(c.Status_Code_Description, p.Status_Code_Description)AS Status_Code_Description,
  COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4)AS GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.PROD_HIER_LEVEL_5, p.PROD_HIER_LEVEL_5)            AS PROD_HIER_LEVEL_5,

  /* Bank_Code mapping */
  CASE
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) = 'ALL'
         AND COALESCE(c.GL_ACCOUNT_CODE, p.GL_ACCOUNT_CODE) IN
         ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
          '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
          '1100001','1142067','1042886','1043008')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
      THEN 'L-FCB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
          'STRAT1','STRAT1-EXCPTN')
      THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,

  /* Risk / credit attributes */
  COALESCE(c.Borrower_Risk_Rating, p.Borrower_Risk_Rating) AS Borrower_Risk_Rating,
  COALESCE(c.PD_Grade,            p.PD_Grade)               AS PD_Grade,
  COALESCE(c.Days_Past_Due,       p.Days_Past_Due)          AS Days_Past_Due,

  /* Flags / codes */
  COALESCE(c.Non_Accrual_Flag, p.Non_Accrual_Flag) AS Non_Accrual_Flag,
  COALESCE(c.RBC_Code,         p.RBC_Code)         AS RBC_Code,

  /* Balances */
  p.Source_System_Balance AS Prev_Bal,
  c.Source_System_Balance AS Curr_Bal,
  COALESCE(c.GL_Balance,        p.GL_Balance)        AS GL_Balance,
  COALESCE(c.Available_Balance, p.Available_Balance) AS Available_Balance,

  /* Change tag + exposure for sort */
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Dropped (Resolved/Out)'
  END AS NA_Status_Change,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN c.Source_System_Balance
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN p.Source_System_Balance
  END AS Exposure_For_Sort
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
WHERE
  (p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL)  -- Added
  OR
  (c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL)  -- Dropped
ORDER BY
  Exposure_For_Sort DESC,
  Bank_Code,
  COALESCE(c.Account_Identifier, p.Account_Identifier);






/* ---------- Final selector (one result set) ---------- */
SELECT *
FROM (
    SELECT * FROM snapshot
    WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
    UNION ALL
    SELECT * FROM trend
    WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
    UNION ALL
    SELECT * FROM mom_decomp
    WHERE (SELECT p_section FROM params) = 'MOM_DECOMP'
    UNION ALL
    SELECT * FROM top_movers
    WHERE (SELECT p_section FROM params) = 'TOP_MOVERS'
    UNION ALL
    SELECT * FROM volatility
    WHERE (SELECT p_section FROM params) = 'VOLATILITY'
) u
-- Netezza requires ORDER BY columns to be in the result set.
-- Column ordinals in this unified schema:
-- 1=section, 2=month_end, 3=synthetic_category, 4=contract_source_system,
-- 5=gl_account_code, ..., 32=sort_key
ORDER BY
  1,         -- section
  2 DESC,    -- month_end
  3,         -- synthetic_category
  4,         -- contract_source_system
  5,         -- gl_account_code
  32 DESC;   -- sort_key






/*=========================================================================
  Unified Synthetic Analytics (LOANHUB) — Param-Driven Sections (Netezza)
  Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  Set params.p_section to: 'SNAPSHOT_TREND' | 'MOM_DECOMP' | 'TOP_MOVERS' | 'VOLATILITY'
 *=========================================================================*/

WITH
/* ---------- Parameters ---------- */
params AS (
  SELECT
    24::INT                               AS lookback_months,   -- history window
    1000::INT                             AS topN_movers,       -- for TOP_MOVERS
    CAST('MOM_DECOMP' AS VARCHAR(20))     AS p_section          -- << set per PBI copy
),

/* ---------- Base (Total Loans only) ---------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    CAST(ACCOUNT_IDENTIFIER AS VARCHAR(128))      AS account_identifier,
    CAST(CONTRACT_SOURCE_SYSTEM AS VARCHAR(128))  AS contract_source_system,
    CAST(GL_ACCOUNT_CODE AS INTEGER)              AS gl_account_code,
    CAST(GL_ACCOUNT_DESCRIPTION AS VARCHAR(256))  AS gl_account_description,
    CAST(GL_ACCOUNT_HIER_LEVEL_4 AS VARCHAR(64))  AS gl_hl4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---------- Latest & Prior Month ---------- */
latest AS (
  SELECT MAX(month_end) AS latest_me
  FROM (SELECT DISTINCT month_end FROM base) d
),
prior AS (
  SELECT MAX(month_end) AS prior_me
  FROM (SELECT DISTINCT month_end FROM base) d
  WHERE month_end < (SELECT latest_me FROM latest)
),

/* ---------- Window for history/volatility ---------- */
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_me, -((SELECT lookback_months FROM params) - 1))
),

/* ---------- Synthetic tagging (Cat1 / Cat2) ---------- */
tagged AS (
  SELECT
    w.*,
    CASE
      WHEN UPPER(w.contract_source_system) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(w.contract_source_system) LIKE '%EXCPTN%' THEN 1
      WHEN w.contract_source_system = 'ALL' AND w.gl_account_code IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364) THEN 1
      ELSE 0
    END AS is_synth,
    CASE
      WHEN (UPPER(w.contract_source_system) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(w.contract_source_system) LIKE '%EXCPTN%')
           AND (w.contract_source_system = 'ALL' AND w.gl_account_code IN
              (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
               1043008,1142048,1051872,1061833,1041211,1041344,1041364))
      THEN CAST('Cat1+Cat2' AS VARCHAR(12))
      WHEN (UPPER(w.contract_source_system) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(w.contract_source_system) LIKE '%EXCPTN%')
      THEN CAST('Cat1' AS VARCHAR(12))
      WHEN w.contract_source_system='ALL' AND w.gl_account_code IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364)
      THEN CAST('Cat2' AS VARCHAR(12))
      ELSE CAST(NULL AS VARCHAR(12))
    END AS synthetic_category
  FROM windowed w
),

/* ---------- Monthly aggregates for SNAPSHOT/TREND ---------- */
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description)                   AS gl_account_description,
    COUNT(*)                                      AS rows_flagged,
    COUNT(DISTINCT account_identifier)            AS accounts_flagged,
    SUM(exposure)                                 AS exposure_sum,
    SUM(ABS(exposure))                            AS exposure_abs_sum,
    AVG(ABS(exposure))                            AS exposure_abs_avg
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, synthetic_category, contract_source_system, gl_account_code
),
m_latest AS (SELECT MAX(month_end) AS month_end FROM monthly_group),
m_prior2 AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),
latest_per_group AS (SELECT g.* FROM monthly_group g JOIN m_latest ml ON g.month_end = ml.month_end),
prior_per_group  AS (SELECT g.* FROM monthly_group g JOIN m_prior2 mp ON g.month_end = mp.month_end),

history_stats AS (
  SELECT
    synthetic_category,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description)             AS gl_account_description,
    COUNT(*)                                AS hist_months,
    AVG(ABS(exposure_sum))                  AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))          AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))                  AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))                  AS hist_max_abs_exposure
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, contract_source_system, gl_account_code
),

/* ---------- SNAPSHOT rows ---------- */
snapshot AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20))         AS section,
    lp.month_end                                   AS month_end,
    CAST(lp.synthetic_category AS VARCHAR(12))     AS synthetic_category,
    CAST(lp.contract_source_system AS VARCHAR(128))AS contract_source_system,
    CAST(lp.gl_account_code AS INTEGER)            AS gl_account_code,
    CAST(lp.gl_account_description AS VARCHAR(256))AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                     AS account_identifier,
    CAST(NULL AS FLOAT8)                           AS exposure_prev,
    CAST(NULL AS FLOAT8)                           AS exposure_cur,
    CAST(NULL AS FLOAT8)                           AS delta_total,
    CAST(NULL AS FLOAT8)                           AS cont_growth,
    CAST(NULL AS FLOAT8)                           AS adds,
    CAST(NULL AS FLOAT8)                           AS drops,
    lp.rows_flagged                                AS rows_flagged,
    lp.accounts_flagged                            AS accounts_flagged,
    lp.exposure_sum                                AS exposure_sum,
    lp.exposure_abs_sum                            AS exposure_abs_sum,
    lp.exposure_abs_avg                            AS exposure_abs_avg,
    (SELECT month_end FROM m_prior2)               AS prev_month_end,
    COALESCE(pp.exposure_sum,0.0)                  AS prev_exposure_sum,
    CASE WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN NULL
         ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum,0.0) END AS pct_delta_exposure,
    hs.hist_months                                 AS hist_months,
    hs.hist_avg_abs_exposure                       AS hist_avg_abs_exposure,
    hs.hist_std_abs_exposure                       AS hist_std_abs_exposure,
    hs.hist_min_abs_exposure                       AS hist_min_abs_exposure,
    hs.hist_max_abs_exposure                       AS hist_max_abs_exposure,
    CASE WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
         ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure END AS zscore_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                           AS exposure_delta,
    /* sort_key for UNION ORDER BY */
    CASE 
      WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN ABS(lp.exposure_sum)
      ELSE ABS(lp.exposure_sum - pp.exposure_sum)
    END::FLOAT8                                    AS sort_key
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category=lp.synthetic_category
   AND pp.contract_source_system=lp.contract_source_system
   AND pp.gl_account_code=lp.gl_account_code
  LEFT JOIN history_stats hs
    ON hs.synthetic_category=lp.synthetic_category
   AND hs.contract_source_system=lp.contract_source_system
   AND hs.gl_account_code=lp.gl_account_code
),

/* ---------- TREND rows ---------- */
trend AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20))          AS section,
    g.month_end                                     AS month_end,
    CAST(g.synthetic_category AS VARCHAR(12))       AS synthetic_category,
    CAST(g.contract_source_system AS VARCHAR(128))  AS contract_source_system,
    CAST(g.gl_account_code AS INTEGER)              AS gl_account_code,
    CAST(g.gl_account_description AS VARCHAR(256))  AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                      AS account_identifier,
    CAST(NULL AS FLOAT8)                            AS exposure_prev,
    CAST(NULL AS FLOAT8)                            AS exposure_cur,
    CAST(NULL AS FLOAT8)                            AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    g.rows_flagged                                  AS rows_flagged,
    g.accounts_flagged                              AS accounts_flagged,
    g.exposure_sum                                  AS exposure_sum,
    g.exposure_abs_sum                              AS exposure_abs_sum,
    g.exposure_abs_avg                              AS exposure_abs_avg,
    CAST(NULL AS DATE)                              AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                            AS exposure_delta,
    CAST(ABS(g.exposure_sum) AS FLOAT8)             AS sort_key
  FROM monthly_group g
),

/* ---------- MoM Decomposition (synthetic only) ---------- */
cur_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT latest_me FROM latest)),
prev_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT prior_me  FROM prior)),

aligned_mom AS (
  SELECT
    COALESCE(c.account_identifier, p.account_identifier)           AS account_identifier,
    COALESCE(c.contract_source_system, p.contract_source_system)   AS css_key,
    COALESCE(c.gl_account_code,        p.gl_account_code)          AS gl_key,
    COALESCE(c.gl_account_description, p.gl_account_description)   AS gl_desc,
    p.exposure AS prev_exp,
    c.exposure AS cur_exp
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.account_identifier = p.account_identifier
),
rolled_mom AS (
  SELECT
    css_key  AS contract_source_system,
    gl_key   AS gl_account_code,
    MAX(gl_desc) AS gl_account_description,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NOT NULL THEN cur_exp - prev_exp ELSE 0 END) AS cont_growth,
    SUM(CASE WHEN prev_exp IS NULL  AND cur_exp IS NOT NULL THEN cur_exp ELSE 0 END)               AS adds,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NULL THEN -prev_exp ELSE 0 END)              AS drops,
    SUM(COALESCE(prev_exp,0.0)) AS exposure_prev,
    SUM(COALESCE(cur_exp,0.0))  AS exposure_cur
  FROM aligned_mom
  GROUP BY css_key, gl_key
),
mom_decomp AS (
  SELECT
    CAST('MOM_DECOMP' AS VARCHAR(20))              AS section,
    (SELECT latest_me FROM latest)                 AS month_end,
    CAST(NULL AS VARCHAR(12))                      AS synthetic_category,
    CAST(r.contract_source_system AS VARCHAR(128)) AS contract_source_system,
    CAST(r.gl_account_code AS INTEGER)             AS gl_account_code,
    CAST(r.gl_account_description AS VARCHAR(256)) AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                     AS account_identifier,
    r.exposure_prev                                AS exposure_prev,
    r.exposure_cur                                 AS exposure_cur,
    (r.exposure_cur - r.exposure_prev)             AS delta_total,
    r.cont_growth                                  AS cont_growth,
    r.adds                                         AS adds,
    r.drops                                        AS drops,
    CAST(NULL AS INTEGER)                          AS rows_flagged,
    CAST(NULL AS INTEGER)                          AS accounts_flagged,
    CAST(NULL AS FLOAT8)                           AS exposure_sum,
    CAST(NULL AS FLOAT8)                           AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                           AS exposure_abs_avg,
    (SELECT prior_me FROM prior)                   AS prev_month_end,
    CAST(NULL AS FLOAT8)                           AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                           AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                          AS hist_months,
    CAST(NULL AS FLOAT8)                           AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                           AS zscore_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                           AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                           AS exposure_delta,
    CAST(ABS(r.exposure_cur - r.exposure_prev) AS FLOAT8) AS sort_key
  FROM rolled_mom r
),

/* ---------- Top Movers (account-level, latest vs prior) ---------- */
aligned_movers AS (
  SELECT
    COALESCE(c.account_identifier, p.account_identifier)           AS account_identifier,
    COALESCE(c.contract_source_system, p.contract_source_system)   AS contract_source_system,
    COALESCE(c.gl_account_code,        p.gl_account_code)          AS gl_account_code,
    COALESCE(c.gl_account_description, p.gl_account_description)   AS gl_account_description,
    COALESCE(p.exposure,0.0) AS exposure_prev,
    COALESCE(c.exposure,0.0) AS exposure_cur
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.account_identifier = p.account_identifier
),
ranked_movers AS (
  SELECT
    am.*,
    (exposure_cur - exposure_prev) AS exposure_delta,
    ROW_NUMBER() OVER (ORDER BY ABS(exposure_cur - exposure_prev) DESC) AS rn
  FROM aligned_movers am
),
top_movers AS (
  SELECT
    CAST('TOP_MOVERS' AS VARCHAR(20))               AS section,
    (SELECT latest_me FROM latest)                  AS month_end,
    CAST(NULL AS VARCHAR(12))                       AS synthetic_category,
    CAST(rm.contract_source_system AS VARCHAR(128)) AS contract_source_system,
    CAST(rm.gl_account_code AS INTEGER)             AS gl_account_code,
    CAST(rm.gl_account_description AS VARCHAR(256)) AS gl_account_description,
    CAST(rm.account_identifier AS VARCHAR(128))     AS account_identifier,
    rm.exposure_prev                                AS exposure_prev,
    rm.exposure_cur                                 AS exposure_cur,
    rm.exposure_cur - rm.exposure_prev              AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    CAST(NULL AS INTEGER)                           AS rows_flagged,
    CAST(NULL AS INTEGER)                           AS accounts_flagged,
    CAST(NULL AS FLOAT8)                            AS exposure_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_avg,
    (SELECT prior_me FROM prior)                    AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_std_abs,
    CAST(NULL AS FLOAT8)                            AS volatility_cv_abs,
    (exposure_cur - exposure_prev)                  AS exposure_delta,
    CAST(ABS(exposure_cur - exposure_prev) AS FLOAT8) AS sort_key
  FROM ranked_movers rm
  WHERE rn <= (SELECT topN_movers FROM params)
),

/* ---------- Volatility (window) ---------- */
bucket_month AS (
  SELECT
    month_end,
    contract_source_system,
    gl_account_code,
    MAX(gl_account_description) AS gl_account_description,
    SUM(exposure)               AS exposure_sum
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, contract_source_system, gl_account_code
),
volatility AS (
  SELECT
    CAST('VOLATILITY' AS VARCHAR(20))               AS section,
    MAX(month_end)                                  AS month_end,
    CAST(NULL AS VARCHAR(12))                       AS synthetic_category,
    CAST(contract_source_system AS VARCHAR(128))    AS contract_source_system,
    CAST(gl_account_code AS INTEGER)                AS gl_account_code,
    CAST(MAX(gl_account_description) AS VARCHAR(256)) AS gl_account_description,
    CAST(NULL AS VARCHAR(128))                      AS account_identifier,
    CAST(NULL AS FLOAT8)                            AS exposure_prev,
    CAST(NULL AS FLOAT8)                            AS exposure_cur,
    CAST(NULL AS FLOAT8)                            AS delta_total,
    CAST(NULL AS FLOAT8)                            AS cont_growth,
    CAST(NULL AS FLOAT8)                            AS adds,
    CAST(NULL AS FLOAT8)                            AS drops,
    CAST(NULL AS INTEGER)                           AS rows_flagged,
    CAST(NULL AS INTEGER)                           AS accounts_flagged,
    CAST(NULL AS FLOAT8)                            AS exposure_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)                            AS exposure_abs_avg,
    CAST(NULL AS DATE)                              AS prev_month_end,
    CAST(NULL AS FLOAT8)                            AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)                            AS pct_delta_exposure,
    CAST(NULL AS INTEGER)                           AS hist_months,
    CAST(NULL AS FLOAT8)                            AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)                            AS zscore_abs,
    AVG(ABS(exposure_sum))                          AS volatility_avg_abs,
    STDDEV_SAMP(ABS(exposure_sum))                  AS volatility_std_abs,
    CASE WHEN AVG(ABS(exposure_sum))=0 THEN NULL
         ELSE (STDDEV_SAMP(ABS(exposure_sum)) / AVG(ABS(exposure_sum))) END AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)                            AS exposure_delta,
    CAST(ABS(STDDEV_SAMP(ABS(exposure_sum))) AS FLOAT8) AS sort_key
  FROM bucket_month
  GROUP BY contract_source_system, gl_account_code
)

/* ---------- Final selector (one result set) ---------- */
SELECT * FROM snapshot
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM trend
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM mom_decomp
WHERE (SELECT p_section FROM params) = 'MOM_DECOMP'
UNION ALL
SELECT * FROM top_movers
WHERE (SELECT p_section FROM params) = 'TOP_MOVERS'
UNION ALL
SELECT * FROM volatility
WHERE (SELECT p_section FROM params) = 'VOLATILITY'
ORDER BY
  section,
  month_end DESC,
  COALESCE(synthetic_category, ''),
  contract_source_system,
  gl_account_code,
  sort_key DESC;






/*=========================================================================
  Unified Synthetic Analytics (LOANHUB) — One Script, Param-Driven Sections
  Table: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  Set params.p_section to: 'SNAPSHOT_TREND' | 'MOM_DECOMP' | 'TOP_MOVERS' | 'VOLATILITY'
 *=========================================================================*/

WITH
/* ---------- Parameters ---------- */
params AS (
  SELECT
    24::INT                                AS lookback_months,   -- history window
    1000::INT                              AS topN_movers,       -- for TOP_MOVERS
    CAST('MOM_DECOMP' AS VARCHAR(20))      AS p_section          -- << set per PBI copy
),

/* ---------- Base (Total Loans only) ---------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8  AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---------- Latest & Prior Month ---------- */
latest AS (
  SELECT MAX(month_end) AS latest_me
  FROM (SELECT DISTINCT month_end FROM base) d
),
prior AS (
  SELECT MAX(month_end) AS prior_me
  FROM (SELECT DISTINCT month_end FROM base) d
  WHERE month_end < (SELECT latest_me FROM latest)
),

/* ---------- Window for history/volatility ---------- */
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_me, -((SELECT lookback_months FROM params) - 1))
),

/* ---------- Synthetic tagging (Cat1 / Cat2) ---------- */
tagged AS (
  SELECT
    w.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%' THEN 1
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364) THEN 1
      ELSE 0
    END AS is_synth,
    CASE
      WHEN (UPPER(CONTRACT_SOURCE_SYSTEM) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%')
           AND (CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE IN
              (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
               1043008,1142048,1051872,1061833,1041211,1041344,1041364))
      THEN 'Cat1+Cat2'
      WHEN (UPPER(CONTRACT_SOURCE_SYSTEM) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%')
      THEN 'Cat1'
      WHEN CONTRACT_SOURCE_SYSTEM='ALL' AND GL_ACCOUNT_CODE IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364)
      THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM windowed w
),

/* ---------- Monthly aggregates for SNAPSHOT/TREND ---------- */
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)                  AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                                     AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER)           AS accounts_flagged,
    SUM(exposure)                                AS exposure_sum,
    SUM(ABS(exposure))                           AS exposure_abs_sum,
    AVG(ABS(exposure))                           AS exposure_abs_avg
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
m_latest AS (SELECT MAX(month_end) AS month_end FROM monthly_group),
m_prior2 AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),
latest_per_group AS (SELECT g.* FROM monthly_group g JOIN m_latest ml ON g.month_end = ml.month_end),
prior_per_group  AS (SELECT g.* FROM monthly_group g JOIN m_prior2 mp ON g.month_end = mp.month_end),

history_stats AS (
  SELECT
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)            AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                               AS hist_months,
    AVG(ABS(exposure_sum))                 AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))         AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))                 AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))                 AS hist_max_abs_exposure
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),

/* ---------- SNAPSHOT rows ---------- */
snapshot AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20)) AS section,
    lp.month_end,
    lp.synthetic_category,
    lp.CONTRACT_SOURCE_SYSTEM,
    lp.GL_ACCOUNT_CODE,
    lp.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128)) AS account_identifier,
    CAST(NULL AS FLOAT8)       AS exposure_prev,
    CAST(NULL AS FLOAT8)       AS exposure_cur,
    CAST(NULL AS FLOAT8)       AS delta_total,
    CAST(NULL AS FLOAT8)       AS cont_growth,
    CAST(NULL AS FLOAT8)       AS adds,
    CAST(NULL AS FLOAT8)       AS drops,
    lp.rows_flagged,
    lp.accounts_flagged,
    lp.exposure_sum,
    lp.exposure_abs_sum,
    lp.exposure_abs_avg,
    (SELECT month_end FROM m_prior2)          AS prev_month_end,
    COALESCE(pp.exposure_sum,0.0)             AS prev_exposure_sum,
    CASE WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN NULL
         ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum,0.0) END AS pct_delta_exposure,
    hs.hist_months,
    hs.hist_avg_abs_exposure,
    hs.hist_std_abs_exposure,
    hs.hist_min_abs_exposure,
    hs.hist_max_abs_exposure,
    CASE WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
         ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure END AS zscore_abs,
    CAST(NULL AS FLOAT8) AS volatility_avg_abs,
    CAST(NULL AS FLOAT8) AS volatility_std_abs,
    CAST(NULL AS FLOAT8) AS volatility_cv_abs,
    CAST(NULL AS FLOAT8) AS exposure_delta
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category=lp.synthetic_category
   AND pp.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND pp.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
  LEFT JOIN history_stats hs
    ON hs.synthetic_category=lp.synthetic_category
   AND hs.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND hs.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
),

/* ---------- TREND rows ---------- */
trend AS (
  SELECT
    CAST('SNAPSHOT_TREND' AS VARCHAR(20)) AS section,
    g.month_end,
    g.synthetic_category,
    g.CONTRACT_SOURCE_SYSTEM,
    g.GL_ACCOUNT_CODE,
    g.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128)) AS account_identifier,
    CAST(NULL AS FLOAT8) AS exposure_prev,
    CAST(NULL AS FLOAT8) AS exposure_cur,
    CAST(NULL AS FLOAT8) AS delta_total,
    CAST(NULL AS FLOAT8) AS cont_growth,
    CAST(NULL AS FLOAT8) AS adds,
    CAST(NULL AS FLOAT8) AS drops,
    g.rows_flagged,
    g.accounts_flagged,
    g.exposure_sum,
    g.exposure_abs_sum,
    g.exposure_abs_avg,
    CAST(NULL AS DATE)   AS prev_month_end,
    CAST(NULL AS FLOAT8) AS prev_exposure_sum,
    CAST(NULL AS FLOAT8) AS pct_delta_exposure,
    CAST(NULL AS INTEGER)AS hist_months,
    CAST(NULL AS FLOAT8) AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8) AS zscore_abs,
    CAST(NULL AS FLOAT8) AS volatility_avg_abs,
    CAST(NULL AS FLOAT8) AS volatility_std_abs,
    CAST(NULL AS FLOAT8) AS volatility_cv_abs,
    CAST(NULL AS FLOAT8) AS exposure_delta
  FROM monthly_group g
),

/* ---------- MoM Decomposition (synthetic only) ---------- */
cur_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT latest_me FROM latest)),
prev_syn AS (SELECT * FROM tagged WHERE is_synth=1 AND month_end=(SELECT prior_me  FROM prior)),

aligned_mom AS (
  SELECT
    COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS css_key,
    COALESCE(c.GL_ACCOUNT_CODE,        p.GL_ACCOUNT_CODE)        AS gl_key,
    COALESCE(c.GL_ACCOUNT_DESCRIPTION, p.GL_ACCOUNT_DESCRIPTION)  AS gl_desc,
    p.exposure AS prev_exp,
    c.exposure AS cur_exp
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),
rolled_mom AS (
  SELECT
    css_key  AS CONTRACT_SOURCE_SYSTEM,
    gl_key   AS GL_ACCOUNT_CODE,
    MAX(gl_desc) AS GL_ACCOUNT_DESCRIPTION,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NOT NULL THEN cur_exp - prev_exp ELSE 0 END) AS cont_growth,
    SUM(CASE WHEN prev_exp IS NULL  AND cur_exp IS NOT NULL THEN cur_exp ELSE 0 END)               AS adds,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NULL THEN -prev_exp ELSE 0 END)              AS drops,
    SUM(COALESCE(prev_exp,0.0)) AS exposure_prev,
    SUM(COALESCE(cur_exp,0.0))  AS exposure_cur
  FROM aligned_mom
  GROUP BY css_key, gl_key
),
mom_decomp AS (
  SELECT
    CAST('MOM_DECOMP' AS VARCHAR(20)) AS section,
    (SELECT latest_me FROM latest)    AS month_end,
    CAST(NULL AS VARCHAR(12))         AS synthetic_category,
    r.CONTRACT_SOURCE_SYSTEM,
    r.GL_ACCOUNT_CODE,
    r.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128))        AS account_identifier,
    r.exposure_prev,
    r.exposure_cur,
    (r.exposure_cur - r.exposure_prev) AS delta_total,
    r.cont_growth,
    r.adds,
    r.drops,
    CAST(NULL AS INTEGER) AS rows_flagged,
    CAST(NULL AS INTEGER) AS accounts_flagged,
    CAST(NULL AS FLOAT8)  AS exposure_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_avg,
    (SELECT prior_me FROM prior)      AS prev_month_end,
    CAST(NULL AS FLOAT8)  AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)  AS pct_delta_exposure,
    CAST(NULL AS INTEGER) AS hist_months,
    CAST(NULL AS FLOAT8)  AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)  AS zscore_abs,
    CAST(NULL AS FLOAT8)  AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)  AS volatility_std_abs,
    CAST(NULL AS FLOAT8)  AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)  AS exposure_delta
  FROM rolled_mom r
),

/* ---------- Top Movers (account-level, latest vs prior) ---------- */
aligned_movers AS (
  SELECT
    COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_CODE,        p.GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    COALESCE(c.GL_ACCOUNT_DESCRIPTION, p.GL_ACCOUNT_DESCRIPTION)  AS GL_ACCOUNT_DESCRIPTION,
    COALESCE(p.exposure,0.0) AS exposure_prev,
    COALESCE(c.exposure,0.0) AS exposure_cur
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),
ranked_movers AS (
  SELECT
    am.*,
    (exposure_cur - exposure_prev) AS exposure_delta,
    ROW_NUMBER() OVER (ORDER BY ABS(exposure_cur - exposure_prev) DESC) AS rn
  FROM aligned_movers am
),
top_movers AS (
  SELECT
    CAST('TOP_MOVERS' AS VARCHAR(20)) AS section,
    (SELECT latest_me FROM latest)    AS month_end,
    CAST(NULL AS VARCHAR(12))         AS synthetic_category,
    rm.CONTRACT_SOURCE_SYSTEM,
    rm.GL_ACCOUNT_CODE,
    rm.GL_ACCOUNT_DESCRIPTION,
    rm.ACCOUNT_IDENTIFIER             AS account_identifier,
    rm.exposure_prev,
    rm.exposure_cur,
    rm.exposure_cur - rm.exposure_prev AS delta_total,
    CAST(NULL AS FLOAT8) AS cont_growth,
    CAST(NULL AS FLOAT8) AS adds,
    CAST(NULL AS FLOAT8) AS drops,
    CAST(NULL AS INTEGER) AS rows_flagged,
    CAST(NULL AS INTEGER) AS accounts_flagged,
    CAST(NULL AS FLOAT8)  AS exposure_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_avg,
    (SELECT prior_me FROM prior)      AS prev_month_end,
    CAST(NULL AS FLOAT8)  AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)  AS pct_delta_exposure,
    CAST(NULL AS INTEGER) AS hist_months,
    CAST(NULL AS FLOAT8)  AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)  AS zscore_abs,
    CAST(NULL AS FLOAT8)  AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)  AS volatility_std_abs,
    CAST(NULL AS FLOAT8)  AS volatility_cv_abs,
    rm.exposure_delta
  FROM ranked_movers rm
  WHERE rn <= (SELECT topN_movers FROM params)
),

/* ---------- Volatility (window) ---------- */
bucket_month AS (
  SELECT
    month_end,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION) AS GL_ACCOUNT_DESCRIPTION,
    SUM(exposure)               AS exposure_sum
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
volatility AS (
  SELECT
    CAST('VOLATILITY' AS VARCHAR(20)) AS section,
    MAX(month_end)                    AS month_end,
    CAST(NULL AS VARCHAR(12))         AS synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)       AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128))        AS account_identifier,
    CAST(NULL AS FLOAT8)              AS exposure_prev,
    CAST(NULL AS FLOAT8)              AS exposure_cur,
    CAST(NULL AS FLOAT8)              AS delta_total,
    CAST(NULL AS FLOAT8)              AS cont_growth,
    CAST(NULL AS FLOAT8)              AS adds,
    CAST(NULL AS FLOAT8)              AS drops,
    CAST(NULL AS INTEGER)             AS rows_flagged,
    CAST(NULL AS INTEGER)             AS accounts_flagged,
    CAST(NULL AS FLOAT8)              AS exposure_sum,
    CAST(NULL AS FLOAT8)              AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)              AS exposure_abs_avg,
    CAST(NULL AS DATE)                AS prev_month_end,
    CAST(NULL AS FLOAT8)              AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)              AS pct_delta_exposure,
    CAST(NULL AS INTEGER)             AS hist_months,
    CAST(NULL AS FLOAT8)              AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)              AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)              AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)              AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)              AS zscore_abs,
    AVG(ABS(exposure_sum))            AS volatility_avg_abs,
    STDDEV_SAMP(ABS(exposure_sum))    AS volatility_std_abs,
    CASE WHEN AVG(ABS(exposure_sum))=0 THEN NULL
         ELSE (STDDEV_SAMP(ABS(exposure_sum)) / AVG(ABS(exposure_sum))) END AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)              AS exposure_delta
  FROM bucket_month
  GROUP BY CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* ---------- Final selector (one result set) ---------- */
SELECT * FROM snapshot
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM trend
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM mom_decomp
WHERE (SELECT p_section FROM params) = 'MOM_DECOMP'
UNION ALL
SELECT * FROM top_movers
WHERE (SELECT p_section FROM params) = 'TOP_MOVERS'
UNION ALL
SELECT * FROM volatility
WHERE (SELECT p_section FROM params) = 'VOLATILITY'
ORDER BY
  section,
  month_end DESC,
  COALESCE(synthetic_category, '') ,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  COALESCE(ABS(exposure_delta), ABS(delta_total), ABS(exposure_sum), 0) DESC;







/*=========================================================================
  Unified Synthetic Analytics (LOANHUB) — One Script, Param-Driven Sections
  Table: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  NOTE: Set params.p_section to one of:
        'SNAPSHOT_TREND' | 'MOM_DECOMP' | 'TOP_MOVERS' | 'VOLATILITY'
 *=========================================================================*/

WITH
/* ---------- Parameters ---------- */
params AS (
  SELECT
    24::INT               AS lookback_months,    -- window for history/volatility
    1000::INT             AS topN_movers,        -- TOP N for TOP_MOVERS section
    'MOM_DECOMP'::VARCHAR AS p_section           -- << set per PBI copy
),

/* ---------- Base (Total Loans only) ---------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8  AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---------- Latest & Prior Month ---------- */
latest AS (
  SELECT MAX(month_end) AS latest_me
  FROM (SELECT DISTINCT month_end FROM base) d
),
prior AS (
  SELECT MAX(month_end) AS prior_me
  FROM (SELECT DISTINCT month_end FROM base) d
  WHERE month_end < (SELECT latest_me FROM latest)
),

/* ---------- Window for history/volatility ---------- */
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_me, -((SELECT lookback_months FROM params) - 1))
),

/* ---------- Synthetic tagging (Cat1 / Cat2) ---------- */
tagged AS (
  SELECT
    w.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%' THEN 1
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364) THEN 1
      ELSE 0
    END AS is_synth,
    CASE
      WHEN (UPPER(CONTRACT_SOURCE_SYSTEM) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%')
           AND (CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE IN
              (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
               1043008,1142048,1051872,1061833,1041211,1041344,1041364))
      THEN 'Cat1+Cat2'
      WHEN (UPPER(CONTRACT_SOURCE_SYSTEM) IN
              ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%')
      THEN 'Cat1'
      WHEN CONTRACT_SOURCE_SYSTEM='ALL' AND GL_ACCOUNT_CODE IN
           (1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364)
      THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM windowed w
),

/* ---------- Monthly aggregates for SNAPSHOT/TREND ---------- */
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)                  AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                                     AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER)           AS accounts_flagged,
    SUM(exposure)                                AS exposure_sum,
    SUM(ABS(exposure))                           AS exposure_abs_sum,
    AVG(ABS(exposure))                           AS exposure_abs_avg
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
m_latest AS (SELECT MAX(month_end) AS month_end FROM monthly_group),
m_prior2 AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),
latest_per_group AS (
  SELECT g.* FROM monthly_group g JOIN m_latest ml ON g.month_end = ml.month_end
),
prior_per_group AS (
  SELECT g.* FROM monthly_group g JOIN m_prior2 mp ON g.month_end = mp.month_end
),
history_stats AS (
  SELECT
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)            AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                               AS hist_months,
    AVG(ABS(exposure_sum))                 AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))         AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))                 AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))                 AS hist_max_abs_exposure
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),

/* ---------- SNAPSHOT rows ---------- */
snapshot AS (
  SELECT
    'SNAPSHOT_TREND'::VARCHAR AS section,
    lp.month_end,
    lp.synthetic_category,
    lp.CONTRACT_SOURCE_SYSTEM,
    lp.GL_ACCOUNT_CODE,
    lp.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128)) AS account_identifier,
    CAST(NULL AS FLOAT8)       AS exposure_prev,
    CAST(NULL AS FLOAT8)       AS exposure_cur,
    CAST(NULL AS FLOAT8)       AS delta_total,
    CAST(NULL AS FLOAT8)       AS cont_growth,
    CAST(NULL AS FLOAT8)       AS adds,
    CAST(NULL AS FLOAT8)       AS drops,
    lp.rows_flagged,
    lp.accounts_flagged,
    lp.exposure_sum,
    lp.exposure_abs_sum,
    lp.exposure_abs_avg,
    (SELECT month_end FROM m_prior2)          AS prev_month_end,
    COALESCE(pp.exposure_sum,0.0)             AS prev_exposure_sum,
    CASE WHEN COALESCE(pp.exposure_sum,0.0)=0 THEN NULL
         ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum,0.0) END AS pct_delta_exposure,
    hs.hist_months,
    hs.hist_avg_abs_exposure,
    hs.hist_std_abs_exposure,
    hs.hist_min_abs_exposure,
    hs.hist_max_abs_exposure,
    CASE WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
         ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure END AS zscore_abs,
    CAST(NULL AS FLOAT8) AS volatility_avg_abs,
    CAST(NULL AS FLOAT8) AS volatility_std_abs,
    CAST(NULL AS FLOAT8) AS volatility_cv_abs,
    CAST(NULL AS FLOAT8) AS exposure_delta
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category=lp.synthetic_category
   AND pp.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND pp.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
  LEFT JOIN history_stats hs
    ON hs.synthetic_category=lp.synthetic_category
   AND hs.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND hs.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
),

/* ---------- TREND rows ---------- */
trend AS (
  SELECT
    'SNAPSHOT_TREND'::VARCHAR AS section,
    g.month_end,
    g.synthetic_category,
    g.CONTRACT_SOURCE_SYSTEM,
    g.GL_ACCOUNT_CODE,
    g.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128)) AS account_identifier,
    CAST(NULL AS FLOAT8) AS exposure_prev,
    CAST(NULL AS FLOAT8) AS exposure_cur,
    CAST(NULL AS FLOAT8) AS delta_total,
    CAST(NULL AS FLOAT8) AS cont_growth,
    CAST(NULL AS FLOAT8) AS adds,
    CAST(NULL AS FLOAT8) AS drops,
    g.rows_flagged,
    g.accounts_flagged,
    g.exposure_sum,
    g.exposure_abs_sum,
    g.exposure_abs_avg,
    CAST(NULL AS DATE)   AS prev_month_end,
    CAST(NULL AS FLOAT8) AS prev_exposure_sum,
    CAST(NULL AS FLOAT8) AS pct_delta_exposure,
    CAST(NULL AS INTEGER)AS hist_months,
    CAST(NULL AS FLOAT8) AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8) AS zscore_abs,
    CAST(NULL AS FLOAT8) AS volatility_avg_abs,
    CAST(NULL AS FLOAT8) AS volatility_std_abs,
    CAST(NULL AS FLOAT8) AS volatility_cv_abs,
    CAST(NULL AS FLOAT8) AS exposure_delta
  FROM monthly_group g
),

/* ---------- MoM Decomposition (synthetic only) ---------- */
cur_syn AS (
  SELECT * FROM tagged
  WHERE is_synth=1 AND month_end=(SELECT latest_me FROM latest)
),
prev_syn AS (
  SELECT * FROM tagged
  WHERE is_synth=1 AND month_end=(SELECT prior_me FROM prior)
),
aligned_mom AS (
  SELECT
    COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS css_key,
    COALESCE(c.GL_ACCOUNT_CODE,        p.GL_ACCOUNT_CODE)        AS gl_key,
    COALESCE(c.GL_ACCOUNT_DESCRIPTION, p.GL_ACCOUNT_DESCRIPTION)  AS gl_desc,
    p.exposure AS prev_exp,
    c.exposure AS cur_exp
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),
rolled_mom AS (
  SELECT
    css_key  AS CONTRACT_SOURCE_SYSTEM,
    gl_key   AS GL_ACCOUNT_CODE,
    MAX(gl_desc) AS GL_ACCOUNT_DESCRIPTION,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NOT NULL THEN cur_exp - prev_exp ELSE 0 END) AS cont_growth,
    SUM(CASE WHEN prev_exp IS NULL  AND cur_exp IS NOT NULL THEN cur_exp ELSE 0 END)               AS adds,
    SUM(CASE WHEN prev_exp IS NOT NULL AND cur_exp IS NULL THEN -prev_exp ELSE 0 END)              AS drops,
    SUM(COALESCE(prev_exp,0.0)) AS exposure_prev,
    SUM(COALESCE(cur_exp,0.0))  AS exposure_cur
  FROM aligned_mom
  GROUP BY css_key, gl_key
),

mom_decomp AS (
  SELECT
    'MOM_DECOMP'::VARCHAR AS section,
    (SELECT latest_me FROM latest) AS month_end,
    CAST(NULL AS VARCHAR(12))      AS synthetic_category,
    r.CONTRACT_SOURCE_SYSTEM,
    r.GL_ACCOUNT_CODE,
    r.GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128))     AS account_identifier,
    r.exposure_prev,
    r.exposure_cur,
    (r.exposure_cur - r.exposure_prev) AS delta_total,
    r.cont_growth,
    r.adds,
    r.drops,
    CAST(NULL AS INTEGER) AS rows_flagged,
    CAST(NULL AS INTEGER) AS accounts_flagged,
    CAST(NULL AS FLOAT8)  AS exposure_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_avg,
    (SELECT prior_me FROM prior)   AS prev_month_end,
    CAST(NULL AS FLOAT8)  AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)  AS pct_delta_exposure,
    CAST(NULL AS INTEGER) AS hist_months,
    CAST(NULL AS FLOAT8)  AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)  AS zscore_abs,
    CAST(NULL AS FLOAT8)  AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)  AS volatility_std_abs,
    CAST(NULL AS FLOAT8)  AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)  AS exposure_delta
  FROM rolled_mom r
),

/* ---------- Top Movers (account-level, latest vs prior) ---------- */
aligned_movers AS (
  SELECT
    COALESCE(c.ACCOUNT_IDENTIFIER, p.ACCOUNT_IDENTIFIER) AS ACCOUNT_IDENTIFIER,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM, p.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_CODE,        p.GL_ACCOUNT_CODE)        AS GL_ACCOUNT_CODE,
    COALESCE(c.GL_ACCOUNT_DESCRIPTION, p.GL_ACCOUNT_DESCRIPTION)  AS GL_ACCOUNT_DESCRIPTION,
    COALESCE(p.exposure,0.0) AS exposure_prev,
    COALESCE(c.exposure,0.0) AS exposure_cur
  FROM cur_syn c
  FULL OUTER JOIN prev_syn p
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
),
ranked_movers AS (
  SELECT
    am.*,
    (exposure_cur - exposure_prev) AS exposure_delta,
    ROW_NUMBER() OVER (ORDER BY ABS(exposure_cur - exposure_prev) DESC) AS rn
  FROM aligned_movers am
),
top_movers AS (
  SELECT
    'TOP_MOVERS'::VARCHAR AS section,
    (SELECT latest_me FROM latest) AS month_end,
    CAST(NULL AS VARCHAR(12))      AS synthetic_category,
    rm.CONTRACT_SOURCE_SYSTEM,
    rm.GL_ACCOUNT_CODE,
    rm.GL_ACCOUNT_DESCRIPTION,
    rm.ACCOUNT_IDENTIFIER          AS account_identifier,
    rm.exposure_prev,
    rm.exposure_cur,
    rm.exposure_cur - rm.exposure_prev AS delta_total,
    CAST(NULL AS FLOAT8) AS cont_growth,
    CAST(NULL AS FLOAT8) AS adds,
    CAST(NULL AS FLOAT8) AS drops,
    CAST(NULL AS INTEGER) AS rows_flagged,
    CAST(NULL AS INTEGER) AS accounts_flagged,
    CAST(NULL AS FLOAT8)  AS exposure_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)  AS exposure_abs_avg,
    (SELECT prior_me FROM prior)   AS prev_month_end,
    CAST(NULL AS FLOAT8)  AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)  AS pct_delta_exposure,
    CAST(NULL AS INTEGER) AS hist_months,
    CAST(NULL AS FLOAT8)  AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)  AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)  AS zscore_abs,
    CAST(NULL AS FLOAT8)  AS volatility_avg_abs,
    CAST(NULL AS FLOAT8)  AS volatility_std_abs,
    CAST(NULL AS FLOAT8)  AS volatility_cv_abs,
    rm.exposure_delta
  FROM ranked_movers rm
  WHERE rn <= (SELECT topN_movers FROM params)
),

/* ---------- Volatility (window) ---------- */
bucket_month AS (
  SELECT
    month_end,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION) AS GL_ACCOUNT_DESCRIPTION,
    SUM(exposure)               AS exposure_sum
  FROM tagged
  WHERE is_synth = 1
  GROUP BY month_end, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
volatility AS (
  SELECT
    'VOLATILITY'::VARCHAR        AS section,
    MAX(month_end)               AS month_end,
    CAST(NULL AS VARCHAR(12))    AS synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)  AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(128))   AS account_identifier,
    CAST(NULL AS FLOAT8)         AS exposure_prev,
    CAST(NULL AS FLOAT8)         AS exposure_cur,
    CAST(NULL AS FLOAT8)         AS delta_total,
    CAST(NULL AS FLOAT8)         AS cont_growth,
    CAST(NULL AS FLOAT8)         AS adds,
    CAST(NULL AS FLOAT8)         AS drops,
    CAST(NULL AS INTEGER)        AS rows_flagged,
    CAST(NULL AS INTEGER)        AS accounts_flagged,
    CAST(NULL AS FLOAT8)         AS exposure_sum,
    CAST(NULL AS FLOAT8)         AS exposure_abs_sum,
    CAST(NULL AS FLOAT8)         AS exposure_abs_avg,
    CAST(NULL AS DATE)           AS prev_month_end,
    CAST(NULL AS FLOAT8)         AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)         AS pct_delta_exposure,
    CAST(NULL AS INTEGER)        AS hist_months,
    CAST(NULL AS FLOAT8)         AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)         AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)         AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)         AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)         AS zscore_abs,
    AVG(ABS(exposure_sum))       AS volatility_avg_abs,
    STDDEV_SAMP(ABS(exposure_sum)) AS volatility_std_abs,
    CASE WHEN AVG(ABS(exposure_sum))=0 THEN NULL
         ELSE (STDDEV_SAMP(ABS(exposure_sum)) / AVG(ABS(exposure_sum))) END AS volatility_cv_abs,
    CAST(NULL AS FLOAT8)         AS exposure_delta
  FROM bucket_month
  GROUP BY CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* ---------- Final selector (one result set) ---------- */
SELECT * FROM snapshot
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM trend
WHERE (SELECT p_section FROM params) = 'SNAPSHOT_TREND'
UNION ALL
SELECT * FROM mom_decomp
WHERE (SELECT p_section FROM params) = 'MOM_DECOMP'
UNION ALL
SELECT * FROM top_movers
WHERE (SELECT p_section FROM params) = 'TOP_MOVERS'
UNION ALL
SELECT * FROM volatility
WHERE (SELECT p_section FROM params) = 'VOLATILITY'

ORDER BY
  section,
  month_end DESC,
  synthetic_category NULLS FIRST,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  COALESCE(ABS(exposure_delta), ABS(delta_total), ABS(exposure_sum), 0) DESC;






-- ==================== KDE MoM Changes — Changes-Only (Upgraded+) ====================
-- - 13-month rolling window (tune in params)
-- - Aggregate ONLY changed rows: counts, exposure deltas, MoM%
-- - Flip-type breakdown: NULL→VAL, VAL→NULL, VAL→VAL (counts & $ deltas)
-- - Rolling 12M stability stats (mean, stddev) on $Δ for each KDE
-- - Drift Severity Index per KDE×month: 0.7*|%Δ exposure on changed| + 0.3*share of changed accts
-- - Per-month ranks by |$Δ|, #accounts, Severity Index
-- - Optional materiality gates (min accounts OR min |$Δ|)
-- ===================================================================================

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,          -- 13 months back from today
    5::INTEGER                         AS min_accts_gate,   -- minimum changed accounts to keep
    1000000.0::FLOAT8                  AS min_abs_exp_delta_gate  -- OR minimum absolute $Δ to keep
),

/* 1) Base rows (Total Loans, 13-month window) */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) Long-form (UNION ALL) for selected KDEs; cast to stable VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure, CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* 3) LAG prev month value/exposure for change detection */
lagged AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    kde_val,
    LAG(kde_val)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)  OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end) OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* 4) Keep only rows that changed vs prior month (incl. NULL flips), adjacent months only */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure AS this_exp,
    prev_exp,
    CASE
      WHEN prev_val IS NULL AND kde_val IS NOT NULL THEN 'NULL→VAL'
      WHEN prev_val IS NOT NULL AND kde_val IS NULL THEN 'VAL→NULL'
      ELSE 'VAL→VAL'
    END AS flip_type
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,'~NULL~') <> COALESCE(prev_val,'~NULL~')
),

/* 5) Aggregate change-only rows + flip-type breakdowns */
agg AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*) AS accounts_changed,
    SUM(COALESCE(prev_exp,0))                        AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                        AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed,

    -- Flip counts
    SUM(CASE WHEN flip_type='NULL→VAL' THEN 1 ELSE 0 END) AS cnt_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN 1 ELSE 0 END) AS cnt_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN 1 ELSE 0 END) AS cnt_val_to_val,

    -- Flip exposure deltas
    SUM(CASE WHEN flip_type='NULL→VAL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_val
  FROM changed
  GROUP BY kde_name, month_end
),

/* 6) Final metrics + MoM% on changed population */
final_raw AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE (exposure_delta_on_changed / exposure_prev_on_changed)
    END::FLOAT8 AS exposure_mom_pct_on_changed,

    cnt_null_to_val, cnt_val_to_null, cnt_val_to_val,
    exp_delta_null_to_val, exp_delta_val_to_null, exp_delta_val_to_val
  FROM agg
),

/* 7) Apply optional materiality gates */
final_gated AS (
  SELECT fr.*
  FROM final_raw fr, params p
  WHERE (fr.accounts_changed >= p.min_accts_gate)
     OR (ABS(fr.exposure_delta_on_changed) >= p.min_abs_exp_delta_gate)
),

/* 8) Rolling 12M stability stats on $Δ per KDE */
rolling_stats AS (
  SELECT
    f.kde_name,
    f.month_end,
    f.accounts_changed,
    f.exposure_prev_on_changed,
    f.exposure_cur_on_changed,
    f.exposure_delta_on_changed,
    f.exposure_mom_pct_on_changed,
    f.cnt_null_to_val, f.cnt_val_to_null, f.cnt_val_to_val,
    f.exp_delta_null_to_val, f.exp_delta_val_to_null, f.exp_delta_val_to_val,

    AVG(f.exposure_delta_on_changed) OVER (
      PARTITION BY f.kde_name
      ORDER BY f.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS rolling_mean_12m,

    STDDEV_SAMP(f.exposure_delta_on_changed) OVER (
      PARTITION BY f.kde_name
      ORDER BY f.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS rolling_sd_12m
  FROM final_gated f
),

/* 9) Drift components: exposure change % and share of changed accounts (per month) */
drift_components AS (
  SELECT
    r.*,
    -- % change of exposure on changed cohort
    (CASE
       WHEN r.exposure_prev_on_changed = 0 THEN NULL
       ELSE (r.exposure_delta_on_changed / r.exposure_prev_on_changed) * 100.0
     END)::FLOAT8 AS exposure_change_pct,

    -- total changed accounts this month across all KDEs
    SUM(r.accounts_changed) OVER (PARTITION BY r.month_end) AS month_total_accounts_changed
  FROM rolling_stats r
),

/* 10) Severity index + per-month ranks */
scored AS (
  SELECT
    d.*,

    -- Share of changes (as % of total changed accounts this month)
    (CASE
       WHEN d.month_total_accounts_changed = 0 OR d.month_total_accounts_changed IS NULL
         THEN NULL
       ELSE (d.accounts_changed::FLOAT8 / d.month_total_accounts_changed::FLOAT8) * 100.0
     END)::FLOAT8 AS share_of_changes_pct,

    -- Drift Severity Index (0..∞): 0.7*|%Δ exposure| + 0.3*share_of_changes
    ( 0.70 * COALESCE(ABS(d.exposure_change_pct),0)
    + 0.30 * COALESCE(
         (CASE
            WHEN d.month_total_accounts_changed = 0 OR d.month_total_accounts_changed IS NULL
            THEN NULL
            ELSE (d.accounts_changed::FLOAT8 / d.month_total_accounts_changed::FLOAT8) * 100.0
          END), 0)
    )::FLOAT8 AS drift_severity_idx
  FROM drift_components d
)

SELECT
  s.kde_name,
  s.month_end,

  -- core totals
  s.accounts_changed,
  s.exposure_prev_on_changed,
  s.exposure_cur_on_changed,
  s.exposure_delta_on_changed,
  s.exposure_mom_pct_on_changed,

  -- flip breakdowns
  s.cnt_null_to_val, s.cnt_val_to_null, s.cnt_val_to_val,
  s.exp_delta_null_to_val, s.exp_delta_val_to_null, s.exp_delta_val_to_val,

  -- rolling stability
  s.rolling_mean_12m,
  s.rolling_sd_12m,

  -- drift components + index
  s.exposure_change_pct,
  s.month_total_accounts_changed,
  s.share_of_changes_pct,
  s.drift_severity_idx,

  -- per-month ranks
  DENSE_RANK() OVER (PARTITION BY s.month_end ORDER BY ABS(s.exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY s.month_end ORDER BY s.accounts_changed DESC)               AS rk_by_accounts,
  DENSE_RANK() OVER (PARTITION BY s.month_end ORDER BY s.drift_severity_idx DESC)             AS rk_by_severity

FROM scored s
ORDER BY s.month_end DESC, rk_by_severity, rk_by_abs_exposure, s.kde_name;





-- ==================== KDE MoM Changes — Changes-Only (Upgraded) ====================
-- - 13-month rolling window (tune in params)
#NAME?
#NAME?
-- - Aggregate ONLY changed rows: counts, exposure deltas, MoM%
-- - Flip-type breakdown: NULL→VAL, VAL→NULL, VAL→VAL (counts & $ deltas)
-- - Per-month ranks by |$Δ| and by #accounts changed
-- - Optional materiality gates (min accounts OR min |$Δ|) to suppress noise
-- ===================================================================================

WITH
/* 0) Parameters (tune thresholds here) */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    5::INTEGER                         AS min_accts_gate,         -- keep rows with ≥ this many changed accts
    1000000.0::FLOAT8                  AS min_abs_exp_delta_gate  -- OR with ≥ this absolute $ change
),

/* 1) Base rows (Total Loans, 13-month window) */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) Long-form (UNION ALL) for selected KDEs; cast to stable VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure, CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* 3) LAG previous month state/value/exposure for change detection */
lagged AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    kde_val,
    LAG(kde_val)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)  OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end) OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* 4) Only rows that changed value vs prior month (including NULL flips) */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure AS this_exp,
    prev_exp,
    CASE
      WHEN prev_val IS NULL AND kde_val IS NOT NULL THEN 'NULL→VAL'
      WHEN prev_val IS NOT NULL AND kde_val IS NULL THEN 'VAL→NULL'
      ELSE 'VAL→VAL'
    END AS flip_type
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,'~NULL~') <> COALESCE(prev_val,'~NULL~')
),

/* 5) Aggregate change-only rows + flip-type breakdowns */
agg AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*) AS accounts_changed,
    SUM(COALESCE(prev_exp,0))                        AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                        AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed,

    -- Flip counts
    SUM(CASE WHEN flip_type='NULL→VAL' THEN 1 ELSE 0 END) AS cnt_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN 1 ELSE 0 END) AS cnt_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN 1 ELSE 0 END) AS cnt_val_to_val,

    -- Flip exposure deltas
    SUM(CASE WHEN flip_type='NULL→VAL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_val
  FROM changed
  GROUP BY kde_name, month_end
),

/* 6) Final metrics + MoM% on changed population */
final_raw AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE (exposure_delta_on_changed / exposure_prev_on_changed)
    END::FLOAT8 AS exposure_mom_pct_on_changed,

    cnt_null_to_val, cnt_val_to_null, cnt_val_to_val,
    exp_delta_null_to_val, exp_delta_val_to_null, exp_delta_val_to_val
  FROM agg
),

/* 7) Apply optional materiality gates (keep noise out upstream) */
final_gated AS (
  SELECT fr.*
  FROM final_raw fr, params p
  WHERE (fr.accounts_changed >= p.min_accts_gate)
     OR (ABS(fr.exposure_delta_on_changed) >= p.min_abs_exp_delta_gate)
)

SELECT
  f.*,
  -- Per-month ranks
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY ABS(f.exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY f.accounts_changed DESC)               AS rk_by_accounts
FROM final_gated f
ORDER BY f.month_end DESC, rk_by_abs_exposure, rk_by_accounts;









MONTH_END
RC_DESC
EXP_SUM 
PREV_EXP_SUM 
DELTA_EXP 
PCT_SHARE
PREV_PCT
DELTA_PCT
PSI_CONTRIB
PSI_TOTAL
PSI_CONTRIB_PCT_OF_TOTAL
PORTFOLIO_PSI_FLAG
RC_PSI_CLASS
RC_PSI_ALERT_FLAG 
RK_BY_ABS_CONTRIB 
PSI_CONTRIB_ABS








RC_CODE
RC_DESCRIPTION
MONTH_END
BEST_MODEL
FORECAST_SELECTED 
ACTUAL 
RESID 
ABSRESID 
MOM_ABS 
MOM_PCT_ABS
Z_RESID
Z_MOM_ABS
Z_MOM_PCT
RMSE 
PI_LO 
PI_HI 
SEVERITY_0_100
PERSISTENT_OUTLIER_3OF6
REASON_CODE











import pandas as pd
import numpy as np

# ---------- Helpers ----------
def promote_first_row_to_header(df):
    """If columns look like 0,1,2..., use the first row as headers."""
    if all(isinstance(c, (int, np.integer)) or str(c).isdigit() for c in df.columns):
        header = df.iloc[0].astype(str).str.strip()
        df = df.iloc[1:].copy()
        df.columns = header
    return df

def normalize_columns(df):
    out = df.copy()
    out.columns = (
        out.columns.astype(str)
        .str.strip()
        .str.replace(r"[^A-Za-z0-9]+", "_", regex=True)
        .str.replace(r"_+", "_", regex=True)
        .str.strip("_")
        .str.lower()
    )
    return out

def find_rc_desc(cols):
    # Try exacts
    for c in ["rc_description","rc_desc","rc_code_description","rc_name","rcdescription"]:
        if c in cols: return c
    # Fuzzy contains rc + (desc|descr|description)
    for c in cols:
        cl = c.lower()
        if "rc" in cl and ("desc" in cl or "descr" in cl or "description" in cl):
            return c
    return None

def try_parse_dates(df, candidates):
    for c in candidates:
        if c in df.columns:
            df["month_end"] = pd.to_datetime(df[c], errors="coerce")
    return df

# ---------- Load from Excel Tables ----------
# IMPORTANT: This xl() object exists only in Python in Excel.
# If you see NameError: xl, make sure this code is running in a Python cell inside Excel.
model_tbl = "RC_Code_Model_Base"
psi_tbl   = "RC_PSI_ByDescription"

m_raw = pd.DataFrame(xl(model_tbl))
p_raw = pd.DataFrame(xl(psi_tbl))

# Promote first row to header if needed, then normalize headers
m = normalize_columns(promote_first_row_to_header(m_raw))
p = normalize_columns(promote_first_row_to_header(p_raw))

# Try to create a canonical 'month_end' column
m = try_parse_dates(m, ["month_end","end_of_month_date","monthend"])
p = try_parse_dates(p, ["month_end","end_of_month_date","monthend"])

# Find RC description columns
rc_model_col = find_rc_desc(m.columns)
rc_psi_col   = find_rc_desc(p.columns)

# Make rc_desc the unified name on both
if rc_model_col is None or rc_psi_col is None:
    raise ValueError(
        "Couldn't find RC description column.\n"
        f"Model columns: {list(m.columns)}\n"
        f"PSI columns:   {list(p.columns)}\n"
        "Tip: Make sure your headers include 'RC_DESCRIPTION' (or similar) "
        "and that the first row really is headers."
    )

m = m.rename(columns={rc_model_col:"rc_desc"})
p = p.rename(columns={rc_psi_col:"rc_desc"})

# Minimal columns we expect
need_m = {"rc_desc","month_end"}
need_p = {"rc_desc","month_end"}
if not need_m.issubset(m.columns) or not need_p.issubset(p.columns):
    raise ValueError(
        "Missing key columns after normalization.\n"
        f"Model has: {list(m.columns)}\n"
        f"PSI has:   {list(p.columns)}\n"
        "Make sure each table has RC description and a month_end/date column."
    )

# Drop empty rc_desc / invalid dates
m = m.dropna(subset=["rc_desc","month_end"])
p = p.dropna(subset=["rc_desc","month_end"])

# Show what we detected so you can confirm
print("✅ Loaded tables with headers:")
print("Model columns:", list(m.columns))
print("PSI columns:  ", list(p.columns))
print("\nMODEL preview:")
display(m.head(5))
print("\nPSI preview:")
display(p.head(5))






# ==== Python in Excel: import an Excel Table named RC_Code_Model_Base ====
# Paste this entire cell as-is. Do not add other lines that reference df['RC_Code_Model_Base'].

import pandas as pd
import re
import unicodedata

TABLE_NAME = "RC_Code_Model_Base"   # <-- Excel TABLE name (not a column)

# 1) Import the Excel Table
df = xl(TABLE_NAME)  # pulls the table/range into a pandas DataFrame

# 2) Normalize headers (safe across weird spacing/unicode). Keeps only actual column names.
def normalize_headers(cols):
    def norm(c):
        c = '' if c is None else str(c)
        c = unicodedata.normalize('NFKC', c)
        c = c.strip()
        c = re.sub(r'\s+', '_', c)   # spaces -> underscores
        return c.upper()             # standardize to ALL CAPS
    return [norm(c) for c in cols]

df.columns = normalize_headers(df.columns)

# 3) Sanity check: show exactly what columns exist
print("Imported table:", TABLE_NAME)
print("Columns:", list(df.columns))

# 4) Example access that CANNOT raise KeyError for the table name:
#    Replace 'RC_CODE' etc. with *real* columns you see printed above.
#    (Commented out so this cell can't fail. Uncomment after you confirm names.)
# filtered = df[(df["SOURCE_SYSTEM_BALANCE"].notna()) & (df["SOURCE_SYSTEM_BALANCE"] != 0)]
# filtered[["RC_CODE", "RC_DESCRIPTION", "SOURCE_SYSTEM_BALANCE"]]

# 5) Return df so you can see it in the cell output
df





# --- Option A: Read Excel TABLE named RC_Code_Model_Base into pandas, normalize headers, and go ---
import pandas as pd
import re
import unicodedata

TABLE_NAME = "RC_Code_Model_Base"   # <-- Excel Table name (not a column name)

# 1) Load the Excel Table into a DataFrame
df = xl(TABLE_NAME)   # In Python in Excel, xl("TableName") pulls the table data

# 2) Normalize column headers (safe even if already ALL-CAPS)
def normalize_headers(cols):
    def norm(c):
        c = '' if c is None else str(c)
        c = unicodedata.normalize('NFKC', c)  # normalize unicode
        c = c.strip()
        c = re.sub(r'\s+', '_', c)            # spaces -> underscores
        return c.upper()                      # standardize to ALL CAPS
    return [norm(c) for c in cols]

df.columns = normalize_headers(df.columns)

# 3) (Optional) If a table was mis-imported and headers became a row, fix it.
#    This is rare with proper Excel Tables, but harmless to keep:
if all(isinstance(c, (int, float)) for c in df.columns):
    # assume first row contains headers
    new_headers = normalize_headers(df.iloc[0].tolist())
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = new_headers

# 4) EXAMPLES — use your ALL-CAPS columns directly (replace with your real ones):
#    Example: filter out NULLs and 0s from RC_EXPOSURE
def nz_nonzero(s):
    # keeps non-null and non-zero values
    return s.notna() & (s != 0)

# ---- Example usage (uncomment and adapt as needed) ----
# filtered = df[nz_nonzero(df["RC_EXPOSURE"])]
# top10 = (df.sort_values("RC_EXPOSURE", ascending=False).head(10))
# keep_cols = ["RC_CODE", "RC_DESCRIPTION", "RC_EXPOSURE"]
# result = filtered[keep_cols].copy()

# 5) Show what columns are available (useful for quick verification)
print("Columns:", list(df.columns))

# 6) Return `df` (or any derived DataFrame, e.g., `filtered`) as the cell output
df






import pandas as pd
import numpy as np

# ---------- Helpers ----------
def promote_first_row_to_header(df):
    """If columns look like 0,1,2..., use the first row as headers."""
    if all(isinstance(c, (int, np.integer)) or str(c).isdigit() for c in df.columns):
        header = df.iloc[0].astype(str).str.strip()
        df = df.iloc[1:].copy()
        df.columns = header
    return df

def normalize_columns(df):
    out = df.copy()
    out.columns = (
        out.columns.astype(str)
        .str.strip()
        .str.replace(r"[^A-Za-z0-9]+", "_", regex=True)
        .str.replace(r"_+", "_", regex=True)
        .str.strip("_")
        .str.lower()
    )
    return out

def find_rc_desc(cols):
    # Try exacts
    for c in ["rc_description","rc_desc","rc_code_description","rc_name","rcdescription"]:
        if c in cols: return c
    # Fuzzy contains rc + (desc|descr|description)
    for c in cols:
        cl = c.lower()
        if "rc" in cl and ("desc" in cl or "descr" in cl or "description" in cl):
            return c
    return None

def try_parse_dates(df, candidates):
    for c in candidates:
        if c in df.columns:
            df["month_end"] = pd.to_datetime(df[c], errors="coerce")
    return df

# ---------- Load from Excel Tables ----------
# IMPORTANT: This xl() object exists only in Python in Excel.
# If you see NameError: xl, make sure this code is running in a Python cell inside Excel.
model_tbl = "RC_Code_Model_Base"
psi_tbl   = "RC_PSI_ByDescription"

m_raw = pd.DataFrame(xl(model_tbl))
p_raw = pd.DataFrame(xl(psi_tbl))

# Promote first row to header if needed, then normalize headers
m = normalize_columns(promote_first_row_to_header(m_raw))
p = normalize_columns(promote_first_row_to_header(p_raw))

# Try to create a canonical 'month_end' column
m = try_parse_dates(m, ["month_end","end_of_month_date","monthend"])
p = try_parse_dates(p, ["month_end","end_of_month_date","monthend"])

# Find RC description columns
rc_model_col = find_rc_desc(m.columns)
rc_psi_col   = find_rc_desc(p.columns)

# Make rc_desc the unified name on both
if rc_model_col is None or rc_psi_col is None:
    raise ValueError(
        "Couldn't find RC description column.\n"
        f"Model columns: {list(m.columns)}\n"
        f"PSI columns:   {list(p.columns)}\n"
        "Tip: Make sure your headers include 'RC_DESCRIPTION' (or similar) "
        "and that the first row really is headers."
    )

m = m.rename(columns={rc_model_col:"rc_desc"})
p = p.rename(columns={rc_psi_col:"rc_desc"})

# Minimal columns we expect
need_m = {"rc_desc","month_end"}
need_p = {"rc_desc","month_end"}
if not need_m.issubset(m.columns) or not need_p.issubset(p.columns):
    raise ValueError(
        "Missing key columns after normalization.\n"
        f"Model has: {list(m.columns)}\n"
        f"PSI has:   {list(p.columns)}\n"
        "Make sure each table has RC description and a month_end/date column."
    )

# Drop empty rc_desc / invalid dates
m = m.dropna(subset=["rc_desc","month_end"])
p = p.dropna(subset=["rc_desc","month_end"])

# Show what we detected so you can confirm
print("✅ Loaded tables with headers:")
print("Model columns:", list(m.columns))
print("PSI columns:  ", list(p.columns))
print("\nMODEL preview:")
display(m.head(5))
print("\nPSI preview:")
display(p.head(5))






import pandas as pd
import numpy as np

# --- Read Excel Tables into DataFrames ---
df_model = pd.DataFrame(xl("RC_Code_Model_Base"))
df_psi   = pd.DataFrame(xl("RC_PSI_ByDescription"))

# --- Normalize column names (lowercase, underscores) ---
def norm_cols(df):
    df = df.copy()
    df.columns = (
        df.columns.astype(str)
        .str.strip().str.lower()
        .str.replace(r"[^a-z0-9]+", "_", regex=True)
        .str.replace(r"_+", "_", regex=True)
        .str.strip("_")
    )
    return df

m = norm_cols(df_model)
p = norm_cols(df_psi)

# --- Robust date parsing ---
for c in ["month_end","end_of_month_date"]:
    if c in m.columns:
        m["month_end"] = pd.to_datetime(m[c])
for c in ["month_end"]:
    if c in p.columns:
        p["month_end"] = pd.to_datetime(p[c])

# --- Robust RC description mapping ---
# Prefer 'rc_description' in model; 'rc_desc' in PSI
rc_model_col = "rc_description" if "rc_description" in m.columns else "rc_desc" if "rc_desc" in m.columns else None
rc_psi_col   = "rc_desc"        if "rc_desc"        in p.columns else "rc_description" if "rc_description" in p.columns else None
if rc_model_col is None or rc_psi_col is None:
    raise ValueError(f"Couldn't find RC description column. Model cols: {m.columns.tolist()} | PSI cols: {p.columns.tolist()}")

# --- Keep only the columns we need now; keep extras if present ---
keep_model = [c for c in [rc_model_col, "month_end", "r2_by_model",
                          "severity_weighted_latest_rc",  # if you used this exact name
                          "severity_weighted_latest___rc", # fallback if punctuation collapsed
                          "exposure_latest",
                          "exposure___moM_per_rc", "exposure_delta_mom_per_rc", "actual", "forecast_selected"]
              if c in m.columns]
m_small = m[keep_model].copy()

# Align severity col name
if "severity_weighted_latest_rc" not in m_small.columns:
    if "severity_weighted_latest___rc" in m_small.columns:
        m_small = m_small.rename(columns={"severity_weighted_latest___rc":"severity_weighted_latest_rc"})

# PSI essentials
keep_psi = [c for c in ["rc_desc", "rc_description", "month_end",
                        "psi_contrib_abs", "psi_contrib", "delta_pct", "exp_sum", "delta_exp"]
            if c in p.columns]
p_small = p[keep_psi].copy()

# Unify RC column name on both sides
m_small = m_small.rename(columns={rc_model_col:"rc_desc"})
p_small = p_small.rename(columns={rc_psi_col:"rc_desc"})

# --- Basic sanity: drop blank rc_desc and bad dates ---
m_small = m_small.dropna(subset=["rc_desc","month_end"])
p_small = p_small.dropna(subset=["rc_desc","month_end"])

# Preview (Excel: right-click output → Convert to Table to persist)
m_small.head(5), p_small.head(5)







-- MoM Non-Accrual Adds & Drops Only (Option 3: per-month positive balance)
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      -- Required attributes
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_ACCOUNT_HIER_LEVEL_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      -- Needed for Bank_Code derivation
      GL_ACCOUNT_CODE
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- current EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
),
prev AS (  -- prior EOM non-accruals (must have positive exposure)
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
    AND Source_System_Balance > 0
)
SELECT
  /* Identity / keys */
  COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
  COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
  COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
  COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
  COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

  /* Source / hierarchy / descriptors */
  COALESCE(c.Contract_Source_System, p.Contract_Source_System)  AS Contract_Source_System,
  COALESCE(c.Status_Code_Description, p.Status_Code_Description)AS Status_Code_Description,
  COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4, p.GL_ACCOUNT_HIER_LEVEL_4)AS GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.PROD_HIER_LEVEL_5, p.PROD_HIER_LEVEL_5)            AS PROD_HIER_LEVEL_5,

  /* Bank_Code mapping */
  CASE
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) = 'ALL'
         AND COALESCE(c.GL_ACCOUNT_CODE, p.GL_ACCOUNT_CODE) IN
         ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
          '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
          '1100001','1142067','1042886','1043008')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
      THEN 'L-FCB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
          'STRAT1','STRAT1-EXCPTN')
      THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,

  /* Risk / credit attributes */
  COALESCE(c.Borrower_Risk_Rating, p.Borrower_Risk_Rating) AS Borrower_Risk_Rating,
  COALESCE(c.PD_Grade,            p.PD_Grade)               AS PD_Grade,
  COALESCE(c.Days_Past_Due,       p.Days_Past_Due)          AS Days_Past_Due,

  /* Flags / codes */
  COALESCE(c.Non_Accrual_Flag, p.Non_Accrual_Flag) AS Non_Accrual_Flag,
  COALESCE(c.RBC_Code,         p.RBC_Code)         AS RBC_Code,

  /* Balances */
  p.Source_System_Balance AS Prev_Bal,
  c.Source_System_Balance AS Curr_Bal,
  COALESCE(c.GL_Balance,        p.GL_Balance)        AS GL_Balance,
  COALESCE(c.Available_Balance, p.Available_Balance) AS Available_Balance,

  /* Change tag + exposure for sort */
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Dropped (Resolved/Out)'
  END AS NA_Status_Change,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN c.Source_System_Balance
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN p.Source_System_Balance
  END AS Exposure_For_Sort
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
WHERE
  (p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL)  -- Added
  OR
  (c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL)  -- Dropped
ORDER BY
  Exposure_For_Sort DESC,
  Bank_Code,
  COALESCE(c.Account_Identifier, p.Account_Identifier);








-- MoM Non-Accrual Adds & Drops Only
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      -- Required attributes
      Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_Account_Hier_Level_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code,
      -- Needed for Bank_Code derivation
      GL_Account_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- current EOM non-accruals
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
),
prev AS (  -- prior EOM non-accruals
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
)
SELECT
  /* Identity / keys */
  COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
  COALESCE(c.Account_Key,        p.Account_Key)        AS Account_Key,
  COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
  COALESCE(c.CIS_Customer_Number,p.CIS_Customer_Number)AS CIS_Customer_Number,
  COALESCE(c.Facility_ID,        p.Facility_ID)        AS Facility_ID,

  /* Source / hierarchy / descriptors */
  COALESCE(c.Contract_Source_System, p.Contract_Source_System) AS Contract_Source_System,
  COALESCE(c.Status_Code_Description, p.Status_Code_Description) AS Status_Code_Description,
  COALESCE(c.GL_Account_Hier_Level_4, p.GL_Account_Hier_Level_4) AS GL_Account_Hier_Level_4,
  COALESCE(c.PROD_HIER_LEVEL_5, p.PROD_HIER_LEVEL_5)             AS PROD_HIER_LEVEL_5,

  /* Bank_Code mapping */
  CASE
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) = 'ALL'
         AND COALESCE(c.GL_Account_Code, p.GL_Account_Code) IN
         ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
          '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
          '1100001','1142067','1042886','1043008')
      THEN 'L-SVB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
      THEN 'L-FCB'
    WHEN COALESCE(c.Contract_Source_System, p.Contract_Source_System) IN
         ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN',
          'INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001',
          'SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN',
          'STRAT1','STRAT1-EXCPTN')
      THEN 'L-CIT'
    ELSE 'NULL-Need to Research'
  END AS Bank_Code,

  /* Risk / credit attributes (coalesced) */
  COALESCE(c.Borrower_Risk_Rating, p.Borrower_Risk_Rating) AS Borrower_Risk_Rating,
  COALESCE(c.PD_Grade,            p.PD_Grade)               AS PD_Grade,
  COALESCE(c.Days_Past_Due,       p.Days_Past_Due)          AS Days_Past_Due,

  /* Flags / codes */
  COALESCE(c.Non_Accrual_Flag, p.Non_Accrual_Flag) AS Non_Accrual_Flag,
  COALESCE(c.RBC_Code,         p.RBC_Code)         AS RBC_Code,

  /* Balances */
  p.Source_System_Balance AS Prev_Bal,
  c.Source_System_Balance AS Curr_Bal,
  COALESCE(c.GL_Balance,          p.GL_Balance)          AS GL_Balance,
  COALESCE(c.Available_Balance,   p.Available_Balance)   AS Available_Balance,

  /* Change tag + exposure for sort */
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Dropped (Resolved/Out)'
  END AS NA_Status_Change,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN c.Source_System_Balance
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN p.Source_System_Balance
  END AS Exposure_For_Sort
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
WHERE
  (p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL)  -- Added
  OR
  (c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL)  -- Dropped
ORDER BY
  Exposure_For_Sort DESC,
  Bank_Code,
  COALESCE(c.Account_Identifier, p.Account_Identifier);








Account_Name,
      Contract_Source_System,
      CIS_Customer_Number,
      Facility_ID,
      Account_Identifier,
      Account_Key,
      Status_Code_Description,
      GL_Account_Hier_Level_4,
      Source_System_Balance,
      GL_Balance,
      Available_Balance,
      Borrower_Risk_Rating,
      PD_Grade,
      Days_Past_Due,
      Non_Accrual_Flag,
      PROD_HIER_LEVEL_5,
      RBC_Code










CASE
        WHEN CONTRACT_SOURCE_SYSTEM IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN') THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1051872' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1061833' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1041344' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1041211' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1041345' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1041364' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1041210' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042127' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042213' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042048' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042368' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042408' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042409' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042424' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1100001' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1142067' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1042886' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM = 'ALL' AND GL_ACCOUNT_CODE = '1043008' THEN 'L-SVB'
        WHEN CONTRACT_SOURCE_SYSTEM IN ('ADJ', 'ALL', 'ALS', 'FDR', 'FISERV', 'GGSL', 'GL', 'LEA', 'PCFS', 'PSL','SBO') THEN 'L-FCB'
        WHEN CONTRACT_SOURCE_SYSTEM IN ('ACAR01', 'ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN','INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN','LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN','STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN') THEN 'L-CIT'
        ELSE 'NULL-Need to Research' END AS bank,        







-- Query: MoM Non-Accrual Adds & Drops Only (with RBC_Code), sorted by exposure
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Identifier,
      Account_Name,
      Bank_Code,
      Contract_Source_System,
      RBC_Code,
      Source_System_Balance,
      Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (  -- current EOM non-accruals
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
),
prev AS (  -- prior EOM non-accruals
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
)
SELECT
  COALESCE(c.Account_Identifier, p.Account_Identifier)            AS Account_Identifier,
  COALESCE(c.Account_Name,       p.Account_Name)                  AS Account_Name,
  COALESCE(c.Bank_Code,          p.Bank_Code)                     AS Bank_Code,
  COALESCE(c.Contract_Source_System, p.Contract_Source_System)    AS Contract_Source_System,
  COALESCE(c.RBC_Code,           p.RBC_Code)                      AS RBC_Code,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Dropped (Resolved/Out)'
  END                                                             AS NA_Status_Change,
  p.Source_System_Balance                                         AS Prev_Bal,
  c.Source_System_Balance                                         AS Curr_Bal,
  -- Use the live-side balance as the exposure for sorting (current for adds, prior for drops)
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN c.Source_System_Balance
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN p.Source_System_Balance
  END                                                             AS Exposure_For_Sort
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
-- keep only adds or drops; exclude persisting
WHERE
  (p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL)  -- Added
  OR
  (c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL)  -- Dropped
ORDER BY
  Exposure_For_Sort DESC,
  COALESCE(c.Bank_Code, p.Bank_Code),
  COALESCE(c.Account_Identifier, p.Account_Identifier);







--Query 5 - MoM Changes / Persisting (vs prior EOM)
WITH params AS (
  SELECT
    DATE '2025-09-30'                 AS curr_eom,
    ADD_MONTHS(DATE '2025-09-30', -1) AS prev_eom
),
pop AS (
  SELECT
      End_of_Month_Date,
      Account_Identifier,
      Account_Name,
      Bank_Code,
      Contract_Source_System,
      Source_System_Balance,
      Non_Accrual_Flag
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 in ('Total Loans','Lns Held for Sale')
    AND Source_System_Balance > 0
    AND End_of_Month_Date IN ((SELECT curr_eom FROM params),
                              (SELECT prev_eom FROM params))
),
curr AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
),
prev AS (
  SELECT *
  FROM pop
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
    AND Non_Accrual_Flag = 'Y'
)
SELECT
  COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
  COALESCE(c.Account_Name,       p.Account_Name)       AS Account_Name,
  COALESCE(c.Bank_Code,          p.Bank_Code)          AS Bank_Code,
  COALESCE(c.Contract_Source_System, p.Contract_Source_System) AS Contract_Source_System,
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 'Added (New NA)'
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 'Removed (Resolved/Out)'
    ELSE 'Persisting'
  END AS NA_Status_Change,
  p.Source_System_Balance AS Prev_Bal,
  c.Source_System_Balance AS Curr_Bal,
  /* use a numeric sort key instead of ordering by the alias */
  CASE
    WHEN p.Account_Identifier IS NULL AND c.Account_Identifier IS NOT NULL THEN 0
    WHEN c.Account_Identifier IS NULL AND p.Account_Identifier IS NOT NULL THEN 1
    WHEN c.Account_Identifier IS NOT NULL AND p.Account_Identifier IS NOT NULL THEN 2
    ELSE 3
  END AS Sort_Order
FROM curr c
FULL OUTER JOIN prev p
  ON c.Account_Identifier = p.Account_Identifier
ORDER BY
  Sort_Order,
  Bank_Code,
  Account_Identifier;










-- ============================================================
-- RC_DESCRIPTION PSI Classification (Netezza-safe)
-- - 13-month window
-- - Computes per-RC PSI contribution and classifies:
--     * Portfolio_PSI_Flag: Stable / Monitor / Drift
--     * RC_PSI_Class: Dominant/Major/Moderate/Minor/Background (+ direction)
--     * RC_PSI_Alert_Flag: 1/0 for high-impact RCs in Drift/Monitor months
-- - No POWER; uses LN only; parameters tunable below.
-- ============================================================

WITH params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,

    /* tiny share cutoff to damp micro-categories (set to 0 to include all) */
    0.0001::FLOAT8 AS min_share,

    /* Portfolio PSI bands (industry-typical) */
    0.10::FLOAT8 AS psi_stable_max,     -- < 0.10 = Stable
    0.25::FLOAT8 AS psi_monitor_max,    -- 0.10–0.25 = Monitor; >0.25 = Drift

    /* RC contribution bands by % of total PSI (choose what fits your scale) */
    0.20::FLOAT8 AS pct_dom,            -- >=20% of month’s PSI = Dominant
    0.10::FLOAT8 AS pct_major,          -- >=10% = Major
    0.05::FLOAT8 AS pct_moderate,       -- >=5%  = Moderate
    0.02::FLOAT8 AS pct_minor,          -- >=2%  = Minor (else Background)

    /* Optional alert floor on share movement (percentage points of portfolio) */
    0.0025::FLOAT8 AS min_delta_pct_for_alert  -- 0.25 ppts = 0.0025
),

-- 1) Base: 13-month Total Loans population
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)          AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8            AS exposure,
    CAST(RC_DESCRIPTION AS VARCHAR(128))     AS rc_desc
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
    AND SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND RC_DESCRIPTION IS NOT NULL
),

-- 2) Monthly exposure per RC_DESCRIPTION
agg AS (
  SELECT
    month_end,
    rc_desc,
    SUM(exposure) AS exp_sum
  FROM base
  GROUP BY month_end, rc_desc
),

-- 3) Monthly percent share of exposure
norm AS (
  SELECT
    a.month_end,
    a.rc_desc,
    a.exp_sum,
    a.exp_sum / NULLIF(SUM(a.exp_sum) OVER (PARTITION BY a.month_end), 0) AS pct_share
  FROM agg a
),

-- 4) Bring prior-month shares for same RC
lagged AS (
  SELECT
    rc_desc,
    month_end,
    exp_sum,
    pct_share,
    LAG(exp_sum)   OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_exp_sum,
    LAG(pct_share) OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_pct,
    LAG(month_end) OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_me
  FROM norm
),

-- 5) PSI piece + deltas (adjacent months only)
psi_piece AS (
  SELECT
    l.month_end,
    l.rc_desc,
    l.exp_sum,
    l.prev_exp_sum,
    l.pct_share,
    l.prev_pct,
    (l.pct_share - l.prev_pct)                       AS delta_pct,
    (l.exp_sum   - l.prev_exp_sum)                   AS delta_exp,
    /* classic PSI term: (A - E) * ln(A/E) [non-negative when A,E>0] */
    (l.pct_share - l.prev_pct)
      * LN( NULLIF(l.pct_share / NULLIF(l.prev_pct, 0), 0) )      AS psi_contrib
  FROM lagged l, params p
  WHERE l.prev_me = ADD_MONTHS(l.month_end, -1)
    AND l.prev_pct IS NOT NULL
    AND l.pct_share  > 0
    AND l.prev_pct   > 0
    AND l.pct_share >= p.min_share
    AND l.prev_pct  >= p.min_share
),

-- 6) Total PSI per month
psi_month AS (
  SELECT
    month_end,
    SUM(psi_contrib) AS psi_total
  FROM psi_piece
  GROUP BY month_end
),

-- 7) Join totals and compute % contribution + direction
joined AS (
  SELECT
    p.month_end,
    p.rc_desc,
    p.exp_sum,
    p.prev_exp_sum,
    p.delta_exp,
    p.pct_share,
    p.prev_pct,
    p.delta_pct,
    p.psi_contrib,
    m.psi_total,
    /* share of total PSI this RC drove (can be NULL if total=0) */
    CASE WHEN m.psi_total IS NULL OR m.psi_total = 0 THEN NULL
         ELSE p.psi_contrib / m.psi_total END AS psi_contrib_pct_of_total,
    /* direction sign (+1 share up, -1 share down) */
    CASE WHEN p.delta_pct >= 0 THEN 1 ELSE -1 END AS dir_sign
  FROM psi_piece p
  JOIN psi_month m USING (month_end)
),

-- 8) Portfolio PSI flag + RC class + alert flag
classified AS (
  SELECT
    j.*,
    /* Portfolio-level PSI band */
    CASE
      WHEN j.psi_total <  (SELECT psi_stable_max  FROM params) THEN 'Stable'
      WHEN j.psi_total <  (SELECT psi_monitor_max FROM params) THEN 'Monitor'
      ELSE 'Drift'
    END AS portfolio_psi_flag,

    /* RC contribution class by % of total PSI (with direction suffix) */
    CASE
      WHEN j.psi_total IS NULL OR j.psi_total = 0 OR j.psi_contrib_pct_of_total IS NULL THEN 'Background'
      WHEN j.psi_contrib_pct_of_total >= (SELECT pct_dom     FROM params)
        THEN CASE WHEN j.dir_sign = 1 THEN 'Dominant (Share↑)' ELSE 'Dominant (Share↓)' END
      WHEN j.psi_contrib_pct_of_total >= (SELECT pct_major   FROM params)
        THEN CASE WHEN j.dir_sign = 1 THEN 'Major (Share↑)'    ELSE 'Major (Share↓)'    END
      WHEN j.psi_contrib_pct_of_total >= (SELECT pct_moderate FROM params)
        THEN CASE WHEN j.dir_sign = 1 THEN 'Moderate (Share↑)' ELSE 'Moderate (Share↓)' END
      WHEN j.psi_contrib_pct_of_total >= (SELECT pct_minor   FROM params)
        THEN CASE WHEN j.dir_sign = 1 THEN 'Minor (Share↑)'    ELSE 'Minor (Share↓)'    END
      ELSE CASE WHEN j.dir_sign = 1 THEN 'Background (Share↑)' ELSE 'Background (Share↓)' END
    END AS rc_psi_class,

    /* Simple alert: only flag RCs that are sizable contributors in Monitor/Drift months
       and changed share by at least min_delta_pct_for_alert (to avoid micro flicker). */
    CASE
      WHEN ( (j.psi_total >= (SELECT psi_stable_max FROM params))     -- Monitor/Drift
             AND j.psi_contrib_pct_of_total IS NOT NULL
             AND j.psi_contrib_pct_of_total >= (SELECT pct_moderate FROM params) -- >= moderate contributor
             AND ABS(j.delta_pct) >= (SELECT min_delta_pct_for_alert FROM params)
           )
      THEN 1 ELSE 0
    END AS rc_psi_alert_flag,

    /* Rank by absolute contribution (magnitude) within the month */
    DENSE_RANK() OVER (PARTITION BY j.month_end ORDER BY j.psi_contrib DESC) AS rk_by_abs_contrib
  FROM joined j
)

SELECT
  month_end,
  rc_desc,
  exp_sum,
  prev_exp_sum,
  delta_exp,
  pct_share,
  prev_pct,
  delta_pct,
  psi_contrib,
  psi_total,
  psi_contrib_pct_of_total,
  portfolio_psi_flag,
  rc_psi_class,
  rc_psi_alert_flag,
  rk_by_abs_contrib
FROM classified
ORDER BY month_end DESC, rk_by_abs_contrib, rc_desc;






-- ============================================================
-- RC_DESCRIPTION PSI Contributions by Month
-- - Uses RC_DESCRIPTION instead of RC_CODE
-- - Measures each RC's contribution to month-over-month PSI
-- - Netezza-safe (no POWER; uses LN)
-- ============================================================

WITH params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    0.0001::FLOAT8 AS min_share     -- optional cutoff for tiny categories
),

-- 1) Base: 13-month Total Loans population
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    CAST(RC_DESCRIPTION AS VARCHAR(128)) AS rc_desc
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
    AND SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND RC_DESCRIPTION IS NOT NULL
),

-- 2) Monthly exposure per RC_DESCRIPTION
agg AS (
  SELECT
    month_end,
    rc_desc,
    SUM(exposure) AS exp_sum
  FROM base
  GROUP BY month_end, rc_desc
),

-- 3) Monthly percent share of exposure
norm AS (
  SELECT
    a.month_end,
    a.rc_desc,
    a.exp_sum,
    a.exp_sum / NULLIF(SUM(a.exp_sum) OVER (PARTITION BY a.month_end), 0) AS pct_share
  FROM agg a
),

-- 4) Bring prior-month shares
lagged AS (
  SELECT
    rc_desc,
    month_end,
    exp_sum,
    pct_share,
    LAG(exp_sum)   OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_exp_sum,
    LAG(pct_share) OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_pct,
    LAG(month_end) OVER (PARTITION BY rc_desc ORDER BY month_end) AS prev_me
  FROM norm
),

-- 5) PSI component per RC_DESCRIPTION
psi_piece AS (
  SELECT
    month_end,
    rc_desc,
    exp_sum,
    prev_exp_sum,
    pct_share,
    prev_pct,
    (pct_share - prev_pct) AS delta_pct,
    (exp_sum   - prev_exp_sum) AS delta_exp,
    (pct_share - prev_pct) * LN(NULLIF(pct_share / NULLIF(prev_pct, 0), 0)) AS psi_contrib
  FROM lagged, params p
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND prev_pct IS NOT NULL
    AND pct_share  > 0
    AND prev_pct   > 0
    AND pct_share >= p.min_share
    AND prev_pct  >= p.min_share
),

-- 6) Monthly PSI total (for percent-of-total calc)
psi_month AS (
  SELECT
    month_end,
    SUM(psi_contrib) AS psi_total
  FROM psi_piece
  GROUP BY month_end
)

SELECT
  p.month_end,
  p.rc_desc,
  ROUND(p.psi_contrib,6)                     AS psi_contrib,
  ABS(p.psi_contrib)                         AS psi_contrib_abs,
  ROUND(m.psi_total,6)                       AS psi_total,
  CASE WHEN m.psi_total = 0 OR m.psi_total IS NULL
       THEN NULL ELSE p.psi_contrib / m.psi_total END AS psi_contrib_pct_of_total,
  p.prev_exp_sum,
  p.exp_sum,
  p.delta_exp,
  p.prev_pct,
  p.pct_share,
  p.delta_pct,
  DENSE_RANK() OVER (PARTITION BY p.month_end ORDER BY ABS(p.psi_contrib) DESC) AS rk_by_abs_contrib
FROM psi_piece p
JOIN psi_month m USING (month_end)
ORDER BY p.month_end DESC, rk_by_abs_contrib, p.rc_desc;






-- ============================================================
-- RC_CODE PSI Contributions by RC (per month)
-- - 13-month window
-- - PSI term per rc_val: (A - E) * ln(A/E)
-- - Includes current/prior shares & exposures + ranks
-- - Netezza-safe (uses LN, no POWER)
-- ============================================================

WITH params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    0.0001::FLOAT8 AS min_share   -- optional tiny-share gate
),

-- 1) Base (Total Loans, 13m)
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    CAST(RC_CODE AS VARCHAR(64))    AS rc_val,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
    AND SOURCE_SYSTEM_BALANCE IS NOT NULL
),

-- 2) Aggregate exposure per RC per month
agg AS (
  SELECT
    month_end,
    rc_val,
    SUM(exposure) AS exp_sum
  FROM base
  GROUP BY month_end, rc_val
),

-- 3) Compute monthly shares
norm AS (
  SELECT
    a.month_end,
    a.rc_val,
    a.exp_sum,
    a.exp_sum / NULLIF(SUM(a.exp_sum) OVER (PARTITION BY a.month_end), 0) AS pct_share
  FROM agg a
),

-- 4) Bring prior-month values for same RC
lagged AS (
  SELECT
    rc_val,
    month_end,
    exp_sum,
    pct_share,
    LAG(exp_sum)   OVER (PARTITION BY rc_val ORDER BY month_end) AS prev_exp_sum,
    LAG(pct_share) OVER (PARTITION BY rc_val ORDER BY month_end) AS prev_pct,
    LAG(month_end) OVER (PARTITION BY rc_val ORDER BY month_end) AS prev_me
  FROM norm
),

-- 5) PSI piece + deltas (only adjacent months)
psi_piece AS (
  SELECT
    month_end,
    rc_val,
    exp_sum,
    prev_exp_sum,
    pct_share,
    prev_pct,
    (pct_share - prev_pct)                  AS delta_pct,
    (exp_sum   - prev_exp_sum)              AS delta_exp,
    /* PSI contribution of this RC to the month's RC_CODE PSI */
    (pct_share - prev_pct)
      * LN( NULLIF(pct_share / NULLIF(prev_pct, 0), 0) )         AS psi_contrib
  FROM lagged, params p
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND prev_pct IS NOT NULL
    AND pct_share  > 0
    AND prev_pct   > 0
    AND pct_share >= p.min_share         -- damp tiny categories (optional)
    AND prev_pct  >= p.min_share
),

-- 6) Total PSI per month (for % contribution calc)
psi_month AS (
  SELECT
    month_end,
    SUM(psi_contrib) AS psi_total
  FROM psi_piece
  GROUP BY month_end
)

SELECT
  p.month_end,
  p.rc_val,
  /* direction & magnitude */
  p.psi_contrib,
  ABS(p.psi_contrib)                            AS psi_contrib_abs,
  m.psi_total,
  CASE
    WHEN m.psi_total IS NULL OR m.psi_total = 0 THEN NULL
    ELSE p.psi_contrib / m.psi_total
  END                                          AS psi_contrib_pct_of_total,
  /* exposure & share context */
  p.prev_exp_sum,
  p.exp_sum,
  p.delta_exp,
  p.prev_pct,
  p.pct_share,
  p.delta_pct,
  /* ranks within month by absolute contribution */
  DENSE_RANK() OVER (PARTITION BY p.month_end ORDER BY ABS(p.psi_contrib) DESC) AS rk_by_abs_contrib
FROM psi_piece p
JOIN psi_month m USING (month_end)
ORDER BY p.month_end DESC, rk_by_abs_contrib, p.rc_val;







-- ============================================
-- RC_CODE Population Stability Index (PSI)
-- - Compares each month to the prior month
-- - 13-month window for performance
-- - Netezza-safe (no POWER; uses LN)
-- ============================================

WITH params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me
),

-- 1) Base (Total Loans, 13m)
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)       AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8         AS exposure,
    CAST(RC_CODE AS VARCHAR(64))          AS rc_val
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
    AND SOURCE_SYSTEM_BALANCE IS NOT NULL
),

-- 2) Aggregate exposure per RC_CODE value per month
agg AS (
  SELECT
    month_end,
    rc_val,
    SUM(exposure) AS exp_sum
  FROM base
  GROUP BY month_end, rc_val
),

-- 3) Normalize to monthly percentage shares
norm AS (
  SELECT
    a.month_end,
    a.rc_val,
    a.exp_sum,
    a.exp_sum / NULLIF(SUM(a.exp_sum) OVER (PARTITION BY a.month_end), 0) AS pct_share
  FROM agg a
),

-- 4) Bring prior-month shares for the same rc_val
lagged AS (
  SELECT
    rc_val,
    month_end,
    pct_share,
    LAG(pct_share) OVER (PARTITION BY rc_val ORDER BY month_end) AS prev_pct,
    LAG(month_end) OVER (PARTITION BY rc_val ORDER BY month_end) AS prev_me
  FROM norm
),

-- 5) PSI contributions per rc_val (only when month is directly prior)
psi_piece AS (
  SELECT
    month_end,
    rc_val,
    /* classic PSI term: (A - E) * ln(A/E) */
    (pct_share - prev_pct) * LN( NULLIF(pct_share / NULLIF(prev_pct,0), 0) ) AS psi_term
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND prev_pct IS NOT NULL
    AND pct_share > 0
    AND prev_pct  > 0
),

-- 6) Sum contributions into one PSI per month
psi_month AS (
  SELECT
    month_end,
    SUM(psi_term) AS psi_value
  FROM psi_piece
  GROUP BY month_end
)

SELECT
  month_end,
  ROUND(psi_value, 4) AS psi_value,
  CASE
    WHEN psi_value < 0.10 THEN 'Stable'
    WHEN psi_value < 0.25 THEN 'Monitor'
    ELSE 'Drift'
  END AS psi_flag
FROM psi_month
ORDER BY month_end DESC;







/*=========================================================================*
  Directional Flip Analysis: Non-Synthetic ↔ Synthetic
 *=========================================================================*/
WITH
params AS (SELECT 24::INT AS lookback_months),

base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8  AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

-- recent window
latest AS (SELECT MAX(month_end) AS latest_month_end FROM (SELECT DISTINCT month_end FROM base) d),
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_month_end, -((SELECT lookback_months FROM params) - 1))
),

-- tagging
cat1 AS (
  SELECT w.*,
         CASE
           WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
                ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
           THEN 1 ELSE 0 END AS cat1_flag
  FROM windowed w
),
cat2 AS (
  SELECT c1.*,
         CASE
           WHEN CONTRACT_SOURCE_SYSTEM='ALL'
            AND GL_ACCOUNT_CODE IN (
                 1041210,1142067,1042213,1042368,1042409,1042424,1042886,
                 1043008,1142048,1051872,1061833,1041211,1041344,1041364
               )
           THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE 'Non-Synthetic' END AS category
  FROM cat2 c2
),

-- add previous month’s category per account
lagged AS (
  SELECT
    l.*,
    LAG(category) OVER (PARTITION BY ACCOUNT_IDENTIFIER ORDER BY month_end) AS prev_category
  FROM labeled l
),

-- determine direction of change
flagged AS (
  SELECT
    month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    category           AS curr_category,
    prev_category,
    CASE
      WHEN prev_category = 'Non-Synthetic' AND category <> 'Non-Synthetic' THEN 1 ELSE 0 END AS flip_in_flag,
    CASE
      WHEN prev_category <> 'Non-Synthetic' AND category = 'Non-Synthetic' THEN 1 ELSE 0 END AS flip_out_flag,
    CASE
      WHEN prev_category NOT IN ('Non-Synthetic') AND category NOT IN ('Non-Synthetic')
           AND prev_category <> category THEN 1 ELSE 0 END AS flip_type_flag
  FROM lagged
  WHERE prev_category IS NOT NULL
),

-- aggregate to GL × System × direction
summary AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER)                      AS acct_cnt,
    SUM(flip_in_flag)                                       AS flips_in,
    SUM(flip_out_flag)                                      AS flips_out,
    SUM(flip_type_flag)                                     AS flips_typechange,
    COUNT(*)                                                AS obs_cnt,
    ROUND(100.0 * SUM(flip_in_flag)  / NULLIF(COUNT(*),0),2) AS flip_in_pct,
    ROUND(100.0 * SUM(flip_out_flag) / NULLIF(COUNT(*),0),2) AS flip_out_pct
  FROM flagged
  GROUP BY CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

SELECT
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  acct_cnt,
  flips_in,
  flips_out,
  flips_typechange,
  flip_in_pct,
  flip_out_pct,
  (flips_in - flips_out) AS net_inflow
FROM summary
ORDER BY ABS(flips_in - flips_out) DESC;






/*=========================================================================*
  C) FLIP ANALYSIS (Synthetic category flips across months)
 *=========================================================================*/
WITH
params AS (SELECT 24::INT AS lookback_months),

base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
latest AS (SELECT MAX(month_end) AS latest_month_end FROM (SELECT DISTINCT month_end FROM base) d),
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_month_end, -((SELECT lookback_months FROM params) - 1))
),

cat1 AS (
  SELECT w.*,
         CASE
           WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
                ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
           THEN 1 ELSE 0 END AS cat1_flag
  FROM windowed w
),
cat2 AS (
  SELECT c1.*,
         CASE
           WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
            AND GL_ACCOUNT_CODE IN (
                 1041210,1142067,1042213,1042368,1042409,1042424,1042886,
                 1043008,1142048,1051872,1061833,1041211,1041344,1041364
               )
           THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
flags_only AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL END AS synthetic_category
  FROM c2
  WHERE (cat1_flag=1 OR cat2_flag=1)
),
flip_base AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    ACCOUNT_IDENTIFIER
  FROM flags_only
),
flip_lag AS (
  SELECT
    fb.*,
    LAG(synthetic_category) OVER (
      PARTITION BY ACCOUNT_IDENTIFIER
      ORDER BY month_end
    ) AS prev_category
  FROM flip_base fb
),
flip_flags AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    ACCOUNT_IDENTIFIER,
    prev_category,
    CASE WHEN prev_category IS NOT NULL AND prev_category <> synthetic_category THEN 1 ELSE 0 END AS flipped
  FROM flip_lag
)
SELECT
  'FLIPS' AS view_type,
  (SELECT latest_month_end FROM latest) AS latest_month_end,
  (SELECT MIN(month_end) FROM windowed) AS earliest_in_window,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  COUNT(DISTINCT ACCOUNT_IDENTIFIER) AS acct_cnt,
  SUM(flipped)                       AS flips,
  COUNT(*)                           AS obs_cnt,
  CASE WHEN COUNT(*)=0 THEN NULL ELSE ROUND(100.0 * SUM(flipped) / COUNT(*), 2) END AS flip_rate_pct
FROM flip_flags
GROUP BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
ORDER BY flip_rate_pct DESC NULLS LAST, flips DESC, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE;







/*=========================================================================*
  B) DIRECTORY (Latest ME, minimal fields from table)
 *=========================================================================*/
WITH
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
latest AS (SELECT MAX(month_end) AS latest_month_end FROM (SELECT DISTINCT month_end FROM base) d),
latest_only AS (SELECT * FROM base b JOIN latest l ON b.month_end = l.latest_month_end),

cat1 AS (
  SELECT lo.*,
         CASE
           WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
                ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
           THEN 1 ELSE 0 END AS cat1_flag
  FROM latest_only lo
),
cat2 AS (
  SELECT c1.*,
         CASE
           WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
            AND GL_ACCOUNT_CODE IN (
                 1041210,1142067,1042213,1042368,1042409,1042424,1042886,
                 1043008,1142048,1051872,1061833,1041211,1041344,1041364
               )
           THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
flags_only AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL END AS synthetic_category
  FROM c2
  WHERE (cat1_flag=1 OR cat2_flag=1)
)

SELECT
  'DIRECTORY' AS view_type,
  month_end,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  ACCOUNT_IDENTIFIER,
  exposure
FROM flags_only
ORDER BY
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  exposure DESC,
  ACCOUNT_IDENTIFIER;






/*=========================================================================*
  B) DIRECTORY (Latest ME). Set params below to filter; if NULLs, returns all.
 *=========================================================================*/
WITH
params AS (
  SELECT
    24::INT AS lookback_months,
    /* Set any/all of these to filter the directory */
    CAST(NULL AS VARCHAR(12))  AS p_category,                 -- 'Cat1','Cat2','Cat1+Cat2'
    CAST(NULL AS VARCHAR(100)) AS p_contract_source_system,   -- e.g. 'ALL'
    CAST(NULL AS INTEGER)      AS p_gl_account_code,          -- e.g. 1041210
    /* Optional: limit N (NULL = no limit) */
    CAST(NULL AS INTEGER)      AS p_topN_by_exposure
),
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    ACCTNBR,
    CUST_LINE_NBR,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure,
    PRODUCT_CODE,
    CUSTOMER_NBR,
    RISK_RATING
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
months AS (SELECT DISTINCT month_end FROM base),
latest AS (SELECT MAX(month_end) AS latest_month_end FROM months),
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON b.month_end = l.latest_month_end
),
cat1 AS (
  SELECT w.*,
         CASE
           WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
                ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
           THEN 1 ELSE 0 END AS cat1_flag
  FROM windowed w
),
cat2 AS (
  SELECT c1.*,
         CASE
           WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
            AND GL_ACCOUNT_CODE IN (
                 1041210,1142067,1042213,1042368,1042409,1042424,1042886,
                 1043008,1142048,1051872,1061833,1041211,1041344,1041364
               )
           THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
flags_only AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL END AS synthetic_category
  FROM c2
  WHERE (cat1_flag=1 OR cat2_flag=1)
),
filtered AS (
  SELECT *
  FROM flags_only f
  WHERE ( (SELECT p_category FROM params) IS NULL OR f.synthetic_category = (SELECT p_category FROM params) )
    AND ( (SELECT p_contract_source_system FROM params) IS NULL OR f.CONTRACT_SOURCE_SYSTEM = (SELECT p_contract_source_system FROM params) )
    AND ( (SELECT p_gl_account_code FROM params) IS NULL OR f.GL_ACCOUNT_CODE = (SELECT p_gl_account_code FROM params) )
),
ranked AS (
  SELECT
    f.*,
    ROW_NUMBER() OVER (ORDER BY exposure DESC, ACCOUNT_IDENTIFIER) AS rn
  FROM filtered f
)
SELECT
  'DIRECTORY' AS view_type,
  month_end,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  ACCOUNT_IDENTIFIER,
  ACCTNBR,
  CUST_LINE_NBR,
  CUSTOMER_NBR,
  PRODUCT_CODE,
  RISK_RATING,
  exposure
FROM ranked
WHERE ( (SELECT p_topN_by_exposure FROM params) IS NULL OR rn <= (SELECT p_topN_by_exposure FROM params) )
ORDER BY
  synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE, exposure DESC, ACCOUNT_IDENTIFIER;




/*=========================================================================*
  A) SNAPSHOT + TREND
 *=========================================================================*/
WITH
params AS (
  SELECT
    24::INT AS lookback_months
),
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
months AS (
  SELECT month_end,
         ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),
latest AS (SELECT MAX(month_end) AS latest_month_end FROM months),
windowed AS (
  SELECT b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_month_end, -((SELECT lookback_months FROM params) - 1))
),
cat1 AS (
  SELECT w.*,
         CASE
           WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
                ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
             OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
           THEN 1 ELSE 0 END AS cat1_flag
  FROM windowed w
),
cat2 AS (
  SELECT c1.*,
         CASE
           WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
            AND GL_ACCOUNT_CODE IN (
                 1041210,1142067,1042213,1042368,1042409,1042424,1042886,
                 1043008,1142048,1051872,1061833,1041211,1041344,1041364
               )
           THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT c2.*,
         CASE
           WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
           WHEN cat1_flag=1 THEN 'Cat1'
           WHEN cat2_flag=1 THEN 'Cat2'
           ELSE NULL END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (SELECT * FROM labeled WHERE synthetic_category IS NOT NULL),
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)                  AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                                     AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER)           AS accounts_flagged,
    SUM(exposure)                                AS exposure_sum,
    SUM(ABS(exposure))                           AS exposure_abs_sum,
    AVG(ABS(exposure))                           AS exposure_abs_avg
  FROM flags_only
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
m_latest AS (SELECT MAX(month_end) AS month_end FROM monthly_group),
m_prior  AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),
latest_per_group AS (
  SELECT g.* FROM monthly_group g JOIN m_latest ml ON g.month_end = ml.month_end
),
prior_per_group AS (
  SELECT g.* FROM monthly_group g JOIN m_prior mp ON g.month_end = mp.month_end
),
history_stats AS (
  SELECT
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)          AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                             AS hist_months,
    AVG(ABS(exposure_sum))               AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))       AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))               AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))               AS hist_max_abs_exposure
  FROM monthly_group g
  WHERE g.month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),
snapshot AS (
  SELECT
    'SNAPSHOT' AS view_type,
    lp.month_end,
    lp.synthetic_category,
    lp.CONTRACT_SOURCE_SYSTEM,
    lp.GL_ACCOUNT_CODE,
    lp.GL_ACCOUNT_DESCRIPTION,
    lp.rows_flagged,
    lp.accounts_flagged,
    lp.exposure_sum,
    lp.exposure_abs_sum,
    lp.exposure_abs_avg,
    (SELECT month_end FROM m_prior)                        AS prev_month_end,
    COALESCE(pp.exposure_sum, 0.0)                         AS prev_exposure_sum,
    (lp.exposure_sum - COALESCE(pp.exposure_sum, 0.0))     AS delta_exposure,
    CASE WHEN COALESCE(pp.exposure_sum, 0.0)=0 THEN NULL
         ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum,0.0) END
      AS pct_delta_exposure,
    hs.hist_months,
    hs.hist_avg_abs_exposure,
    hs.hist_std_abs_exposure,
    hs.hist_min_abs_exposure,
    hs.hist_max_abs_exposure,
    CASE WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
         ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure END
      AS zscore_abs,
    ABS(lp.exposure_sum) AS sort_key_exposure_abs
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category=lp.synthetic_category
   AND pp.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND pp.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
  LEFT JOIN history_stats hs
    ON hs.synthetic_category=lp.synthetic_category
   AND hs.CONTRACT_SOURCE_SYSTEM=lp.CONTRACT_SOURCE_SYSTEM
   AND hs.GL_ACCOUNT_CODE=lp.GL_ACCOUNT_CODE
),
trend AS (
  SELECT
    'TREND' AS view_type,
    g.month_end,
    g.synthetic_category,
    g.CONTRACT_SOURCE_SYSTEM,
    g.GL_ACCOUNT_CODE,
    g.GL_ACCOUNT_DESCRIPTION,
    g.rows_flagged,
    g.accounts_flagged,
    g.exposure_sum,
    g.exposure_abs_sum,
    g.exposure_abs_avg,
    CAST(NULL AS DATE)   AS prev_month_end,
    CAST(NULL AS FLOAT8) AS prev_exposure_sum,
    CAST(NULL AS FLOAT8) AS delta_exposure,
    CAST(NULL AS FLOAT8) AS pct_delta_exposure,
    CAST(NULL AS INTEGER)AS hist_months,
    CAST(NULL AS FLOAT8) AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8) AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8) AS zscore_abs,
    CAST(NULL AS FLOAT8) AS sort_key_exposure_abs
  FROM monthly_group g
)
SELECT *
FROM snapshot
UNION ALL
SELECT *
FROM trend
ORDER BY
  view_type,
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  sort_key_exposure_abs DESC;





AnomParms =
DATATABLE(
  "Param", STRING, "Value", DOUBLE,
  {
    -- Weights (sum ~ 1.00)
    {"W_Severity", 0.45},
    {"W_Move",     0.25},
    {"W_Miss",     0.20},
    {"W_Persist",  0.07},
    {"W_R2",       0.03},

    -- Thresholds / scales
    {"T_ResidualPct", 0.05},  -- 5% residual viewed as “large”
    {"T_MovePct",     0.05},  -- 5% of RC size viewed as “large” move
    {"R2_Good",       0.70},
    {"R2_Bad",        0.50},

    -- Exposure floor for normalization (only within the score)
    {"NormFloor", 1000000}    -- $1M, tune as needed
  }
)


AP(Param) :=
VAR p = SELECTEDVALUE( AnomParms[Param] )
RETURN CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = p )

AP_W_Severity := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "W_Severity")
AP_W_Move     := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "W_Move")
AP_W_Miss     := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "W_Miss")
AP_W_Persist  := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "W_Persist")
AP_W_R2       := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "W_R2")

AP_T_Residual := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "T_ResidualPct")
AP_T_Move     := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "T_MovePct")
AP_R2_Good    := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "R2_Good")
AP_R2_Bad     := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "R2_Bad")
AP_NormFloor  := CALCULATE( MAX(AnomParms[Value]), AnomParms[Param] = "NormFloor")


Composite Anomaly Score (0–100, LM) :=
VAR sev_01 =
    VAR s = [Severity (Weighted, Latest – RC)]
    RETURN IF( ISBLANK(s), 0, DIVIDE( s, 100.0 ) )                 -- 0..1

VAR miss_01 =
    VAR r = ABS( [Residual % (LM, per RC)] )                        -- 0..1..?
    VAR t = [AP_T_Residual]
    RETURN MIN( 1.0, DIVIDE( r, t ) )                               -- cap @1

VAR move_01 =
    VAR d      = ABS( [Exposure Δ MoM (per RC)] )                   -- $
    VAR size   = ABS( [Exposure (Latest)] )
    VAR floorN = [AP_NormFloor]
    VAR denom  = MAX( size, floorN )                                -- stabilize small RCs
    VAR ratio  = DIVIDE( d, denom )                                 -- 0..1..?
    VAR t      = [AP_T_Move]
    RETURN MIN( 1.0, DIVIDE( ratio, t ) )                           -- cap @1

VAR persist_01 =
    IF( [Bias Persistence (3M Same Sign)] = 1, 1.0, 0.0 )

VAR r2_penalty_01 =
    VAR r2 = [R2_By_Model]  -- or [R2 (LM, per RC)]
    VAR g  = [AP_R2_Good]
    VAR b  = [AP_R2_Bad]
    RETURN
        IF( ISBLANK(r2),
            0,
            IF( r2 >= g, 0,
                IF( r2 <= b, 1,
                    -- linear between good→bad
                    DIVIDE( g - r2, g - b )
                )
            )
        )

-- weights
VAR w_sev = [AP_W_Severity]
VAR w_mov = [AP_W_Move]
VAR w_mis = [AP_W_Miss]
VAR w_pst = [AP_W_Persist]
VAR w_r2  = [AP_W_R2]

-- base score 0..1
VAR score01 =
        w_sev * sev_01
      + w_mov * move_01
      + w_mis * miss_01
      + w_pst * persist_01
      + w_r2  * r2_penalty_01

-- monitorable gate (don’t inflate non-monitorables)
VAR mon = [Is Monitorable (LM, per RC)]  -- or your monitorable logic
RETURN
    IF( mon <> 1, BLANK(), ROUND( 100.0 * MIN( 1.0, MAX( 0.0, score01 ) ), 0 ) )



Anomaly Flag (LM) :=
VAR s = [Composite Anomaly Score (0–100, LM)]
RETURN IF( NOT ISBLANK(s) && s >= 80, 1 )      -- threshold you can change

Anomaly Rank (LM) :=
RANKX(
  ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
  [Composite Anomaly Score (0–100, LM)],
  ,
  DESC,
  Dense
)

# of Anomalous RCs (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Anomaly Flag (LM)] = 1
  )
)

Total Exposure in Anomalies (LM) :=
SUMX(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Anomaly Flag (LM)] = 1
  ),
  [Exposure (Latest)]
)

Avg Composite Score (Portfolio, LM) :=
AVERAGEX(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1
  ),
  [Composite Anomaly Score (0–100, LM)]
)








Page Title – Anomaly & Root Cause Diagnostics :=
"Anomaly & Root Cause Diagnostics — " &
FORMAT ( [LM Date (Selected)], "MMM yyyy" )








/* ===========================================================
   Unfunded Snapshot & Reconciliation (As of 2025-09-30)

   Sources:
     - CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED        (t)   [ACCTNBR, CUST_LINE_NBR, LoadDt]
     - CRDADMPRD.dbo.CREDITLINES_ALL_TOPSIDED        (c)   [CUST_LINE_NBR, SEC_UNFUNDED, FRB_UNFUNDED_AMT, LoadDt]
     - CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY          (m)   [LoadDate = 2025-09-30]
     - CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED          (u)   [LoadDate = 2025-09-30]

   Joins:
     t.CUST_LINE_NBR = c.CUST_LINE_NBR = m.CreditLineNumber = u.CreditLineNumber
     Dates aligned to 2025-09-30 (t.LoadDt, c.LoadDt, m.LoadDate, u.LoadDate)

   Compares three unfunded amounts:
     - c.SEC_UNFUNDED            (SEC view)
     - c.FRB_UNFUNDED_AMT        (FRB view)
     - u.SecUnfunded             (Calculated/analytics view)

   Notes:
     - Adjust @Tolerance if you want stricter/looser matching.
     - If any source can emit duplicates per credit line on the same date,
       we can add ROW_NUMBER() de-dupe—tell me and I’ll wire it in.
   =========================================================== */

DECLARE @AsOfDate    date = '2025-09-30';
DECLARE @Tolerance   decimal(18,4) = 0.01;   -- cents-level tolerance

WITH t AS (
    SELECT
        t.ACCTNBR,
        t.CUST_LINE_NBR,
        t.LoadDt
    FROM CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED AS t
    WHERE t.LoadDt = @AsOfDate
      AND t.ACCTNBR IN (
          '001100537841','001100538945','001100540103','001100540415','001100544570',
          '001100546406','001100551794','001100557218','001100561196','001100564232',
          '001100564442','001100564481','001100566659','001100566734','001100580705',
          '001100580708','001100583141','001100583633','001100583696','001100585703'
      )
),
c AS (
    SELECT
        c.CUST_LINE_NBR,
        c.LoadDt,
        c.SEC_UNFUNDED,
        c.FRB_UNFUNDED_AMT
    FROM CRDADMPRD.dbo.CREDITLINES_ALL_TOPSIDED AS c
    WHERE c.LoadDt = @AsOfDate
),
m AS (
    SELECT
        m.LoadDate,
        m.Cif,
        m.CreditLineNumber,
        m.ClientName,
        m.FormulaLine,
        m.RevolvingFlag,
        m.Rev_Status,
        m.CommitmentParticipationSold,
        m.GrossLineAmount,
        m.NetLineAmount,
        m.NetUtilized,
        m.GrossDisbursed,
        m.NetDisbursed
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY AS m
    WHERE m.LoadDate = @AsOfDate
),
u AS (
    SELECT
        u.LoadDate,
        u.CreditLineNumber,
        u.SecUnfunded
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED AS u
    WHERE u.LoadDate = @AsOfDate
)

SELECT
    -- Keys / identifiers
    t.ACCTNBR,
    t.CUST_LINE_NBR,
    @AsOfDate AS AsOfDate,

    -- CREDIT_LINE_MONTHLY attributes (for context)
    m.LoadDate                         AS CLM_LoadDate,
    m.Cif,
    m.CreditLineNumber,
    m.ClientName,
    m.FormulaLine,
    m.RevolvingFlag,
    m.Rev_Status,
    m.CommitmentParticipationSold,
    m.GrossLineAmount,
    m.NetLineAmount,
    m.NetUtilized,
    m.GrossDisbursed,
    m.NetDisbursed,

    -- Unfunded amounts (raw from their respective sources)
    c.SEC_UNFUNDED                     AS SEC_UNFUNDED_raw,
    c.FRB_UNFUNDED_AMT                 AS FRB_UNFUNDED_raw,
    u.SecUnfunded                      AS UFC_SEC_UNFUNDED_raw,

    -- Normalized amounts (converted for arithmetic)
    n.SEC_UNFUNDED,
    n.FRB_UNFUNDED,
    n.UFC_SEC_UNFUNDED,

    -- Pairwise differences
    v.Diff_UFC_minus_SEC,
    v.Diff_FRB_minus_SEC,
    v.Diff_UFC_minus_FRB,

    -- Match status with tolerance
    CASE
        WHEN n.SEC_UNFUNDED IS NULL OR n.FRB_UNFUNDED IS NULL OR n.UFC_SEC_UNFUNDED IS NULL
            THEN 'Missing'
        WHEN ABS(v.Diff_UFC_minus_SEC) <= @Tolerance
         AND ABS(v.Diff_FRB_minus_SEC) <= @Tolerance
         AND ABS(v.Diff_UFC_minus_FRB) <= @Tolerance
            THEN 'All 3 match'
        WHEN ABS(v.Diff_UFC_minus_SEC) <= @Tolerance
         AND ABS(v.Diff_FRB_minus_SEC) <= @Tolerance
            THEN 'SEC = FRB = UFC (by tol)'
        WHEN ABS(v.Diff_UFC_minus_SEC) <= @Tolerance
            THEN 'UFC matches SEC only'
        WHEN ABS(v.Diff_FRB_minus_SEC) <= @Tolerance
            THEN 'FRB matches SEC only'
        WHEN ABS(v.Diff_UFC_minus_FRB) <= @Tolerance
            THEN 'UFC matches FRB only'
        ELSE 'All differ'
    END AS Unfunded_Match_Status

FROM t
LEFT JOIN c
       ON c.CUST_LINE_NBR = t.CUST_LINE_NBR
      AND c.LoadDt        = @AsOfDate
LEFT JOIN m
       ON m.CreditLineNumber = t.CUST_LINE_NBR
      AND m.LoadDate         = @AsOfDate
LEFT JOIN u
       ON u.CreditLineNumber = t.CUST_LINE_NBR
      AND u.LoadDate         = @AsOfDate

-- Normalize values to DECIMAL once
CROSS APPLY (
    SELECT
        TRY_CONVERT(decimal(38,4), c.SEC_UNFUNDED)     AS SEC_UNFUNDED,
        TRY_CONVERT(decimal(38,4), c.FRB_UNFUNDED_AMT) AS FRB_UNFUNDED,
        TRY_CONVERT(decimal(38,4), u.SecUnfunded)      AS UFC_SEC_UNFUNDED
) AS n
-- Compute diffs in one place
CROSS APPLY (
    SELECT
        CASE WHEN n.UFC_SEC_UNFUNDED IS NULL OR n.SEC_UNFUNDED IS NULL
             THEN NULL ELSE n.UFC_SEC_UNFUNDED - n.SEC_UNFUNDED END AS Diff_UFC_minus_SEC,
        CASE WHEN n.FRB_UNFUNDED IS NULL OR n.SEC_UNFUNDED IS NULL
             THEN NULL ELSE n.FRB_UNFUNDED - n.SEC_UNFUNDED END     AS Diff_FRB_minus_SEC,
        CASE WHEN n.UFC_SEC_UNFUNDED IS NULL OR n.FRB_UNFUNDED IS NULL
             THEN NULL ELSE n.UFC_SEC_UNFUNDED - n.FRB_UNFUNDED END AS Diff_UFC_minus_FRB
) AS v
ORDER BY t.ACCTNBR, t.CUST_LINE_NBR;








/* ===========================================================
   Unfunded Snapshot & Reconciliation (As of 2025-09-30)
   Compares:
     - CDM.SEC_UNFUNDED                (t.SEC_UNFUNDED)
     - CDM.FRB_UNFUNDED_AMT            (t.FRB_UNFUNDED_AMT)
     - CALCULATED_UNFUNDED.SecUnfunded (u.SecUnfunded)
   =========================================================== */

DECLARE @AsOfDate date = '2025-09-30';
DECLARE @Tolerance decimal(10,4) = 0.01;  -- equality tolerance for money comparisons

WITH t AS (
    SELECT
        t.ACCTNBR,
        t.CUST_LINE_NBR,
        t.LoadDt,
        t.SEC_UNFUNDED,
        t.FRB_UNFUNDED_AMT
    FROM CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED AS t
    WHERE t.LoadDt = @AsOfDate
      AND t.ACCTNBR IN (
          '001100537841',
          '001100538945',
          '001100540103',
          '001100540415',
          '001100544570',
          '001100546406',
          '001100551794',
          '001100557218',
          '001100561196',
          '001100564232',
          '001100564442',
          '001100564481',
          '001100566659',
          '001100566734',
          '001100580705',
          '001100580708',
          '001100583141',
          '001100583633',
          '001100583696',
          '001100585703'
      )
),
m AS (
    SELECT
        m.LoadDate,
        m.Cif,
        m.CreditLineNumber,
        m.ClientName,
        m.FormulaLine,
        m.RevolvingFlag,
        m.Rev_Status,
        m.CommitmentParticipationSold,
        m.GrossLineAmount,
        m.NetLineAmount,
        m.NetUtilized,
        m.GrossDisbursed,
        m.NetDisbursed
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY AS m
    WHERE m.LoadDate = @AsOfDate
),
u AS (
    SELECT
        u.LoadDate,
        u.CreditLineNumber,
        u.SecUnfunded
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED AS u
    WHERE u.LoadDate = @AsOfDate
)

SELECT
    -- Keys / identifiers
    t.ACCTNBR,
    t.CUST_LINE_NBR,
    @AsOfDate AS AsOfDate,

    -- CREDIT_LINE_MONTHLY attributes
    m.LoadDate                         AS CLM_LoadDate,
    m.Cif,
    m.CreditLineNumber,
    m.ClientName,
    m.FormulaLine,
    m.RevolvingFlag,
    m.Rev_Status,
    m.CommitmentParticipationSold,
    m.GrossLineAmount,
    m.NetLineAmount,
    m.NetUtilized,
    m.GrossDisbursed,
    m.NetDisbursed,

    -- Unfunded amounts (raw)
    t.SEC_UNFUNDED                     AS CDM_SEC_UNFUNDED_raw,
    t.FRB_UNFUNDED_AMT                 AS CDM_FRB_UNFUNDED_raw,
    u.SecUnfunded                      AS UFC_SEC_UNFUNDED_raw,

    -- Unfunded amounts (normalized to DECIMAL for math)
    v.CDM_SEC_UNFUNDED,
    v.CDM_FRB_UNFUNDED,
    v.UFC_SEC_UNFUNDED,

    -- Pairwise differences (UFC vs CDM-SEC, FRB vs CDM-SEC, UFC vs FRB)
    v.Diff_UFC_minus_CDM_SEC,
    v.Diff_FRB_minus_CDM_SEC,
    v.Diff_UFC_minus_FRB,

    -- Match flags using tolerance
    CASE
        WHEN v.CDM_SEC_UNFUNDED IS NULL OR v.CDM_FRB_UNFUNDED IS NULL OR v.UFC_SEC_UNFUNDED IS NULL THEN 'Missing'
        WHEN ABS(v.Diff_UFC_minus_CDM_SEC) <= @Tolerance
         AND ABS(v.Diff_FRB_minus_CDM_SEC) <= @Tolerance
         AND ABS(v.Diff_UFC_minus_FRB)     <= @Tolerance THEN 'All 3 match'
        WHEN ABS(v.Diff_UFC_minus_CDM_SEC) <= @Tolerance
         AND ABS(v.Diff_FRB_minus_CDM_SEC) <= @Tolerance THEN 'CDM-SEC = UFC = FRB (by tol)'
        WHEN ABS(v.Diff_UFC_minus_CDM_SEC) <= @Tolerance THEN 'UFC matches CDM-SEC only'
        WHEN ABS(v.Diff_FRB_minus_CDM_SEC) <= @Tolerance THEN 'FRB matches CDM-SEC only'
        WHEN ABS(v.Diff_UFC_minus_FRB)     <= @Tolerance THEN 'UFC matches FRB only'
        ELSE 'All differ'
    END                                       AS Unfunded_Match_Status

FROM t
LEFT JOIN m
    ON m.CreditLineNumber = t.CUST_LINE_NBR
   AND m.LoadDate = @AsOfDate
LEFT JOIN u
    ON u.CreditLineNumber = t.CUST_LINE_NBR
   AND u.LoadDate = @AsOfDate

-- Normalize values and compute diffs in one place
CROSS APPLY (
    SELECT
        TRY_CONVERT(decimal(38,4), t.SEC_UNFUNDED)     AS CDM_SEC_UNFUNDED,
        TRY_CONVERT(decimal(38,4), t.FRB_UNFUNDED_AMT) AS CDM_FRB_UNFUNDED,
        TRY_CONVERT(decimal(38,4), u.SecUnfunded)      AS UFC_SEC_UNFUNDED
) n
CROSS APPLY (
    SELECT
        n.CDM_SEC_UNFUNDED                                    AS CDM_SEC_UNFUNDED,
        n.CDM_FRB_UNFUNDED                                    AS CDM_FRB_UNFUNDED,
        n.UFC_SEC_UNFUNDED                                    AS UFC_SEC_UNFUNDED,
        CASE WHEN n.UFC_SEC_UNFUNDED IS NULL OR n.CDM_SEC_UNFUNDED IS NULL
             THEN NULL
             ELSE n.UFC_SEC_UNFUNDED - n.CDM_SEC_UNFUNDED END AS Diff_UFC_minus_CDM_SEC,
        CASE WHEN n.CDM_FRB_UNFUNDED IS NULL OR n.CDM_SEC_UNFUNDED IS NULL
             THEN NULL
             ELSE n.CDM_FRB_UNFUNDED - n.CDM_SEC_UNFUNDED END AS Diff_FRB_minus_CDM_SEC,
        CASE WHEN n.UFC_SEC_UNFUNDED IS NULL OR n.CDM_FRB_UNFUNDED IS NULL
             THEN NULL
             ELSE n.UFC_SEC_UNFUNDED - n.CDM_FRB_UNFUNDED END AS Diff_UFC_minus_FRB
) v
ORDER BY t.ACCTNBR, t.CUST_LINE_NBR;







/* ============================================
   Unfunded Snapshot (As of 2025-09-30)
   - Filters TOPSIDED to your ACCTNBR list AND LoadDt = '2025-09-30'
   - Joins to CRDLMTUFCALC tables by CreditLineNumber=CUST_LINE_NBR
   - Aligns dates: LoadDt / LoadDate = '2025-09-30'
   ============================================ */

DECLARE @AsOfDate date = '2025-09-30';

WITH t AS (
    SELECT
        t.ACCTNBR,
        t.CUST_LINE_NBR,
        t.LoadDt
    FROM CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED AS t
    WHERE t.LoadDt = @AsOfDate
      AND t.ACCTNBR IN (
          '001100537841',
          '001100538945',
          '001100540103',
          '001100540415',
          '001100544570',
          '001100546406',
          '001100551794',
          '001100557218',
          '001100561196',
          '001100564232',
          '001100564442',
          '001100564481',
          '001100566659',
          '001100566734',
          '001100580705',
          '001100580708',
          '001100583141',
          '001100583633',
          '001100583696',
          '001100585703'
      )
),
m AS (
    SELECT
        m.LoadDate,
        m.Cif,
        m.CreditLineNumber,
        m.ClientName,
        m.FormulaLine,
        m.RevolvingFlag,
        m.Rev_Status,
        m.CommitmentParticipationSold,
        m.GrossLineAmount,
        m.NetLineAmount,
        m.NetUtilized,
        m.GrossDisbursed,
        m.NetDisbursed
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY AS m
    WHERE m.LoadDate = @AsOfDate
),
u AS (
    SELECT
        u.LoadDate,
        u.CreditLineNumber,
        u.SecUnfunded
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED AS u
    WHERE u.LoadDate = @AsOfDate
)

SELECT
    -- Keys / identifiers
    t.ACCTNBR,
    t.CUST_LINE_NBR,
    @AsOfDate AS AsOfDate,

    -- CREDIT_LINE_MONTHLY attributes
    m.LoadDate                         AS CLM_LoadDate,
    m.Cif,
    m.CreditLineNumber,
    m.ClientName,
    m.FormulaLine,
    m.RevolvingFlag,
    m.Rev_Status,
    m.CommitmentParticipationSold,
    m.GrossLineAmount,
    m.NetLineAmount,
    m.NetUtilized,
    m.GrossDisbursed,
    m.NetDisbursed,

    -- CALCULATED_UNFUNDED attribute
    u.SecUnfunded

FROM t
LEFT JOIN m
    ON m.CreditLineNumber = t.CUST_LINE_NBR
   AND m.LoadDate = @AsOfDate
LEFT JOIN u
    ON u.CreditLineNumber = t.CUST_LINE_NBR
   AND u.LoadDate = @AsOfDate
ORDER BY t.ACCTNBR, t.CUST_LINE_NBR;






001100537841
001100538945
001100540103
001100540415
001100544570
001100546406
001100551794
001100557218
001100561196
001100564232
001100564442
001100564481
001100566659
001100566734
001100580705
001100580708
001100583141
001100583633
001100583696
001100585703


LoadDate
Cif
CreditLineNumber
ClientName
FormulaLine
RevolvingFlag
Rev_Status
CommitmentParticipationSold
GrossLineAmount
NetLineAmount
NetUtilized
GrossDisbursed
NetDisbursed
SecUnfunded








/* ============================================
   Latest-Month-End Unfunded Snapshot by ACCTNBR
   Sources:
     - CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED       (alias: t)
     - CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED         (alias: u)
     - CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY         (alias: m)
   Joins:
     t.CUST_LINE_NBR = u.CREDITLINENUMBER = m.CREDITLINENUMBER
     And aligned on the same month-end date column(s) you specify
   TODOs:
     1) Replace {{UFC_DATE_COL}} with the date column in CALCULATED_UNFUNDED
     2) Replace {{CLM_DATE_COL}} with the date column in CREDIT_LINE_MONTHLY
     3) Replace /* …attributes… */ with the fields you want from u and m
     4) Put your ACCTNBR list in the IN (…) filter below
   ============================================ */

-- Option A (recommended): compute a shared @AsOfDate that exists in BOTH tables.
DECLARE @AsOfDate date;

;WITH maxes AS (
    SELECT
        (SELECT MAX({{UFC_DATE_COL}}) FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED) AS max_u,
        (SELECT MAX({{CLM_DATE_COL}}) FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY) AS max_m
)
SELECT
    @AsOfDate = CASE WHEN max_u <= max_m THEN max_u ELSE max_m END
FROM maxes;

-- -- Option B: force to the last completed calendar month (uncomment if you prefer)
-- DECLARE @AsOfDate date = EOMONTH(GETDATE(), -1);

WITH
-- 1) Seed population from TOPSIDED filtered by ACCTNBR list
t AS (
    SELECT
        t.ACCTNBR,
        t.CUST_LINE_NBR
    FROM CRDADMPRD.dbo.CDM_INSTRUMENTS_TOPSIDED AS t
    WHERE t.ACCTNBR IN (
        /* TODO: paste your ACCTNBR values here, e.g. '12345','67890',... */
    )
),

-- 2) One-row-per-credit-line snapshot from CALCULATED_UNFUNDED at @AsOfDate
u_raw AS (
    SELECT
        u.CREDITLINENUMBER,
        u.{{UFC_DATE_COL}}      AS as_of_date,
        /* TODO: select attributes you want from CALCULATED_UNFUNDED, e.g.:
           u.UnfundedCommittedAmount,
           u.AvailableToDraw,
           u.FacilityRiskRating,
           u.UtilizationPct,
        */
        ROW_NUMBER() OVER (
            PARTITION BY u.CREDITLINENUMBER, u.{{UFC_DATE_COL}}
            ORDER BY u.CREDITLINENUMBER
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED AS u
    WHERE u.{{UFC_DATE_COL}} = @AsOfDate
),
u1 AS (
    SELECT *
    FROM u_raw
    WHERE rn = 1
),

-- 3) One-row-per-credit-line snapshot from CREDIT_LINE_MONTHLY at @AsOfDate
m_raw AS (
    SELECT
        m.CREDITLINENUMBER,
        m.{{CLM_DATE_COL}}       AS as_of_date,
        /* TODO: select attributes you want from CREDIT_LINE_MONTHLY, e.g.:
           m.TotalCommitment,
           m.OutstandingBalance,
           m.InterestRate,
           m.CovenantStatus,
        */
        ROW_NUMBER() OVER (
            PARTITION BY m.CREDITLINENUMBER, m.{{CLM_DATE_COL}}
            ORDER BY m.CREDITLINENUMBER
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY AS m
    WHERE m.{{CLM_DATE_COL}} = @AsOfDate
),
m1 AS (
    SELECT *
    FROM m_raw
    WHERE rn = 1
)

-- 4) Final join: preserve only the TOPSIDED population, enrich from both tables
SELECT
    t.ACCTNBR,
    t.CUST_LINE_NBR,
    @AsOfDate                      AS AsOfDate,
    -- Attributes from CALCULATED_UNFUNDED:
    /* e.g. u1.UnfundedCommittedAmount, u1.AvailableToDraw, u1.FacilityRiskRating, u1.UtilizationPct, */
    -- Attributes from CREDIT_LINE_MONTHLY:
    /* e.g. m1.TotalCommitment, m1.OutstandingBalance, m1.InterestRate, m1.CovenantStatus */
    u1.* EXCEPT (CREDITLINENUMBER, as_of_date, rn),   -- remove keys/housekeeping if on SQL 2022+; else list attrs explicitly
    m1.* EXCEPT (CREDITLINENUMBER, as_of_date, rn)    -- same note as above
FROM t
LEFT JOIN u1
    ON u1.CREDITLINENUMBER = t.CUST_LINE_NBR
LEFT JOIN m1
    ON m1.CREDITLINENUMBER = t.CUST_LINE_NBR;







-- ===== Synthetic GL×System Aggregates: Latest Snapshot + History Trend =====
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
-- Filters: GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
-- Categories:
--   Cat1: CONTRACT_SOURCE_SYSTEM in list OR like '%EXCPTN%'
--   Cat2: GL_ACCOUNT_CODE in list AND CONTRACT_SOURCE_SYSTEM = 'ALL'
-- Output contains two view types in one set:
--   - SNAPSHOT: one row per (Category × CSS × GL), latest vs prior month + history stats
--   - TREND:    monthly time series for last N months at same grain (small & chart-ready)

WITH
/* -------- Parameters -------- */
params AS (
  SELECT
    24::INT    AS lookback_months  -- set to 12/24 as you prefer
),

/* -------- Base universe (Total Loans only) -------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* -------- Months & window -------- */
months AS (
  SELECT month_end,
         ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),
latest AS (
  SELECT MAX(month_end) AS latest_month_end FROM months
),
windowed AS (
  SELECT
    b.*
  FROM base b
  JOIN latest l ON 1=1
  WHERE b.month_end >= ADD_MONTHS(l.latest_month_end, -((SELECT lookback_months FROM params) - 1))
),

/* -------- Category flags -------- */
cat1 AS (
  SELECT
    w.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag
  FROM windowed w
),
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT *
  FROM labeled
  WHERE synthetic_category IS NOT NULL
),

/* -------- Monthly aggregates at GL × CSS × Category -------- */
monthly_group AS (
  SELECT
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)                  AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                                     AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER)           AS accounts_flagged,
    SUM(exposure)                                AS exposure_sum,
    SUM(ABS(exposure))                           AS exposure_abs_sum,
    AVG(ABS(exposure))                           AS exposure_abs_avg
  FROM flags_only
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),

/* -------- Identify latest & prior month for joins -------- */
m_latest AS (
  SELECT MAX(month_end) AS month_end FROM monthly_group
),
m_prior AS (
  SELECT MAX(month_end) AS month_end
  FROM monthly_group
  WHERE month_end < (SELECT month_end FROM m_latest)
),

/* -------- Pivot latest and prior per group -------- */
latest_per_group AS (
  SELECT g.*
  FROM monthly_group g
  JOIN m_latest ml ON g.month_end = ml.month_end
),
prior_per_group AS (
  SELECT g.*
  FROM monthly_group g
  JOIN m_prior mp ON g.month_end = mp.month_end
),

/* -------- History stats per group (excluding latest) -------- */
history_stats AS (
  SELECT
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)                            AS GL_ACCOUNT_DESCRIPTION,
    COUNT(*)                                               AS hist_months,
    AVG(ABS(exposure_sum))                                 AS hist_avg_abs_exposure,
    STDDEV_SAMP(ABS(exposure_sum))                         AS hist_std_abs_exposure,
    MIN(ABS(exposure_sum))                                 AS hist_min_abs_exposure,
    MAX(ABS(exposure_sum))                                 AS hist_max_abs_exposure
  FROM monthly_group g
  WHERE g.month_end < (SELECT month_end FROM m_latest)
  GROUP BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
),

/* -------- SNAPSHOT rows: latest vs prior + stats -------- */
snapshot AS (
  SELECT
    'SNAPSHOT'                                            AS view_type,
    lp.month_end                                          AS month_end,           -- latest month
    lp.synthetic_category,
    lp.CONTRACT_SOURCE_SYSTEM,
    lp.GL_ACCOUNT_CODE,
    lp.GL_ACCOUNT_DESCRIPTION,
    lp.rows_flagged                                       AS rows_flagged,
    lp.accounts_flagged                                   AS accounts_flagged,
    lp.exposure_sum                                       AS exposure_sum,
    lp.exposure_abs_sum                                   AS exposure_abs_sum,
    lp.exposure_abs_avg                                   AS exposure_abs_avg,

    /* prior month info (may be NULL if not present) */
    (SELECT month_end FROM m_prior)                        AS prev_month_end,
    COALESCE(pp.exposure_sum, 0.0)                         AS prev_exposure_sum,
    (lp.exposure_sum - COALESCE(pp.exposure_sum, 0.0))     AS delta_exposure,
    CASE
      WHEN COALESCE(pp.exposure_sum, 0.0) = 0 THEN NULL
      ELSE (lp.exposure_sum - pp.exposure_sum) / NULLIF(pp.exposure_sum, 0.0)
    END                                                   AS pct_delta_exposure,

    hs.hist_months,
    hs.hist_avg_abs_exposure,
    hs.hist_std_abs_exposure,
    hs.hist_min_abs_exposure,
    hs.hist_max_abs_exposure,
    CASE
      WHEN COALESCE(hs.hist_std_abs_exposure,0)=0 THEN NULL
      ELSE (ABS(lp.exposure_sum) - hs.hist_avg_abs_exposure) / hs.hist_std_abs_exposure
    END                                                   AS zscore_abs,

    ABS(lp.exposure_sum)                                  AS sort_key_exposure_abs
  FROM latest_per_group lp
  LEFT JOIN prior_per_group pp
    ON pp.synthetic_category     = lp.synthetic_category
   AND pp.CONTRACT_SOURCE_SYSTEM = lp.CONTRACT_SOURCE_SYSTEM
   AND pp.GL_ACCOUNT_CODE        = lp.GL_ACCOUNT_CODE
  LEFT JOIN history_stats hs
    ON hs.synthetic_category     = lp.synthetic_category
   AND hs.CONTRACT_SOURCE_SYSTEM = lp.CONTRACT_SOURCE_SYSTEM
   AND hs.GL_ACCOUNT_CODE        = lp.GL_ACCOUNT_CODE
),

/* -------- TREND rows: monthly series at same grain (last N months) -------- */
trend AS (
  SELECT
    'TREND'                          AS view_type,
    g.month_end,
    g.synthetic_category,
    g.CONTRACT_SOURCE_SYSTEM,
    g.GL_ACCOUNT_CODE,
    g.GL_ACCOUNT_DESCRIPTION,
    g.rows_flagged,
    g.accounts_flagged,
    g.exposure_sum,
    g.exposure_abs_sum,
    g.exposure_abs_avg,

    /* snapshot-only columns set NULL for schema alignment */
    CAST(NULL AS DATE)               AS prev_month_end,
    CAST(NULL AS FLOAT8)             AS prev_exposure_sum,
    CAST(NULL AS FLOAT8)             AS delta_exposure,
    CAST(NULL AS FLOAT8)             AS pct_delta_exposure,
    CAST(NULL AS INTEGER)            AS hist_months,
    CAST(NULL AS FLOAT8)             AS hist_avg_abs_exposure,
    CAST(NULL AS FLOAT8)             AS hist_std_abs_exposure,
    CAST(NULL AS FLOAT8)             AS hist_min_abs_exposure,
    CAST(NULL AS FLOAT8)             AS hist_max_abs_exposure,
    CAST(NULL AS FLOAT8)             AS zscore_abs,

    CAST(NULL AS FLOAT8)             AS sort_key_exposure_abs
  FROM monthly_group g
)

/* -------- Final union (two small, analysis-ready tables in one) -------- */
SELECT *
FROM snapshot
UNION ALL
SELECT *
FROM trend
ORDER BY
  view_type,                 -- 'SNAPSHOT' then 'TREND' alphabetically
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  sort_key_exposure_abs DESC;








-- ===== Synthetic DETAIL (Top-N per group for latest ME) + LATEST SUMMARY + HISTORY SUMMARY =====
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
-- Filters: GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
-- Categories:
--   Cat1: CONTRACT_SOURCE_SYSTEM in list OR like '%EXCPTN%'
--   Cat2: GL_ACCOUNT_CODE in list AND CONTRACT_SOURCE_SYSTEM = 'ALL'

WITH
/* -------- Parameters -------- */
params AS (
  SELECT
    10000::INT   AS top_n_per_group,     -- cap per (category × CSS × GL) for latest ME
    0::FLOAT8    AS min_abs_exposure     -- optional floor for detail (e.g., 25000); keep 0 to disable
),

/* -------- Base universe -------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8  AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* -------- Latest month-end -------- */
months AS (
  SELECT month_end,
         ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),
latest_month AS (
  SELECT month_end FROM months WHERE rn = 1
),

/* -------- Category flags -------- */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag
  FROM base b
),
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT * FROM labeled WHERE synthetic_category IS NOT NULL
),

/* -------- DETAIL (latest ME): Top-N per (category × CSS × GL) by |exposure| -------- */
detail_pool AS (
  SELECT f.*
  FROM flags_only f
  WHERE f.month_end = (SELECT month_end FROM latest_month)
    AND ABS(f.exposure) >= (SELECT min_abs_exposure FROM params)
),
detail_ranked AS (
  SELECT
    detail_pool.*,
    ROW_NUMBER() OVER (
      PARTITION BY synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
      ORDER BY ABS(exposure) DESC, ACCOUNT_IDENTIFIER
    ) AS rn_group
  FROM detail_pool
),
detail_rows AS (
  SELECT
    'DETAIL'                         AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    ACCOUNT_IDENTIFIER,
    exposure,
    CAST(NULL AS INTEGER)            AS rows_flagged,
    CAST(NULL AS INTEGER)            AS accounts_flagged,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_avg,
    ABS(exposure)                    AS sort_key_exposure_abs
  FROM detail_ranked
  WHERE rn_group <= (SELECT top_n_per_group FROM params)
),

/* -------- LATEST MONTH SUMMARY (same latest ME, aggregated) -------- */
latest_summary AS (
  SELECT
    'LATEST_SUMMARY'                 AS view_type,
    f.month_end,
    f.synthetic_category,
    f.CONTRACT_SOURCE_SYSTEM,
    f.GL_ACCOUNT_CODE,
    MAX(f.GL_ACCOUNT_DESCRIPTION)    AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT f.ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(f.exposure)                  AS exposure_sum,
    SUM(ABS(f.exposure))             AS exposure_abs_sum,
    AVG(ABS(f.exposure))             AS exposure_abs_avg,
    CAST(NULL AS FLOAT8)             AS sort_key_exposure_abs
  FROM flags_only f
  WHERE f.month_end = (SELECT month_end FROM latest_month)
  GROUP BY f.month_end, f.synthetic_category, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_CODE
),

/* -------- HISTORY SUMMARY (all months before latest) -------- */
history_summary AS (
  SELECT
    'HISTORY_SUMMARY'                AS view_type,
    f.month_end,
    f.synthetic_category,
    f.CONTRACT_SOURCE_SYSTEM,
    f.GL_ACCOUNT_CODE,
    MAX(f.GL_ACCOUNT_DESCRIPTION)    AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT f.ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(f.exposure)                  AS exposure_sum,
    SUM(ABS(f.exposure))             AS exposure_abs_sum,
    AVG(ABS(f.exposure))             AS exposure_abs_avg,
    CAST(NULL AS FLOAT8)             AS sort_key_exposure_abs
  FROM flags_only f
  WHERE f.month_end < (SELECT month_end FROM latest_month)
  GROUP BY f.month_end, f.synthetic_category, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_CODE
)

/* -------- Final UNION + valid ORDER BY -------- */
SELECT * FROM detail_rows
UNION ALL
SELECT * FROM latest_summary
UNION ALL
SELECT * FROM history_summary
ORDER BY
  view_type,               -- Alphabetical: DETAIL, HISTORY_SUMMARY, LATEST_SUMMARY (adjust if desired)
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  sort_key_exposure_abs DESC,
  ACCOUNT_IDENTIFIER;





-- ===== Synthetic DETAIL (latest ME only) + SUMMARY (all prior history) =====
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
-- Filters: GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
-- Categories:
--   Cat1: CONTRACT_SOURCE_SYSTEM in list OR like '%EXCPTN%'
--   Cat2: GL_ACCOUNT_CODE in list AND CONTRACT_SOURCE_SYSTEM = 'ALL'
-- No tables, no temp tables.

WITH
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)              AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8  AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
months AS (
  SELECT
    month_end,
    ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),
-- Cat1: CSS in list OR like '%EXCPTN%' (case-insensitive)
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag
  FROM base b
),
-- Cat2: GL in list AND CSS = 'ALL'
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT *
  FROM labeled
  WHERE synthetic_category IS NOT NULL
),
with_rank AS (
  SELECT f.*, m.rn
  FROM flags_only f
  JOIN months m ON m.month_end = f.month_end
),

/* -------- DETAIL: latest month-end only (row-level) -------- */
detail_rows AS (
  SELECT
    'DETAIL'                         AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    ACCOUNT_IDENTIFIER,
    exposure,
    CAST(NULL AS INTEGER)            AS rows_flagged,
    CAST(NULL AS INTEGER)            AS accounts_flagged,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_avg,
    ABS(exposure)                    AS sort_key_exposure_abs
  FROM with_rank
  WHERE rn = 1
),

/* -------- SUMMARY: all PRIOR months (grouped) -------- */
summary_rows AS (
  SELECT
    'SUMMARY'                        AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)      AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(exposure)                    AS exposure_sum,
    SUM(ABS(exposure))               AS exposure_abs_sum,
    AVG(ABS(exposure))               AS exposure_abs_avg,
    CAST(NULL AS FLOAT8)             AS sort_key_exposure_abs
  FROM with_rank
  WHERE rn > 1
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* -------- Final UNION + valid ORDER BY (only selected columns) -------- */
SELECT *
FROM detail_rows
UNION ALL
SELECT *
FROM summary_rows
ORDER BY
  view_type,               -- 'DETAIL' sorts before 'SUMMARY' alphabetically
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  sort_key_exposure_abs DESC,
  ACCOUNT_IDENTIFIER;






-- ===== Synthetic Detail (latest 2 month-ends) + Historical Summary =====
-- Source: V_SECURE_PORTFOLIO_DETAIL_LOANHUB
-- No temp/tables; includes GL_ACCOUNT_DESCRIPTION; no ACCOUNT_DESCRIPTION.
-- =======================================================================

WITH
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)             AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE, 0.0)::FLOAT8 AS exposure
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),
months AS (
  SELECT
    month_end,
    ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),
/* Cat1: CSS in list OR like '%EXCPTN%' */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag
  FROM base b
),
/* Cat2: GL in list AND CSS='ALL' */
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag = 1 AND cat2_flag = 1 THEN 'Cat1+Cat2'
      WHEN cat1_flag = 1 THEN 'Cat1'
      WHEN cat2_flag = 1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT *
  FROM labeled
  WHERE synthetic_category IS NOT NULL
),
with_rank AS (
  SELECT f.*, m.rn
  FROM flags_only f
  JOIN months m ON m.month_end = f.month_end
),

/* -------- DETAIL: latest 2 month-ends (row-level) -------- */
detail_rows AS (
  SELECT
    'DETAIL'                         AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    ACCOUNT_IDENTIFIER,
    exposure,
    /* summary fields null for detail */
    CAST(NULL AS INTEGER)            AS rows_flagged,
    CAST(NULL AS INTEGER)            AS accounts_flagged,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_avg,
    /* include a sortable key that IS in the select list */
    ABS(exposure)                    AS sort_key_exposure_abs
  FROM with_rank
  WHERE rn <= 2
),

/* -------- SUMMARY: all older months (grouped) -------- */
summary_rows AS (
  SELECT
    'SUMMARY'                        AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)      AS GL_ACCOUNT_DESCRIPTION,
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(exposure)                    AS exposure_sum,
    SUM(ABS(exposure))               AS exposure_abs_sum,
    AVG(ABS(exposure))               AS exposure_abs_avg,
    CAST(NULL AS FLOAT8)             AS sort_key_exposure_abs
  FROM with_rank
  WHERE rn > 2
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* -------- Final UNION + valid ORDER BY on returned columns -------- */
SELECT *
FROM detail_rows
UNION ALL
SELECT *
FROM summary_rows
ORDER BY
  view_type,                 -- DETAIL first if you prefer: change to CASE or sort by value
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  sort_key_exposure_abs DESC,
  ACCOUNT_IDENTIFIER;










-- ================== Synthetic Detail (latest 2 ME) + History Summary ==================
-- No tables, no temp tables. Cat1/Cat2 logic + GL_ACCOUNT_HIER_LEVEL_4='Total Loans'.
-- DETAIL: latest two month-ends (row-level, includes GL_ACCOUNT_DESCRIPTION)
-- SUMMARY: older months grouped (tiny result set for Excel/PBI)
-- ================================================================================

WITH
/* ---- Base filtered to Total Loans ------------------------------------------------ */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure,
    ACCOUNT_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---- Month ranking to get latest two month-ends --------------------------------- */
months AS (
  SELECT
    month_end,
    ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),

/* ---- Categories ----------------------------------------------------------------- */
/* Cat 1: CSS in list OR like '%EXCPTN%' (case-insensitive) */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0 END AS cat1_flag
  FROM base b
),
/* Cat 2: GL in list AND CSS='ALL' */
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT l.*
  FROM labeled l
  WHERE l.synthetic_category IS NOT NULL
),

/* ---- Split into DETAIL (latest 2 ME) vs SUMMARY (older) ------------------------- */
with_rank AS (
  SELECT f.*, m.rn
  FROM flags_only f
  JOIN months m ON m.month_end = f.month_end
),

detail_rows AS (
  SELECT
    'DETAIL'                         AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    ACCOUNT_IDENTIFIER,
    exposure,
    ACCOUNT_DESCRIPTION,
    /* summary fields null for detail */
    CAST(NULL AS INTEGER)            AS rows_flagged,
    CAST(NULL AS INTEGER)            AS accounts_flagged,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_avg
  FROM with_rank
  WHERE rn <= 2   -- latest two month-ends
),

summary_rows AS (
  SELECT
    'SUMMARY'                        AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)      AS GL_ACCOUNT_DESCRIPTION, -- optional
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    CAST(NULL AS VARCHAR(4000))      AS ACCOUNT_DESCRIPTION,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(exposure)                    AS exposure_sum,
    SUM(ABS(exposure))               AS exposure_abs_sum,
    AVG(ABS(exposure))               AS exposure_abs_avg
  FROM with_rank
  WHERE rn > 2   -- all older months summarized
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* ---- Final union --------------------------------------------------------------- */
SELECT *
FROM detail_rows
UNION ALL
SELECT *
FROM summary_rows
ORDER BY
  CASE view_type WHEN 'DETAIL' THEN 0 ELSE 1 END,
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  -- for DETAIL, show largest exposures first
  CASE WHEN view_type='DETAIL' THEN ABS(exposure) END DESC NULLS LAST,
  ACCOUNT_IDENTIFIER;





-- ===================== Synthetic Identification (Cat1 / Cat2) =====================
-- No tables, no temp tables. Edit lists below as needed.
-- Filters to GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' and returns readable fields.
-- ================================================================================

WITH
/* -------- Optional window (edit or remove) ------------------------------------ */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_month_end,
    CURRENT_DATE::DATE                  AS max_month_end
),

/* -------- Base pulled from your monthly view ---------------------------------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,                       -- for readability
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure,
    ACCOUNT_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME   -- swap to your canonical monthly view if different
  WHERE CAST(END_OF_MONTH_DATE AS DATE) BETWEEN (SELECT min_month_end FROM params)
                                            AND   (SELECT max_month_end FROM params)
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* -------- Category flags ------------------------------------------------------- */
/* Cat 1: CONTRACT_SOURCE_SYSTEM in list OR like '%EXCPTN%' */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN (
        'FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN'
      )
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag,
    /* Reason text for readability */
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%' THEN 'CSS like %EXCPTN%'
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN (
        'FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN'
      ) THEN 'CSS explicit list'
      ELSE NULL
    END AS cat1_reason
  FROM base b
),

/* Cat 2: GL_ACCOUNT_CODE in list AND CONTRACT_SOURCE_SYSTEM = 'ALL' */
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 'GL in Cat2 list with CSS=ALL'
      ELSE NULL
    END AS cat2_reason
  FROM cat1 c1
)

/* -------- Final output --------------------------------------------------------- */
SELECT
  month_end,
  ACCOUNT_IDENTIFIER,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  exposure,
  /* Synthetic category label */
  CASE
    WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
    WHEN cat1_flag=1 THEN 'Cat1'
    WHEN cat2_flag=1 THEN 'Cat2'
    ELSE NULL
  END AS synthetic_category,
  /* Human-readable reasons (only where applicable) */
  cat1_reason,
  cat2_reason
FROM cat2
WHERE (cat1_flag=1 OR cat2_flag=1)
ORDER BY month_end DESC, synthetic_category, ABS(exposure) DESC, ACCOUNT_IDENTIFIER;










FRDS_EXCPTN
SYN
ALL
GL
LJ
ADJ
LNIQ01-EXCPTN
INFL05-EXCPTN

1041210
1142067
1042213
1042368
1042409
1042424
1042886
1043008
1142048
1051872
1061833
1041211
1041344
1041364








-- ========================= Synthetic Tracking (CTE-only) =========================
-- Purpose: Flag synthetic/internal/plug-like records without creating tables/views.
-- How to use:
--   1) Edit the RULES_* blocks below to match your environment (CSS values, GL LIKEs, text markers).
--   2) Optional: set date filter in [params].
--   3) Run. Output returns one row per account_identifier x month with a risk_score and reasons.
-- ================================================================================

WITH
/* --------------------------- PARAMETERS --------------------------------------- */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_month_end,  -- rolling window start
    CURRENT_DATE::DATE                AS max_month_end
),

/* --------------------------- RULES (edit here) --------------------------------
   Keep all rules in CTEs so no tables/views are required.
   You can also externalize these to Power BI (Enter Data) and merge them instead.
---------------------------------------------------------------------------------*/
rules_css AS (
  -- CONTRACT_SOURCE_SYSTEM patterns: exact or LIKE
  -- match_type: 'EQ' or 'LIKE'
  SELECT * FROM (
    VALUES
      ('FRDS_EXCPTN','EQ','Exception feed (synthetic)', 40, TRUE),
      ('FRDS-EXCPTN','EQ','Exception feed (synthetic)', 40, TRUE),
      ('TOPSIDE',    'EQ','Topside adjustment',         50, TRUE),
      ('MANUAL',     'EQ','Manual journal/plug',        40, TRUE),
      ('ALL',        'EQ','Consolidated host (use GL)', 10, TRUE),
      ('ICC%',     'LIKE','Intercompany/clearing',      40, TRUE)
  ) AS t(css_pattern, match_type, reason, weight, is_active)
),
rules_gl AS (
  -- GL LIKE patterns (replace with your true suspense/clearing/due-to ranges)
  SELECT * FROM (
    VALUES
      ('2999%', 'Suspense/Clearing',                 45, TRUE),
      ('2199%', 'Due To/Due From',                   40, TRUE),
      ('1399%', 'Plug/Unassigned asset',             35, TRUE),
      ('1041%', 'Loan GL aggregate (check synthetic)', 25, TRUE)
  ) AS t(gl_like, reason, weight, is_active)
),
rules_text AS (
  -- DESCRIPTION markers; case-insensitive match via UPPER()
  -- field_name currently supports ACCOUNT_DESCRIPTION (extend below if needed)
  SELECT * FROM (
    VALUES
      ('%PLUG%',       'ACCOUNT_DESCRIPTION', 'Plug marker',        30, TRUE),
      ('%INTERCO%',    'ACCOUNT_DESCRIPTION', 'Intercompany',       30, TRUE),
      ('%DUE TO%',     'ACCOUNT_DESCRIPTION', 'Due To/Due From',    25, TRUE),
      ('%CLEARING%',   'ACCOUNT_DESCRIPTION', 'Clearing',           25, TRUE)
  ) AS t(text_like, field_name, reason, weight, is_active)
),
whitelist_accounts AS (
  -- Optional: add known-good aggregator accounts you never want flagged
  -- Keep empty if not used.
  SELECT * FROM (
    VALUES
      -- ('ACCOUNT_ID_123','Legit aggregator – exclude')
  ) AS t(account_identifier, reason)
),

/* --------------------------- BASE --------------------------------------------- */
syn_base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)                      AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8          AS exposure,
    ACCOUNT_DESCRIPTION,
    BUS_UNIT_CODE,
    RC_CODE,
    ACCOUNT_OFFICER_NAME
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE CAST(END_OF_MONTH_DATE AS DATE) BETWEEN (SELECT min_month_end FROM params)
                                            AND (SELECT max_month_end FROM params)
),

/* --------------------------- RULE HITS ---------------------------------------- */
rule_hits_css AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'CSS' AS rule_type,
         r.css_pattern AS pattern
  FROM syn_base b
  JOIN rules_css r
    ON r.is_active
   AND (
       (r.match_type = 'EQ'   AND b.contract_source_system = r.css_pattern)
    OR (r.match_type = 'LIKE' AND b.contract_source_system LIKE r.css_pattern)
   )
),
rule_hits_gl AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'GL' AS rule_type,
         r.gl_like AS pattern
  FROM syn_base b
  JOIN rules_gl r
    ON r.is_active AND b.gl_account_code LIKE r.gl_like
),
rule_hits_text AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'TEXT' AS rule_type,
         r.text_like AS pattern
  FROM syn_base b
  JOIN rules_text r
    ON r.is_active
   AND (
        (r.field_name='ACCOUNT_DESCRIPTION'
         AND UPPER(COALESCE(b.account_description,'')) LIKE UPPER(r.text_like))
       -- Extend here for more fields if needed
   )
),
rule_hits AS (
  SELECT * FROM rule_hits_css
  UNION ALL
  SELECT * FROM rule_hits_gl
  UNION ALL
  SELECT * FROM rule_hits_text
),

/* --------------------------- BEHAVIORAL SIGNALS ------------------------------- */
behavior_signals AS (
  SELECT
    month_end, account_identifier, contract_source_system, gl_account_code, exposure,
    LAG(exposure)  OVER (PARTITION BY account_identifier ORDER BY month_end) AS prev_exp,
    LEAD(exposure) OVER (PARTITION BY account_identifier ORDER BY month_end) AS next_exp
  FROM syn_base
),
behavior_flags AS (
  SELECT
    month_end, account_identifier,
    MAX(
      CASE WHEN prev_exp IS NOT NULL AND next_exp IS NOT NULL
            AND ABS(exposure - COALESCE(prev_exp,0)) >= 50000
            AND ABS(next_exp - COALESCE(prev_exp,0)) <= 0.05 * GREATEST(1, ABS(prev_exp))
           THEN 1 ELSE 0 END
    ) AS spike_reverse_flag,
    MAX(
      CASE WHEN ABS(exposure) IN (10000,25000,50000,100000,250000,500000,1000000)
            OR MOD(ABS(exposure),10000)=0
           THEN 1 ELSE 0 END
    ) AS round_flag,
    MAX(
      CASE WHEN (ACCOUNT_OFFICER_NAME IS NULL OR TRIM(ACCOUNT_OFFICER_NAME)='')
                OR RC_CODE IN ('RC999','UNCLASS','UNKNOWN')
           THEN 1 ELSE 0 END
    ) AS no_ctx_flag
  FROM behavior_signals
  GROUP BY month_end, account_identifier
),

/* --------------------------- INTERNAL TRANSFER PAIRS -------------------------- */
xfer_pairs AS (
  SELECT
    a.month_end,
    a.BUS_UNIT_CODE,
    a.RC_CODE,
    ABS(a.exposure) AS abs_amt
  FROM syn_base a
),
xfer_pairs_flag AS (
  SELECT month_end, 1 AS transfer_pair_flag
  FROM (
    SELECT
      p.month_end, p.BUS_UNIT_CODE, p.RC_CODE, p.abs_amt,
      SUM(CASE WHEN s.exposure >= 0 THEN 1 ELSE 0 END) AS plus_cnt,
      SUM(CASE WHEN s.exposure  < 0 THEN 1 ELSE 0 END) AS minus_cnt,
      COUNT(*) AS pair_size
    FROM xfer_pairs p
    JOIN syn_base s
      ON s.month_end = p.month_end
     AND s.BUS_UNIT_CODE = p.BUS_UNIT_CODE
     AND s.RC_CODE = p.RC_CODE
     AND ABS(s.exposure) = p.abs_amt
    GROUP BY p.month_end, p.BUS_UNIT_CODE, p.RC_CODE, p.abs_amt
  ) z
  WHERE plus_cnt >= 1 AND minus_cnt >= 1 AND pair_size >= 2
  GROUP BY month_end
),

/* --------------------------- AGGREGATE RULES ---------------------------------- */
rules_agg AS (
  SELECT
    month_end, account_identifier,
    MIN(contract_source_system) AS contract_source_system,
    MIN(gl_account_code)        AS gl_account_code,
    SUM(weight)                 AS rule_weight_sum,
    COUNT(*)                    AS rule_hits,
    LISTAGG(rule_type||':'||pattern||' ('||reason||')', '; ') 
      WITHIN GROUP (ORDER BY rule_type, pattern) AS reasons
  FROM rule_hits
  GROUP BY month_end, account_identifier
),

/* --------------------------- EXPOSURE SNAPSHOT -------------------------------- */
exp_agg AS (
  SELECT month_end, account_identifier, MAX(exposure) AS exposure_amount
  FROM syn_base
  GROUP BY month_end, account_identifier
)

/* --------------------------- FINAL OUTPUT ------------------------------------- */
SELECT
  b.month_end,
  b.account_identifier,
  COALESCE(r.contract_source_system, sb.contract_source_system) AS contract_source_system,
  COALESCE(r.gl_account_code,        sb.gl_account_code)        AS gl_account_code,
  e.exposure_amount,
  COALESCE(r.rule_hits,0)        AS rule_hits,
  COALESCE(r.rule_weight_sum,0)  AS rule_weight_sum,
  COALESCE(f.spike_reverse_flag,0)  AS spike_reverse_flag,
  COALESCE(f.round_flag,0)          AS round_flag,
  COALESCE(f.no_ctx_flag,0)         AS no_ctx_flag,
  COALESCE(x.transfer_pair_flag,0)  AS transfer_pair_flag,
  /* Composite risk score (cap at 100). Tune weights below. */
  LEAST(
    100,
    COALESCE(r.rule_weight_sum,0)
    + 15*COALESCE(f.spike_reverse_flag,0)
    + 10*COALESCE(f.round_flag,0)
    + 10*COALESCE(f.no_ctx_flag,0)
    + 20*COALESCE(x.transfer_pair_flag,0)
  ) AS risk_score,
  /* Reasons text */
  COALESCE(r.reasons,'') ||
    CASE WHEN COALESCE(f.spike_reverse_flag,0)=1 THEN '; BEHAV:Spike&Reverse' END ||
    CASE WHEN COALESCE(f.round_flag,0)=1        THEN '; BEHAV:Round'          END ||
    CASE WHEN COALESCE(f.no_ctx_flag,0)=1       THEN '; BEHAV:NoContext'      END ||
    CASE WHEN COALESCE(x.transfer_pair_flag,0)=1 THEN '; BEHAV:InternalTransfer' END
    AS reasons
FROM (
  -- driving set: all account×month present in window
  SELECT DISTINCT month_end, account_identifier, contract_source_system, gl_account_code
  FROM syn_base
) sb
LEFT JOIN rules_agg r
  ON r.month_end = sb.month_end AND r.account_identifier = sb.account_identifier
LEFT JOIN exp_agg e
  ON e.month_end = sb.month_end AND e.account_identifier = sb.account_identifier
LEFT JOIN behavior_flags f
  ON f.month_end = sb.month_end AND f.account_identifier = sb.account_identifier
LEFT JOIN xfer_pairs_flag x
  ON x.month_end = sb.month_end
LEFT JOIN whitelist_accounts w
  ON w.account_identifier = sb.account_identifier
LEFT JOIN syn_base b
  ON b.month_end = sb.month_end AND b.account_identifier = sb.account_identifier
WHERE w.account_identifier IS NULL
ORDER BY month_end DESC, risk_score DESC, account_identifier;





-- ==================== KDE MoM Changes — Changes-Only (Upgraded) ====================
-- - 13-month rolling window (tune in params)
-- - Unpivot to (kde_name, kde_val) via UNION ALL
-- - Detect MoM changes per Account×KDE with LAG (incl. NULL flips)
-- - Aggregate ONLY changed rows: counts, exposure deltas, MoM%
-- - Flip-type breakdown: NULL→VAL, VAL→NULL, VAL→VAL (counts & $ deltas)
-- - Per-month ranks by |$Δ| and by #accounts changed
-- - Optional materiality gates (min accounts OR min |$Δ|) to suppress noise
-- ===================================================================================

WITH
/* 0) Parameters (tune thresholds here) */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    5::INTEGER                         AS min_accts_gate,         -- keep rows with ≥ this many changed accts
    1000000.0::FLOAT8                  AS min_abs_exp_delta_gate  -- OR with ≥ this absolute $ change
),

/* 1) Base rows (Total Loans, 13-month window) */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) Long-form (UNION ALL) for selected KDEs; cast to stable VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure, CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* 3) LAG previous month state/value/exposure for change detection */
lagged AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    kde_val,
    LAG(kde_val)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)  OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end) OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* 4) Only rows that changed value vs prior month (including NULL flips) */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure AS this_exp,
    prev_exp,
    CASE
      WHEN prev_val IS NULL AND kde_val IS NOT NULL THEN 'NULL→VAL'
      WHEN prev_val IS NOT NULL AND kde_val IS NULL THEN 'VAL→NULL'
      ELSE 'VAL→VAL'
    END AS flip_type
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,'~NULL~') <> COALESCE(prev_val,'~NULL~')
),

/* 5) Aggregate change-only rows + flip-type breakdowns */
agg AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*) AS accounts_changed,
    SUM(COALESCE(prev_exp,0))                        AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                        AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed,

    -- Flip counts
    SUM(CASE WHEN flip_type='NULL→VAL' THEN 1 ELSE 0 END) AS cnt_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN 1 ELSE 0 END) AS cnt_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN 1 ELSE 0 END) AS cnt_val_to_val,

    -- Flip exposure deltas
    SUM(CASE WHEN flip_type='NULL→VAL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_val
  FROM changed
  GROUP BY kde_name, month_end
),

/* 6) Final metrics + MoM% on changed population */
final_raw AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE (exposure_delta_on_changed / exposure_prev_on_changed)
    END::FLOAT8 AS exposure_mom_pct_on_changed,

    cnt_null_to_val, cnt_val_to_null, cnt_val_to_val,
    exp_delta_null_to_val, exp_delta_val_to_null, exp_delta_val_to_val
  FROM agg
),

/* 7) Apply optional materiality gates (keep noise out upstream) */
final_gated AS (
  SELECT fr.*
  FROM final_raw fr, params p
  WHERE (fr.accounts_changed >= p.min_accts_gate)
     OR (ABS(fr.exposure_delta_on_changed) >= p.min_abs_exp_delta_gate)
)

SELECT
  f.*,
  -- Per-month ranks
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY ABS(f.exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY f.accounts_changed DESC)               AS rk_by_accounts
FROM final_gated f
ORDER BY f.month_end DESC, rk_by_abs_exposure, rk_by_accounts;









-- ==================== KDE MoM Changes — Changes-Only ==========================
-- - Filters to a rolling window (set win_months)
-- - Detects MoM changes with LAG per Account×KDE (incl. NULL flips)
-- - Aggregates only changed rows to produce exposure/count deltas and MoM%
-- - Ranks by exposure change, then by count %
-- ==============================================================================

WITH params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me
),

base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- KDE columns (add/remove as needed)
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me 
),

kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

lagged AS (
  SELECT
    kde_name, Account_Identifier, month_end, exposure,
    kde_val,
    LAG(kde_val)     OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)    OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure           AS this_exp,
    prev_exp           AS prev_exp,
    CASE WHEN COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~') THEN 1 ELSE 0 END AS is_changed
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~')
),

agg_changed AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*)                                   AS accounts_changed,      -- one row per acct×kde change
    SUM(COALESCE(prev_exp,0))                  AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                  AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed
  FROM changed
  GROUP BY kde_name, month_end
),

final AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE exposure_delta_on_changed / exposure_prev_on_changed
    END::FLOAT8 AS exposure_mom_pct_on_changed
  FROM agg_changed
)

SELECT
  f.*,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY ABS(exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY accounts_changed DESC)               AS rk_by_accounts
FROM final f
ORDER BY month_end DESC, rk_by_abs_exposure, rk_by_accounts;









-- Latest month anchor (already in your model, shown for completeness)
LM Date (Selected) :=
EOMONTH(
    MAXX(ALLSELECTED('RC_Code_Model_Base'[month_end]),
         'RC_Code_Model_Base'[month_end]),
    0
)

Actual (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE(
    SUM('RC_Code_Model_Base'[bal_num]),
    TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
)

Forecast (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE(
    SUM('RC_Code_Model_Base'[Forecast_Selected]),
    TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
)

Residual % (LM, per RC) :=      -- + = over-forecast; adjust if you prefer opposite sign
DIVIDE( [Forecast (LM, per RC)] - [Actual (LM, per RC)],
        [Actual (LM, per RC)] )

MoM % (Actual, LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR pm  = EOMONTH(lm, -1)
VAR aLM = [Actual (LM, per RC)]
VAR aPM = CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
                     TREATAS({ pm }, 'RC_Code_Model_Base'[month_end]) )
RETURN DIVIDE(aLM - aPM, aPM)

YoY % (Actual, LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR ly  = EOMONTH(lm, -12)
VAR aLM = [Actual (LM, per RC)]
VAR aLY = CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
                     TREATAS({ ly }, 'RC_Code_Model_Base'[month_end]) )
RETURN DIVIDE(aLM - aLY, aLY)





Residual % (Mean6 at LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR rng = CALCULATETABLE(
            DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
          )
RETURN
AVERAGEX(
  rng,
  CALCULATE(        -- evaluate residual% at each date d in rng
    DIVIDE(
      SUM('RC_Code_Model_Base'[Forecast_Selected]) - SUM('RC_Code_Model_Base'[bal_num]),
      SUM('RC_Code_Model_Base'[bal_num])
    )
  )
)

Residual % (SD6 at LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR rng = CALCULATETABLE(
            DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
          )
RETURN
STDEVX.P(
  rng,
  CALCULATE(
    DIVIDE(
      SUM('RC_Code_Model_Base'[Forecast_Selected]) - SUM('RC_Code_Model_Base'[bal_num]),
      SUM('RC_Code_Model_Base'[bal_num])
    )
  )
)



-- Parameter helpers (or hardcode 0.08 / 0.10 / 3.0)
Param MoM %  := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="MOM_Pct")
Param YoY %  := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="YOY_Pct")
Param SigmaK := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="SigmaK")

Variance Class (LM) :=
VAR r   = [Residual % (LM, per RC)]
VAR m6  = [Residual % (Mean6 at LM, per RC)]
VAR s6  = [Residual % (SD6 at LM, per RC)]
VAR mom = [MoM % (Actual, LM, per RC)]
VAR yoy = [YoY % (Actual, LM, per RC)]
VAR k   = [Param SigmaK]
VAR t_m = [Param MoM %]
VAR t_y = [Param YoY %]
RETURN
SWITCH(TRUE(),
  ISBLANK(r), BLANK(),
  s6 > 0 && ABS(r - m6) >= k * s6,                           "Outlier Spike",
  NOT ISBLANK(yoy) && ABS(yoy) >= t_y && SIGN(yoy)=SIGN(r),   "Possible Level/Trend Shift",
  NOT ISBLANK(mom) && ABS(mom) >= t_m && SIGN(mom)=SIGN(r),   "Short-term Shock",
  ABS(r) >= 0.05 && (ISBLANK(yoy) || ABS(yoy) < t_y),         "Model Miss (Non-seasonal)",
  "Within Expected Range"
)


Is Monitorable (LM, per RC) :=
VAR lm=[LM Date (Selected)]
VAR m = CALCULATE([Monitorable Flag (Measure)],
                  TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
VAR act = [Actual (LM, per RC)]
VAR floor = [Exposure Floor Amount (Safe)]
RETURN IF( m=1 && NOT ISBLANK(act) && ABS(act) >= floor, 1 )

Count – Outlier Spike (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Outlier Spike"
  )
)

Count – Trend/Level Shift (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Possible Level/Trend Shift"
  )
)

Count – Short-term Shock (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Short-term Shock"
  )
)

Count – Model Miss (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Model Miss (Non-seasonal)"
  )
)





Show – Small Multiples TopN (3M Severity) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR N = SELECTEDVALUE('TopN Parm'[N], 4)
VAR pool =
    ADDCOLUMNS(
        ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
        "Mon",
            CALCULATE(
                [Monitorable Flag (Measure)],
                TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
            ),
        "ActLM",
            CALCULATE(
                [Actual],
                TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
            ),
        "Sev3",
            CALCULATE([Severity (3M Avg)])
    )
VAR cand =
    FILTER(
        pool,
        [Mon] = 1 &&
        ABS([ActLM]) >= floor &&
        NOT ISBLANK([Sev3])
    )
VAR TopSet = TOPN(N, cand, [Sev3], DESC)
RETURN
IF(
    HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
    CONTAINS(TopSet, 'RC_Code_Model_Base'[RC_DESCRIPTION], SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])),
    1
)





VarianceParms =
DATATABLE(
  "Param", STRING, "Value", DOUBLE,
  { {"MOM_Pct", 0.08},   -- 8% MoM threshold
    {"YOY_Pct", 0.10},   -- 10% YoY threshold
    {"SigmaK", 3.0} }    -- 3-sigma
)


Param MoM % := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "MOM_Pct")
Param YoY % := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "YOY_Pct")
Param SigmaK := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "SigmaK")

-- Monthly residual % (portfolio sign convention: + = over-forecast)
Residual % (At Month – RC) :=
DIVIDE( [Forecast] - [Actual], [Actual] )  -- use your existing Forecast/Actual measures

-- MoM and YoY actual changes (per RC, at the axis month)
MoM % (Actual) :=
VAR me = MAX('RC_Code_Model_Base'[month_end])
VAR pm = EOMONTH(me, -1)
VAR a_me = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = me )
VAR a_pm = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = pm )
RETURN DIVIDE( a_me - a_pm, a_pm )

YoY % (Actual) :=
VAR me = MAX('RC_Code_Model_Base'[month_end])
VAR ym = EOMONTH(me, -12)
VAR a_me = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = me )
VAR a_ym = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = ym )
RETURN DIVIDE( a_me - a_ym, a_ym )

-- Rolling baseline for residual%
Residual % (Mean6) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE( [Residual % (At Month – RC)] ) )

Residual % (SD6) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN STDEVX.P( rng, CALCULATE( [Residual % (At Month – RC)] ) )


Variance Class :=
VAR r   = [Residual % (At Month – RC)]
VAR m6  = [Residual % (Mean6)]
VAR s6  = [Residual % (SD6)]
VAR mom = [MoM % (Actual)]
VAR yoy = [YoY % (Actual)]
VAR k   = [Param SigmaK]
VAR t_m = [Param MoM %]
VAR t_y = [Param YoY %]
RETURN
SWITCH(TRUE(),
  ISBLANK(r), BLANK(),
  s6 > 0 && ABS(r - m6) >= k * s6,         "Outlier Spike",
  NOT ISBLANK(yoy) && ABS(yoy) >= t_y
     && SIGN(yoy) = SIGN(r),               "Possible Level/Trend Shift",
  NOT ISBLANK(mom) && ABS(mom) >= t_m
     && SIGN(mom) = SIGN(r),               "Short-term Shock",
  ABS(r) >= 0.05 && (ISBLANK(yoy) || ABS(yoy) < t_y), "Model Miss (Non-seasonal)",
  "Within Expected Range"
)


Residual Sign (±1) :=
VAR r = [Residual % (At Month – RC)]
RETURN IF( ISBLANK(r), BLANK(), IF(r >= 0, 1, -1) )

Bias Persistence (3M Same Sign) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -3, MONTH)
VAR sum3 = SUMX( rng, CALCULATE( [Residual Sign (±1)] ) )
RETURN IF( ABS(sum3) = 3, 1, 0 )


Severity (Monthly) := AVERAGE('RC_Code_Model_Base'[Severity_0_100])  -- or your existing monthly severity measure

Severity (3M Avg) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], [LM Date (Selected)], -3, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Severity (Monthly)]) )

Show – Small Multiples TopN (3M Severity) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR N = SELECTEDVALUE('TopN Parm'[N], 4)          -- reuse your TopN parm if you have it
VAR pool =
  ADDCOLUMNS(
    ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",  CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
    "ActLM",CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
    "Sev3", CALCULATE([Severity (3M Avg)])
  )
VAR cand = FILTER(pool, [Mon]=1 && ABS([ActLM]) >= floor && NOT ISBLANK([Sev3]))
VAR topN = TOPN(N, cand, [Sev3], DESC)
RETURN IF( HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
           CONTAINS(topN, 'RC_Code_Model_Base'[RC_DESCRIPTION], SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])), 1)


Abs Error := ABS( [Actual] - [Forecast] )
Bias %    := DIVIDE( [Forecast] - [Actual], [Actual] )
APE %     := DIVIDE( ABS([Actual] - [Forecast]), [Actual] )

MAE (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Abs Error]) )

MAPE (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([APE %]) )

Bias % (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Bias %]) )

Alert – High Severity & Miss (LM) :=
VAR sev = [Severity (Weighted, Latest – RC)]
VAR res = [Residual % (At Month – RC)]
RETURN IF( sev >= 80 && ABS(res) >= 0.05, 1, 0 )

Alert – Persistent Bias (3M) :=
[Bias Persistence (3M Same Sign)]











Forecast Ratio (At Month – Monitorable) :=
VAR me    = MAX ( 'RC_Code_Model_Base'[month_end] )     -- the axis month
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",
            CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",
            CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",
            CALCULATE ( [Monitorable Flag (Measure)],
                        'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil =
    FILTER (
        perRC,
        [Mon] = 1 &&
        NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
        ABS ( [Act] ) >= floor
    )
VAR num = SUMX ( fil, [Fcst] )
VAR den = SUMX ( fil, [Act] )
RETURN DIVIDE ( num, den )





Exposure (Latest) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE(
    SUM( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] )
)


-- R² at latest month in RC context
R2 (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( [R2_By_Model],
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Cap to a sensible display range for portfolio KPIs
R2 (LM, per RC – Capped) :=
VAR r = [R2 (LM, per RC)]
RETURN
IF ( ISBLANK(r), BLANK(),
     MAX ( -1.0, MIN ( 1.0, r ) )
)

Avg R2 (Exp-Weighted, Latest – Robust) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR t =
    ADDCOLUMNS(
        VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
        "R2C",  [R2 (LM, per RC – Capped)],
        "Act",  [Actual (LM, per RC)],
        "Mon",  [Monitorable (LM, per RC)]
    )
VAR fil = FILTER( t, [Mon] = 1 && NOT ISBLANK([R2C]) && ABS([Act]) >= floor )
VAR num = SUMX( fil, [R2C] * ABS([Act]) )
VAR den = SUMX( fil, ABS([Act]) )
RETURN DIVIDE( num, den )







Exposure Δ MoM (per RC) := [Actual (LM, per RC)] - [Actual (PrevM, per RC)]
Exposure Δ MoM | Abs (per RC) := ABS( [Exposure Δ MoM (per RC)] )






Total Exposure % Delta MoM (Monitorable, Latest) :=
VAR lm    = [LM Date (Selected)]
VAR prev  = EOMONTH( lm, -1 )
VAR floor = [Exposure Floor Amount (Safe)]

VAR T =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "MonLM",   CALCULATE ( [Monitorable Flag (Measure)],
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev", CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR F =
    FILTER (
        T,
        [MonLM] = 1 &&
        NOT ISBLANK ( [ActLM] ) &&
        NOT ISBLANK ( [ActPrev] ) &&
        ABS ( [ActLM] ) >= floor
    )

VAR SumLM   = SUMX ( F, [ActLM] )
VAR SumPrev = SUMX ( F, [ActPrev] )
RETURN DIVIDE ( SumLM - SumPrev, SumPrev )





Total Exposure Delta MoM (Monitorable, Latest) :=
VAR lm    = [LM Date (Selected)]
VAR prev  = EOMONTH(lm, -1)
VAR floor = [Exposure Floor Amount (Safe)]

/* Build one row per RC with LM & PrevM facts */
VAR T =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "MonLM",   CALCULATE ( [Monitorable Flag (Measure)],
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev", CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )

/* Keep only monitorable + above floor + has both months */
VAR F =
    FILTER (
        T,
        [MonLM] = 1 &&
        NOT ISBLANK ( [ActLM] ) &&
        NOT ISBLANK ( [ActPrev] ) &&
        ABS ( [ActLM] ) >= floor
    )

RETURN
SUMX ( F, [ActLM] - [ActPrev] )







LM Date (Selected) :=
EOMONTH(
    MAXX(ALLSELECTED('RC_Code_Model_Base'[month_end]),
         'RC_Code_Model_Base'[month_end]), 0)

PrevM Date (Selected) := EOMONTH([LM Date (Selected)], -1)

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount] RETURN IF(ISBLANK(v), 0, v)

Actual := SUM('RC_Code_Model_Base'[bal_num])
Forecast := SUM('RC_Code_Model_Base'[Forecast_Selected])


Actual (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Actual (PrevM, per RC) :=
VAR pm=[PrevM Date (Selected)]
RETURN CALCULATE([Actual], TREATAS({pm}, 'RC_Code_Model_Base'[month_end]))

Forecast (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Forecast], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

R2 (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([R2_By_Model], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Monitorable (LM, per RC) :=
VAR lm=[LM Date (Selected)]
VAR m=CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
RETURN IF(m=1,1,0)


Exposure Δ MoM (per RC) :=
[Actual (LM, per RC)] - [Actual (PrevM, per RC)]

Exposure %Δ MoM (per RC) :=
DIVIDE([Exposure Δ MoM (per RC)], [Actual (PrevM, per RC)])

Abs Error (LM, per RC) :=
VAR a=[Actual (LM, per RC)]
VAR f=[Forecast (LM, per RC)]
RETURN IF(AND(NOT ISBLANK(a), NOT ISBLANK(f)), ABS(a-f))

Residual % (LM, per RC) :=  -- (Actual−Forecast)/Forecast
DIVIDE([Actual (LM, per RC)] - [Forecast (LM, per RC)], [Forecast (LM, per RC)])


Severity (Weighted, Latest – RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Severity (Weighted, Latest)],
                 TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Severity Δ MoM (per RC) :=
VAR lm=[LM Date (Selected)]
VAR pm=[PrevM Date (Selected)]
VAR curr = CALCULATE([Severity (Weighted, Latest)],
                     TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
VAR prev = CALCULATE([Severity (Weighted, Latest)],
                     TREATAS({pm}, 'RC_Code_Model_Base'[month_end]))
RETURN curr - prev


Contribution Score (LM, per RC) :=
-- material MoM move * current severity
ABS([Exposure Δ MoM (per RC)]) * DIVIDE([Severity (Weighted, Latest – RC)], 100)

Show – Top4 by Contribution (Selected) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR rc = SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])
VAR pool =
    ADDCOLUMNS(
      ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
      "Mon",  CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
      "Act",  CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
      "Score", CALCULATE([Contribution Score (LM, per RC)])
    )
VAR cand = FILTER(pool, [Mon]=1 && NOT ISBLANK([Score]) && ABS([Act])>=floor)
VAR top4 = TOPN(4, cand, [Score], DESC)
RETURN IF(HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
          CONTAINS(top4, 'RC_Code_Model_Base'[RC_DESCRIPTION], rc), 1)


Total Exposure Δ MoM (Monitorable, Latest) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR set =
  ADDCOLUMNS(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",[Monitorable (LM, per RC)],
    "ActLM",[Actual (LM, per RC)],
    "Δ",[Exposure Δ MoM (per RC)]
  )
RETURN SUMX(FILTER(set, [Mon]=1 && ABS([ActLM])>=floor), [Δ])

Avg Residual % (Exp-Weighted, LM) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR set =
  ADDCOLUMNS(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",[Monitorable (LM, per RC)],
    "ActLM",[Actual (LM, per RC)],
    "ResPct",[Residual % (LM, per RC)]
  )
VAR fil = FILTER(set, [Mon]=1 && ABS([ActLM])>=floor && NOT ISBLANK([ResPct]))
VAR num = SUMX(fil, [ResPct] * ABS([ActLM]))
VAR den = SUMX(fil, ABS([ActLM]))
RETURN DIVIDE(num, den)










-- Changes-only exposure Δ by KDE at latest month
KDE Exposure Δ (Changes-only, LM) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'KDE_MoM'[exp_changed] ),
    TREATAS ( { lm }, 'KDE_MoM'[month_end] )
)

-- Changes-only count Δ by KDE at latest month
KDE Count Δ (Changes-only, LM) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'KDE_MoM'[cnt_changed] ),
    TREATAS ( { lm }, 'KDE_MoM'[month_end] )
)

-- Flip diagnostics (null/value churn) at latest month
KDE Flips: NULL→Value (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[null_to_val] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Flips: Value→NULL (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[val_to_null] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Flips: Value→Value (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[val_to_val] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Exposure Δ (LM – for Waterfall) := [KDE Exposure Δ (Changes-only, LM)]


-- Severity at latest month per RC
Severity (Weighted, Latest – RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( [Severity (Weighted, Latest)],
                   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Latest exposure per RC (for weighting/filters)
ActLM (Latest, RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Monitorable gate at latest month per RC
Monitorable (LM, RC) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)],
                     TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1 )









ActLM (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Actual], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

R2 (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [R2_By_Model], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Abs Error (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR act = CALCULATE ( [Actual],   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR fc  = CALCULATE ( [Forecast], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( NOT ISBLANK ( act ) && NOT ISBLANK ( fc ), ABS ( act - fc ) )

Monitorable (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1 )


Avg R2 (Exposure-Weighted, Latest) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2LM",  [R2 (Latest, per RC – Selected)],
        "ActLM", [ActLM (Latest, per RC – Selected)],
        "MonLM", [Monitorable (Latest, per RC – Selected)]
    )
VAR fil = FILTER ( perRC, [MonLM] = 1 && NOT ISBLANK ( [R2LM] ) && ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [R2LM] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Avg RMSE (Exposure-Weighted, Latest) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ErrLM", [Abs Error (Latest, per RC – Selected)],
        "ActLM", [ActLM (Latest, per RC – Selected)],
        "MonLM", [Monitorable (Latest, per RC – Selected)]
    )
VAR fil = FILTER ( perRC, [MonLM] = 1 && NOT ISBLANK ( [ErrLM] ) && ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [ErrLM] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Avg R2 (Exp-Weighted, Latest-1) :=
VAR lm  = [LM Date (Selected)]
VAR prev = EOMONTH ( lm, -1 )
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRCPrev =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2Prev",
            CALCULATE ( [R2_By_Model], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev",
            CALCULATE ( [Actual], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonPrev",
            CALCULATE ( [Monitorable Flag (Measure)], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR filPrev = FILTER ( perRCPrev, [MonPrev] = 1 && NOT ISBLANK ( [R2Prev] ) && ABS ( [ActPrev] ) >= floor )
VAR numPrev = SUMX ( filPrev, [R2Prev] * ABS ( [ActPrev] ) )
VAR denPrev = SUMX ( filPrev, ABS ( [ActPrev] ) )
RETURN DIVIDE ( numPrev, denPrev )

Avg R2 Δ MoM (Exp-Weighted) :=
VAR curr = [Avg R2 (Exposure-Weighted, Latest)]
VAR prev = [Avg R2 (Exp-Weighted, Latest-1)]
RETURN DIVIDE ( curr - prev, prev )






Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR rc    = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )

-- Build candidate pool across all RCs under current slicers
VAR pool_with_stats =
    ADDCOLUMNS (
        ALLSELECTED ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

-- Keep ONLY monitorable, non-trivial exposure, with a severity value
VAR candidates =
    FILTER (
        pool_with_stats,
        [MonLM] = 1 &&
        NOT ISBLANK ( [SevLM] ) &&
        ABS ( [ExpLM] ) >= floor
    )

-- Top 4 by severity (within current slicers)
VAR top4 = TOPN ( 4, candidates, [SevLM], DESC )

-- Is the current RC one of those top 4?
VAR inTop4 =
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION], rc )

RETURN
IF (
    HASONEVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )  -- only emit inside an RC tile/row
        && NOT ISBLANK ( rc )
        && inTop4,
    1
)



-- Latest month inside the current selection
LM Date (Selected) :=
MAXX (
    ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[month_end]
)

-- Per-RC stats at the selected latest month
Severity_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    [Severity (Weighted, Latest)],
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

ActLM_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Monitorable_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
VAR m  =
    CALCULATE (
        [Monitorable Flag (Measure)],
        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN IF ( m = 1, 1, 0 )

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount]
RETURN IF ( ISBLANK ( v ), 0, v )

-- Rank all RCs (monitorable + floor) by latest severity within current slicers
Rank_Severity_Latest_Selected_MonOnly :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
-- build the candidate set ACROSS all RCs under current slicers
VAR candidates =
    ADDCOLUMNS (
        ALLSELECTED ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR filtered =
    FILTER ( candidates,
        [MonLM] = 1 &&
        NOT ISBLANK ( [SevLM] ) &&
        ABS ( [ExpLM] ) >= floor
    )
-- rank by severity (ties are fine; DENSE keeps ranks 1..n)
VAR rThis =
    RANKX (
        filtered,
        [SevLM],
        CALCULATE ( [Severity_Latest_RC_Selected] ),
        DESC,
        DENSE
    )
RETURN
    -- return BLANK if we're not in an RC row/tile
    IF (
        HASONEVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        rThis
    )

-- Gate: only Top 4
Show_SmallMultiples_Top4_Selected :=
VAR r = [Rank_Severity_Latest_Selected_MonOnly]
RETURN IF ( NOT ISBLANK ( r ) && r <= 4, 1 )




Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR rc    = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )

VAR pool_with_stats =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER ( pool_with_stats,
             [MonLM] = 1 &&
             NOT ISBLANK ( [SevLM] ) &&
             ABS ( [ExpLM] ) >= floor )

VAR top4 = TOPN ( 4, candidates, [SevLM], DESC )

RETURN
IF (
    ISINSCOPE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ) &&
    NOT ISBLANK ( rc ) &&
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION], rc ),
    1
)




Severity_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Severity (Weighted, Latest)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

ActLM_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)],
                     TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1, 0 )


Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]

VAR pool_with_stats =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER ( pool_with_stats,
             [MonLM] = 1 &&
             NOT ISBLANK ( [SevLM] ) &&
             ABS ( [ExpLM] ) >= floor )

VAR top4 =
    TOPN ( 4, candidates, [SevLM], DESC )

VAR isThisRCInTop4 =
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION],
               SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ) )

RETURN IF ( isThisRCInTop4, 1 )










Severity (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( [Severity (Weighted, Latest)],
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

ActLM (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( SUM( 'RC_Code_Model_Base'[bal_num] ),
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE( [Monitorable Flag (Measure)],
                    TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF( m = 1, 1, 0 )




Rank – Severity (Latest – Selected, Monitorable only) :=
VAR lm     = [LM Date (Selected)]
VAR floor  = [Exposure Floor Amount (Safe)]
VAR currSev = [Severity (Latest, per RC – Selected)]
VAR currExp = ABS( [ActLM (Latest, per RC – Selected)] )
VAR currMon = [Monitorable (Latest, per RC – Selected)]

VAR pool =
    ADDCOLUMNS(
        VALUES( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Sev",  CALCULATE( [Severity (Weighted, Latest)],
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "Exp",  CALCULATE( SUM( 'RC_Code_Model_Base'[bal_num] ),
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "Mon",  CALCULATE( [Monitorable Flag (Measure)],
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER( pool,
        [Mon] = 1 &&
        NOT ISBLANK([Sev]) &&
        ABS([Exp]) >= floor
    )

/* Tie-breaker: exposure scaled tiny so severity dominates */
VAR rankVal =
    RANKX( candidates,
           [Sev] + (ABS([Exp]) / 1e15),
           currSev + (currExp / 1e15),
           DESC, SKIP )

RETURN IF( currMon = 1 && NOT ISBLANK(currSev) && currExp >= floor, rankVal )

Show – Small Multiples Top4 (Selected) :=
VAR r = [Rank – Severity (Latest – Selected, Monitorable only)]
RETURN IF( NOT ISBLANK(r) && r <= 4, 1 )



-- Assumes:
--   Actual := SUM('RC_Code_Model_Base'[bal_num])
--   Quarter Num = QUARTER('RC_Code_Model_Base'[month_end])  (calculated column)

Seasonal Volatility (Per RC – Matrix Safe) :=
VAR quarters =
    CALCULATETABLE (
        VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )   -- keep RC filters, drop quarter filter
    )
VAR liftsPerQ =
    ADDCOLUMNS (
        quarters,
        "lift",
            VAR q = 'RC_Code_Model_Base'[Quarter Num]
            VAR NumAvg =
                CALCULATE (
                    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                    KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = q )
                )
            VAR DenAvg =
                CALCULATE (
                    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                    REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
                )
            RETURN DIVIDE ( NumAvg, DenAvg )
    )
VAR valid = FILTER ( liftsPerQ, NOT ISBLANK ( [lift] ) )
VAR n = COUNTROWS ( valid )
RETURN IF ( n >= 2, STDEVX.P ( valid, [lift] ) )




TopN Parm =
DATATABLE (
    "N", INTEGER,
    {
        {5},
        {10},
        {15},
        {20}
    }
)




-- Average of the quarterly lifts (Q1..Q4) for the RC in context
Seasonal Lift (Avg Q per RC) :=
AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
           [Seasonal Lift (Q vs All – Matrix)] )

-- Population stdev of the quarterly lifts (how “seasonal” the RC is)
Seasonal Volatility (Per RC) :=
VAR qs = VALUES ( 'RC_Code_Model_Base'[Quarter Num] )
RETURN STDEVX.P ( qs, [Seasonal Lift (Q vs All – Matrix)] )

-- Mean absolute deviation from 1.0 (sometimes more intuitive than stdev)
Seasonal Intensity (|Lift-1|) :=
AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
           ABS ( [Seasonal Lift (Q vs All – Matrix)] - 1.0 ) )

-- How many quarters have data (helps judge reliability)
Quarters Covered (Count) :=
COUNTROWS ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ) )


ActLM (Latest, Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( [Actual], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable (Latest, RC – Selected) :=
VAR lm  = [LM Date (Selected)]
VAR mon = CALCULATE ( [Monitorable Flag (Measure)],
                      TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR act = [ActLM (Latest, Selected)]
RETURN IF ( mon = 1 && NOT ISBLANK ( act ) && ABS ( act ) >= [Exposure Floor Amount (Safe)], 1 )


-- Rank RCs by strongest seasonality (higher volatility first)
Rank by Seasonal Volatility :=
RANKX ( ALL ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        [Seasonal Volatility (Per RC)], , DESC, DENSE )

-- Show only Top N (parameterized). If you don’t have a parameter, hardcode 10.
TopN Value (Disconnected) := SELECTEDVALUE ( 'TopN Parm'[N], 10 )

Show – TopN Seasonal RCs :=
VAR r = [Rank by Seasonal Volatility]
VAR n = [TopN Value (Disconnected)]
RETURN IF ( NOT ISBLANK ( r ) && r <= n, 1 )











Realized Ratio (At Month – Monitorable) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )          -- axis month
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",   CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",  CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil = FILTER ( perRC,
                   [Mon] = 1 &&
                   NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
                   ABS ( [Act] ) >= floor )
VAR num = SUMX ( fil, [Act] )
VAR den = SUMX ( fil, [Fcst] )
RETURN DIVIDE ( num, den )


LM Date (Selected) :=
MAXX ( ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
       'RC_Code_Model_Base'[month_end] )

Realized Ratio (Latest – Monitorable) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActLM",  CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = lm ),
        "FcstLM", CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = lm ),
        "MonLM",  CALCULATE ( [Monitorable Flag (Measure)],
                              'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil = FILTER ( perRC,
                   [MonLM] = 1 &&
                   NOT ISBLANK ( [ActLM] ) && NOT ISBLANK ( [FcstLM] ) &&
                   ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [ActLM] )
VAR den = SUMX ( fil, [FcstLM] )
RETURN DIVIDE ( num, den )


Residual % (At Month – Monitorable) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",   CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",  CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil = FILTER ( perRC,
                   [Mon] = 1 &&
                   NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
                   ABS ( [Act] ) >= floor )
VAR num = SUMX ( fil, [Act] - [Fcst] )
VAR den = SUMX ( fil, [Fcst] )
RETURN DIVIDE ( num, den )






LM Date (Selected) :=
MAXX ( ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
       'RC_Code_Model_Base'[month_end] )

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount]
RETURN IF ( ISBLANK ( v ), 0, v )

ActLM (Latest, Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Actual],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Seasonal Lift (Selected Q – Card Safe) :=
VAR qSel = SELECTEDVALUE ( 'RC_Code_Model_Base'[Quarter Num] )
VAR qEff = COALESCE ( qSel, QUARTER ( [LM Date (Selected)] ) )
VAR Num :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = qEff )
    )
VAR Den :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
    )
RETURN DIVIDE ( Num, Den )



Avg Seasonal Lift (Selected Q – Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Lift] ) )
RETURN AVERAGEX ( fil, [Lift] )


Avg Seasonal Lift (Selected Q – Exp Weighted, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Lift] ) )
VAR num = SUMX ( fil, [Lift] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Seasonal Volatility (Per RC) :=
VAR qs =
    CALCULATETABLE (
        VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
    )
VAR lifts =
    ADDCOLUMNS (
        qs,
        "lift",
            VAR q = [Quarter Num]
            RETURN
                DIVIDE (
                    CALCULATE (
                        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                        KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = q )
                    ),
                    CALCULATE (
                        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
                    )
                )
    )
VAR n = COUNTROWS ( lifts )
RETURN IF ( n >= 2, STDEVX.P ( lifts, [lift] ) )


Avg Seasonal Volatility (Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Vol",  [Seasonal Volatility (Per RC)],
        "Mon",  CALCULATE ( [Monitorable Flag (Measure)],
                            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Vol] ) )
RETURN AVERAGEX ( fil, [Vol] )


RCs Lift > +10% (Selected Q, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
RETURN
COUNTROWS ( FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && [Lift] > 1.10 ) )

RCs Lift < –10% (Selected Q, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
RETURN
COUNTROWS ( FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && [Lift] < 0.90 ) )












-- core facts
Actual := SUM('RC_Code_Model_Base'[bal_num])

-- X-axis: lift for the selected quarter vs all quarters, per RC (scatter-safe)
Seasonal Lift (Scatter – Selected Q) :=
VAR qSel = SELECTEDVALUE('RC_Code_Model_Base'[Quarter Num])  -- slicer
VAR num :=
    CALCULATE(
        AVERAGEX(VALUES('RC_Code_Model_Base'[month_end]), [Actual]),
        KEEPFILTERS('RC_Code_Model_Base'[Quarter Num] = qSel)
    )
VAR den :=
    CALCULATE(
        AVERAGEX(VALUES('RC_Code_Model_Base'[month_end]), [Actual]),
        REMOVEFILTERS('RC_Code_Model_Base'[Quarter Num])          -- drop ONLY quarter
    )
RETURN DIVIDE(num, den)



-- Uses your existing lift measure that works in matrix context:
--   [Seasonal Lift (Q vs All – Matrix)]

Seasonal Volatility (Q vs All) :=
VAR qs =
    VALUES ( 'RC_Code_Model_Base'[Quarter Num] )      -- quarters present under current filters
VAR series =
    ADDCOLUMNS (
        qs,
        "lift",
            CALCULATE (
                [Seasonal Lift (Q vs All – Matrix)],
                -- force eval per quarter value in this iterator row
                TREATAS ( { SELECTEDVALUE ( 'RC_Code_Model_Base'[Quarter Num] ) },
                          'RC_Code_Model_Base'[Quarter Num] )
            )
    )
VAR n = COUNTROWS ( series )
RETURN IF ( n >= 2, STDEVX.P ( series, [lift] ) )




-- tweak the bounds if you want
CF Min := 0.90
CF Max := 1.10

Seasonal Lift (for CF – Clamped) :=
VAR v = [Seasonal Lift (Q vs All – Matrix)]
VAR mn = [CF Min]
VAR mx = [CF Max]
RETURN IF( ISBLANK(v), BLANK(), MIN( mx, MAX( mn, v ) ) )



Seasonal Volatility = STDEVX.P(VALUES(Quarter Num), [Seasonal Lift (Q vs All – Matrix])), sort DESC




DBG NumAvg :=
CALCULATE ( AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ) )

DBG DenAvg :=
CALCULATE (
    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
    REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
)




-- Core measures you already have:
Actual := SUM ( 'RC_Code_Model_Base'[bal_num] )
-- (Forecast not needed here)

-- Seasonal Lift (Quarter vs All) – Matrix Safe
Seasonal Lift (Q vs All – Matrix) :=
VAR NumAvg :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] )
        -- uses the current matrix cell's filters, including Quarter Num and RC_DESCRIPTION
    )
VAR DenAvg :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )   -- drop quarter only; keep RC filter
    )
RETURN DIVIDE ( NumAvg, DenAvg )



Seasonal Lift (Quarter vs All) :=
VAR CurrQ = SELECTEDVALUE( 'RC_Code_Model_Base'[Quarter Num] )
VAR CurrRC = SELECTEDVALUE( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR CurrY  = SELECTEDVALUE( 'RC_Code_Model_Base'[Year] )

-- numerator: this RC in this quarter
VAR Num =
    CALCULATE(
        AVERAGE('RC_Code_Model_Base'[Actual]),
        'RC_Code_Model_Base'[Quarter Num] = CurrQ,
        'RC_Code_Model_Base'[RC_DESCRIPTION] = CurrRC
    )

-- denominator: same RC, all quarters (removes quarter filter)
VAR Den =
    CALCULATE(
        AVERAGE('RC_Code_Model_Base'[Actual]),
        ALL('RC_Code_Model_Base'[Quarter Num]),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = CurrRC
    )

RETURN DIVIDE(Num, Den)




Quarter Num := QUARTER( 'RC_Code_Model_Base'[month_end] )        -- 1..4
Year := YEAR( 'RC_Code_Model_Base'[month_end] )
Year–Quarter := FORMAT( 'RC_Code_Model_Base'[month_end], "YYYY" ) & " Q" & QUARTER( 'RC_Code_Model_Base'[month_end] )


Actual := SUM( 'RC_Code_Model_Base'[bal_num] )
Forecast := SUM( 'RC_Code_Model_Base'[Forecast_Selected] )
LM Date := MAXX( ALL( 'RC_Code_Model_Base' ), 'RC_Code_Model_Base'[month_end] )


Axis Quarter :=
QUARTER( MAX( 'RC_Code_Model_Base'[month_end] ) )


Seasonal Lift (Quarter vs All) :=
VAR q =
    IF( HASONEVALUE( 'RC_Code_Model_Base'[Quarter Num] ),
        SELECTEDVALUE( 'RC_Code_Model_Base'[Quarter Num] ),
        QUARTER( MAX( 'RC_Code_Model_Base'[month_end] ) )
    )
VAR num :=
    CALCULATE( [Actual], 'RC_Code_Model_Base'[Quarter Num] = q )
VAR den :=
    CALCULATE( [Actual], ALL( 'RC_Code_Model_Base'[Quarter Num] ) )
/* use averages so scale doesn’t bias: avg per month in numerator/denominator */
VAR mon_num :=
    CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ), 'RC_Code_Model_Base'[Quarter Num] = q )
VAR mon_den :=
    CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ), ALL( 'RC_Code_Model_Base'[Quarter Num] ) )
RETURN
DIVIDE( DIVIDE(num, mon_num), DIVIDE(den, mon_den) )


Seasonal Lift (SameQ, 3Y) :=
VAR me  = MAX( 'RC_Code_Model_Base'[month_end] )
VAR st  = EDATE( me, -36 )
VAR q   = QUARTER( me )
VAR num = CALCULATE( [Actual],
            'RC_Code_Model_Base'[Quarter Num] = q,
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR den = CALCULATE( [Actual],
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR mon_num = CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[Quarter Num] = q,
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR mon_den = CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
RETURN DIVIDE( DIVIDE(num,mon_num), DIVIDE(den,mon_den) )


Seasonal Gap % :=
DIVIDE( [Actual] - [Forecast], [Forecast] )












-- A. Severity at Latest (per RC) – explicit, for ranking
Severity (Latest, per RC) :=
VAR lm = [LM Date]
RETURN
CALCULATE ( [Severity (Weighted, Latest)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- B. Monitorable at Latest (per RC) – explicit
Monitorable (Latest, per RC) :=
VAR lm = [LM Date]
RETURN
CALCULATE ( [Monitorable Flag (Measure)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- C. Rank among monitorable RCs (by Severity at Latest)
Rank – Monitorable by Severity (Latest) :=
VAR lm = [LM Date]
VAR currSev =
    CALCULATE ( [Severity (Weighted, Latest)],
                TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR currMon =
    CALCULATE ( [Monitorable Flag (Measure)],
                TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Build the candidate list (only monitorable RCs with a severity value)
VAR rcList =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR candidates = FILTER ( rcList, [MonLM] = 1 && NOT ISBLANK ( [SevLM] ) )

-- Rank current RC among the candidates
VAR r = RANKX ( candidates, [SevLM], currSev, DESC, DENSE )
RETURN IF ( currMon = 1 && NOT ISBLANK ( currSev ), r )

-- D. Gate for Top 4 monitorable RCs at Latest (use this in the visual filter)
Show in Small Multiples – Top4 Monitorable (Latest) :=
VAR r = [Rank – Monitorable by Severity (Latest)]
RETURN IF ( NOT ISBLANK ( r ) && r <= 4, 1 )




Monitorable (LM per RC – Selected) :=
VAR rc   = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lmRC =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[month_end] ),
        ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
    )
VAR actLM =
    CALCULATE (
        SUM ( 'RC_Code_Model_Base'[bal_num] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
        'RC_Code_Model_Base'[month_end] = lmRC
    )
VAR isIntCol =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
        'RC_Code_Model_Base'[month_end] = lmRC
    )

-- text fallback if column is missing/blank
VAR descUpper =
    UPPER (
        COALESCE (
            CALCULATE (
                MAX ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
                'RC_Code_Model_Base'[month_end] = lmRC
            ),
            ""
        )
    )
VAR codeUpper =
    UPPER (
        COALESCE (
            CALCULATE (
                MAX ( 'RC_Code_Model_Base'[RC_CODE] ),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
                'RC_Code_Model_Base'[month_end] = lmRC
            ),
            ""
        )
    )
VAR isIntText =
    IF (
        CONTAINSSTRING ( descUpper, "CORPORATE" ) ||
        CONTAINSSTRING ( descUpper, "HOLDING" ) ||
        CONTAINSSTRING ( descUpper, "INTERCOMPANY" ) ||
        CONTAINSSTRING ( descUpper, "INTERNAL" ) ||
        CONTAINSSTRING ( descUpper, "ADMIN" ) ||
        CONTAINSSTRING ( codeUpper, "CORP" ) ||
        CONTAINSSTRING ( codeUpper, "HOLD" ) ||
        CONTAINSSTRING ( codeUpper, "INTCO" ),
        1, 0
    )
VAR isInt = COALESCE ( isIntCol, isIntText )
VAR floor = [Exposure Floor Amount (Safe)]
RETURN IF ( NOT ISBLANK ( lmRC ) && isInt = 0 && NOT ISBLANK ( actLM ) && ABS ( actLM ) >= floor, 1 )



Trend Debug – Included RC Count :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "IsInternal", MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "Act",        [Actual]
    )
RETURN
COUNTROWS ( FILTER ( t, [IsInternal] = 0 && ABS([Act]) >= [Exposure Floor Amount] ) )




-- Exposure-weighted avg severity by month (works on the chart axis month)
Avg Weighted Severity (Exposure-Weighted, Trend) :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        // per-RC values in the CURRENT month context (from the axis)
        "IsInternal", MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "Act",        [Actual],   -- your measure
        "SevW",
            VAR sev := AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] )    -- raw 0–100
            VAR act := [Actual]
            VAR w   := IF ( ABS ( act ) <= 1, 0.10, MIN ( 1, MAX ( 0.10, LOG10 ( ABS ( act ) ) / 6 ) ) )
            RETURN IF ( NOT ISBLANK ( sev ), sev * w )
    )
VAR fil =
    FILTER ( t,
        [IsInternal] = 0
        && ABS ( [Act] ) >= [Exposure Floor Amount]          -- e.g., 1,000,000
        && NOT ISBLANK ( [SevW] )
    )
VAR num := SUMX ( fil, [SevW] * ABS ( [Act] ) )  -- weight by ABS(exposure)
VAR den := SUMX ( fil, ABS ( [Act] ) )
RETURN DIVIDE ( num, den, 0 )





-- Exposure-weighted average severity by month (trend line)
Avg Weighted Severity (Exposure-Weighted, Trend) :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        // per-RC values in the current month context (from the axis)
        "Act",
            SUM ( 'RC_Code_Model_Base'[Actual] ),
        "IsInternal",
            MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "SevW",
            VAR sev = AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] )
            VAR act = SUM ( 'RC_Code_Model_Base'[Actual] )
            VAR w   = IF ( ABS ( act ) <= 1, 0.10, MIN ( 1, MAX ( 0.10, LOG10 ( ABS ( act ) ) / 6 ) ) )
            RETURN IF ( NOT ISBLANK ( sev ), sev * w )
    )
VAR fil =
    FILTER ( t,
        [IsInternal] = 0
        && ABS ( [Act] ) >= [Exposure Floor Amount]        -- uses your floor (e.g., 1,000,000)
        && NOT ISBLANK ( [SevW] )
    )
VAR num = SUMX ( fil, [SevW] * [Act] )   -- exposure-weighted numerator
VAR den = SUMX ( fil, [Act] )            -- exposure sum
RETURN COALESCE ( DIVIDE ( num, den ), 0 )





-- ==================== KDE MoM Changes — Changes-Only & Fast ====================
-- - Filters to a rolling window (set win_months)
-- - Detects MoM changes with LAG per Account×KDE (incl. NULL flips)
-- - Aggregates only changed rows to produce exposure/count deltas and MoM%
-- - Ranks by exposure change, then by count %
-- ==============================================================================

-- >>> tune this window to your need (e.g., 13 or 18 months) <<<
WITH params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -18)::DATE AS min_me
),

base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- KDE columns (add/remove as needed)
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me   -- 🔥 critical for zone maps
),

/* Unpivot only once. Keep VARCHAR size modest for speed. */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* Detect MoM changes per Account×KDE using LAG; include NULL flips.
   Require prev row to be exactly previous month to keep it MoM. */
lagged AS (
  SELECT
    kde_name, Account_Identifier, month_end, exposure,
    kde_val,
    LAG(kde_val)     OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)    OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* Keep only rows where the value changed vs last month (including NULL↔value) and prev month exists */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure           AS this_exp,
    prev_exp           AS prev_exp,
    CASE WHEN COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~') THEN 1 ELSE 0 END AS is_changed
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~')
),

/* Aggregate changes-only per KDE × month */
agg_changed AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*)                                   AS accounts_changed,      -- one row per acct×kde change
    SUM(COALESCE(prev_exp,0))                  AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                  AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed
  FROM changed
  GROUP BY kde_name, month_end
),

/* Compute % changes; guard divide-by-zero */
final AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE exposure_delta_on_changed / exposure_prev_on_changed
    END::FLOAT8 AS exposure_mom_pct_on_changed
  FROM agg_changed
)

SELECT
  f.*,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY ABS(exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY accounts_changed DESC)               AS rk_by_accounts
FROM final f
ORDER BY month_end DESC, rk_by_abs_exposure, rk_by_accounts;




/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),





Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] )
- AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )


Band_Height (Per RC) :=
VAR rc = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_CODE] )
RETURN
CALCULATE(
    AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] ) - AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] ),
    KEEPFILTERS ( 'RC_Code_Model_Base'[RC_CODE] = rc )
)








Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGEX (
    'RC_Code_Model_Base',
    VAR hi = 'RC_Code_Model_Base'[PI_Hi]
    VAR lo = 'RC_Code_Model_Base'[PI_Lo]
    RETURN IF ( NOT ( ISBLANK ( hi ) || ISBLANK ( lo ) ), hi - lo )
)





Dynamic Y Min :=
VAR lo =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Lo]
    )
VAR act =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MIN(lo, act)


Dynamic Y Max :=
VAR hi =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Hi]
    )
VAR act =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MAX(hi, act)








R2_Scatter =
VAR SS_Total =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLSELECTED ( RC_Code_Model_Base ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )



R2_By_Model =
VAR SS_Total =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Actual] ) ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLEXCEPT ( RC_Code_Model_Base, RC_Code_Model_Base[RC_Code], RC_Code_Model_Base[Model_Type] ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )


RMSE_By_Model =
VAR Count_Obs =
    COUNTROWS ( FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ) )
VAR Sum_Squared_Errors =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
SQRT ( DIVIDE ( Sum_Squared_Errors, Count_Obs ) )











Avg MoM % Abs (3M) :=
VAR currentMonth = MAX('RC_Code_Model_Base'[month_end])
RETURN
AVERAGEX(
    FILTER(
        ALL('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[RC_CODE] = SELECTEDVALUE('RC_Code_Model_Base'[RC_CODE])
        && 'RC_Code_Model_Base'[month_end] <= currentMonth
        && 'RC_Code_Model_Base'[month_end] > EDATE(currentMonth, -3)
    ),
    'RC_Code_Model_Base'[MoM_Pct_Abs]
)





Latest Month :=
CALCULATE( MAX('RC_Code_Model_Base'[month_end]), ALL('RC_Code_Model_Base') )

Selected Months := DISTINCTCOUNT('RC_Code_Model_Base'[month_end])

RMSE :=
VAR sse =
    SUMX(
        'RC_Code_Model_Base',
        VAR r = 'RC_Code_Model_Base'[Resid]
        RETURN r * r
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN IF(n>0, SQRT( sse / n ))

MAE :=
AVERAGEX( 'RC_Code_Model_Base', ABS('RC_Code_Model_Base'[Resid]) )

MAPE :=
AVERAGEX(
    'RC_Code_Model_Base',
    VAR f = 'RC_Code_Model_Base'[Forecast_Selected]
    VAR a = 'RC_Code_Model_Base'[bal_num]
    RETURN IF( NOT ISBLANK(f) && f<>0, ABS( (a - f) / f ), BLANK() )
)


Inside PI % :=
VAR hits =
    SUMX(
        'RC_Code_Model_Base',
        VAR a = 'RC_Code_Model_Base'[bal_num]
        VAR lo = 'RC_Code_Model_Base'[PI_Lo]
        VAR hi = 'RC_Code_Model_Base'[PI_Hi]
        RETURN IF( NOT(ISBLANK(lo)||ISBLANK(hi)) && a>=lo && a<=hi, 1, 0 )
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN DIVIDE(hits,n)

RMSE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [RMSE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAE],  TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAPE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAPE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

Inside PI % (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [Inside PI %], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )


RMSE Last 6 :=
VAR lm = [Latest Month]
VAR period =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period)
    )
RETURN IF(n>0, SQRT(sse/n))

RMSE Prev 12 (excl last 6) :=
VAR lm = [Latest Month]
VAR last6 = DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
VAR prev12 =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], MAXX(last6,[Value])-1, -12, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        ),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        )
    )
RETURN IF(n>0, SQRT(sse/n))

Break Ratio (Err Vol) :=
DIVIDE( [RMSE Last 6], [RMSE Prev 12 (excl last 6)] )


RMSE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [RMSE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )

MAE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [MAE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )


Resid Mean := AVERAGE('RC_Code_Model_Base'[Resid])
Resid SD   := STDEVX.S('RC_Code_Model_Base', 'RC_Code_Model_Base'[Resid])

+2 SD := [Resid Mean] + 2*[Resid SD]
-2 SD := [Resid Mean] - 2*[Resid SD]





-- Severity (latest)
Avg Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

RC Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

High Severity Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE ( [High Severity Count (Latest)], [RC Count (Latest)] )





-- Anchor
Latest Month :=
CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )

Is Latest Month :=
VAR lm = [Latest Month]
RETURN IF ( MAX ( 'RC_Code_Model_Base'[month_end] ) = lm, 1, 0 )


-- Portfolio totals (latest)
Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE ( [Total Residual (Latest)], [Total Forecast (Latest)] )



-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] > 0
)


Top Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Severity Tier (Latest) :=
VAR sev =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
        TREATAS ( { [Latest Month] }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN
SWITCH (
    TRUE (),
    ISBLANK ( sev ), BLANK (),
    sev >= 80, "Critical",
    sev >= 60, "High",
    sev >= 40, "Moderate",
    "Stable"
)






Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )




-- Reusable anchor
Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

-- Boolean-as-1/0 flag for visuals that need it
Is Latest Month :=
IF (
    MAX ( 'RC_Code_Model_Base'[month_end] ) = [Latest Month],
    1, 0
)


-- Totals (latest)
Total Balance (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Forecast (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )

-- Severity (latest)
Avg Severity (Latest) :=
CALCULATE(
    AVERAGE('RC_Code_Model_Base'[Severity_0_100]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

RC Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

High Severity Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE( [High Severity Count (Latest)], [RC Count (Latest)] )

-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] > 0
)





/* --- rank top components WITHOUT LISTAGG --- */
exp_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_exp_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_exp_component) DESC
    ) AS rn_exp
  FROM psi_calc p
),
cnt_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_cnt_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_cnt_component) DESC
    ) AS rn_cnt
  FROM psi_calc p
),

/* pivot top 3 exposure drivers */
exp_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_exp=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp1,
    MAX(CASE WHEN rn_exp=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp2,
    MAX(CASE WHEN rn_exp=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp3
  FROM exp_rank
  WHERE rn_exp <= 3
  GROUP BY kde_name, month_end
),

/* pivot top 3 count drivers */
cnt_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_cnt=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt1,
    MAX(CASE WHEN rn_cnt=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt2,
    MAX(CASE WHEN rn_cnt=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt3
  FROM cnt_rank
  WHERE rn_cnt <= 3
  GROUP BY kde_name, month_end
)

/* --- final result (no LISTAGG) --- */
SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,

  /* build comma-separated strings manually */
  TRIM(BOTH ', ' FROM
      COALESCE(e.exp1,'') ||
      CASE WHEN e.exp1 IS NOT NULL AND e.exp2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp2,'') ||
      CASE WHEN (e.exp1 IS NOT NULL OR e.exp2 IS NOT NULL) AND e.exp3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp3,'')
  ) AS top_exp_drivers,

  TRIM(BOTH ', ' FROM
      COALESCE(c.cnt1,'') ||
      CASE WHEN c.cnt1 IS NOT NULL AND c.cnt2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt2,'') ||
      CASE WHEN (c.cnt1 IS NOT NULL OR c.cnt2 IS NOT NULL) AND c.cnt3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt3,'')
  ) AS top_cnt_drivers

FROM psi_tot t
LEFT JOIN exp_top3 e ON e.kde_name = t.kde_name AND e.month_end = t.month_end
LEFT JOIN cnt_top3 c ON c.kde_name = t.kde_name AND c.month_end = t.month_end
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;




/* ================= KDE Distribution Drift (PSI) ==================== */
/* Filters portfolio, maps long tails to _OTHER, computes PSI Count/Exposure */
/* =================================================================== */

WITH
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* Flatten per KDE as categories (explicit VARCHAR sizes for Netezza) */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(255)) FROM base
),

/* Define the 12-month window and pick Top 20 values per KDE by exposure */
max_me AS ( SELECT MAX(month_end) AS max_me FROM kde_flat ),
last12 AS (
  SELECT * FROM kde_flat, max_me WHERE month_end >= ADD_MONTHS(max_me, -11)
),
topvals AS (
  SELECT kde_name, kde_value,
         ROW_NUMBER() OVER (PARTITION BY kde_name ORDER BY SUM(exposure) DESC) AS rn
  FROM last12
  GROUP BY kde_name, kde_value
),
value_map AS (
  SELECT f.kde_name, f.Account_Identifier, f.month_end, f.exposure,
         CASE WHEN t.rn IS NOT NULL AND t.rn <= 20
              THEN f.kde_value ELSE '_OTHER' END AS kde_bucket
  FROM kde_flat f
  LEFT JOIN topvals t
    ON t.kde_name = f.kde_name AND t.kde_value = f.kde_value
),

/* Current distributions (per KDE x month x bucket) */
dist_cur AS (
  SELECT kde_name, month_end, kde_bucket,
         COUNT(DISTINCT Account_Identifier)            AS cnt,
         SUM(exposure)                                 AS exp
  FROM value_map
  GROUP BY kde_name, month_end, kde_bucket
),
dist_tot AS (
  SELECT kde_name, month_end,
         SUM(cnt) AS cnt_tot,
         SUM(exp) AS exp_tot
  FROM dist_cur
  GROUP BY kde_name, month_end
),
dist_cur_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         c.cnt, c.exp, t.cnt_tot, t.exp_tot,
         CASE WHEN t.cnt_tot=0 THEN 0 ELSE c.cnt::FLOAT8 / t.cnt_tot END AS p_cnt,
         CASE WHEN t.exp_tot=0 THEN 0 ELSE c.exp::FLOAT8 / t.exp_tot END AS p_exp
  FROM dist_cur c
  JOIN dist_tot t USING (kde_name, month_end)
),

/* Previous month distributions aligned to current month_end */
dist_prev_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         COALESCE(p.p_cnt, 0) AS q_cnt,
         COALESCE(p.p_exp, 0) AS q_exp
  FROM dist_cur_p c
  LEFT JOIN dist_cur_p p
    ON p.kde_name = c.kde_name
   AND p.kde_bucket = c.kde_bucket
   AND p.month_end = ADD_MONTHS(c.month_end, -1)
),

/* PSI components and totals */
psi_calc AS (
  SELECT
    c.kde_name, c.month_end, c.kde_bucket,
    c.p_cnt, v.q_cnt,
    c.p_exp, v.q_exp,
    /* Small epsilon to avoid ln(0) */
    ( (c.p_cnt - v.q_cnt)
      * LN( (CASE WHEN c.p_cnt <= 0 THEN 1e-9 ELSE c.p_cnt END)
          / (CASE WHEN v.q_cnt <= 0 THEN 1e-9 ELSE v.q_cnt END) )
    ) AS psi_cnt_component,
    ( (c.p_exp - v.q_exp)
      * LN( (CASE WHEN c.p_exp <= 0 THEN 1e-9 ELSE c.p_exp END)
          / (CASE WHEN v.q_exp <= 0 THEN 1e-9 ELSE v.q_exp END) )
    ) AS psi_exp_component
  FROM dist_cur_p c
  JOIN dist_prev_p v
    ON v.kde_name = c.kde_name
   AND v.kde_bucket = c.kde_bucket
   AND v.month_end = c.month_end
),
psi_tot AS (
  SELECT
    kde_name, month_end,
    SUM(psi_cnt_component) AS psi_count,
    SUM(psi_exp_component) AS psi_exposure
  FROM psi_calc
  GROUP BY kde_name, month_end
),
/* Rank top contributing buckets each month */
psi_top_components AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket,
    psi_cnt_component, psi_exp_component,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_exp_component) DESC) AS rk_exp,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_cnt_component) DESC) AS rk_cnt
  FROM psi_calc p
)

SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,
  /* Optional: top 3 exposure-contributing buckets for explainability */
  LISTAGG(CASE WHEN c.rk_exp <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_exp_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_exp) AS top_exp_drivers,
  LISTAGG(CASE WHEN c.rk_cnt <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_cnt_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_cnt) AS top_cnt_drivers
FROM psi_tot t
LEFT JOIN psi_top_components c
  ON c.kde_name = t.kde_name AND c.month_end = t.month_end
GROUP BY t.kde_name, t.month_end, t.psi_count, t.psi_exposure
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;






/* 1) Flatten per KDE (UNION ALL) with explicit VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value,
         LAG(CAST(CRE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL
  SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         CAST(PD_GRADE AS VARCHAR(255)),
         LAG(CAST(PD_GRADE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         CAST(FDIC_CALL_CODE AS VARCHAR(255)),
         LAG(CAST(FDIC_CALL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)),
         LAG(CAST(NON_ACCRUAL_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         CAST(INDUSTRY_CODE AS VARCHAR(255)),
         LAG(CAST(INDUSTRY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'LTV', Account_Identifier, month_end, exposure,
         CAST(LTV AS VARCHAR(255)),
         LAG(CAST(LTV AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         CAST(GL_ACCOUNT_CODE AS VARCHAR(255)),
         LAG(CAST(GL_ACCOUNT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         CAST(DAYS_PAST_DUE AS VARCHAR(255)),
         LAG(CAST(DAYS_PAST_DUE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         CAST(RBC_CODE AS VARCHAR(255)),
         LAG(CAST(RBC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         CAST(MATURITY_DATE AS VARCHAR(255)),
         LAG(CAST(MATURITY_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         CAST(NAICS_CODE AS VARCHAR(255)),
         LAG(CAST(NAICS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         CAST(RC_CODE AS VARCHAR(255)),
         LAG(CAST(RC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         CAST(REVOLVING_CODE AS VARCHAR(255)),
         LAG(CAST(REVOLVING_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)),
         LAG(CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)),
         LAG(CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         CAST(BOOK_DATE AS VARCHAR(255)),
         LAG(CAST(BOOK_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         CAST(BUS_UNIT_CODE AS VARCHAR(255)),
         LAG(CAST(BUS_UNIT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         CAST(COLLATERAL_CODE AS VARCHAR(255)),
         LAG(CAST(COLLATERAL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         CAST(ISSUE_DATE AS VARCHAR(255)),
         LAG(CAST(ISSUE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         CAST(OCCUPANCY_CODE AS VARCHAR(255)),
         LAG(CAST(OCCUPANCY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         CAST(PAST_DUE_FLAG AS VARCHAR(255)),
         LAG(CAST(PAST_DUE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)),
         LAG(CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         CAST(PURPOSE_CODE AS VARCHAR(255)),
         LAG(CAST(PURPOSE_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         CAST(STATUS_CODE AS VARCHAR(255)),
         LAG(CAST(STATUS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         CAST(RISK_UNIT AS VARCHAR(255)),
         LAG(CAST(RISK_UNIT AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
)





/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* 1) Flatten per KDE (UNION ALL pattern) with current & previous values and exposures */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CRE_FLAG::VARCHAR AS kde_value,
         LAG(CRE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure)        OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         PD_GRADE::VARCHAR,
         LAG(PD_GRADE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         FDIC_CALL_CODE::VARCHAR,
         LAG(FDIC_CALL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         NON_ACCRUAL_FLAG::VARCHAR,
         LAG(NON_ACCRUAL_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                  OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         INDUSTRY_CODE::VARCHAR,
         LAG(INDUSTRY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure,
         LTV::VARCHAR,
         LAG(LTV::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)     OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         GL_ACCOUNT_CODE::VARCHAR,
         LAG(GL_ACCOUNT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         DAYS_PAST_DUE::VARCHAR,
         LAG(DAYS_PAST_DUE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         RBC_CODE::VARCHAR,
         LAG(RBC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         MATURITY_DATE::VARCHAR,
         LAG(MATURITY_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         NAICS_CODE::VARCHAR,
         LAG(NAICS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         RC_CODE::VARCHAR,
         LAG(RC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)         OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         REVOLVING_CODE::VARCHAR,
         LAG(REVOLVING_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         NEXT_RATE_CHANGE_DATE::VARCHAR,
         LAG(NEXT_RATE_CHANGE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                       OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         ACCOUNT_OFFICER_NAME::VARCHAR,
         LAG(ACCOUNT_OFFICER_NAME::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                      OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         BOOK_DATE::VARCHAR,
         LAG(BOOK_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         BUS_UNIT_CODE::VARCHAR,
         LAG(BUS_UNIT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         COLLATERAL_CODE::VARCHAR,
         LAG(COLLATERAL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         ISSUE_DATE::VARCHAR,
         LAG(ISSUE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         OCCUPANCY_CODE::VARCHAR,
         LAG(OCCUPANCY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         PAST_DUE_FLAG::VARCHAR,
         LAG(PAST_DUE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         PROD_HIER_LEVEL_5::VARCHAR,
         LAG(PROD_HIER_LEVEL_5::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                   OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         PURPOSE_CODE::VARCHAR,
         LAG(PURPOSE_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)              OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         STATUS_CODE::VARCHAR,
         LAG(STATUS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)             OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         RISK_UNIT::VARCHAR,
         LAG(RISK_UNIT::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
),

/* 2) Row-level changed flag (NULL-safe) + exposure delta */
chg_rows AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    prev_exposure,
    kde_value,
    prev_kde_value,
    CASE
      WHEN (kde_value IS NULL AND prev_kde_value IS NULL) THEN 0
      WHEN (kde_value IS NULL AND prev_kde_value IS NOT NULL) THEN 1
      WHEN (kde_value IS NOT NULL AND prev_kde_value IS NULL) THEN 1
      WHEN (kde_value <> prev_kde_value) THEN 1
      ELSE 0
    END AS changed_flag,
    (exposure - COALESCE(prev_exposure,0.0))::FLOAT8 AS delta_exposure
  FROM kde_flat
),

/* 3) Aggregate per KDE x month: totals and changes-only */
agg_m AS (
  SELECT
    kde_name,
    month_end,
    COUNT(DISTINCT Account_Identifier)                                   AS total_accts,
    SUM(exposure)                                                        AS total_exposure,
    COUNT(DISTINCT CASE WHEN changed_flag=1 THEN Account_Identifier END) AS chg_accts,
    SUM(CASE WHEN changed_flag=1 THEN delta_exposure ELSE 0.0 END)       AS chg_exposure
  FROM chg_rows
  GROUP BY kde_name, month_end
),

/* 4) Add prior totals, MoM %, and rolling 12m stats */
with_mom AS (
  SELECT
    a.*,
    LAG(total_accts)    OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_accts,
    LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_exposure,

    /* Overall MoM % (relative to prior total exposure) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE (total_exposure - LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end))
                / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS total_exp_mom_pct,

    /* Changes-only % (relative to prior total exposure/accounts) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_exposure / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_exp_mom_pct,

    CASE WHEN LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_accts::FLOAT8 / NULLIF(LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_cnt_mom_pct,

    /* Rolling 12m stats on changes-only exposure & count (levels) */
    AVG(chg_exposure)  OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_ma12,
    STDDEV_SAMP(chg_exposure) OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_sd12,
    AVG(chg_accts)     OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_ma12,
    STDDEV_SAMP(chg_accts)    OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_sd12
  FROM agg_m a
),

/* 5) Z-scores and severity */
scored AS (
  SELECT
    w.*,
    CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
         ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END AS z_chg_exposure,
    CASE WHEN w.chg_cnt_sd12 IS NULL OR w.chg_cnt_sd12 = 0 THEN NULL
         ELSE (w.chg_accts   - w.chg_cnt_ma12) / w.chg_cnt_sd12 END AS z_chg_count,

    ( 0.55 * ABS(COALESCE(
          CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
               ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END, 0))
    + 0.30 * ABS(COALESCE(w.chg_exp_mom_pct,0))
    + 0.15 * ABS(COALESCE(w.chg_cnt_mom_pct,0))
    ) AS severity_raw
  FROM with_mom w
),

/* 6) KDE grouping for visuals */
labeled AS (
  SELECT
    s.*,
    CASE
      WHEN kde_name IN ('RC_CODE','RBC_CODE','RISK_UNIT','STATUS_CODE') THEN 'Risk/Reg'
      WHEN kde_name IN ('LTV','COLLATERAL_CODE','OCCUPANCY_CODE') THEN 'Collateral'
      WHEN kde_name IN ('PROD_HIER_LEVEL_5','PURPOSE_CODE','GL_ACCOUNT_CODE','REVOLVING_CODE') THEN 'Product'
      WHEN kde_name IN ('PD_GRADE','NON_ACCRUAL_FLAG','PAST_DUE_FLAG','DAYS_PAST_DUE') THEN 'Credit Quality'
      WHEN kde_name IN ('NAICS_CODE','INDUSTRY_CODE','BUS_UNIT_CODE','ACCOUNT_OFFICER_NAME') THEN 'Org/Segment'
      WHEN kde_name IN ('MATURITY_DATE','BOOK_DATE','ISSUE_DATE','NEXT_RATE_CHANGE_DATE') THEN 'Dates'
      ELSE 'Other'
    END AS kde_group
  FROM scored s
),

/* 7) Final compute: severity squash + per-month ranks */
final AS (
  SELECT
    l.*,
    /* 0..100 severity via 1 - exp(-x) */
    ROUND(100 * (1 - EXP(-COALESCE(l.severity_raw,0))), 0)::INT AS severity_0_100,

    /* Per-month ranks (null-safe using COALESCE) */
    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY ABS(COALESCE(l.chg_exposure, -1e308)) DESC
    ) AS rank_exp_abs,

    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY COALESCE(l.chg_cnt_mom_pct, -1e308) DESC
    ) AS rank_cnt_pct
  FROM labeled l
)

SELECT
  kde_name,
  kde_group,
  month_end,
  /* Totals */
  total_accts,
  total_exposure,
  prev_total_accts,
  prev_total_exposure,
  total_exp_mom_pct,
  /* Changes-only */
  chg_accts,
  chg_exposure,
  chg_cnt_mom_pct,
  chg_exp_mom_pct,
  /* Rolling & Z */
  chg_exp_ma12, chg_exp_sd12, z_chg_exposure,
  chg_cnt_ma12, chg_cnt_sd12, z_chg_count,
  /* Severity & ranks */
  severity_0_100,
  rank_exp_abs,
  rank_cnt_pct
FROM final
-- Optional history limiter (e.g., last 36 months):
-- WHERE month_end >= ADD_MONTHS(CURRENT_DATE, -36)
ORDER BY month_end DESC, rank_exp_abs ASC;





import pandas as pd

latest = df["month_end"].max()
d = df[df["month_end"]==latest].copy()
top = d.sort_values("severity_0_100", ascending=False).head(5)

lines = [f"Month: {latest.date()}"]
lines.append(f"Outside PI: {int((d['outside_pi']).sum())} of {len(d)} RCs")
lines.append(f"Persistent (3 of 6): {int((d['persistent_outlier_3of6']==1).sum())}")

for _, r in top.iterrows():
    lines.append(f"- {r['rc_code']}: Sev {int(r['severity_0_100'])} — {r.get('reason_code','')}; "
                 f\"Δ vs Fcst = {r['actual']-r['forecast_selected']:.0f}; "
                 f"MoM=$ {r.get('mom_abs',float('nan')):.0f}; Outside PI={bool(r['outside_pi'])}\")

"\n".join(lines)




import pandas as pd
import numpy as np

# assumes df already loaded/cleaned from Step 1 and has lowercase headers
d = df.copy()

# --- correlations per RC (safe even if some columns are missing) ---
def _corr(a, b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a": a, "b": b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs  = "absresid" in d.columns
have_mom  = "mom_abs" in d.columns
have_momp = "mom_pct_abs" in d.columns

rows = []
for rc, g in d.groupby("rc_code"):
    rows.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(rows)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (flat index) ---
dd = d.sort_values(["rc_code", "month_end"]).copy()
dd["se"] = (pd.to_numeric(dd["actual"], errors="coerce") - pd.to_numeric(dd["forecast_selected"], errors="coerce"))**2

dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick the latest row per RC (no droplevel needed)
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code", "break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




import pandas as pd
import numpy as np

# assume df already loaded/cleaned from Step 1
d = df.copy()

# --- correlations per RC ---
def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs   = "absresid" in d.columns
have_mom$  = "mom_abs" in d.columns
have_momp  = "mom_pct_abs" in d.columns

parts = []
for rc, g in d.groupby("rc_code"):
    parts.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom$) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(parts)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (no MultiIndex) ---
dd = d.sort_values(["rc_code","month_end"]).copy()
dd["se"] = (dd["actual"] - dd["forecast_selected"])**2

# rolling means via transform (keeps a flat index)
dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick latest row per RC without droplevel
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code","break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




Error:Python
ValueError: Cannot remove 1 levels from an index with 1 levels: at least one level must be left.




import pandas as pd

d = df.copy()
latest = d["month_end"].max()
top = (
    d[d["month_end"]==latest]
    .sort_values("severity_0_100", ascending=False)
    .loc[:, ["rc_code","rc_description","month_end","severity_0_100","outside_pi",
             "persistent_outlier_3of6","reason_code","z_resid","z_mom_abs","mom_abs"]]
    .head(25)
    .reset_index(drop=True)
)
top



import pandas as pd
import numpy as np

g = df.groupby("rc_code", as_index=False)

def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce"); b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3: return np.nan
    return m["a"].corr(m["b"])

diag = g.apply(lambda x: pd.Series({
    "corr_resid_momabs": _corr(x["absresid"], x["mom_abs"]) if "absresid" in x and "mom_abs" in x else np.nan,
    "corr_resid_mompct": _corr(x["absresid"], x["mom_pct_abs"]) if "mom_pct_abs" in x else np.nan
})).reset_index(drop=True)

# Drift signal: 3-mo MSE / prior 9-mo MSE
df_sorted = df.sort_values(["rc_code","month_end"]).copy()
df_sorted["se"] = (df_sorted["actual"] - df_sorted["forecast_selected"])**2
df_sorted["mse_curr3"] = df_sorted.groupby("rc_code")["se"].rolling(3, min_periods=2).mean().reset_index(level=0, drop=True)
df_sorted["mse_prev9"] = df_sorted.groupby("rc_code")["se"].rolling(12, min_periods=10).mean().reset_index(level=0, drop=True).shift(3)
drift = (df_sorted
         .assign(break_ratio=lambda x: np.where((x["mse_prev9"]>0)&np.isfinite(x["mse_prev9"]),
                                                x["mse_curr3"]/x["mse_prev9"], np.nan))
         .groupby("rc_code", as_index=False)
         .apply(lambda x: x.loc[x["month_end"].idxmax(), ["rc_code","break_ratio"]])
         .droplevel(0)
)
diag = diag.merge(drift, on="rc_code", how="left")
diag




import pandas as pd
import numpy as np

# If you created RC_Anom_Clean, read that; otherwise reuse df from above cell
try:
    df2 = xl("RC_Anom_Clean").copy()
    df2.columns = [str(c).strip().lower().replace(" ","_") for c in df2.columns]
    df2["month_end"] = pd.to_datetime(df2["month_end"], errors="coerce")
    df2["severity_0_100"] = pd.to_numeric(df2["severity_0_100"], errors="coerce")
    df2["outside_pi"] = df2["outside_pi"].astype(bool)
except:
    df2 = df.copy()

thresholds = list(range(55, 91, 5))  # 55,60,...,90
rows = []
for thr in thresholds:
    pred = df2["severity_0_100"] >= thr
    tp = int((pred & df2["outside_pi"]).sum())
    fp = int((pred & ~df2["outside_pi"]).sum())
    fn = int((~pred & df2["outside_pi"]).sum())
    alerts = int(pred.sum())
    prec = tp / (tp + fp) if (tp+fp) else np.nan
    rec  = tp / (tp + fn) if (tp+fn) else np.nan
    rows.append((thr, alerts, tp, fp, fn, prec, rec))

cal = pd.DataFrame(rows, columns=["threshold","alerts","true_pos","false_pos","false_neg","precision","recall"])

# Add avg alerts per latest month (how noisy will it be?)
latest = df2["month_end"].max()
latest_alerts = df2.loc[df2["month_end"]==latest, ["rc_code","severity_0_100"]]
cal["alerts_latest"] = cal["threshold"].map(lambda t: int((latest_alerts["severity_0_100"]>=t).sum()))

cal




import pandas as pd
import numpy as np

# Read the whole table (headers + data), then promote first row as headers
raw = xl("RC_Anomaly_all").copy()
hdr = raw.iloc[0].astype(str).tolist()
df  = raw.iloc[1:].copy()
df.columns = [h.strip().lower().replace(" ","_") for h in hdr]

# Types
num_cols = ["actual","forecast_selected","pi_lo","pi_hi","severity_0_100","absresid","mom_abs","z_resid","z_mom_abs"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")
df["month_end"] = pd.to_datetime(df["month_end"], errors="coerce")

# Helpful boolean: outside prediction interval
df["outside_pi"] = (df["actual"] < df["pi_lo"]) | (df["actual"] > df["pi_hi"])

# (Optional) persist back to Excel visually
df






/* Clean up temp tables */
IF OBJECT_ID('tempdb..#FLUX')   IS NOT NULL DROP TABLE #FLUX;
IF OBJECT_ID('tempdb..#CARDS')  IS NOT NULL DROP TABLE #CARDS;

/* Params */
DECLARE @system NVARCHAR(150);
DECLARE @current_period DATETIME = '2025-08-31';
DECLARE @prior_period   DATETIME = '2025-07-31';

/* Cards for system tagging */
SELECT DISTINCT LOADDT, CUST_LINE_NBR
INTO #CARDS
FROM CRDADMPRD.CRDADMPRD.dbo.CDM_CARDS_LOAN
WHERE CAST(LOADDT AS DATE) IN (@current_period, @prior_period);

/* === Latest row per table, per date & credit line === */
WITH CLM AS (
    SELECT
        CAST(a.LoadDate AS DATE) AS LoadDate,
        a.CreditLineNumber,
        a.NetUtilized,
        a.ApplID,
        a.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(a.LoadDate AS DATE), a.CreditLineNumber
            ORDER BY a.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    WHERE CAST(a.LoadDate AS DATE) IN (@current_period, @prior_period)
),
CLM_Latest AS (
    SELECT * FROM CLM WHERE rn = 1
),
UF AS (
    SELECT
        CAST(b.LoadDate AS DATE) AS LoadDate,
        b.CreditLineNumber,
        b.SecUnfunded,
        b.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(b.LoadDate AS DATE), b.CreditLineNumber
            ORDER BY b.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
    WHERE CAST(b.LoadDate AS DATE) IN (@current_period, @prior_period)
),
UF_Latest AS (
    SELECT * FROM UF WHERE rn = 1
)

/* Build flux set (one row per date & credit line) */
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    (c.NetUtilized + COALESCE(u.SecUnfunded, 0)) AS commitment,
    c.NetUtilized,
    COALESCE(u.SecUnfunded, 0) AS SecUnfunded,
    c.ApplID,
    @system AS [system]
INTO #FLUX
FROM CLM_Latest c
LEFT JOIN UF_Latest u
  ON u.LoadDate = c.LoadDate
 AND u.CreditLineNumber = c.CreditLineNumber;

/* System tagging (date-scoped) */
UPDATE f
SET    [system] = 'Cards'
FROM   #FLUX f
JOIN   #CARDS c
  ON   c.CUST_LINE_NBR = f.CreditLineNumber
 AND   CAST(c.LOADDT AS DATE) = f.LoadDate
WHERE  f.[system] IS NULL;

UPDATE #FLUX SET [system] = 'CFD'            WHERE ApplID IN ('CF')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Lines'    WHERE ApplID IN ('ML')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Mortgage' WHERE ApplID IN ('MO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'iMX'            WHERE CreditLineNumber LIKE '%iMX%' AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'CBS'            WHERE ApplID IN ('LN')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'UBS'            WHERE ApplID IN ('LO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'LJ'             WHERE ApplID IN ('LJ')         AND [system] IS NULL;

/* Results */
SELECT *
FROM #FLUX;




/* ================= RC_Code Anomaly Detection — PBI-safe (no views, no POWER) ================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages (then restrict) */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 5 PRECEDING AND CURRENT ROW)::FLOAT8  AS fc_ma6,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means/SST per window */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics */
metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM (SELECT DISTINCT RC_CODE FROM idx_tm) x
  LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
  LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) In-sample best model (fallback) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality (unchanged from your logic) */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT RC_CODE, AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT RC_CODE, qnum,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
         SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT RC_CODE,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE, q.qnum,
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE q.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q q
  LEFT JOIN seasonal_all a ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE, l.qnum,
    CASE WHEN l.lift_raw IS NULL THEN 1.0
         WHEN l.lift_raw < 0.85 THEN 0.85
         WHEN l.lift_raw > 1.15 THEN 1.15
         ELSE l.lift_raw END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE, f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0))::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36', fc_reg36
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6',   fc_ma6
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12',  fc_ma12
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Attach prev_bal and pos3_count */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residual/MoM stats per (RC,Model) */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,
    CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for PI */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) OOS MSE (last 3 months) */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
/* Pivot OOS to columns to avoid correlated subqueries */
oos_pivot AS (
  SELECT
    RC_CODE,
    MAX(CASE WHEN model='REG12' THEN mse_oos END) AS mse_reg12,
    MAX(CASE WHEN model='REG36' THEN mse_oos END) AS mse_reg36,
    MAX(CASE WHEN model='MA6'   THEN mse_oos END) AS mse_ma6,
    MAX(CASE WHEN model='MA12'  THEN mse_oos END) AS mse_ma12
  FROM oos
  GROUP BY RC_CODE
),
best_model_oos AS (
  SELECT
    m.RC_CODE,
    CASE
      /* prefer regressions only if their R2 gate passes */
      WHEN m.r2_reg12 >= 0.5 AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_reg36,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG12'
      WHEN m.r2_reg36 >= 0.5 AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG36'
      /* otherwise choose the better moving average */
      WHEN COALESCE(o.mse_ma6,9e99) <= COALESCE(o.mse_ma12,9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_OOS
  FROM metrics m
  LEFT JOIN oos_pivot o ON o.RC_CODE = m.RC_CODE
),

/* 18) Final model: OOS if present else in-sample */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows with PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    CASE WHEN z.prev_bal IS NULL THEN NULL ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid, z.Z_MoM_Abs, z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 via rank (no percentile func) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT RC_CODE, AbsResid,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT RC_CODE, MoM_Abs,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                    AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity (robust scaling) */
sev AS (
  SELECT
    f.*,
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - CASE WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0 ELSE s.Severity_Raw END )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier (3 of last 6 months, threshold 70) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code without GREATEST */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= CASE
                               WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0)) THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
                               ELSE ABS(COALESCE(p.MoM_Abs,0.0))
                             END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






/* ======================== RC_Code Anomaly Detection (Enhanced, single query) =========================
   - Models: REG12, REG36, MA6, MA12 with best model chosen by out-of-sample (last 3 months) RMSE,
             falling back to your original in-sample rule if needed.
   - Seasonality: Quarterly lifts from non-spike months, capped & shrunken, damped if recent spikes.
   - Residual / MoM metrics & Z-scores (per RC, per chosen model window).
   - Prediction Intervals: ±1.96 * RMSE (per-RC, per-model).
   - Severity: uses per-RC P95 scale for AbsResid and MoM_Abs (no POWER; no percentile functions).
               P95 is computed via rank logic: the first value at or above 95th percentile.
   - Flags: Persistent outlier (3 of last 6) and Reason_Code for explainability.
   - No views; no POWER().
   ================================================================================================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (arithmetic only) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Original best-model rule (fallback if OOS cannot be computed) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT
    RC_CODE,
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT
    RC_CODE,
    qnum,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT
    RC_CODE,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE,
    q.qnum,
    CASE
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
      ELSE q.avg_q_nospike / a.avg_all_nospike
    END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q   q
  LEFT JOIN seasonal_all a
    ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts by model (limit rows to each model's window) */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift to forecast */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Add prev_bal & "active last 3 months" flag */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for prediction intervals */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) Out-of-sample (last 3 months of each model) selection */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
best_model_oos AS (
  /* Pick lowest OOS MSE, with R2 ≥ 0.5 gates for regressions; else fall back to MA6/MA12 */
  SELECT d.RC_CODE,
         CASE
           WHEN (SELECT r2_reg12 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o1.mse_oos,9e99) FROM oos o1 WHERE o1.RC_CODE=d.RC_CODE AND o1.model='REG12')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='REG36'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG12'

           WHEN (SELECT r2_reg36 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o2.mse_oos,9e99) FROM oos o2 WHERE o2.RC_CODE=d.RC_CODE AND o2.model='REG36')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG36'

           WHEN COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99)
                <= COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
           THEN 'MA6'
           ELSE 'MA12'
         END AS Best_Model_OOS
  FROM (SELECT DISTINCT RC_CODE FROM union_with_z) d
),

/* 18) Choose final best model: OOS if available else in-sample rule */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows for chosen model; attach RMSE and PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    /* MoM absolute & percent (already abs for pct) */
    CASE WHEN z.prev_bal IS NULL THEN NULL
         ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    /* 95% prediction interval (no POWER) */
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 scales for AbsResid and MoM_Abs (computed via rank, no percentile fn) */
p95_abs AS (
  SELECT RC_CODE,
         MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid)                      AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                         AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE,
         MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs)                        AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                          AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity using robust (per-RC) P95 scales */
sev AS (
  SELECT
    f.*,
    /* robust components: guard denominators with NULLIF */
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  /* Exponential squash to 0..100; no POWER used */
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - GREATEST(0.0, COALESCE(s.Severity_Raw,0.0)) )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier: 3 of last 6 months (threshold 70, adjust as needed) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code (simple dominance logic) */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= GREATEST(ABS(COALESCE(p.Z_MoM_Abs,0.0)), ABS(COALESCE(p.MoM_Abs,0.0))) THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






--QUERY 1										
/* ======================== RC_Code Anomaly Detection =========================										
   - Runs Seasonally Adjusted Regression (12mo, 36mo) and Moving Average (6mo, 12mo), selecting model w/ best fit										
   - Assigns severity score based on various Z-Scores and materiality										
   ============================================================================ */										
WITH										
/* 0) Base */										
base AS (										
  SELECT										
    RC_CODE,										
    RC_DESCRIPTION,										
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,										
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num										
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB										
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL										
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'										
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)										
),										
										
/* 1) Index and tmax; also prev_bal and Month/Quarter tags */										
idx AS (										
  SELECT										
    b.*,										
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t										
  FROM base b										
),										
idx_tm AS (										
  SELECT										
    i.*,										
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,										
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,										
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,										
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum										
  FROM idx i										
),										
										
/* 2) Evaluation windows */										
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),										
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),										
										
/* 3) Regression params (grouped) */										
reg12_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n12,										
    SUM(t)::FLOAT8           AS sumx12,										
    SUM(bal_num)::FLOAT8     AS sumy12,										
    SUM(t*bal_num)::FLOAT8   AS sumxy12,										
    SUM(t*t)::FLOAT8         AS sumx2_12										
  FROM last12										
  GROUP BY RC_CODE										
),										
reg36_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n36,										
    SUM(t)::FLOAT8           AS sumx36,										
    SUM(bal_num)::FLOAT8     AS sumy36,										
    SUM(t*bal_num)::FLOAT8   AS sumxy36,										
    SUM(t*t)::FLOAT8         AS sumx2_36										
  FROM last36										
  GROUP BY RC_CODE										
),										
										
/* 4) Regression fits over their windows */										
reg12_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0										
      THEN										
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t										
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg12										
  FROM last12 l										
  JOIN reg12_params p USING (RC_CODE)										
),										
reg36_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0										
      THEN										
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t										
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg36										
  FROM last36 l										
  JOIN reg36_params p USING (RC_CODE)										
),										
										
/* 5) Moving averages once, then restrict to windows */										
ma_all AS (										
  SELECT										
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma6,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma12										
  FROM idx_tm i										
),										
ma6_last12 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6										
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma6 IS NOT NULL										
),										
ma12_last36 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12										
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma12 IS NOT NULL										
),										
										
/* 6) Means and SST per window (grouped) */										
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),										
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),										
										
sst12 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12										
  FROM last12 l JOIN mean12 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
sst36 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36										
  FROM last36 l JOIN mean36 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
										
/* 7) SSE + counts per model/window (grouped) */										
agg_reg12 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,										
         COUNT(*) AS n_reg12										
  FROM reg12_fit f										
  WHERE f.fc_reg12 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_reg36 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,										
         COUNT(*) AS n_reg36										
  FROM reg36_fit f										
  WHERE f.fc_reg36 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_ma6_12 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,										
         COUNT(*) AS n_ma6										
  FROM ma6_last12 m										
  GROUP BY m.RC_CODE										
),										
agg_ma12_36 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,										
         COUNT(*) AS n_ma12										
  FROM ma12_last36 m										
  GROUP BY m.RC_CODE										
),										
										
/* 8) Metrics (arithmetic only) */										
metrics AS (										
  SELECT										
    x.RC_CODE,										
										
    s12.sst12,  s36.sst36,										
    ar12.sse_reg12, ar12.n_reg12,										
    ar36.sse_reg36, ar36.n_reg36,										
    am6.sse_ma6,    am6.n_ma6,										
    am12.sse_ma12,  am12.n_ma12,										
										
    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,										
										
    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,										
										
    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,										
										
    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12										
  FROM										
    (SELECT DISTINCT RC_CODE FROM idx_tm) x										
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE										
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE										
),										
										
/* 9) Best model pick (no aggregates) */										
best_model AS (										
  SELECT										
    m.RC_CODE,										
    CASE										
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG12'										
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG36'										
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'										
      ELSE 'MA12'										
    END AS Best_Model										
  FROM metrics m										
),										
										
/* 10) --- Robust seasonality: compute spike-aware quarterly lifts --- */										
										
/* 10a) Build MoM (on full series) and spike flags per RC */										
mom_base AS (										
  SELECT										
    t.*,										
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,										
    CASE										
      WHEN t.prev_bal IS NULL THEN NULL										
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0										
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)										
    END::FLOAT8 AS mom_pct										
  FROM idx_tm t										
),										
mom_stats AS (										
  SELECT										
    RC_CODE,										
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs										
  FROM mom_base										
  GROUP BY RC_CODE										
),										
mom_flag AS (										
  /* spike = big percentage change OR big absolute jump relative to typical */										
  SELECT										
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,										
    CASE										
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1										
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1										
      ELSE 0										
    END AS is_spike										
  FROM mom_base b										
  LEFT JOIN mom_stats s USING (RC_CODE)										
),										
/* 10b) recent spike signal (last 6 months relative to series max month) */										
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),										
recent_spike AS (										
  SELECT f.RC_CODE,										
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike										
  FROM mom_flag f										
  JOIN max_me m USING (RC_CODE)										
  GROUP BY f.RC_CODE										
),										
										
/* 10c) Seasonal lifts per RC×Quarter using NON-spike months (revised) */										
seasonal_q AS (										
  SELECT										
    RC_CODE,										
    qnum,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,										
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q										
  FROM mom_flag										
  GROUP BY RC_CODE, qnum										
),										
seasonal_all AS (										
  SELECT										
    RC_CODE,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike										
  FROM mom_flag										
  GROUP BY RC_CODE										
),										
seasonal_lifts AS (										
  SELECT										
    q.RC_CODE,										
    q.qnum,										
    /* raw lift */										
    CASE										
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0										
      ELSE q.avg_q_nospike / a.avg_all_nospike										
    END::FLOAT8 AS lift_raw,										
    q.n_q										
  FROM seasonal_q   q										
  LEFT JOIN seasonal_all a										
    ON a.RC_CODE = q.RC_CODE										
),										
										
/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes (unchanged) */										
seasonal_final AS (										
  SELECT										
    l.RC_CODE,										
    l.qnum,										
    /* cap to [0.85, 1.15] */										
    CASE										
      WHEN l.lift_raw IS NULL THEN 1.0										
      WHEN l.lift_raw < 0.85 THEN 0.85										
      WHEN l.lift_raw > 1.15 THEN 1.15										
      ELSE l.lift_raw										
    END::FLOAT8 AS lift_capped,										
    /* history-based shrink 0..1 (min points to fully trust ≈ 8) */										
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight										
  FROM seasonal_lifts l										
),										
seasonal_ready AS (										
  SELECT										
    f.RC_CODE,										
    f.qnum,										
    /* extra damp if recent spikes: halve the effect */										
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)										
          * f.hist_weight * (f.lift_capped - 1.0)										
    )::FLOAT8 AS lift_final										
  FROM seasonal_final f										
  LEFT JOIN recent_spike r USING (RC_CODE)										
),										
/* 11) Union forecasts by model (limit rows to each model's window) */										
fits_union AS (										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast										
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast										
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast										
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast										
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL										
),										
										
/* 12) Apply seasonal lift to forecast */										
fits_seasonal AS (										
  SELECT										
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,										
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj										
  FROM fits_union u										
  LEFT JOIN seasonal_ready s										
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum										
),										
										
/* 13) Add prev_bal & "active last 3 months" flag */										
union_with_prev AS (										
  SELECT										
    f.*,										
    t.prev_bal,										
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)										
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count										
  FROM fits_seasonal f										
  JOIN idx_tm t										
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end										
),										
										
/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */										
union_enriched AS (										
  SELECT										
    x.*,										
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,										
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,										
										
    CASE WHEN x.prev_bal IS NULL THEN NULL										
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,										
										
    CASE										
      WHEN x.prev_bal IS NULL THEN NULL										
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
    END::FLOAT8 AS mom_pct_abs,										
										
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,										
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,										
										
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,										
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,										
										
    AVG(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,										
    STDDEV_SAMP(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct										
  FROM union_with_prev x										
),										
										
/* 15) Z-scores */										
union_with_z AS (										
  SELECT										
    e.*,										
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0										
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,										
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0										
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,										
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0										
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct										
  FROM union_enriched e										
),										
										
/* 16) Portfolio-wide scales for severity */										
port_scales AS (										
  SELECT										
    MAX(abs_resid) AS max_abs_resid,										
    MAX(mom_abs)   AS max_mom_abs										
  FROM union_with_z										
),										
										
/* 17) Best model decided earlier; join and return FULL history inside chosen window */										
final AS (										
  SELECT										
    z.RC_CODE,										
    z.RC_DESCRIPTION,										
    z.month_end,										
    bm.Best_Model,										
    z.prev_bal,										
    z.forecast_adj       AS Forecast_Selected,										
    z.bal_num            AS Actual,										
    z.resid              AS Resid,										
    z.abs_resid          AS AbsResid,										
    z.mom_abs            AS MoM_Abs,										
    z.mom_pct_abs        AS MoM_Pct_Abs,										
    z.Z_Resid,										
    z.Z_MoM_Abs,										
    z.Z_MoM_Pct,										
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos										
  FROM union_with_z z										
  JOIN best_model bm										
    ON bm.RC_CODE = z.RC_CODE										
  WHERE z.model = bm.Best_Model										
)										
										
SELECT										
  f.*,										
  /* Severity emphasizing AbsResid and Z_Resid */										
  (										
    0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
  + 0.65 * ABS(f.Z_Resid)										
  + 0.07 * ABS(f.Z_MoM_Abs)										
  + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
  )::FLOAT8 AS Severity_Raw,										
										
  ROUND(										
    100.0 * (1.0 - EXP(										
      -(										
        0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
      + 0.65 * ABS(f.Z_Resid)										
      + 0.07 * ABS(f.Z_MoM_Abs)										
      + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
      )										
    )),										
0										
  )::INTEGER AS Severity_0_100										
FROM final f										
CROSS JOIN port_scales ps										
ORDER BY f.RC_CODE, f.month_end;										





import pandas as pd
import numpy as np

# Read the whole table (headers + data) via the named range
raw = xl("KDE_Clean_all").copy()

# Promote first row to headers
header = raw.iloc[0].astype(str).tolist()
df = raw.iloc[1:].copy()
df.columns = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header]

# Sanity check
print("rows:", len(df))
print("cols:", list(df.columns))

# Types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple slope
    t = np.arange(len(g), dtype=float); y = g["exp_changed"].astype(float).to_numpy()
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c, y_c = t - t.mean(), y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c*y_c).sum()/denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)
df_feat





import pandas as pd

df = xl("KDE_Clean").copy()
print("rows:", len(df))
print("columns:", list(df.columns))
df.head()



import pandas as pd
import numpy as np

df = xl("KDE_Clean").copy()
# normalize in case of variations
df.columns = [str(c).strip().lower().replace(" ", "_") for c in df.columns]

# required
for col in ["kde_name","this_eom","exp_changed"]:
    if col not in df.columns:
        raise KeyError(f"Missing column: {col}. Got: {list(df.columns)}")

# types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
df["exp_changed"] = pd.to_numeric(df["exp_changed"], errors="coerce")

# rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple OLS slope (no sklearn): slope = cov(t,y)/var(t)
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].to_numpy(dtype=float)
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c = t - t.mean()
        y_c = y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c * y_c).sum() / denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)

# return full table; convert to an Excel Table named KDE_Features after it renders
df_feat




import pandas as pd

# get data body
dat = xl("KDE_Summary3").copy()

# get header row from the new named range
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols
print("rows:", len(dat), "| cols:", cols)
dat




import pandas as pd

# data body (no headers) comes from the table name
dat = xl("KDE_Summary3").copy()

# headers come from the named range you just created
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols

print("rows:", len(dat), "| cols:", cols)
dat  # returns full table with proper headers




import pandas as pd

TBL = "KDE_Summary3"   # exact Table Name from Table Design

# Read the header row and the data body separately
hdr = xl(f"{TBL}[#Headers]").copy()
dat = xl(f"{TBL}[#Data]").copy()

# Convert the single header row to a list of strings, then clean the names
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

# Apply headers to the data body
dat.columns = cols

# Show a quick summary and the FULL dataframe (no .head/.tail)
print("rows:", len(dat), "cols:", cols)
dat





import pandas as pd
df = xl("KDE_Summary3").copy()
print(list(df.columns))
df.head(3)




tbl = "KDE_Summary3[#All]"   # note the [#All]
df = xl(tbl).copy()
print(df.shape, list(df.columns))


df = xl("KDE_Summary3").copy()




import pandas as pd

tbl = "KDE_Summary3"  # <-- make sure this matches Table Design > Table Name exactly
df = xl(tbl).copy()

print("shape:", df.shape)
print("columns (as Excel passes them):", list(df.columns))
df.head(3)



Error:Python
KeyError: "Couldn't find a KDE identifier column. Expected one of ['kde_name', 'kde', 'key_data_element', 'field_name', 'attribute_name', 'attribute']. Got: ['next_rate_change_date', '2025-09-30_00:00:00', '71809863129.06', '100970', '0.583402', '173071', '171867', '-1204', '-0.006957', '92887577678.95', '93253920099.4', '366342420.45', '0.003944', '-1085822458.44966', '70338547296.7333', '7053855244.00191', '0.208583218882717', '1']"





import pandas as pd
import numpy as np

df_raw = xl("KDE_Summary").copy()
print("raw rows:", len(df_raw))

# If headers came through as numbers, promote first row to headers
if all(isinstance(c, (int, float)) for c in df_raw.columns):
    header = df_raw.iloc[0].tolist()
    df = df_raw.iloc[1:].copy()
    df.columns = [str(x).strip() if pd.notna(x) else f"col_{i}" for i, x in enumerate(header)]
else:
    df = df_raw.copy()

# normalize headers
def norm(c): return str(c).replace("\n"," ").strip().lower().replace(" ", "_")
df.columns = [norm(c) for c in df.columns]
print("normalized columns:", list(df.columns))
print("rows after normalization:", len(df))

# find key columns
kde_candidates  = ["kde_name","kde","key_data_element","field_name","attribute_name","attribute"]
date_candidates = ["this_eom","end_of_month_date","end_of_month","month_end","eom","eom_date","as_of_eom","as_of_date"]

kde_col  = next((c for c in kde_candidates if c in df.columns), None)
date_col = next((c for c in date_candidates if c in df.columns), None)

if kde_col is None:
    raise KeyError(f"Couldn't find a KDE identifier column. Expected one of {kde_candidates}. Got: {list(df.columns)}")

if date_col is None:
    # try auto-detect a date-like column
    for c in df.columns:
        s = pd.to_datetime(df[c], errors="coerce")
        if s.notna().sum() >= max(3, int(0.5*len(s))):
            df["this_eom"] = s
            date_col = "this_eom"
            break
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

# type-cast numerics where present
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# sort for readability
df = df.sort_values([kde_col, "this_eom"]).reset_index(drop=True)

print("kde column:", kde_col, "| date column:", "this_eom")
print("final row count:", len(df))

# IMPORTANT: return the full DataFrame (no .head() / .tail())
df





import pandas as pd
import numpy as np

# ---- 1) Load the Excel table ----
# If your table name isn't KDE_Summary, change it here:
df = xl("KDE_Summary").copy()

# Show raw headers (helps debugging)
print("Raw columns:", list(df.columns))

# ---- 2) Normalize headers safely (handles non-string headers) ----
def to_str(x):
    try:
        return "_".join(map(str, x)).strip() if isinstance(x, tuple) else str(x).strip()
    except Exception:
        return str(x)

df.columns = [to_str(c) for c in df.columns]
df.columns = [c.replace("\n"," ") for c in df.columns]  # remove line breaks from header cells
df.columns = [c.lower().replace(" ", "_") for c in df.columns]

print("Normalized columns:", list(df.columns))

# ---- 3) Find the EOM/date column (handles THIS_EOM and common aliases) ----
aliases = [
    "this_eom","end_of_month_date","end_of_month","month_end",
    "eom","eom_date","as_of_eom","as_of_date","report_eom"
]
date_col = next((c for c in aliases if c in df.columns), None)

# If not found by name, try to detect a date-like column
if date_col is None:
    name_candidates = [c for c in df.columns if any(k in c for k in ["date","eom","month"])]
    parsed = []
    for c in name_candidates + list(df.columns):
        try:
            s = pd.to_datetime(df[c], errors="coerce")
            if s.notna().sum() >= max(3, int(0.5*len(s))):  # at least half the rows look like dates
                parsed.append((c, s))
        except Exception:
            pass
    if parsed:
        date_col, s = parsed[0]
        df["this_eom"] = s
    else:
        raise KeyError(f"Could not find a date column to use as 'this_eom'. "
                       f"Available columns: {list(df.columns)}")
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

print("Using date column as this_eom:", date_col)

# ---- 4) Make sure key numeric columns are numeric (skip if absent) ----
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ---- 5) Sort & preview ----
key_name = "kde_name" if "kde_name" in df.columns else (next((c for c in df.columns if "kde" in c and "name" in c), None))
if key_name is None:
    print("Warning: couldn't find KDE name column (expected 'KDE_NAME'). Continuing without it.")
    df = df.sort_values(["this_eom"]).reset_index(drop=True)
else:
    df = df.sort_values([key_name, "this_eom"]).reset_index(drop=True)

df.tail(10)



import pandas as pd
import numpy as np

df = xl("KDE_Summary").copy()

# convert all headers to lowercase
df.columns = [c.lower() for c in df.columns]

# now you can safely reference 'this_eom'
df['this_eom'] = pd.to_datetime(df['this_eom'], errors='coerce')

# continue with your numeric conversions, sorting, etc.
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct",
            "exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["kde_name","this_eom"]).reset_index(drop=True)
df.tail(10)




import pandas as pd
import numpy as np

# Pull the Excel table into pandas
df = xl("KDE_Summary").copy()

# Basic typing & ordering
df["this_eom"] = pd.to_datetime(df["this_eom"])
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["KDE_NAME","this_eom"]).reset_index(drop=True)

# Show a peek
df.tail(10)





import matplotlib.pyplot as plt

kde = xl("SelectedKDE") if "SelectedKDE" in dir() else None
if not kde:
    kde = df_feat["KDE_NAME"].iloc[0]

g = df_feat[df_feat["KDE_NAME"]==kde].sort_values("this_eom")

plt.figure()
plt.plot(g["this_eom"], g["exp_changed"], label="exp_changed")
if g["exp_changed_ma12"].notna().any():
    plt.plot(g["this_eom"], g["exp_changed_ma12"], linestyle=":", label="MA12")
# add a straight trend line from the slope if you want a visual guide
if len(g) >= 2 and np.isfinite(g["exp_changed"]).sum() >= 2:
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].astype(float).values
    # reconstruct fit using mean-centered form with the slope we computed
    slope = g["exp_changed_trend_slope"].iloc[-1]
    y_hat = (t - t.mean()) * slope + np.nanmean(y)
    plt.plot(g["this_eom"], y_hat, linestyle="--", label="trend")

plt.title(f"{kde} — exp_changed, MA12 & trend")
plt.xlabel("Month End")
plt.ylabel("Exposure changed")
plt.legend()
plt.tight_layout()





import pandas as pd
from sklearn.linear_model import LinearRegression

df = dataset
df = df.groupby('KDE_NAME', as_index=False)['exp_changed'].mean()
model = LinearRegression().fit(df.index.values.reshape(-1,1), df['exp_changed'])
df['trend'] = model.coef_[0]






-- HISTORY + TRENDS (Netezza-safe, no POWER(), no analytic REGR_*)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)

WITH
params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

/* Month index across the window and its prior month */
months AS (
  SELECT DISTINCT t.End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date) AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

/* Base pull: choose exposure and carry all KDEs */
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

/* UNPIVOT via UNION ALL, cast all KDEs to VARCHAR to align types */
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

/* Pair each current month with its previous month using months_seq */
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.End_of_Month_Date
),

/* Compare prev vs curr at (Account, KDE, month) grain */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

/* Row-level flags and attributions */
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,
    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,
    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,
    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

/* Monthly KDE rollups */
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom) AS this_eom,
    SUM(changed_flag) AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag) AS cnt_prev,
    SUM(curr_flag) AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END) AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END) AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

/* MoM metrics per KDE per month */
metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

/* Linear trend slope of exp_changed across the window (per KDE) — no POWER() */
trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
            - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION)))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION))) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

/* Rolling 12-means and stdev for exp_changed (uses multiplications, no POWER()) */
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - (
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          *
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - (
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            *
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),

/* Join trend + rolling stats back to monthly metrics */
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

/* Latest month only + ranking */
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  /* ranking keys */
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  /* MoM context */
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  /* trend context */
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;



base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'     -- 🔹 added filter
),






trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
            - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
          - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION)) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),




rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            CAST(2.0 AS DOUBLE PRECISION)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              CAST(2.0 AS DOUBLE PRECISION)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),




[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            2
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(NUMERIC, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






-- ***** REPLACE trend_all CTE *****
trend_all AS (
  /* slope = Cov(x,y) / Var(x)
     = ( n*Σ(xy) - Σx*Σy ) / ( n*Σ(x^2) - (Σx)^2 ) */
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM( (t_idx*1.0) * (exp_changed*1.0) )
          - (SUM(t_idx*1.0) * SUM(exp_changed*1.0)) )
        /
        ( COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


-- ***** REPLACE rolling_stats CTE *****
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    /* rolling mean over last 12 (or fewer for early months) */
    AVG(exp_changed*1.0)
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    /* rolling stdev using sqrt(E[x^2] - (E[x])^2) */
    CASE
      WHEN
        ( AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        ) < 0
        THEN 0  -- guard against tiny negative from floating error
      ELSE
        SQRT(
          AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'REGR_SLOPE(NUMERIC, NUMERIC)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





-- KDE Changes-Only History + Trend (Netezza-safe, patched)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)
-- Window: set your start/end month-ends below

WITH params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

-- Distinct month-ends in range, and previous month for each
months AS (
  SELECT DISTINCT End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date)           AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

-- Base rows (exposure: Derived -> Amortized)
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,

    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

-- UNPIVOT via UNION ALL (cast to VARCHAR for type alignment)
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

-- Pair each month with its previous month
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.End_of_Month_Date
),

-- *** FIXED joined CTE (no GROUP BY; no stray attrs) ***
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

-- Row-level flags & attribution
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,

    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,

    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,

    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

-- Monthly KDE rollups
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom)                                             AS this_eom,
    SUM(changed_flag)                                         AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag)                                            AS cnt_prev,
    SUM(curr_flag)                                            AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END)   AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END)   AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

-- ***** FIX: compute regression as an aggregate (no OVER) *****
trend_all AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(exp_changed * 1.0, t_idx * 1.0) AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

-- Rolling 12-month stats (still analytic — supported in Netezza)
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(exp_changed)    OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    STDDEV_SAMP(exp_changed) OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_sd12
  FROM metrics_monthly
),

-- Join trend + rolling stats back to the monthly metrics
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

-- Latest month only + ranking by changes-only exposure, then by count %
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  -- changes-only (ranking keys)
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  -- MoM context
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  -- Trend features
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;
