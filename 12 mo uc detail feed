-- =========================================================
-- Set your schema and month-end ONCE
-- =========================================================
-- Replace with your schema (e.g., CIDPR.DATAHUB)
SET SCHEMA 'YOUR_SCHEMA';

-- Pick the reporting month-end:
-- (Change each run; keep YYYY-MM-DD format)
-- =========================================================
-- Safety: drop old params if left around
DROP TABLE IF EXISTS WRK_PARAMS;

CREATE TABLE WRK_PARAMS AS
SELECT DATE '2025-08-31' AS asof_eom;

-- =========================================================
-- 1) Current / Prior snapshots (NA only)
--    Use safe numeric cast for GL_BALANCE to handle 'N'/'NULL'
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_CUR;
CREATE TABLE WRK_NA_CUR AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  /* safe cast in case of text noise */
  CASE
    WHEN t.GL_BALANCE ~ '^[0-9\.\-]+$' THEN t.GL_BALANCE::NUMERIC
    ELSE NULL
  END AS GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = p.asof_eom
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

DROP TABLE IF EXISTS WRK_NA_PREV;
CREATE TABLE WRK_NA_PREV AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  CASE
    WHEN t.GL_BALANCE ~ '^[0-9\.\-]+$' THEN t.GL_BALANCE::NUMERIC
    ELSE NULL
  END AS GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

GENERATE STATISTICS ON WRK_NA_CUR;
GENERATE STATISTICS ON WRK_NA_PREV;

-- Quick counts (optional)
SELECT 'CUR' src, COUNT(*) cnt FROM WRK_NA_CUR
UNION ALL SELECT 'PREV', COUNT(*) FROM WRK_NA_PREV;

-- =========================================================
-- 2) Sets: ADDS / REMOVALS / PERSIST (NOT EXISTS / JOIN)
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_ADDS;
CREATE TABLE WRK_NA_ADDS AS
SELECT c.*
FROM WRK_NA_CUR c
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_PREV p WHERE p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_REMOVALS;
CREATE TABLE WRK_NA_REMOVALS AS
SELECT p.*
FROM WRK_NA_PREV p
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_CUR c WHERE c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_PERSIST;
CREATE TABLE WRK_NA_PERSIST AS
SELECT
  c.eom,
  c.BANK_CODE,
  c.CONTRACT_SOURCE_SYSTEM,
  c.GL_ACCOUNT_HIER_LEVEL_4,
  c.ACCOUNT_IDENTIFIER,
  c.FACILITY_ID,
  c.GL_BALANCE AS cur_balance,
  p.GL_BALANCE AS prev_balance,
  c.INDUSTRY_CODE,
  c.PD_GRADE
FROM WRK_NA_CUR  c
JOIN WRK_NA_PREV p
  ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER;

GENERATE STATISTICS ON WRK_NA_ADDS;
GENERATE STATISTICS ON WRK_NA_REMOVALS;
GENERATE STATISTICS ON WRK_NA_PERSIST;

-- =========================================================
-- 3) Pre-aggregate once (no correlated subselects)
-- =========================================================
DROP TABLE IF EXISTS WRK_AGG_CUR;
CREATE TABLE WRK_AGG_CUR AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS na_eom_balance,
       COUNT(*)        AS na_eom_count
FROM WRK_NA_CUR
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_ADDS;
CREATE TABLE WRK_AGG_ADDS AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS adds_balance,
       COUNT(*)        AS adds_count
FROM WRK_NA_ADDS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
CREATE TABLE WRK_AGG_REMOVALS AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS removals_balance,
       COUNT(*)        AS removals_count
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_PERSIST;
CREATE TABLE WRK_AGG_PERSIST AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(cur_balance) AS persist_balance,
       COUNT(*)         AS persist_count
FROM WRK_NA_PERSIST
GROUP BY 1,2,3;

GENERATE STATISTICS ON WRK_AGG_CUR;
GENERATE STATISTICS ON WRK_AGG_ADDS;
GENERATE STATISTICS ON WRK_AGG_REMOVALS;
GENERATE STATISTICS ON WRK_AGG_PERSIST;

-- =========================================================
-- 4) Unified keyset, KPI table
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_KEYS;
CREATE TABLE WRK_NA_KEYS AS
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_CUR
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PREV
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PERSIST;

GENERATE STATISTICS ON WRK_NA_KEYS;

DROP TABLE IF EXISTS WRK_NA_KPI;
CREATE TABLE WRK_NA_KPI AS
SELECT
  k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.na_eom_balance,  0)::NUMERIC AS na_eom_balance,
  COALESCE(c.na_eom_count,    0)::NUMERIC AS na_eom_count,
  COALESCE(a.adds_balance,    0)::NUMERIC AS adds_balance,
  COALESCE(a.adds_count,      0)::NUMERIC AS adds_count,
  COALESCE(r.removals_balance,0)::NUMERIC AS removals_balance,
  COALESCE(r.removals_count,  0)::NUMERIC AS removals_count,
  COALESCE(p.persist_balance, 0)::NUMERIC AS persist_balance,
  COALESCE(p.persist_count,   0)::NUMERIC AS persist_count
FROM WRK_NA_KEYS k
LEFT JOIN WRK_AGG_CUR      c USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_ADDS     a USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_REMOVALS r USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_PERSIST  p USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4);

GENERATE STATISTICS ON WRK_NA_KPI;

-- =========================================================
-- 5) Waterfall & Adds composition (long format)
-- =========================================================
DROP TABLE IF EXISTS WRK_NA_WATERFALL;
CREATE TABLE WRK_NA_WATERFALL AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT 'WATERFALL'::VARCHAR(20) AS section,
       (SELECT asof_eom FROM prm) AS eom,
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'start_balance'::VARCHAR(50) AS metric_name,
       SUM(GL_BALANCE)::NUMERIC AS metric_value,
       NULL::VARCHAR(100) AS extra_dim1,
       NULL::VARCHAR(100) AS extra_dim2
FROM WRK_NA_PREV
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'adds', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'removals', -SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'end_balance', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_CUR
GROUP BY 1,2,3,4,5;

GENERATE STATISTICS ON WRK_NA_WATERFALL;

DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
CREATE TABLE WRK_NA_ADDS_COMP AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT
  'ADDS_COMPOSITION'::VARCHAR(20) AS section,
  (SELECT asof_eom FROM prm)      AS eom,
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_balance'::VARCHAR(50)     AS metric_name,
  SUM(GL_BALANCE)::NUMERIC        AS metric_value,
  COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
  COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9

UNION ALL
SELECT
  'ADDS_COMPOSITION', (SELECT asof_eom FROM prm),
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_count',
  COUNT(*)::NUMERIC,
  COALESCE(INDUSTRY_CODE,'(unknown)'),
  COALESCE(PD_GRADE,'(unknown)')
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9;

GENERATE STATISTICS ON WRK_NA_ADDS_COMP;

-- =========================================================
-- 6) Peek outputs (query these in this or later sessions)
-- =========================================================
SELECT * FROM WRK_NA_KPI        ORDER BY na_eom_balance DESC NULLS LAST LIMIT 200;
SELECT * FROM WRK_NA_WATERFALL  ORDER BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name;
SELECT * FROM WRK_NA_ADDS_COMP  ORDER BY metric_value DESC NULLS LAST LIMIT 200;

-- =========================================================
-- 7) CLEANUP (optional)
--    Comment out this whole block if you want to keep tables
-- =========================================================
-- DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
-- DROP TABLE IF EXISTS WRK_NA_WATERFALL;
-- DROP TABLE IF EXISTS WRK_NA_KPI;
-- DROP TABLE IF EXISTS WRK_NA_KEYS;
-- DROP TABLE IF EXISTS WRK_AGG_PERSIST;
-- DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
-- DROP TABLE IF EXISTS WRK_AGG_ADDS;
-- DROP TABLE IF EXISTS WRK_AGG_CUR;
-- DROP TABLE IF EXISTS WRK_NA_PERSIST;
-- DROP TABLE IF EXISTS WRK_NA_REMOVALS;
-- DROP TABLE IF EXISTS WRK_NA_ADDS;
-- DROP TABLE IF EXISTS WRK_NA_PREV;
-- DROP TABLE IF EXISTS WRK_NA_CUR;
-- DROP TABLE IF EXISTS WRK_PARAMS;






-- 1) Drop if exists (safe if it never existed)
DROP TABLE IF EXISTS WRK_DEMO_TEMP;

-- 2) Create a tiny temp table
CREATE TEMP TABLE WRK_DEMO_TEMP (id INTEGER, note VARCHAR(20));

-- 3) Insert one row
INSERT INTO WRK_DEMO_TEMP VALUES (1, 'hello');

-- 4) Read it back
SELECT * FROM WRK_DEMO_TEMP;

-- 5) Confirm it exists in session temp catalog
SELECT objname, objtype
FROM _v_tempobjects
WHERE UPPER(objname) = 'WRK_DEMO_TEMP';






-- ========= PARAM =========
-- Set your month-end once here
CREATE TEMP TABLE WRK_PARAMS AS
SELECT DATE '2025-08-31' AS asof_eom;

-- ========= CURRENT / PRIOR NA SLICES (ONLY NEEDED COLS) =========
DROP TABLE IF EXISTS WRK_NA_CUR;
CREATE TEMP TABLE WRK_NA_CUR
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  -- If GL_BALANCE might have non-numeric values, use the safe cast below instead:
  -- CAST(NULLIF(t.GL_BALANCE,'N') AS NUMERIC) AS GL_BALANCE,
  t.GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = p.asof_eom
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

DROP TABLE IF EXISTS WRK_NA_PREV;
CREATE TEMP TABLE WRK_NA_PREV
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
  t.BANK_CODE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.GL_ACCOUNT_HIER_LEVEL_4,
  t.ACCOUNT_IDENTIFIER,
  t.FACILITY_ID,
  -- CAST(NULLIF(t.GL_BALANCE,'N') AS NUMERIC) AS GL_BALANCE,
  t.GL_BALANCE,
  t.INDUSTRY_CODE,
  t.PD_GRADE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
JOIN WRK_PARAMS p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE');

GENERATE STATISTICS ON WRK_NA_CUR;
GENERATE STATISTICS ON WRK_NA_PREV;

-- ========= SETS: ADDS / REMOVALS / PERSIST =========
DROP TABLE IF EXISTS WRK_NA_ADDS;
CREATE TEMP TABLE WRK_NA_ADDS
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT c.*
FROM WRK_NA_CUR c
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_PREV p
  WHERE p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_REMOVALS;
CREATE TEMP TABLE WRK_NA_REMOVALS
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT p.*
FROM WRK_NA_PREV p
WHERE NOT EXISTS (
  SELECT 1 FROM WRK_NA_CUR c
  WHERE c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
);

DROP TABLE IF EXISTS WRK_NA_PERSIST;
CREATE TEMP TABLE WRK_NA_PERSIST
DISTRIBUTE ON (ACCOUNT_IDENTIFIER) AS
SELECT
  c.eom,
  c.BANK_CODE,
  c.CONTRACT_SOURCE_SYSTEM,
  c.GL_ACCOUNT_HIER_LEVEL_4,
  c.ACCOUNT_IDENTIFIER,
  c.FACILITY_ID,
  c.GL_BALANCE  AS cur_balance,
  p.GL_BALANCE  AS prev_balance,
  c.INDUSTRY_CODE,
  c.PD_GRADE
FROM WRK_NA_CUR  c
JOIN WRK_NA_PREV p
  ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER;

GENERATE STATISTICS ON WRK_NA_ADDS;
GENERATE STATISTICS ON WRK_NA_REMOVALS;
GENERATE STATISTICS ON WRK_NA_PERSIST;

-- ========= KEYSET (ALL SEGMENTS THAT APPEAR IN EITHER MONTH) =========
DROP TABLE IF EXISTS WRK_NA_KEYS;
CREATE TEMP TABLE WRK_NA_KEYS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_CUR
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PREV
UNION
SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM WRK_NA_PERSIST;

GENERATE STATISTICS ON WRK_NA_KEYS;

-- ========= PRE-AGGREGATE ONCE (NO CORRELATED SUBSELECTS) =========
DROP TABLE IF EXISTS WRK_AGG_CUR;
CREATE TEMP TABLE WRK_AGG_CUR
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS na_eom_balance,
       COUNT(*)        AS na_eom_count
FROM WRK_NA_CUR
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_ADDS;
CREATE TEMP TABLE WRK_AGG_ADDS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS adds_balance,
       COUNT(*)        AS adds_count
FROM WRK_NA_ADDS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_REMOVALS;
CREATE TEMP TABLE WRK_AGG_REMOVALS
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(GL_BALANCE) AS removals_balance,
       COUNT(*)        AS removals_count
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3;

DROP TABLE IF EXISTS WRK_AGG_PERSIST;
CREATE TEMP TABLE WRK_AGG_PERSIST
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       SUM(cur_balance) AS persist_balance,
       COUNT(*)         AS persist_count
FROM WRK_NA_PERSIST
GROUP BY 1,2,3;

GENERATE STATISTICS ON WRK_AGG_CUR;
GENERATE STATISTICS ON WRK_AGG_ADDS;
GENERATE STATISTICS ON WRK_AGG_REMOVALS;
GENERATE STATISTICS ON WRK_AGG_PERSIST;

-- ========= KPI (JOIN PRE-AGGS TO KEYSET) =========
DROP TABLE IF EXISTS WRK_NA_KPI;
CREATE TEMP TABLE WRK_NA_KPI
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
SELECT
  k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
  COALESCE(c.na_eom_balance,  0)::NUMERIC AS na_eom_balance,
  COALESCE(c.na_eom_count,    0)::NUMERIC AS na_eom_count,
  COALESCE(a.adds_balance,    0)::NUMERIC AS adds_balance,
  COALESCE(a.adds_count,      0)::NUMERIC AS adds_count,
  COALESCE(r.removals_balance,0)::NUMERIC AS removals_balance,
  COALESCE(r.removals_count,  0)::NUMERIC AS removals_count,
  COALESCE(p.persist_balance, 0)::NUMERIC AS persist_balance,
  COALESCE(p.persist_count,   0)::NUMERIC AS persist_count
FROM WRK_NA_KEYS k
LEFT JOIN WRK_AGG_CUR      c USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_ADDS     a USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_REMOVALS r USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4)
LEFT JOIN WRK_AGG_PERSIST  p USING (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4);

GENERATE STATISTICS ON WRK_NA_KPI;

-- ========= WATERFALL =========
DROP TABLE IF EXISTS WRK_NA_WATERFALL;
CREATE TEMP TABLE WRK_NA_WATERFALL
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT 'WATERFALL'::VARCHAR(20) AS section,
       (SELECT asof_eom FROM prm) AS eom,
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'start_balance'::VARCHAR(50) AS metric_name,
       SUM(GL_BALANCE)::NUMERIC AS metric_value,
       NULL::VARCHAR(100) AS extra_dim1,
       NULL::VARCHAR(100) AS extra_dim2
FROM WRK_NA_PREV
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'adds', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'removals', -SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_REMOVALS
GROUP BY 1,2,3,4,5

UNION ALL
SELECT 'WATERFALL', (SELECT asof_eom FROM prm),
       BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
       'end_balance', SUM(GL_BALANCE)::NUMERIC, NULL, NULL
FROM WRK_NA_CUR
GROUP BY 1,2,3,4,5;

GENERATE STATISTICS ON WRK_NA_WATERFALL;

-- ========= ADDS COMPOSITION =========
DROP TABLE IF EXISTS WRK_NA_ADDS_COMP;
CREATE TEMP TABLE WRK_NA_ADDS_COMP
DISTRIBUTE ON (BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4) AS
WITH prm AS (SELECT asof_eom FROM WRK_PARAMS)
SELECT
  'ADDS_COMPOSITION'::VARCHAR(20) AS section,
  (SELECT asof_eom FROM prm)      AS eom,
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_balance'::VARCHAR(50)     AS metric_name,
  SUM(GL_BALANCE)::NUMERIC        AS metric_value,
  COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
  COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9

UNION ALL
SELECT
  'ADDS_COMPOSITION', (SELECT asof_eom FROM prm),
  BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
  'adds_count',
  COUNT(*)::NUMERIC,
  COALESCE(INDUSTRY_CODE,'(unknown)'),
  COALESCE(PD_GRADE,'(unknown)')
FROM WRK_NA_ADDS
GROUP BY 1,2,3,4,5,8,9;

GENERATE STATISTICS ON WRK_NA_ADDS_COMP;

-- ========= OPTIONAL: QUICK PEEK =========
SELECT * FROM WRK_NA_KPI        ORDER BY na_eom_balance DESC NULLS LAST LIMIT 200;
SELECT * FROM WRK_NA_WATERFALL  ORDER BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name;
SELECT * FROM WRK_NA_ADDS_COMP  ORDER BY metric_value DESC NULLS LAST LIMIT 200;







WITH params AS (
  SELECT DATE '2025-08-31' AS asof_eom
),

/* 1) Current & prior month NA slices */
cur AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = p.asof_eom
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),
prev AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),

/* 2) Sets via joins on ACCOUNT_IDENTIFIER */
adds AS (         /* in cur, not in prev */
  SELECT c.*
  FROM cur c
  LEFT JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
  WHERE p.ACCOUNT_IDENTIFIER IS NULL
),
removals AS (     /* in prev, not in cur */
  SELECT p.*
  FROM prev p
  LEFT JOIN cur c
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
),
persist AS (      /* in both */
  SELECT
    c.eom,
    c.BANK_CODE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.ACCOUNT_IDENTIFIER,
    c.FACILITY_ID,
    c.GL_BALANCE  AS cur_balance,
    p.GL_BALANCE  AS prev_balance,
    c.INDUSTRY_CODE,
    c.PD_GRADE
  FROM cur c
  INNER JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
),

/* 3) KPI rollups (by BANK/SYSTEM/GL_L4) */
kpi AS (
  SELECT
    COALESCE(x.BANK_CODE, y.BANK_CODE, z.BANK_CODE) AS BANK_CODE,
    COALESCE(x.CONTRACT_SOURCE_SYSTEM, y.CONTRACT_SOURCE_SYSTEM, z.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4, y.GL_ACCOUNT_HIER_LEVEL_4, z.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,

    /* EOM NA */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_balance,
    COALESCE( (SELECT COUNT(*) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_count,

    /* Adds */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_balance,
    COALESCE( (SELECT COUNT(*) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_count,

    /* Removals (use prev dollars) */
    COALESCE( (SELECT SUM(GL_BALANCE) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_balance,
    COALESCE( (SELECT COUNT(*) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_count,

    /* Persist (use current dollars) */
    COALESCE( (SELECT SUM(cur_balance) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_balance,
    COALESCE( (SELECT COUNT(*) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_count

  FROM (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM cur) x
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM prev) y
    ON y.BANK_CODE=x.BANK_CODE AND y.CONTRACT_SOURCE_SYSTEM=x.CONTRACT_SOURCE_SYSTEM AND y.GL_ACCOUNT_HIER_LEVEL_4=x.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM persist) z
    ON z.BANK_CODE = COALESCE(x.BANK_CODE,y.BANK_CODE)
   AND z.CONTRACT_SOURCE_SYSTEM = COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM)
   AND z.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 4) Waterfall rows */
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    SUM(GL_BALANCE)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM prev
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds', SUM(GL_BALANCE), NULL, NULL
  FROM adds
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals', -SUM(GL_BALANCE), NULL, NULL
  FROM removals
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'end_balance', SUM(GL_BALANCE), NULL, NULL
  FROM cur
  GROUP BY 1,2,3,4,5
),

/* 5) Adds composition (Industry / PD_GRADE) — FIXED GROUP BY */
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,              -- 1
    (SELECT asof_eom FROM params)   AS eom,                  -- 2
    BANK_CODE,                                                -- 3
    CONTRACT_SOURCE_SYSTEM,                                   -- 4
    GL_ACCOUNT_HIER_LEVEL_4,                                  -- 5
    'adds_balance'::VARCHAR(50)     AS metric_name,           -- 6
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,          -- 7 (aggregate)
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,        -- 8
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2         -- 9
  FROM adds
  GROUP BY 1,2,3,4,5,8,9

  UNION ALL

  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count',
    COUNT(*)::NUMERIC,
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,8,9
),

/* 6) KPI long rows */
kpi_long AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    na_eom_balance::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', na_eom_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance::NUMERIC, NULL, NULL FROM kpi

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count::NUMERIC, NULL, NULL FROM kpi
)

/* === FINAL OUTPUT === */
SELECT * FROM kpi_long
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM adds_comp_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 20000;





-- ====== 5) Adds composition (Industry / PD_GRADE) — FIXED GROUP BY ======
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,            -- 1
    (SELECT asof_eom FROM params)   AS eom,                -- 2
    BANK_CODE,                                              -- 3
    CONTRACT_SOURCE_SYSTEM,                                 -- 4
    GL_ACCOUNT_HIER_LEVEL_4,                                -- 5
    'adds_balance'::VARCHAR(50)     AS metric_name,         -- 6
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,        -- 7 (aggregate)
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,      -- 8
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2       -- 9
  FROM adds
  GROUP BY 1,2,3,4,5,8,9   -- ✅ exclude column 7 (aggregate)

  UNION ALL

  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count',
    COUNT(*)::NUMERIC,                                     -- aggregate
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,8,9   -- ✅ exclude the COUNT(*) column
)





-- ====== PARAMETERS ======
WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom
),

-- ====== 1) Current & prior month NA slices (only needed columns) ======
cur AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = p.asof_eom
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),
prev AS (
  SELECT
    CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.ACCOUNT_IDENTIFIER,
    t.FACILITY_ID,
    t.GL_BALANCE,
    t.INDUSTRY_CODE,
    t.PD_GRADE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON t.END_OF_MONTH_DATE = ADD_MONTHS(p.asof_eom,-1)
  WHERE UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE')
),

-- ====== 2) Sets: ADDS, REMOVALS, PERSISTING (set joins, no windows) ======
adds AS (         -- in cur, not in prev
  SELECT c.*
  FROM cur c
  LEFT JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
  WHERE p.ACCOUNT_IDENTIFIER IS NULL
),
removals AS (     -- in prev, not in cur
  SELECT p.*
  FROM prev p
  LEFT JOIN cur c
    ON c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
),
persist AS (      -- in both
  SELECT
    c.eom,
    c.BANK_CODE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.GL_ACCOUNT_HIER_LEVEL_4,
    c.ACCOUNT_IDENTIFIER,
    c.FACILITY_ID,
    c.GL_BALANCE      AS cur_balance,
    p.GL_BALANCE      AS prev_balance,
    c.INDUSTRY_CODE,
    c.PD_GRADE
  FROM cur c
  INNER JOIN prev p
    ON p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
),

-- ====== 3) KPI rollups (by BANK/SYSTEM/GL_L4) ======
kpi AS (
  SELECT
    COALESCE(x.BANK_CODE, y.BANK_CODE, z.BANK_CODE) AS BANK_CODE,
    COALESCE(x.CONTRACT_SOURCE_SYSTEM, y.CONTRACT_SOURCE_SYSTEM, z.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4, y.GL_ACCOUNT_HIER_LEVEL_4, z.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,

    -- EOM NA balance/count (from cur)
    COALESCE( (SELECT SUM(GL_BALANCE) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_balance,
    COALESCE( (SELECT COUNT(*) FROM cur  c
               WHERE c.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND c.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND c.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS na_eom_count,

    -- Adds $/count
    COALESCE( (SELECT SUM(GL_BALANCE) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_balance,
    COALESCE( (SELECT COUNT(*) FROM adds a
               WHERE a.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND a.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND a.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS adds_count,

    -- Removals $/count (use prev_balance dollars)
    COALESCE( (SELECT SUM(GL_BALANCE) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_balance,
    COALESCE( (SELECT COUNT(*) FROM removals r
               WHERE r.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND r.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND r.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS removals_count,

    -- Persisting $/count (use current balances for $)
    COALESCE( (SELECT SUM(cur_balance) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_balance,
    COALESCE( (SELECT COUNT(*) FROM persist p2
               WHERE p2.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE,z.BANK_CODE)
                 AND p2.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM,z.CONTRACT_SOURCE_SYSTEM)
                 AND p2.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4,z.GL_ACCOUNT_HIER_LEVEL_4)
              ), 0) AS persist_count

  FROM (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM cur) x
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM prev) y
    ON y.BANK_CODE=x.BANK_CODE AND y.CONTRACT_SOURCE_SYSTEM=x.CONTRACT_SOURCE_SYSTEM AND y.GL_ACCOUNT_HIER_LEVEL_4=x.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN (SELECT DISTINCT BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4 FROM persist) z
    ON z.BANK_CODE=COALESCE(x.BANK_CODE,y.BANK_CODE)
   AND z.CONTRACT_SOURCE_SYSTEM=COALESCE(x.CONTRACT_SOURCE_SYSTEM,y.CONTRACT_SOURCE_SYSTEM)
   AND z.GL_ACCOUNT_HIER_LEVEL_4=COALESCE(x.GL_ACCOUNT_HIER_LEVEL_4,y.GL_ACCOUNT_HIER_LEVEL_4)
),

-- ====== 4) Waterfall rows (per key) without joining giant sets ======
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    SUM(GL_BALANCE)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM prev
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds', SUM(GL_BALANCE), NULL, NULL
  FROM adds
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals', -SUM(GL_BALANCE), NULL, NULL    -- negative for removals
  FROM removals
  GROUP BY 1,2,3,4,5

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params),
         BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'end_balance', SUM(GL_BALANCE), NULL, NULL
  FROM cur
  GROUP BY 1,2,3,4,5
),

-- ====== 5) Adds composition (Industry / PD_GRADE) ======
adds_comp_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params)   AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50)     AS metric_name,
    SUM(GL_BALANCE)::NUMERIC        AS metric_value,
    COALESCE(INDUSTRY_CODE,'(unknown)') AS extra_dim1,
    COALESCE(PD_GRADE,'(unknown)')      AS extra_dim2
  FROM adds
  GROUP BY 1,2,3,4,5,7,8

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', COUNT(*)::NUMERIC,
    COALESCE(INDUSTRY_CODE,'(unknown)'),
    COALESCE(PD_GRADE,'(unknown)')
  FROM adds
  GROUP BY 1,2,3,4,5,7,8
),

-- ====== 6) KPI long rows (so you can reuse visuals easily) ======
kpi_long AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    na_eom_balance::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', na_eom_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance::NUMERIC, NULL, NULL FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count::NUMERIC, NULL, NULL FROM kpi
)

-- ====== FINAL OUTPUT (long format) ======
SELECT * FROM kpi_long
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM adds_comp_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 20000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag Y/N -> 1/0, use GL_BALANCE, include FACILITY_ID */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.ACCOUNT_IDENTIFIER,
      t.FACILITY_ID,
      t.GL_BALANCE,
      CASE
        WHEN UPPER(TRIM(t.NON_ACCRUAL_FLAG)) IN ('Y','YES','T','TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional
      t.PD_GRADE           -- replaced Risk_Rating
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per account */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_na_flag,
    LAG(b.GL_BALANCE)        OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_balance
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    ACCOUNT_IDENTIFIER, FACILITY_ID,
    GL_BALANCE, prev_balance,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, PD_GRADE,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) using GL_BALANCE */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='ADD'     THEN 1           ELSE 0 END)  AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN 1           ELSE 0 END)  AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN GL_BALANCE   ELSE 0 END) AS persist_balance,
    SUM(CASE WHEN na_transition='PERSIST' THEN 1           ELSE 0 END)  AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS na_eom_balance,
    COUNT(*)        AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) using GL_BALANCE */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS prev_na_balance
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS curr_na_balance
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na2 AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.ACCOUNT_IDENTIFIER ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na2 l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.ACCOUNT_IDENTIFIER ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.ACCOUNT_IDENTIFIER, s.FACILITY_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.PD_GRADE,
    MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) )::INT AS months_since_entry,
    s.GL_BALANCE
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & PD_GRADE) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.PD_GRADE,'(unknown)')      AS PD_GRADE,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN c.na_transition='ADD' THEN 1           ELSE 0 END)    AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50) AS metric_name,
    adds_balance::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    PD_GRADE      AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, PD_GRADE
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag to 1/0, use GL_BALANCE, include FACILITY_ID */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.ACCOUNT_IDENTIFIER,
      t.FACILITY_ID,
      t.GL_BALANCE,
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional, keep if available
      t.PD_GRADE           -- replaced Risk_Rating
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per account */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_na_flag,
    LAG(b.GL_BALANCE)        OVER (PARTITION BY b.ACCOUNT_IDENTIFIER ORDER BY b.eom) AS prev_balance
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    ACCOUNT_IDENTIFIER, FACILITY_ID,
    GL_BALANCE, prev_balance,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, PD_GRADE,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) using GL_BALANCE */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    COUNT(CASE WHEN na_transition='ADD'     THEN 1 END)                  AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance,
    COUNT(CASE WHEN na_transition='REMOVAL' THEN 1 END)                  AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN GL_BALANCE   ELSE 0 END) AS persist_balance,
    COUNT(CASE WHEN na_transition='PERSIST' THEN 1 END)                  AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS na_eom_balance,
    COUNT(*)        AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_balance'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_balance', adds_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_balance', removals_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_balance', persist_balance, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) using GL_BALANCE */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS prev_na_balance
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(GL_BALANCE) AS curr_na_balance
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN GL_BALANCE   ELSE 0 END) AS adds_balance,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_balance ELSE 0 END) AS removals_balance
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_balance,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_balance,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) using ACCOUNT_IDENTIFIER, GL_BALANCE carried for optional weighting */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.ACCOUNT_IDENTIFIER ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.ACCOUNT_IDENTIFIER ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.ACCOUNT_IDENTIFIER, s.FACILITY_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.PD_GRADE,
    MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.ACCOUNT_IDENTIFIER, s.streak_id))) )::INT AS months_since_entry,
    s.GL_BALANCE
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & PD_GRADE) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.PD_GRADE,'(unknown)')      AS PD_GRADE,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.GL_BALANCE   ELSE 0 END) AS adds_balance,
    COUNT(CASE WHEN c.na_transition='ADD' THEN 1 END)                    AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_balance'::VARCHAR(50) AS metric_name,
    adds_balance::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    PD_GRADE      AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, PD_GRADE
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;








WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,      -- latest month-end to report
    17 AS lookback_months               -- prior 17 + current = 18 months
),

/* 0) Base slice (last 18 months); map NA flag to 1/0 */
base AS (
  SELECT
      CAST(t.END_OF_MONTH_DATE AS DATE) AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.LOAN_ID,
      t.EXPOSURE_AMOUNT,
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,     -- optional, keep if available
      t.RISK_RATING        -- optional, keep if available
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months) AND p.asof_eom
),

/* 1) Month-over-month transitions per loan */
lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (PARTITION BY b.LOAN_ID ORDER BY b.eom) AS prev_na_flag,
    LAG(b.EXPOSURE_AMOUNT)  OVER (PARTITION BY b.LOAN_ID ORDER BY b.eom) AS prev_exposure
  FROM base b
),

classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    LOAN_ID, EXPOSURE_AMOUNT, prev_exposure,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, RISK_RATING,
    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
),

/* 2) Current month slice */
current_month AS (
  SELECT c.*
  FROM classified c
  JOIN params p ON c.eom = p.asof_eom
),

/* 3) KPI rollups for current month (by BANK/SYSTEM/GL_L4) */
kpi AS (
  SELECT
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    SUM(CASE WHEN na_transition='ADD'     THEN EXPOSURE_AMOUNT  ELSE 0 END) AS adds_exposure,
    COUNT(CASE WHEN na_transition='ADD'     THEN 1 END)                      AS adds_count,

    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_exposure  ELSE 0 END)   AS removals_exposure,
    COUNT(CASE WHEN na_transition='REMOVAL' THEN 1 END)                      AS removals_count,

    SUM(CASE WHEN na_transition='PERSIST' THEN EXPOSURE_AMOUNT ELSE 0 END)  AS persist_exposure,
    COUNT(CASE WHEN na_transition='PERSIST' THEN 1 END)                      AS persist_count
  FROM current_month
  GROUP BY 1,2,3
),

na_eom AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS na_eom_exposure,
    COUNT(*)             AS na_eom_count
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),

kpi_out AS (
  SELECT
    'KPI'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
    'na_eom_exposure'::VARCHAR(50) AS metric_name,
    COALESCE(n.na_eom_exposure,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), k.BANK_CODE, k.CONTRACT_SOURCE_SYSTEM, k.GL_ACCOUNT_HIER_LEVEL_4,
         'na_eom_count', COALESCE(n.na_eom_count,0), NULL, NULL
  FROM kpi k
  LEFT JOIN na_eom n
    ON n.BANK_CODE=k.BANK_CODE AND n.CONTRACT_SOURCE_SYSTEM=k.CONTRACT_SOURCE_SYSTEM AND n.GL_ACCOUNT_HIER_LEVEL_4=k.GL_ACCOUNT_HIER_LEVEL_4

  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_exposure', adds_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'adds_count', adds_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_exposure', removals_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'removals_count', removals_count, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_exposure', persist_exposure, NULL, NULL
  FROM kpi
  UNION ALL
  SELECT 'KPI', (SELECT asof_eom FROM params), BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
         'persist_count', persist_count, NULL, NULL
  FROM kpi
),

/* 4) Waterfall inputs: Start (prev NA), Adds, Removals, End (curr NA) */
prev_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS prev_na_exposure
  FROM classified c
  JOIN params p ON c.eom = ADD_MONTHS(p.asof_eom, -1)
  WHERE c.NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
curr_na AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(EXPOSURE_AMOUNT) AS curr_na_exposure
  FROM current_month
  WHERE NON_ACCRUAL_FLAG = 1
  GROUP BY 1,2,3
),
flows AS (
  SELECT
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    SUM(CASE WHEN na_transition='ADD'     THEN EXPOSURE_AMOUNT ELSE 0 END) AS adds_exposure,
    SUM(CASE WHEN na_transition='REMOVAL' THEN prev_exposure  ELSE 0 END) AS removals_exposure
  FROM current_month
  GROUP BY 1,2,3
),
waterfall_long AS (
  SELECT
    'WATERFALL'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE) AS BANK_CODE,
    COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4) AS GL_ACCOUNT_HIER_LEVEL_4,
    'start_balance'::VARCHAR(50) AS metric_name,
    COALESCE(p.prev_na_exposure,0)::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'adds', COALESCE(f.adds_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'removals', -COALESCE(f.removals_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)

  UNION ALL
  SELECT 'WATERFALL', (SELECT asof_eom FROM params), 
         COALESCE(c.BANK_CODE,p.BANK_CODE,f.BANK_CODE),
         COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM,f.CONTRACT_SOURCE_SYSTEM),
         COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4,f.GL_ACCOUNT_HIER_LEVEL_4),
         'end_balance', COALESCE(c.curr_na_exposure,0), NULL, NULL
  FROM curr_na c
  FULL OUTER JOIN prev_na p
    ON p.BANK_CODE=c.BANK_CODE AND p.CONTRACT_SOURCE_SYSTEM=c.CONTRACT_SOURCE_SYSTEM AND p.GL_ACCOUNT_HIER_LEVEL_4=c.GL_ACCOUNT_HIER_LEVEL_4
  FULL OUTER JOIN flows f
    ON f.BANK_CODE = COALESCE(c.BANK_CODE,p.BANK_CODE)
   AND f.CONTRACT_SOURCE_SYSTEM = COALESCE(c.CONTRACT_SOURCE_SYSTEM,p.CONTRACT_SOURCE_SYSTEM)
   AND f.GL_ACCOUNT_HIER_LEVEL_4 = COALESCE(c.GL_ACCOUNT_HIER_LEVEL_4,p.GL_ACCOUNT_HIER_LEVEL_4)
),

/* 5) Persistence months (avg duration in NA as of current eom) */
na_only AS (
  SELECT * FROM base WHERE NON_ACCRUAL_FLAG = 1
),
lag_na AS (
  SELECT
    n.*,
    LAG(n.eom) OVER (PARTITION BY n.LOAN_ID ORDER BY n.eom) AS prev_eom
  FROM na_only n
),
entries AS (
  SELECT
    l.*,
    CASE WHEN l.prev_eom IS NULL OR l.prev_eom <> ADD_MONTHS(l.eom,-1) THEN 1 ELSE 0 END AS is_entry
  FROM lag_na l
),
streaks AS (
  SELECT
    e.*,
    SUM(is_entry) OVER (PARTITION BY e.LOAN_ID ORDER BY e.eom) AS streak_id
  FROM entries e
),
fixed_streak_stats AS (
  SELECT
    s.LOAN_ID, s.BANK_CODE, s.CONTRACT_SOURCE_SYSTEM, s.GL_ACCOUNT_HIER_LEVEL_4,
    s.INDUSTRY_CODE, s.RISK_RATING,
    MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id) AS entry_month,
    s.eom,
    ( (EXTRACT(YEAR  FROM s.eom) - EXTRACT(YEAR  FROM MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id))) * 12
    + (EXTRACT(MONTH FROM s.eom) - EXTRACT(MONTH FROM MIN(s.eom) OVER (PARTITION BY s.LOAN_ID, s.streak_id))) )::INT AS months_since_entry,
    s.EXPOSURE_AMOUNT
  FROM streaks s
),
curr_persistence AS (
  SELECT
    f.BANK_CODE, f.CONTRACT_SOURCE_SYSTEM, f.GL_ACCOUNT_HIER_LEVEL_4,
    AVG(months_since_entry)::FLOAT AS avg_persistence_months
  FROM fixed_streak_stats f
  JOIN params p ON f.eom = p.asof_eom
  GROUP BY 1,2,3
),
persistence_long AS (
  SELECT
    'PERSISTENCE'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'avg_persistence_months'::VARCHAR(50) AS metric_name,
    avg_persistence_months::NUMERIC AS metric_value,
    NULL::VARCHAR(100) AS extra_dim1,
    NULL::VARCHAR(100) AS extra_dim2
  FROM curr_persistence
),

/* 6) Adds composition (by Industry & Risk) */
adds_comp AS (
  SELECT
    c.BANK_CODE, c.CONTRACT_SOURCE_SYSTEM, c.GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(c.INDUSTRY_CODE,'(unknown)') AS INDUSTRY_CODE,
    COALESCE(c.RISK_RATING,'(unknown)')   AS RISK_RATING,
    SUM(CASE WHEN c.na_transition='ADD' THEN c.EXPOSURE_AMOUNT ELSE 0 END) AS adds_exposure,
    COUNT(CASE WHEN c.na_transition='ADD' THEN 1 END)                       AS adds_count
  FROM current_month c
  GROUP BY 1,2,3,4,5
),
adds_long AS (
  SELECT
    'ADDS_COMPOSITION'::VARCHAR(20) AS section,
    (SELECT asof_eom FROM params) AS eom,
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_exposure'::VARCHAR(50) AS metric_name,
    adds_exposure::NUMERIC AS metric_value,
    INDUSTRY_CODE AS extra_dim1,
    RISK_RATING  AS extra_dim2
  FROM adds_comp

  UNION ALL
  SELECT
    'ADDS_COMPOSITION', (SELECT asof_eom FROM params),
    BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    'adds_count', adds_count::NUMERIC,
    INDUSTRY_CODE, RISK_RATING
  FROM adds_comp
)

/* === Final unified long-format output === */
SELECT * FROM kpi_out
UNION ALL
SELECT * FROM waterfall_long
UNION ALL
SELECT * FROM persistence_long
UNION ALL
SELECT * FROM adds_long
ORDER BY section, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4, metric_name, extra_dim1, extra_dim2
LIMIT 10000;






WITH params AS (
  SELECT
    DATE '2025-08-31' AS asof_eom,
    17 AS lookback_months   -- prior 17 + current = 18 months total
),
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.LOAN_ID,
      t.EXPOSURE_AMOUNT,
      /* Map Non-Accrual to 1/0 if your source uses Y/N or text */
      CASE
        WHEN t.NON_ACCRUAL_FLAG IN (1, '1', 'Y', 'YES', 'T', 'TRUE') THEN 1
        ELSE 0
      END AS NON_ACCRUAL_FLAG,
      t.INDUSTRY_CODE,
      t.RISK_RATING
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -lookback_months)
                                AND p.asof_eom
)
SELECT *
FROM base
ORDER BY eom DESC
LIMIT 100;





-- Anchor at the latest month-end you want in the dashboard
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    17 AS lookback_months  -- prior 17 + current = 18 months
),

/* Base: keep only fields we need */
base AS (
  SELECT
    t.END_OF_MONTH_DATE::DATE AS eom,
    t.BANK_CODE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.GL_ACCOUNT_HIER_LEVEL_4,
    t.LOAN_ID,
    t.EXPOSURE_AMOUNT,                     -- or your preferred balance
    t.NON_ACCRUAL_FLAG,                    -- 1/0 (adjust if Y/N or text)
    t.INDUSTRY_CODE,                       -- optional
    t.RISK_RATING                          -- optional
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
)




, lagged AS (
  SELECT
    b.*,
    LAG(b.NON_ACCRUAL_FLAG) OVER (
      PARTITION BY b.LOAN_ID
      ORDER BY b.eom
    ) AS prev_na_flag,

    LAG(b.EXPOSURE_AMOUNT) OVER (
      PARTITION BY b.LOAN_ID
      ORDER BY b.eom
    ) AS prev_exposure
  FROM base b
),

/* Classify each loan each month */
classified AS (
  SELECT
    eom, BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4,
    LOAN_ID, EXPOSURE_AMOUNT, prev_exposure,
    NON_ACCRUAL_FLAG, prev_na_flag,
    INDUSTRY_CODE, RISK_RATING,

    CASE
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 0 THEN 'ADD'
      WHEN NON_ACCRUAL_FLAG = 0 AND COALESCE(prev_na_flag,0) = 1 THEN 'REMOVAL'
      WHEN NON_ACCRUAL_FLAG = 1 AND COALESCE(prev_na_flag,0) = 1 THEN 'PERSIST'
      ELSE 'OTHER'
    END AS na_transition
  FROM lagged
)





-- Set the anchor month (latest month-end you want to analyze)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    12                      AS lookback_months,  -- prior 12 + current = 13 months
    2.5::FLOAT              AS z_threshold,
    0.10::FLOAT             AS pct_threshold,    -- 10% MoM % change threshold
    10000000::NUMERIC       AS abs_threshold     -- $10M absolute MoM change threshold
),

/* 1) Pre-aggregate to month × dims to reduce volume */
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.BANK_CODE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE) AS measure_val           -- swap this line to analyze other measures
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
  GROUP BY 1,2,3,4
),

/* 2) Compute prior-month and delta (single window usage) */
calc1 AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      measure_val                                                AS curr_val,
      LAG(measure_val) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                          AS prev_val,
      (measure_val - LAG(measure_val) OVER (
         PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                        AS delta
  FROM base
),

/* 3) Add % change (uses prev_val computed above; still no nesting) */
calc2 AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      curr_val,
      prev_val,
      delta,
      CASE
        WHEN prev_val IS NULL OR prev_val = 0 THEN NULL
        ELSE delta / prev_val
      END AS pct_change
  FROM calc1
),

/* 4) Rolling stats over delta (now delta is a simple column, so no nested window funcs) */
roll AS (
  SELECT
      eom,
      BANK_CODE,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,
      curr_val,
      prev_val,
      delta,
      pct_change,
      AVG(delta)       OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS avg_delta_12,
      STDDEV_SAMP(delta) OVER (
        PARTITION BY BANK_CODE, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      ) AS sd_delta_12
  FROM calc2
),

/* 5) Latest month only + z-score */
scored AS (
  SELECT
      r.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM roll r
  JOIN params p ON r.eom = p.asof_eom
)

/* 6) Flag, rank, and return anomalies */
SELECT
    eom,
    BANK_CODE,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,
    prev_val,
    curr_val,
    delta,
    pct_change,
    avg_delta_12,
    sd_delta_12,
    z_score,

    CASE WHEN z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS flag_z,
    CASE WHEN ABS(delta)      >= p.abs_threshold                        THEN 1 ELSE 0 END AS flag_abs,
    CASE WHEN ABS(pct_change) >= p.pct_threshold                         THEN 1 ELSE 0 END AS flag_pct,

    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
      (z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold)
   OR (ABS(delta)      >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
LIMIT 100;





-- Set the anchor month you want to analyze (latest month-end available)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,
    12                      AS lookback_months,     -- prior 12 + current = 13 months total
    2.5::FLOAT              AS z_threshold,         -- z-score flag threshold
    0.10::FLOAT             AS pct_threshold,       -- 10% MoM % change threshold
    10000000::NUMERIC       AS abs_threshold        -- $10M absolute MoM change threshold
),

/* 1) Pre-aggregate to reduce volume (month × dims) */
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE AS eom,
      t.REVISED_BANK,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE) AS measure_val
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS(p.asof_eom, -p.lookback_months)
                                AND p.asof_eom
  GROUP BY 1,2,3,4
),

/* 2) Compute prior month, MoM Δ and %Δ, plus rolling stats on Δ over prior 12 months */
calc AS (
  SELECT
      eom,
      REVISED_BANK,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      measure_val                                                   AS curr_val,
      LAG(measure_val) OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                             AS prev_val,

      (measure_val - LAG(measure_val) OVER (
         PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                           AS delta,

      CASE
        WHEN LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) IS NULL
             OR LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) = 0
        THEN NULL
        ELSE (measure_val - LAG(measure_val) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ))
             / NULLIF(LAG(measure_val) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ), 0)
      END                                                           AS pct_change,

      AVG( (measure_val - LAG(measure_val) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
           )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                             AS avg_delta_12,

      STDDEV_SAMP( (measure_val - LAG(measure_val) OVER (
                      PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                      ORDER BY eom
                    )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                             AS sd_delta_12
  FROM base
),

/* 3) Compute z-score (for latest month only) */
scored AS (
  SELECT
      c.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM calc c
  JOIN params p ON 1=1
  WHERE c.eom = p.asof_eom
)

/* 4) Flag and rank anomalies for leadership */
SELECT
    eom,
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    prev_val,
    curr_val,
    delta,
    pct_change,
    avg_delta_12,
    sd_delta_12,
    z_score,

    /* Flags */
    CASE WHEN z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS flag_z,
    CASE WHEN ABS(delta)      >= p.abs_threshold                        THEN 1 ELSE 0 END AS flag_abs,
    CASE WHEN ABS(pct_change) >= p.pct_threshold                         THEN 1 ELSE 0 END AS flag_pct,

    /* Composite ranking: materiality first, then z, then % */
    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
      (z_score IS NOT NULL AND ABS(z_score) >= p.z_threshold)
   OR (ABS(delta)      >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
LIMIT 100;





-- Set the anchor month (last month-end you want to analyze)
-- Example: '2025-08-31'
WITH params AS (
    SELECT DATE '2025-08-31'::DATE AS asof_eom
),

-- 1) Pull current and prior month balances, aggregated by dimensions
base AS (
    SELECT
        t.END_OF_MONTH_DATE::DATE AS eom,
        t.REVISED_BANK,
        t.CONTRACT_SOURCE_SYSTEM,
        t.GL_ACCOUNT_HIER_LEVEL_4,
        SUM(t.GL_BALANCE)           AS gl_balance,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS source_system_balance,
        SUM(t.COMMITMENT_BALANCE)    AS commitment_balance,
        SUM(t.EXPOSURE_AMOUNT)       AS exposure_amount,
        SUM(t.AVAILABLE_BALANCE)     AS available_balance
    FROM V_DPRT_CREDIT_INSTRUMENTS t
    JOIN params p ON 1=1
    WHERE t.END_OF_MONTH_DATE IN (p.asof_eom, ADD_MONTHS(p.asof_eom,-1))
    GROUP BY 1,2,3,4
),

-- 2) Pivot to align current and prior month
paired AS (
    SELECT
        REVISED_BANK,
        CONTRACT_SOURCE_SYSTEM,
        GL_ACCOUNT_HIER_LEVEL_4,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN gl_balance END) AS curr_gl_balance,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN gl_balance END) AS prev_gl_balance,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN source_system_balance END) AS curr_source_bal,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN source_system_balance END) AS prev_source_bal,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN commitment_balance END) AS curr_commit,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN commitment_balance END) AS prev_commit,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN exposure_amount END) AS curr_exposure,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN exposure_amount END) AS prev_exposure,

        MAX(CASE WHEN eom = p.asof_eom
                 THEN available_balance END) AS curr_available,
        MAX(CASE WHEN eom = ADD_MONTHS(p.asof_eom,-1)
                 THEN available_balance END) AS prev_available
    FROM base b
    JOIN params p ON 1=1
    GROUP BY 1,2,3
)

-- 3) Calculate variance
SELECT
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    curr_gl_balance, prev_gl_balance,
    (curr_gl_balance - prev_gl_balance) AS gl_delta,
    CASE WHEN prev_gl_balance = 0 OR prev_gl_balance IS NULL
         THEN NULL
         ELSE (curr_gl_balance - prev_gl_balance) / prev_gl_balance
    END AS gl_pct_change,

    curr_source_bal, prev_source_bal,
    (curr_source_bal - prev_source_bal) AS source_delta,

    curr_commit, prev_commit,
    (curr_commit - prev_commit) AS commit_delta,

    curr_exposure, prev_exposure,
    (curr_exposure - prev_exposure) AS exposure_delta,

    curr_available, prev_available,
    (curr_available - prev_available) AS available_delta

FROM paired
ORDER BY ABS(curr_gl_balance - prev_gl_balance) DESC NULLS LAST
FETCH FIRST 50 ROWS ONLY;







WITH detail AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SUM(GL_BALANCE) AS DETAIL_GL_BALANCE
    FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
    WHERE END_OF_MONTH_DATE = DATE '2025-08-31'
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM
),
credit AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SUM(GL_BALANCE) AS CREDIT_GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE END_OF_MONTH_DATE = DATE '2025-08-31'
      AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    GROUP BY END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM
)
SELECT
    COALESCE(d.END_OF_MONTH_DATE, c.END_OF_MONTH_DATE) AS END_OF_MONTH_DATE,
    COALESCE(d.CONTRACT_SOURCE_SYSTEM, c.CONTRACT_SOURCE_SYSTEM) AS CONTRACT_SOURCE_SYSTEM,
    COALESCE(d.DETAIL_GL_BALANCE, 0) AS DETAIL_GL_BALANCE,
    COALESCE(c.CREDIT_GL_BALANCE, 0) AS CREDIT_GL_BALANCE,
    COALESCE(d.DETAIL_GL_BALANCE, 0) - COALESCE(c.CREDIT_GL_BALANCE, 0) AS BALANCE_DIFFERENCE
FROM detail d
FULL OUTER JOIN credit c
  ON d.END_OF_MONTH_DATE = c.END_OF_MONTH_DATE
 AND d.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
ORDER BY CONTRACT_SOURCE_SYSTEM;






-- ====== PARAMETERS: edit these ======
-- Anchor date = last month you want included (month-end date)
-- Example: DATE '2025-08-31'
WITH params AS (
  SELECT
    DATE '2025-08-31'::DATE AS asof_eom,    -- last month-end to include
    12                                    AS lookback_months,  -- rolling window length
    2.5                                   AS z_threshold,      -- flag threshold for |z|
    0.10                                  AS pct_threshold,    -- 10% MoM threshold
    10000000::NUMERIC                     AS abs_threshold     -- $10M absolute change
),

-- 1) Limit to the last (lookback_months + 1) months and pre-aggregate
base AS (
  SELECT
      t.END_OF_MONTH_DATE::DATE                AS eom,
      t.REVISED_BANK,
      t.CONTRACT_SOURCE_SYSTEM,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      SUM(t.GL_BALANCE)                        AS gl_balance
  FROM V_DPRT_CREDIT_INSTRUMENTS t
  JOIN params p ON 1=1
  WHERE t.END_OF_MONTH_DATE BETWEEN
        ADD_MONTHS(p.asof_eom, -(p.lookback_months))  -- include prior 12 months
        AND p.asof_eom
  GROUP BY 1,2,3,4
),

-- 2) Compute prior-month, Δ, %Δ, and rolling stats on Δ
calc AS (
  SELECT
      eom,
      REVISED_BANK,
      CONTRACT_SOURCE_SYSTEM,
      GL_ACCOUNT_HIER_LEVEL_4,

      gl_balance                                           AS curr_bal,
      LAG(gl_balance) OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
      )                                                    AS prev_bal,

      /* MoM absolute change */
      (gl_balance - LAG(gl_balance) OVER (
         PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
         ORDER BY eom
       ))                                                  AS delta,

      /* MoM percent change (guard divide-by-zero) */
      CASE
        WHEN LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) = 0
          OR LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
             ) IS NULL
        THEN NULL
        ELSE (gl_balance - LAG(gl_balance) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ))
             / NULLIF(LAG(gl_balance) OVER (
                PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                ORDER BY eom
             ), 0)
      END                                                  AS pct_change,

      /* Rolling stats of delta over prior N months (exclude current row) */
      AVG( (gl_balance - LAG(gl_balance) OVER (
               PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
               ORDER BY eom
           )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                    AS avg_delta_12,

      STDDEV_SAMP( (gl_balance - LAG(gl_balance) OVER (
                      PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
                      ORDER BY eom
                    )) )
      OVER (
        PARTITION BY REVISED_BANK, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_HIER_LEVEL_4
        ORDER BY eom
        ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
      )                                                    AS sd_delta_12
  FROM base
),

-- 3) Z-score and flags (current month only)
scored AS (
  SELECT
      c.*,
      CASE
        WHEN sd_delta_12 IS NULL OR sd_delta_12 = 0 THEN NULL
        ELSE (delta - avg_delta_12) / sd_delta_12
      END AS z_score
  FROM calc c
  JOIN params p ON 1=1
  WHERE c.eom = p.asof_eom                -- only show flags for latest month
)

-- 4) Rank anomalies and filter to interesting rows
SELECT
    eom,
    REVISED_BANK,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_HIER_LEVEL_4,

    prev_bal,
    curr_bal,
    delta,
    pct_change,
    z_score,

    /* Flags for prioritization */
    CASE WHEN ABS(z_score) >= p.z_threshold THEN 1 ELSE 0 END AS z_flag,
    CASE WHEN ABS(delta)  >= p.abs_threshold THEN 1 ELSE 0 END AS abs_flag,
    CASE WHEN ABS(pct_change) >= p.pct_threshold THEN 1 ELSE 0 END AS pct_flag,

    /* Composite rank: materiality first, then z-score */
    ROW_NUMBER() OVER (
      ORDER BY
        CASE WHEN ABS(delta) >= p.abs_threshold THEN 1 ELSE 0 END DESC,
        ABS(z_score) DESC NULLS LAST,
        ABS(pct_change) DESC NULLS LAST
    ) AS anomaly_rank
FROM scored s
JOIN params p ON 1=1
WHERE
  /* Show rows that trip at least one meaningful flag */
  (ABS(z_score) >= p.z_threshold)
   OR (ABS(delta) >= p.abs_threshold)
   OR (ABS(pct_change) >= p.pct_threshold)
ORDER BY anomaly_rank
;





# Python in Excel — Robust Top-25 review (range/table passed via =PY(...))
# Call example: =PY(Sheet1!A1:Q50000)   <-- include the header row in the range!

import pandas as pd
import numpy as np

# -------------------- ingest from args[0] --------------------
if len(args) == 0:
    raise RuntimeError("No input range passed. Use a formula like =PY(Sheet1!A1:Q50000) that includes the header row.")

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# If columns aren't strings (e.g., 0..N), assume first row contains headers and promote it
if not all(isinstance(c, str) for c in df.columns):
    first = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = first

# Trim header whitespace
df.columns = df.columns.astype(str).str.strip()

# -------------------- Phase 2 core metrics (recompute if missing) --------------------
# Tunables
MIN_HISTORY           = 6
STD_FLOOR_ABS         = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005  # 0.5%

# Ensure numerics if present
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# (Re)compute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# (Re)compute Z with stdev floor if missing / all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    df["Z_Prev12"] = np.nan

# Convenience columns
df["Abs_MoM"]    = df["MoM_Diff"].abs()
df["Pct_Points"] = (df["MoM_Pct"].abs() * 100.0)
df["Abs_Z"]      = df["Z_Prev12"].abs()

# -------------------- Flags + Why --------------------
Z_FLAG_STRICT = 3.0
Z_FLAG_WARN   = 2.0
AMT_FLAG      = 250000
PCT_FLAG      = 0.25  # 25%

df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# -------------------- Severity score + Top-N --------------------
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
df["SeverityScore"] = (
    W_Z   * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

TOP_N = 25
review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# Build tidy output
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# add common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]




import pandas as pd
import numpy as np

TABLE_NAME = "tblPrecomputed"   # <-- no [#All]
TOP_N = 25

# thresholds / weights
MIN_HISTORY           = 6
STD_FLOOR_ABS         = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005
W_Z, W_AMT, W_PCT     = 100.0, 10.0, 1.0
Z_FLAG_STRICT, Z_FLAG_WARN = 3.0, 2.0
AMT_FLAG, PCT_FLAG    = 250000, 0.25

df = xl(TABLE_NAME, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

# numeric
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# recompute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)
if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# recompute Z with floor if missing/all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean, stdev = df["Mean_Prev12"].astype(float), df["StDev_Prev12"].astype(float)
    cnt, curr   = df["Cnt_Prev12"].astype(float), df["SecUnfunded_Curr"].astype(float)
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    df["Z_Prev12"] = np.nan

# convenience + flags
df["Abs_MoM"]    = df["MoM_Diff"].abs()
df["Pct_Points"] = df["MoM_Pct"].abs() * 100.0
df["Abs_Z"]      = df["Z_Prev12"].abs()

df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# severity + top N
df["SeverityScore"] = (
    W_Z * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]





# === Python in Excel: Phase 2 Core Metrics + Flags + Top 25 ===
# Call in a Python cell with no args; it pulls the table via xl()
# Example: =PY()

import pandas as pd
import numpy as np

# -------------------- CONFIG --------------------
TABLE_REF = "tblPrecomputed[#All]"   # change if needed, e.g., "Sheet1!A1:K5000"
TOP_N = 25

# Phase 2 (core metrics) params
MIN_HISTORY           = 6          # min prior months to trust stats
STD_FLOOR_ABS         = 250.0      # absolute stdev floor in $
STD_FLOOR_PCT_OF_MEAN = 0.005      # 0.5% of trailing mean

# Severity weights
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0

# Flag thresholds
Z_FLAG_STRICT = 3.0    # ≥3σ
Z_FLAG_WARN   = 2.0    # ≥2σ
AMT_FLAG      = 250000 # $ MoM
PCT_FLAG      = 0.25   # 25% MoM (0.25 = 25%)

# -------------------- LOAD --------------------
df = xl(TABLE_REF, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

# Validate required columns; some will be recomputed if missing
expected_any = {
    "CreditLineNumber","LoadDate_Curr","SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
}
missing_now = [c for c in expected_any if c not in df.columns]
# it's OK if MoM_* or Z_Prev12 are missing; we'll compute them below

# -------------------- PHASE 2: CORE METRICS --------------------
# 1) Numeric types
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# 2) (Re)compute MoM if missing
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# 3) (Re)compute Z with stdev floor if missing or all-NaN
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
elif "Z_Prev12" not in df.columns:
    # If we can't compute Z and it's not present, create it so downstream works
    df["Z_Prev12"] = np.nan

# 4) Convenience columns
df["Abs_MoM"]     = df["MoM_Diff"].abs()
df["Pct_Points"]  = (df["MoM_Pct"].abs() * 100.0)
df["Abs_Z"]       = df["Z_Prev12"].abs()

# -------------------- FLAGS + WHY --------------------
df["Flag_Z_3plus"]        = (df["Abs_Z"] >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= Z_FLAG_WARN) & (df["Abs_Z"] < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (df["Pct_Points"] >= PCT_FLAG*100).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

def why_row(r):
    bits = []
    if r["Flag_Z_3plus"]:       bits.append("High Z (≥3σ)")
    elif r["Flag_Z_2plus"]:     bits.append("Notable Z (≥2σ)")
    if r["Flag_BigDollar"]:     bits.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if r["Flag_BigPercent"]:    bits.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if r["Flag_ZeroToNonZero"]: bits.append("0 → non-0")
    if r["Flag_NonZeroToZero"]: bits.append("non-0 → 0")
    return "; ".join(bits) if bits else "Severity mix"

df["Why"] = df.apply(why_row, axis=1)

# -------------------- SEVERITY SCORE + TOP N --------------------
df["SeverityScore"] = (
    W_Z   * df["Abs_Z"].fillna(0) +
    W_AMT * np.log10(df["Abs_MoM"].fillna(0) + 1.0) +
    W_PCT * df["Pct_Points"].fillna(0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()

review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# -------------------- OUTPUT --------------------
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# Append common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns and extra not in cols:
        cols.append(extra)

review[cols]




import numpy as np

# --- 0) Parameters (tune as you like) ---
MIN_HISTORY          = 6       # need this many prior months to trust stats
STD_FLOOR_ABS        = 250.0   # absolute stdev floor in $
STD_FLOOR_PCT_OF_MEAN= 0.005   # 0.5% of trailing mean

# --- 1) Ensure numeric types for all stat columns ---
num_cols_expected = [
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
for c in num_cols_expected:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# --- 2) (Re)compute MoM if missing (or keep what’s there) ---
if "MoM_Diff" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    df["MoM_Diff"] = (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]).round(2)

if "MoM_Pct" not in df.columns and {"SecUnfunded_Curr","Prev_SecUnfunded"}.issubset(df.columns):
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df["Prev_SecUnfunded"].fillna(0)==0,
            np.nan,
            (df["SecUnfunded_Curr"] - df["Prev_SecUnfunded"]) / np.abs(df["Prev_SecUnfunded"])
        )

# --- 3) (Re)compute Z with stdev floor if missing or untrusted ---
need_for_z = {"Mean_Prev12","StDev_Prev12","Cnt_Prev12","SecUnfunded_Curr"}
if ("Z_Prev12" not in df.columns or df["Z_Prev12"].isna().all()) and need_for_z.issubset(df.columns):
    mean  = df["Mean_Prev12"].astype(float)
    stdev = df["StDev_Prev12"].astype(float)
    cnt   = df["Cnt_Prev12"].astype(float)
    curr  = df["SecUnfunded_Curr"].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)

# --- 4) Convenience analysis columns ---
df["Abs_MoM"]       = df["MoM_Diff"].abs()
df["Pct_Points"]    = (df["MoM_Pct"].abs() * 100.0)  # %-points
df["Abs_Z"]         = df["Z_Prev12"].abs()

# --- 5) Useful flags for review/explanations ---
df["Flag_Z_3plus"]        = (df["Abs_Z"] >= 3.0).astype(int)
df["Flag_Z_2plus"]        = ((df["Abs_Z"] >= 2.0) & (df["Abs_Z"] < 3.0)).astype(int)
df["Flag_BigDollar"]      = (df["Abs_MoM"] >= 250000).astype(int)   # tweak threshold
df["Flag_BigPercent"]     = (df["Pct_Points"] >= 25).astype(int)    # 25%-points
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)








import pandas as pd
import numpy as np

# ====== CONFIG ======
TABLE_REF = "tblPrecomputed[#All]"  # change if needed (e.g., "Sheet1!A1:K5000")
TOP_N = 25

# thresholds
Z_FLAG_STRICT = 3.0      # severe outlier
Z_FLAG_WARN   = 2.0      # notable outlier
AMT_FLAG      = 250000   # $ change threshold for "Big $" flag
PCT_FLAG      = 0.25     # 25% MoM threshold for "Big %"
# severity weights
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0

# ====== LOAD & CLEAN ======
df = xl(TABLE_REF, headers=True).copy()
df.columns = df.columns.astype(str).str.strip()

required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(f"Missing columns: {missing}\nFound: {sorted(df.columns.tolist())}")

for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# ====== FLAGS ======
abs_z   = df["Z_Prev12"].abs()
abs_amt = df["MoM_Diff"].abs()
abs_pct = df["MoM_Pct"].abs()

df["Flag_Z_3plus"]        = (abs_z >= Z_FLAG_STRICT).astype(int)
df["Flag_Z_2plus"]        = ((abs_z >= Z_FLAG_WARN) & (abs_z < Z_FLAG_STRICT)).astype(int)
df["Flag_BigDollar"]      = (abs_amt >= AMT_FLAG).astype(int)
df["Flag_BigPercent"]     = (abs_pct >= PCT_FLAG).astype(int)
df["Flag_ZeroToNonZero"]  = ((df["Prev_SecUnfunded"].fillna(0)==0) & (df["SecUnfunded_Curr"].fillna(0)!=0)).astype(int)
df["Flag_NonZeroToZero"]  = ((df["Prev_SecUnfunded"].fillna(0)!=0) & (df["SecUnfunded_Curr"].fillna(0)==0)).astype(int)

# human-readable reason
def reason(row):
    r = []
    if row["Flag_Z_3plus"]:       r.append("High Z (≥3σ)")
    elif row["Flag_Z_2plus"]:     r.append("Notable Z (≥2σ)")
    if row["Flag_BigDollar"]:     r.append(f"Big $ (≥{AMT_FLAG:,.0f})")
    if row["Flag_BigPercent"]:    r.append(f"Big % (≥{int(PCT_FLAG*100)}%)")
    if row["Flag_ZeroToNonZero"]: r.append("0 → non-0")
    if row["Flag_NonZeroToZero"]: r.append("non-0 → 0")
    return "; ".join(r) if r else "Severity mix"
df["Why"] = df.apply(reason, axis=1)

# ====== SEVERITY SCORE & RANK ======
df["SeverityScore"] = (
    W_Z   * abs_z.fillna(0) +
    W_AMT * np.log10(abs_amt.fillna(0) + 1.0) +
    W_PCT * (abs_pct.fillna(0) * 100.0)
)

review = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(TOP_N).copy()

review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# ====== OUTPUT (Top 25 with flags & reasons) ======
cols = [
    "SeverityRank","SeverityScore","Why",
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "Flag_Z_3plus","Flag_Z_2plus","Flag_BigDollar","Flag_BigPercent",
    "Flag_ZeroToNonZero","Flag_NonZeroToZero"
]
# include common metadata if present
for extra in ["CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
              "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase","BUSINESS_UNIT"]:
    if extra in review.columns:
        cols.append(extra)

review[cols]





df = xl("tblPrecomputed[#All]", headers=True).copy()
df.columns = df.columns.astype(str).str.strip()




import numpy as np

# Ensure numeric
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# Robust Z (median & MAD over prev 12 months, optional)
# Needs historical data → skip if you only have 1 row/line
df["RobustZ"] = np.nan  # placeholder for now





import pandas as pd
import numpy as np

# 1) Pull your table into a DataFrame.
#    Change the table name if yours is different.
#    headers=True tells Python that the first row contains headers.
df = xl("tblPrecomputed[#All]", headers=True).copy()

# 2) Light sanity check
df.columns = df.columns.astype(str).str.strip()
print("Rows x Cols:", df.shape)
print("First 10 cols:", df.columns.tolist()[:10])

# 3) Expect the precomputed SQL columns (one row per credit line)
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        f"Missing columns: {missing}\n"
        f"Found: {sorted(df.columns.tolist())}\n"
        "Check your header row and table name."
    )

# 4) Fast severity score + Top 25
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct
out = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(25).copy()

out.insert(0, "SeverityRank", np.arange(1, len(out)+1))
out[[
    "SeverityRank","SeverityScore","CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]]






import pandas as pd
df = args[0]
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()
df.head()







import pandas as pd

df = args[0]  # take the first argument passed in (your range or table)
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()

print("Shape:", df.shape)
print("First 5 columns:", df.columns.tolist()[:5])
df.head(5)






# Robust Top-25 review from precomputed SQL result
# Call this cell with a range/table that INCLUDES the header row, e.g.:
#   =PY(tblPrecomputed[#All])    or    =PY(Sheet1!A1:K5000)

import pandas as pd
import numpy as np
import re

TOP_N = 25
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0  # severity weights

# ---------- ingest ----------
if len(args) == 0:
    raise RuntimeError(
        "No input provided. Call like: =PY(tblPrecomputed[#All]) or =PY(Sheet1!A1:K5000) (headers included)."
    )

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# If columns aren't strings (e.g., 0..N), assume first row contains headers and promote it
if not all(isinstance(c, str) for c in df.columns):
    first = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = first

# Normalize headers: strip, lower, replace spaces/dots/dashes with underscores, squeeze repeats
def norm(s):
    s = str(s).strip().lower()
    s = re.sub(r"[ \t\-.]+", "_", s)
    s = re.sub(r"_+", "_", s)
    return s.strip("_")

df.columns = [norm(c) for c in df.columns]

# Build a lookup from normalized name -> original column name
norm_to_orig = {norm(c): c for c in df.columns}  # after norm, norm(c)==c; we’ll keep for clarity

# Required canonical columns and acceptable aliases (normalized)
aliases = {
    "loaddate_curr": {"loaddate_curr","loaddate","load_date_curr","loaddate_current","load_date"},
    "creditlinenumber": {"creditlinenumber","credit_line_number","cln","line_number"},
    "secunfunded_curr": {"secunfunded_curr","secunfunded","sec_unfunded_curr","secured_unfunded_curr"},
    "prev_secunfunded": {"prev_secunfunded","prev_sec_unfunded","previous_secunfunded","secunfunded_prev"},
    "mom_diff": {"mom_diff","mom$","delta","change","mom_change"},
    "mom_pct": {"mom_pct","mom%","pct_change","percent_change","mom_percent"},
    "mean_prev12": {"mean_prev12","avg_prev12","mean_12","rolling_mean_12"},
    "stdev_prev12": {"stdev_prev12","std_prev12","stddev_prev12","rolling_std_12","stdev"},
    "cnt_prev12": {"cnt_prev12","count_prev12","n_prev12","count_12"},
    "z_prev12": {"z_prev12","zscore","z_score_prev12","z"},
}

# Resolve each canonical column by checking aliases against normalized df columns
resolved = {}
missing = []
for canon, opts in aliases.items():
    found = None
    for opt in opts:
        if opt in df.columns:
            found = opt
            break
    if found:
        resolved[canon] = found
    else:
        missing.append(canon)

# If many are missing, show diagnostics to help fix the input
if missing:
    # Show what we do have (first 20 normalized headers)
    have = ", ".join(list(df.columns)[:20])
    raise ValueError(
        "Some expected columns were not found.\n"
        f"Missing (canonical names): {missing}\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and the header row is included.\n"
        f"Detected (normalized) headers: {have}\n"
        "Tip: If your headers look different, rename them in Excel to the expected names."
    )

# For convenience, get original names (they're equal to normalized now, but left here for clarity)
c = resolved  # shorthand

# Make numerics numeric
num_cols = [c["secunfunded_curr"], c["prev_secunfunded"], c["mom_diff"], c["mom_pct"],
            c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"]]
for col in num_cols:
    df[col] = pd.to_numeric(df[col], errors="coerce")

# Severity score (simple & fast)
abs_z   = df[c["z_prev12"]].abs().fillna(0.0)
abs_amt = df[c["mom_diff"]].abs().fillna(0.0)
abs_pct = (df[c["mom_pct"]].abs() * 100.0).fillna(0.0)

df["severity_score"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct

# Sort & take Top N
order = ["severity_score", c["z_prev12"], c["mom_diff"], c["mom_pct"], c["creditlinenumber"]]
out = df.sort_values(order, ascending=[False, False, False, False, True]).head(TOP_N).copy()
out.insert(0, "severity_rank", np.arange(1, len(out)+1))

# Build tidy output (include common metadata if present)
cols = [
    "severity_rank","severity_score",
    c["creditlinenumber"], c["loaddate_curr"],
    c["secunfunded_curr"], c["prev_secunfunded"],
    c["mom_diff"], c["mom_pct"],
    c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"],
]
# Try to add nice-to-have metadata if columns exist with common names
for extra in ["cif","clientname","applid","formulaline","revolvingflag","line_status",
              "netlineamount","netutilized","netdisbursed","netborrowingbase","business_unit"]:
    if extra in df.columns:
        cols.append(extra)

# Drop any that aren't present (shouldn't be necessary but safe)
cols = [col for col in cols if col in out.columns]

# Return to Excel
out[cols]






# --- DIAGNOSTIC: just tell me what you passed in ---
import pandas as pd

if len(args) == 0:
    raise RuntimeError("No input given. Call like: =PY(<cell>, Sheet1!A1:Q50000) or =PY(<cell>, MyTable[#All])")

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# Try to detect if the FIRST ROW contains your headers; if so, promote it.
first_row = df.iloc[0].astype(str).str.strip().tolist()
expected_any = {"CreditLineNumber","LoadDate_Curr","SecUnfunded_Curr"}  # from precompute SQL
headers_look_ok = len(set(first_row) & expected_any) > 0

if headers_look_ok and "CreditLineNumber" not in df.columns:
    df.columns = [str(x).strip() for x in first_row]
    df = df.iloc[1:].reset_index(drop=True)

# Always strip column whitespace
df.columns = df.columns.astype(str).str.strip()

print("Shape (rows, cols):", df.shape)
print("First 12 column names:", df.columns.tolist()[:12])

# Show the first 5 rows so we can see if headers are correct
df.head(5)







# Python in Excel — Range-Passed Review (fast, no name lookup)
# Call pattern:
#   =PY(<this_cell>, Sheet1!A1:Q50000)
#   =PY(<this_cell>, tblPrecomputed[#All])

import numpy as np
import pandas as pd

# ---------- CONFIG ----------
TOP_N = 25                 # rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold (still ranked by score)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0   # severity weights

# ---------- INPUT ----------
if len(args) == 0:
    raise RuntimeError(
        "No input range provided. In the formula bar, pass a range or table, e.g.:\n"
        "  =PY(<this_cell>, Sheet1!A1:Q50000)\n"
        "  =PY(<this_cell>, tblPrecomputed[#All])"
    )

df = args[0].copy()
if not isinstance(df, pd.DataFrame):
    # If Excel passed a numpy array, convert to DataFrame
    df = pd.DataFrame(df)

# Normalize headers (first row must be headers in the passed range/table)
df.columns = df.columns.astype(str).str.strip()

# ---------- REQUIRED COLUMNS (from the precompute SQL) ----------
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        "Missing required columns: %s\n"
        "Found columns: %s\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and included the header row in the range."
        % (missing, sorted(df.columns.tolist()))
    )

# ---------- TYPES ----------
num_cols = ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
            "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]
for c in num_cols:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# ---------- SEVERITY SCORE (very light) ----------
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = (
    W_Z * abs_z +
    W_AMT * np.log10(abs_amt + 1.0) +
    W_PCT * abs_pct
)

# Optional: force-include Z outliers (|Z| >= threshold)
mask_z = abs_z >= Z_THRESHOLD

# Final ranking
order_cols = ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"]
review = df.sort_values(order_cols, ascending=[False, False, False, False, True]).copy()

# If you want to *only* include Z-outliers + top-N by SeverityScore, uncomment below:
# review = review[mask_z].copy() if mask_z.any() else review

# Keep top N
review = review.head(TOP_N).reset_index(drop=True)

# Build clean output
cols = [
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "SeverityScore"
]
# Only include those that exist (in case extra columns came through)
cols = [c for c in cols if c in review.columns]

# Add a 1-based rank
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# Return to Excel
review[["SeverityRank"] + cols]





# Minimal check that Python can see your table and how big it is.
TABLE_NAME = "tblPrecomputed"  # <- change if your table has a different name

df = xl(TABLE_NAME)
print("Rows x Cols:", df.shape)
df.columns = df.columns.str.strip()
print("Sample cols:", df.columns.tolist()[:12])
df.head(3)



# ==============================
# Clean Review Builder (fast)
# Works with *precomputed* SQL output per line (latest month)
# ==============================

import re
import numpy as np
import pandas as pd

# ---- Set this to your Excel Table / Named Range ----
TABLE_NAME = "tblPrecomputed"   # <-- change to your actual table name

# ---- Tunable parameters ----
TOP_N = 50                 # number of rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold
DOLLAR_ALWAYS_INCLUDE = None  # e.g., 250000 to always include very large $ moves

# Severity weights
W_Z   = 100.0    # per 1.0 of |Z|
W_AMT = 10.0     # per log10(|$|+1)
W_PCT = 1.0      # per percentage point (100 * |MoM_Pct|)

# Z stdev floor (Fix A) used if we need to recompute Z
MIN_HISTORY = 6
STD_FLOOR_ABS = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005  # 0.5% of mean

# ---- Load data from Excel ----
df = xl(TABLE_NAME)

# Normalize column names: strip spaces
df.columns = df.columns.str.strip()

# Helper: pick a column by preferred name, falling back to suffixed variants (e.g., "Z_Prev12.1")
def pick(colname: str) -> str | None:
    if colname in df.columns:
        return colname
    # exact suffix like .1 or .2
    matches = [c for c in df.columns if re.fullmatch(fr"{re.escape(colname)}(\.\d+)?", str(c))]
    return matches[0] if matches else None

# Map required columns (accept a couple of common variants)
col_LoadDate   = pick("LoadDate_Curr") or pick("LoadDate")
col_CLN        = pick("CreditLineNumber")
col_SecCurr    = pick("SecUnfunded_Curr") or pick("SecUnfunded")
col_SecPrev    = pick("Prev_SecUnfunded")
col_Mean       = pick("Mean_Prev12")
col_StDev      = pick("StDev_Prev12")
col_Cnt        = pick("Cnt_Prev12")
col_MoMdiff    = pick("MoM_Diff")
col_MoMpct     = pick("MoM_Pct")
col_Z          = pick("Z_Prev12")

required = {
    "CreditLineNumber": col_CLN,
    "LoadDate (Curr or generic)": col_LoadDate,
    "SecUnfunded (Curr or generic)": col_SecCurr,
}
missing_core = [k for k,v in required.items() if v is None]
if missing_core:
    raise ValueError(
        "Your table is missing core columns needed for ranking.\n"
        f"Missing: {missing_core}\n"
        f"Columns found: {sorted(df.columns.tolist())}"
    )

# Ensure numeric types for calculations
for c in [col_SecCurr, col_SecPrev, col_Mean, col_StDev, col_Cnt, col_MoMdiff, col_MoMpct, col_Z]:
    if c and c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Compute MoM fields if they’re missing but we have current/prev
if col_MoMdiff is None and col_SecPrev:
    df["MoM_Diff"] = (df[col_SecCurr] - df[col_SecPrev]).round(2)
    col_MoMdiff = "MoM_Diff"

if col_MoMpct is None and col_SecPrev:
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df[col_SecPrev].fillna(0) == 0,
            np.nan,
            (df[col_SecCurr] - df[col_SecPrev]) / np.abs(df[col_SecPrev])
        )
    col_MoMpct = "MoM_Pct"

# Recompute Z if missing and inputs exist (uses same stdev floor logic you asked for)
if col_Z is None and all(x is not None for x in [col_Mean, col_StDev, col_Cnt]):
    mean = df[col_Mean].astype(float)
    stdev = df[col_StDev].astype(float)
    cnt = df[col_Cnt].astype(float)
    curr = df[col_SecCurr].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
    col_Z = "Z_Prev12"

# Build severity components (handle nulls)
df["AbsZ"]          = df[col_Z].abs() if col_Z else 0.0
df["AbsAmt"]        = df[col_MoMdiff].abs() if col_MoMdiff else 0.0
df["AbsPctPoints"]  = (df[col_MoMpct].abs() * 100.0).fillna(0) if col_MoMpct else 0.0

# Composite SeverityScore
df["SeverityScore"] = (
    W_Z   * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1.0) +
    W_PCT * df["AbsPctPoints"]
)

# Candidate filters (fast)
mask_z   = (df["AbsZ"].notna()) & (df["AbsZ"] >= Z_THRESHOLD) if col_Z else False
mask_top = df["AbsAmt"].rank(method="first", ascending=False) <= TOP_N if col_MoMdiff else False
mask_big = (df["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE) if DOLLAR_ALWAYS_INCLUDE is not None else False

# If none of the masks exist (e.g., missing MoM), just sort everything and take TOP_N
if (isinstance(mask_z, bool) and isinstance(mask_top, bool) and isinstance(mask_big, bool)):
    review = df.copy()
else:
    review = df[ mask_z | mask_top | mask_big ].copy()
    if review.empty:
        # Fallback: take top-N by SeverityScore
        review = df.copy()

# Final ordering & rank
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints", col_CLN],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)

# Build clean output with whatever columns are available
cols_keep = [
    "SeverityRank","SeverityScore",
    col_LoadDate, col_CLN,
    "AbsAmt","AbsPctPoints","AbsZ",
]
# Add common fields if present
for c in [
    col_SecPrev, col_SecCurr, col_MoMdiff, col_MoMpct,
    col_Mean, col_StDev, col_Cnt, col_Z,
    "CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
    "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "BUSINESS_UNIT"
]:
    if c and c in review.columns and c not in cols_keep:
        cols_keep.append(c)

# Make nicer header names (optional)
rename_map = {
    col_LoadDate: "LoadDate",
    col_CLN: "CreditLineNumber",
    col_SecCurr: "SecUnfunded_Curr",
    col_SecPrev: "Prev_SecUnfunded",
    col_MoMdiff: "MoM_Diff",
    col_MoMpct:  "MoM_Pct",
    col_Mean:    "Mean_Prev12",
    col_StDev:   "StDev_Prev12",
    col_Cnt:     "Cnt_Prev12",
    col_Z:       "Z_Prev12",
}
review_out = review[cols_keep].rename(columns={k:v for k,v in rename_map.items() if k})

# Return only the top N rows to Excel (fast)
review_out.head(TOP_N)







df = xl("tblPrecomputed")  # the result of the SQL above
df["AbsZ"] = df["Z_Prev12"].abs()
df["AbsAmt"] = df["MoM_Diff"].abs()
df["AbsPctPoints"] = (df["MoM_Pct"].abs() * 100).fillna(0)

# Simple severity score (same weights as before)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
df["SeverityScore"] = (
    W_Z * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1) +
    W_PCT * df["AbsPctPoints"]
)

review = df.sort_values(
    ["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)
review.head(50)  # return top 50 only




/*==============================================================
  Portfolio Variance Precompute (hand-off to Python/Excel)
  - Population from CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
  - SecUnfunded from CALCULATED_UNFUNDED
  - Current EOM = last day of previous month
  - Output: ONE row per CreditLineNumber (latest ≤ @CurrEOM) with:
      Prev_SecUnfunded, Mean_Prev12, StDev_Prev12 (prev-12 only),
      Z_Prev12 (with stdev floor), MoM_Diff, MoM_Pct,
      and requested CLM metadata/amounts
==============================================================*/

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13; -- current + prior 12
-- Current EOM without EOMONTH(): last day of previous month
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

-- Z-score floor (Fix A)
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean
DECLARE @MinHistory          int           = 6;       -- min months in prev window to compute Z

;WITH base AS (
    /* Pull last 13 months for BUS00 population from CLM, join SecUnfunded from CU */
    SELECT
        cl.LoadDate,
        cl.CreditLineNumber,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BUSINESS_UNIT,
        cl.RevolvingFlag,
        cl.Line_Status,

        CAST(cl.NetLineAmount    AS decimal(38,2)) AS NetLineAmount,
        CAST(cl.NetUtilized      AS decimal(38,2)) AS NetUtilized,
        CAST(cl.NetDisbursed     AS decimal(38,2)) AS NetDisbursed,
        CAST(cl.NetBorrowingBase AS decimal(38,2)) AS NetBorrowingBase,

        CAST(cu.SecUnfunded      AS decimal(38,2)) AS SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
           ON cu.LoadDate         = cl.LoadDate
          AND cu.CreditLineNumber = cl.CreditLineNumber
    WHERE cl.BUSINESS_UNIT = 'BUS00'
      AND cl.LoadDate >= @StartEOM
      AND cl.LoadDate <= @CurrEOM
),
series AS (
    /* Compute per-line rolling (prev-12) stats and prev month */
    SELECT
        b.*,

        LAG(b.SecUnfunded, 1) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
        ) AS Prev_SecUnfunded,

        /* prev-12 window excludes the current row via ... AND 1 PRECEDING */
        AVG(b.SecUnfunded)   OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Mean_Prev12,

        STDEV(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS StDev_Prev12,

        COUNT(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Cnt_Prev12,

        ROW_NUMBER() OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate DESC
        ) AS rn_desc
    FROM base b
),
calc AS (
    /* Keep latest available month per line; compute MoM, Z with stdev floor */
    SELECT
        s.LoadDate                       AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF,
        s.ClientName,
        s.ApplID,
        s.FormulaLine,
        s.BUSINESS_UNIT,
        s.RevolvingFlag,
        s.Line_Status,

        s.NetLineAmount,
        s.NetUtilized,
        s.NetDisbursed,
        s.NetBorrowingBase,

        s.SecUnfunded                   AS SecUnfunded_Curr,
        s.Prev_SecUnfunded,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(
            CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                 ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
            END AS decimal(38,6)
        ) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4)) AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
        s.Cnt_Prev12,

        /* Z-score with stdev floor (Fix A):
           floor = MAX(@StdFloorAbs, ABS(Mean_Prev12) * @StdFloorPctOfMean).
           If StDev_Prev12 < floor OR insufficient history => Z = NULL.
        */
        CAST(
            CASE
              WHEN s.Cnt_Prev12 < @MinHistory THEN NULL
              WHEN s.StDev_Prev12 IS NULL THEN NULL
              WHEN s.StDev_Prev12 <
                   CASE
                     WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                     ELSE CASE
                            WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                                 THEN @StdFloorAbs
                                 ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                          END
                   END
                   THEN NULL
              ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
            END AS decimal(38,4)
        ) AS Z_Prev12
    FROM series s
    WHERE s.rn_desc = 1
)
SELECT
    c.LoadDate_Curr,
    c.CreditLineNumber,
    c.CIF,
    c.ClientName,
    c.ApplID,
    c.FormulaLine,
    c.BUSINESS_UNIT,
    c.RevolvingFlag,
    c.Line_Status,

    c.NetLineAmount,
    c.NetUtilized,
    c.NetDisbursed,
    c.NetBorrowingBase,

    c.Prev_SecUnfunded,
    c.SecUnfunded_Curr,
    c.MoM_Diff,
    c.MoM_Pct,

    c.Mean_Prev12,
    c.StDev_Prev12,
    c.Cnt_Prev12,
    c.Z_Prev12
FROM calc c
ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber;






# Python in Excel: Portfolio variance & outlier review
# Requirements: your SQL extract is in an Excel Table named "tblCreditLines"

import pandas as pd
import numpy as np
from datetime import date
try:
    # Python in Excel function to pull an Excel Table by name
    df = xl("tblCreditLines")
except NameError:
    # Fallback for testing outside Excel: df must be defined externally
    raise RuntimeError("In Python in Excel, rename your data table to 'tblCreditLines' and re-run this cell.")

# -------------------------
# Tunable parameters
# -------------------------
LOOKBACK = 12                # trailing months (excluding current month)
MIN_HISTORY = 6              # minimum months to compute any Z/Robust Z
Z_THRESHOLD = 2.0            # notable Z
ROBUST_Z_THRESHOLD = 2.5     # optional robust Z threshold for review
TOP_N = 25                   # top N by $ move (abs)
DOLLAR_ALWAYS_INCLUDE = None # e.g., 250000 to always include very large $ moves

# Stdev floor (Fix A)
STD_FLOOR_ABS = 250.0        # absolute $ floor
STD_FLOOR_PCT_OF_MEAN = 0.005 # 0.5% of trailing mean

# SeverityScore weights
W_Z = 100.0                  # weight per 1.0 of |Z|
W_AMT = 10.0                 # weight per log10(|$|+1)
W_PCT = 1.0                  # weight per percentage point (100 * |MoM_Pct|)

# -------------------------
# Prep & sanity checks
# -------------------------
# Ensure expected columns exist
expected_cols = {
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "BusinessUnit","RevolvingFlag","Line_Status","NetLineAmount","NetUtilized",
    "NetDisbursed","NetBorrowingBase","SecUnfunded"
}
missing = sorted(list(expected_cols - set(df.columns)))
if missing:
    raise ValueError(f"Missing columns in Excel table: {missing}")

# Filter to BusinessUnit='BUS00' (population per your requirement)
df = df[df["BusinessUnit"] == "BUS00"].copy()

# Parse dates and sort
df["LoadDate"] = pd.to_datetime(df["LoadDate"]).dt.date
df = df.sort_values(["CreditLineNumber","LoadDate"]).reset_index(drop=True)

# Latest month-end anchor = last day of previous month relative to "today"
today = date.today()
curr_eom = (pd.Timestamp(today).to_period("M") - 1).to_timestamp("M").date()
df = df[df["LoadDate"] <= curr_eom].copy()

# -----------------------------------------
# Per-line rolling stats (exclude current)
# -----------------------------------------
def compute_metrics(g: pd.DataFrame) -> pd.DataFrame:
    g = g.sort_values("LoadDate").copy()
    s = g["SecUnfunded"].astype(float)

    # Prior month
    g["Prev_SecUnfunded"] = s.shift(1)

    # Trailing (prev-12) windows built on the *shifted* series so current is excluded
    prev = s.shift(1)

    roll = prev.rolling(window=LOOKBACK, min_periods=MIN_HISTORY)
    g["Mean_Prev12"] = roll.mean()
    g["StDev_Prev12"] = roll.std(ddof=1)

    # Z with stdev floor
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(g["Mean_Prev12"]) * STD_FLOOR_PCT_OF_MEAN)
    z_num = (s - g["Mean_Prev12"])
    z_den = g["StDev_Prev12"]
    z_ok = (g["StDev_Prev12"].notna()) & (g["StDev_Prev12"] >= eff_floor) & (roll.count() >= MIN_HISTORY)
    g["Z_Prev12"] = np.where(z_ok, z_num / z_den, np.nan)

    # Robust Z: median & MAD on prev-12 (exclude current)
    med_prev12 = roll.median()
    # MAD: median of |prev - median|
    mad_prev12 = (prev - med_prev12).abs().rolling(window=LOOKBACK, min_periods=MIN_HISTORY).median()
    robust_den_ok = (mad_prev12.notna()) & (mad_prev12 > 0) & (roll.count() >= MIN_HISTORY)
    g["RobustZ_Prev12"] = np.where(
        robust_den_ok, 0.6745 * (s - med_prev12) / mad_prev12, np.nan
    )

    # MoM diffs
    g["MoM_Diff"] = (s - g["Prev_SecUnfunded"]).round(2)
    with np.errstate(divide="ignore", invalid="ignore"):
        g["MoM_Pct"] = np.where(
            g["Prev_SecUnfunded"].fillna(0) == 0,
            np.nan,
            (s - g["Prev_SecUnfunded"]) / np.abs(g["Prev_SecUnfunded"])
        )

    return g

df_metrics = df.groupby("CreditLineNumber", group_keys=False).apply(compute_metrics)

# -----------------------------------------
# Latest month per credit line (on/before curr_eom)
# -----------------------------------------
idx_latest = df_metrics.groupby("CreditLineNumber")["LoadDate"].transform("max") == df_metrics["LoadDate"]
latest = df_metrics[idx_latest].copy()

# SeverityScore & Rank
latest["AbsZ"] = latest["Z_Prev12"].abs()
latest["AbsAmt"] = latest["MoM_Diff"].abs()
latest["AbsPctPoints"] = (latest["MoM_Pct"].abs() * 100.0).fillna(0)

latest["SeverityScore"] = (
    W_Z * latest["AbsZ"].fillna(0)
    + W_AMT * np.log10(latest["AbsAmt"].fillna(0) + 1.0)
    + W_PCT * latest["AbsPctPoints"]
)

# Candidate sets: Z outliers, Top-N $ movers, optional dollar threshold
mask_z = (latest["AbsZ"].notna()) & (latest["AbsZ"] >= Z_THRESHOLD)
top_n_idx = latest["AbsAmt"].rank(method="first", ascending=False) <= TOP_N
if DOLLAR_ALWAYS_INCLUDE is not None:
    mask_big = latest["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE
else:
    mask_big = pd.Series(False, index=latest.index)

review = latest[mask_z | top_n_idx | mask_big].copy()

# Rank rows for review
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review) + 1)

# Optional: also include RobustZ thresholding (uncomment if you want it to force include)
# mask_robust = review["RobustZ_Prev12"].abs() >= ROBUST_Z_THRESHOLD
# review.loc[mask_robust & ~mask_z, "SeverityScore"] += 50.0  # small bump for robust-only outliers
# review = review.sort_values(by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
#                             ascending=[False, False, False, False, True]).reset_index(drop=True)
# review["SeverityRank"] = np.arange(1, len(review) + 1)

# Select final columns for Excel
cols_out = [
    "SeverityRank","SeverityScore",
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "RevolvingFlag","Line_Status","NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "Prev_SecUnfunded","SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Z_Prev12","RobustZ_Prev12"
]
review_out = review[cols_out]

# Return the review table back to Excel (spills into the sheet)
review_out



-- Base extract for Python-in-Excel variance analysis
-- Population = CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
-- SecUnfunded pulled from CALCULATED_UNFUNDED

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Latest month-end (works without EOMONTH)
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cl.LoadDate,
    cl.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BUSINESS_UNIT,
    cl.RevolvingFlag,
    cl.Line_Status,

    -- Amounts from CREDIT_LINE_MONTHLY
    CAST(cl.NetLineAmount     AS decimal(38,2)) AS NetLineAmount,
    CAST(cl.NetUtilized       AS decimal(38,2)) AS NetUtilized,
    CAST(cl.NetDisbursed      AS decimal(38,2)) AS NetDisbursed,
    CAST(cl.NetBorrowingBase  AS decimal(38,2)) AS NetBorrowingBase,

    -- Only SecUnfunded from CALCULATED_UNFUNDED
    CAST(cu.SecUnfunded       AS decimal(38,2)) AS SecUnfunded

FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
       ON cu.LoadDate         = cl.LoadDate
      AND cu.CreditLineNumber = cl.CreditLineNumber

WHERE cl.LoadDate >= @StartEOM
  AND cl.LoadDate <= @CurrEOM
  AND cl.BUSINESS_UNIT = 'BUS00'

-- Optional scope refinements (uncomment as needed):
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
--   AND cl.Line_Status IN ('Active','Open')

ORDER BY cl.LoadDate, cl.CreditLineNumber;





-- Base extract for Python-in-Excel variance analysis
-- One row per (LoadDate, CreditLineNumber)

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Compute latest month end (works without EOMONTH)
DECLARE @CurrEOM date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cu.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
       ON cl.LoadDate = cu.LoadDate
      AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate >= @StartEOM
  AND cu.LoadDate <= @CurrEOM
-- Optional scope filters:
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
ORDER BY cu.LoadDate, cu.CreditLineNumber;






/*==============================================================
  Base extract for Python-in-Excel variance analysis
  - SQL Server (CRDLMTUFCALC)
  - Pulls current EOM (as of today) + trailing @LookbackMonths-1 EOMs
  - One row per (LoadDate, CreditLineNumber)
==============================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM         date = EOMONTH(GETDATE(), -1);  -- e.g., today 2025-09-05 -> 2025-08-31
DECLARE @LookbackMonths  int  = 13;  -- current + prior 12 (adjust if you want more history)

;WITH rng AS (
    SELECT
        /* Start at the earliest month we want to include */
        EOMONTH(DATEADD(MONTH, -( @LookbackMonths - 1 ), @CurrEOM)) AS StartEOM,
        @CurrEOM AS EndEOM
),
-- Pull SecUnfunded + join line metadata
raw AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM

    /* Optional: scope filters (uncomment as desired)
       AND cl.ApplID = 'LN'
       AND cl.FormulaLine = 1
       -- AND cl.ClientName IS NOT NULL
       -- AND cu.CreditLineNumber IN ('123456','789012')
    */
),
/* If your source can have duplicates per (LoadDate, CreditLineNumber)
   (e.g., multiple calc runs without RunID scoping), keep a deterministic
   single record. MAX() is a safe choice for balances that should end
   the month at a single figure. Switch to SUM() if your data model
   expects summation across fragments. */
dedup AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        MAX(SecUnfunded) AS SecUnfunded,   -- or SUM(SecUnfunded)
        MAX(CIF)         AS CIF,
        MAX(ClientName)  AS ClientName,
        MAX(ApplID)      AS ApplID,
        MAX(FormulaLine) AS FormulaLine
    FROM raw
    GROUP BY LoadDate, CreditLineNumber
)
SELECT
    LoadDate,
    CreditLineNumber,
    SecUnfunded,      -- numeric, cast already applied
    CIF,
    ClientName,
    ApplID,
    FormulaLine
FROM dedup
ORDER BY LoadDate, CreditLineNumber;








/*=============================================================================
  Portfolio-Wide Review with StDev Floor (Fix A) + SeverityScore/Rank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Rolling Z vs trailing 12 months (excluding current), with stdev floor
  - Returns union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;   -- notable outlier
DECLARE @TopN             int           = 25;       -- top-N abs $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;     -- e.g., 250000 to always include big $ moves

-- Severity weights (tune as you like)
DECLARE @wZ   float = 100.0;   -- per 1.0 of |Z|
DECLARE @wAmt float = 10.0;    -- per log10(|$|+1)
DECLARE @wPct float = 1.0;     -- per percentage point (100×|MoM_Pct|)

-- *** Fix A: StDev floor parameters ***
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        /* -------- Fix A: Z with stdev floor --------
           Effective floor = MAX(@StdFloorAbs, |Mean_Prev12| * @StdFloorPctOfMean)
           If StDev_Prev12 < floor => Z = NULL (unreliable)
        */
        CAST(
          CASE 
            WHEN s.Cnt_Prev12 < 6 THEN NULL  -- require minimum history
            WHEN s.StDev_Prev12 IS NULL THEN NULL
            WHEN s.StDev_Prev12 <
                 CASE 
                   WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                   ELSE
                     CASE 
                       WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                            THEN @StdFloorAbs
                            ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                     END
                 END
              THEN NULL
            ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
          END AS decimal(38,4)
        ) AS Z_Prev12

    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        ABS(ISNULL(rs.Z_Prev12, 0))             AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0) AS LogAmt,
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0       AS AbsPctPoints,

        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0)) AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;









DECLARE @StdFloorAbs       decimal(38,6) = 250.0;   -- absolute stdev floor in $
DECLARE @StdFloorPctOfMean decimal(9,6)  = 0.005;   -- 0.5% of trailing mean




-- Effective floor = max(abs floor, % of mean)
CAST(
  CASE
    WHEN s.Cnt_Prev12 < 6 THEN NULL
    ELSE
      CASE 
        WHEN s.StDev_Prev12 IS NULL THEN NULL
        WHEN s.StDev_Prev12 < 
             CASE 
               WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
               ELSE 
                 CASE 
                   WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                        THEN @StdFloorAbs
                        ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                 END
             END
          THEN NULL
        ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
      END
  END AS decimal(38,4)
) AS Z_Prev12







/*=============================================================================
  Portfolio-Wide Review with SeverityScore + SeverityRank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Compute MoM change + Z vs trailing 12 months (excluding current)
  - Return union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
  - Compute SeverityScore and SeverityRank for the final set
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;  -- notable outlier
DECLARE @TopN             int           = 25;      -- top-N absolute $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;    -- e.g., 250000 to always include big $ moves

-- Severity weights (tune these)
DECLARE @wZ   float = 100.0;  -- impact per 1.0 of |Z|
DECLARE @wAmt float = 10.0;   -- impact per log10(|$|+1)
DECLARE @wPct float = 1.0;    -- impact per percentage point of |MoM_Pct| (i.e., 100 * fraction)

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        CAST(CASE WHEN s.StDev_Prev12 IS NULL OR s.StDev_Prev12=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
             END AS decimal(38,4)) AS Z_Prev12,

        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)=0 AND ISNULL(s.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)<>0 AND ISNULL(s.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        -- Components for scoring
        ABS(ISNULL(rs.Z_Prev12, 0))                    AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)        AS LogAmt,               -- stable scale for $ moves
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0              AS AbsPctPoints,         -- convert fraction to pct points

        -- Final SeverityScore (tunable weights)
        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0))  AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.Flag_ZeroToNonZero,
    s.Flag_NonZeroToZero,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;







/*==========================================================
  Single-CreditLine Variance Analysis (12M history + Z-score)
  - Anchors current EOM to latest month-end relative to today
    (e.g., if today is 2025-09-04 -> current EOM = 2025-08-31)
  - Pulls up to 12 prior EOMs (plus current), handles gaps
  - Computes MoM diffs, trailing-12 mean/stdev (prev-12 only),
    and Z-score vs trailing 12 (statistically sound)
==========================================================*/

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line
DECLARE @LookbackMonths    int        = 12;
DECLARE @NaturalCurrEOM    date       = EOMONTH(GETDATE(), -1);

/* Latest available EOM for this line on/before @NaturalCurrEOM */
DECLARE @Anchor date =
(
  SELECT MAX(cu.LoadDate)
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  WHERE cu.CreditLineNumber = @CreditLineNumber
    AND cu.LoadDate <= @NaturalCurrEOM
);

IF @Anchor IS NULL
BEGIN
    DECLARE @msg nvarchar(200) =
        CONCAT('No data found on or before ',
               CONVERT(varchar(10), @NaturalCurrEOM, 120),
               ' for CreditLine ', @CreditLineNumber, '.');
    RAISERROR(@msg, 16, 1);
    RETURN;
END;

/* =========================
   A) Full 13-row Panel
   ========================= */
;WITH spine AS (
    -- generate current anchor + 12 prior EOMs
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1,
           EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT
        s.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT
        h.LoadDate,
        COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
        h.SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,

        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- trailing statistics over the *previous* 12 months (excludes current)
        AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(b.Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN NULL
              ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base b
ORDER BY b.LoadDate
OPTION (MAXRECURSION 200);

/* =========================
   B) Latest-month Spotlight
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           CIF, ClientName, ApplID, FormulaLine, BankCode,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT TOP (1)
    LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode,
    SecUnfunded, Prev_SecUnfunded,
    CAST(SecUnfunded - ISNULL(Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (SecUnfunded - Prev_SecUnfunded) / NULLIF(ABS(Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,
    CAST(Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
    CAST(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN NULL
              ELSE (SecUnfunded - Mean_Prev12) / StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base
ORDER BY LoadDate DESC
OPTION (MAXRECURSION 200);

/* =========================
   C) Quick Summary (Panel)
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    COUNT(*)                                                       AS Rows_In_Panel,
    SUM(CASE WHEN Prev_SecUnfunded IS NULL THEN 0 ELSE 1 END)      AS Rows_With_Prior,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END) AS Cnt_ZeroToNonZero,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END) AS Cnt_NonZeroToZero,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_2plus,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_3plus
FROM base
OPTION (MAXRECURSION 200);



/* ==========================================================
   Drill-Down Variance Analysis for ONE CreditLine
   - Pulls last 12 EOM snapshots (plus one extra to get MoM)
   - Computes MoM_Diff / MoM_Pct
   - Rolling (prev-12) mean & stdev
   - Z-score per month vs trailing 12 (excludes the month itself)
   - Flags: |Z|≥2 (moderate), |Z|≥3 (severe), zero↔nonzero switches

   Assumed tables (SQL Server):
     CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED   (LoadDate, CreditLineNumber, SecUnfunded)
     CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY   (LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode)

   >>> Set @CreditLineNumber below
========================================================== */

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line here
DECLARE @CurrEOM          date        = EOMONTH(GETDATE(), -1);  -- latest month-end as of "today"
DECLARE @LookbackMonths    int        = 12;             -- trailing window

/* 0) Resolve current/prior month-ends that actually exist for this line */
IF OBJECT_ID('tempdb..#LineEOM') IS NOT NULL DROP TABLE #LineEOM;

;WITH d AS (
    SELECT DISTINCT LoadDate
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
    WHERE CreditLineNumber = @CreditLineNumber
      AND LoadDate <= @CurrEOM
),
ranked AS (
    SELECT LoadDate,
           ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
    FROM d
)
SELECT
    MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM_Available,
    MAX(CASE WHEN rn = @LookbackMonths + 1 THEN LoadDate END) AS OldestNeededEOM
INTO #LineEOM
FROM ranked;

/* 1) Build a month-end spine (dates) for the last @LookbackMonths + 1 months up to the available current EOM */
IF OBJECT_ID('tempdb..#Spine') IS NOT NULL DROP TABLE #Spine;

DECLARE @Anchor date = (SELECT CurrEOM_Available FROM #LineEOM);
IF @Anchor IS NULL
BEGIN
    RAISERROR('No data found on or before %s for CreditLine %s.', 16, 1, CONVERT(varchar(10), @CurrEOM, 120), @CreditLineNumber);
    RETURN;
END

;WITH spine AS (
    SELECT @Anchor AS LoadDate, 0 AS step
    UNION ALL
    SELECT EOMONTH(DATEADD(MONTH, -1, LoadDate)), step + 1
    FROM spine
    WHERE step < @LookbackMonths
)
SELECT LoadDate
INTO #Spine
FROM spine
OPTION (MAXRECURSION 200);

/* 2) Pull SecUnfunded history for that line, aligned to the spine (left join → preserves missing months) */
IF OBJECT_ID('tempdb..#Hist') IS NOT NULL DROP TABLE #Hist;

SELECT
    s.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
INTO #Hist
FROM #Spine s
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    ON cu.LoadDate = s.LoadDate
   AND cu.CreditLineNumber = @CreditLineNumber;

/* 3) Attach some metadata (from CREDIT_LINE_MONTHLY at the same LoadDate, if available) */
IF OBJECT_ID('tempdb..#HistMeta') IS NOT NULL DROP TABLE #HistMeta;

SELECT
    h.LoadDate,
    COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
    h.SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode
INTO #HistMeta
FROM #Hist h
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = h.LoadDate
 AND cl.CreditLineNumber = @CreditLineNumber;

/* 4) Compute MoM diffs and rolling stats; Z-score vs trailing 12 (excluding current) */
IF OBJECT_ID('tempdb..#Stats') IS NOT NULL DROP TABLE #Stats;

;WITH base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,
        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- Rolling (prev-12) mean & stdev; excludes the current month by framing to 1 PRECEDING
        AVG(SecUnfunded)  OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded)OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM #HistMeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded, 0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
        CASE WHEN ISNULL(b.Prev_SecUnfunded, 0.00) = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded), 0.00)
        END AS decimal(38,6)
    ) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(
        CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
        END AS decimal(38,4)
    ) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
INTO #Stats
FROM base b;

/* 5) Final outputs
      A) Full 13-row panel (oldest … latest)
      B) Latest-month spotlight (most recent EOM available)
      C) Quick anomaly summary counts across the panel
*/
-- A) Panel
SELECT *
FROM #Stats
ORDER BY LoadDate;

-- B) Latest-month spotlight
SELECT TOP (1) *
FROM #Stats
ORDER BY LoadDate DESC;

-- C) Summary (counts across panel)
SELECT
    COUNT(*)                                           AS Rows_In_Panel,
    SUM(CASE WHEN MoM_Diff IS NULL THEN 0 ELSE 1 END)  AS Rows_With_Prior,
    SUM(Flag_ZeroToNonZero)                            AS Cnt_ZeroToNonZero,
    SUM(Flag_NonZeroToZero)                            AS Cnt_NonZeroToZero,
    SUM(Flag_Z_2plus)                                  AS Cnt_Z_Abs_2plus,
    SUM(Flag_Z_3plus)                                  AS Cnt_Z_Abs_3plus
FROM #Stats;





/*==========================================================
  MoM SecUnfunded Variance @ CreditLine
  Current month = 08/31/2025
  Prior month   = 07/31/2025
==========================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM date = '2025-08-31';
DECLARE @PrevEOM date = '2025-07-31';

/* Current snapshot */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Curr
INTO #Curr
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @CurrEOM
  AND cl.LoadDate = @CurrEOM;

/* Prior snapshot */
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Prev
INTO #Prev
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @PrevEOM
  AND cl.LoadDate = @PrevEOM;

/* MoM Variance */
SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,
    COALESCE(c.CIF, p.CIF)           AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID, p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine, p.FormulaLine) AS FormulaLine,
    COALESCE(c.BankCode, p.BankCode) AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr,0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev,0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
      CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                 / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
      END AS decimal(38,6)
    ) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber
ORDER BY ABS(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00)) DESC;






/*==========================================================
  MoM SecUnfunded Variance @ CreditLine (no RunID)
  - Auto-detects the latest two LoadDates from CALCULATED_UNFUNDED
  - Joins optional line metadata from CREDIT_LINE_MONTHLY (current/prior)
  - Safe math, zero↔nonzero flags
==========================================================*/

SET NOCOUNT ON;

/* 1) Identify the latest two LoadDates present in CALCULATED_UNFUNDED */
IF OBJECT_ID('tempdb..#EOM') IS NOT NULL DROP TABLE #EOM;
WITH DistinctDates AS (
  SELECT DISTINCT LoadDate
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
),
Ranked AS (
  SELECT LoadDate,
         ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
  FROM DistinctDates
)
SELECT
  MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM,
  MAX(CASE WHEN rn = 2 THEN LoadDate END) AS PrevEOM
INTO #EOM
FROM Ranked
WHERE rn IN (1,2);

-- Optional: quick sanity check
-- SELECT * FROM #EOM;

/* 2) Build current & prior SecUnfunded snapshots */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Curr AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.CurrEOM
), CL_Curr AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT CurrEOM FROM #EOM) d
  WHERE cl.LoadDate = d.CurrEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    c.SecUnfunded AS SecUnfunded_Curr
INTO #Curr
FROM CU_Curr c
LEFT JOIN CL_Curr m
  ON m.LoadDate = c.LoadDate
 AND m.CreditLineNumber = c.CreditLineNumber;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Prev AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.PrevEOM
), CL_Prev AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT PrevEOM FROM #EOM) d
  WHERE cl.LoadDate = d.PrevEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    p.LoadDate,
    p.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    p.SecUnfunded AS SecUnfunded_Prev
INTO #Prev
FROM CU_Prev p
LEFT JOIN CL_Prev m
  ON m.LoadDate = p.LoadDate
 AND m.CreditLineNumber = p.CreditLineNumber;

/* 3) Compute MoM */
IF OBJECT_ID('tempdb..#MoM') IS NOT NULL DROP TABLE #MoM;

DECLARE @CurrEOM date = (SELECT CurrEOM FROM #EOM);
DECLARE @PrevEOM date = (SELECT PrevEOM FROM #EOM);

SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,

    -- Prefer current metadata if present
    COALESCE(c.CIF,        p.CIF)        AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID,     p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine,p.FormulaLine)AS FormulaLine,
    COALESCE(c.BankCode,   p.BankCode)   AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr, 0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev, 0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE
           WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
INTO #MoM
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber;

/* 4) Results */
-- Detailed variances
SELECT *
FROM #MoM
ORDER BY ABS(MoM_Diff) DESC, CreditLineNumber;

-- Quick top movers
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff DESC, CreditLineNumber; -- biggest increases
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff ASC,  CreditLineNumber; -- biggest decreases

-- Optional rollups (uncomment as needed):
-- SELECT BankCode, SUM(SecUnfunded_Prev) AS Prev_, SUM(SecUnfunded_Curr) AS Curr_, SUM(MoM_Diff) AS MoM_Diff
-- FROM #MoM GROUP BY BankCode ORDER BY ABS(SUM(MoM_Diff)) DESC;






-- === Define the two months once ===
DECLARE @PrevDate date = DATEFROMPARTS(2025,7,31);
DECLARE @CurrDate date = DATEFROMPARTS(2025,8,31);

WITH Prev AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @PrevDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
),
Curr AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @CurrDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
)

SELECT
    c.LoadDate,
    c.Cif,
    c.CreditLineNumber,
    c.RevolvingFlag,
    c.FormulaLine,

    p.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    c.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(c.NetBorrowingBase,0)  - ISNULL(p.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    p.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    c.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(c.GrossLineAmount,0)   - ISNULL(p.GrossLineAmount,0)   AS GrossLineAmount_Change,

    p.NetLineAmount     AS PrevMonth_NetLineAmount,
    c.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(c.NetLineAmount,0)     - ISNULL(p.NetLineAmount,0)     AS NetLineAmount_Change,

    p.NetUtilized       AS PrevMonth_NetUtilized,
    c.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(c.NetUtilized,0)       - ISNULL(p.NetUtilized,0)       AS NetUtilized_Change,

    p.SecUnfunded       AS PrevMonth_SecUnfunded,
    c.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(c.SecUnfunded,0)       - ISNULL(p.SecUnfunded,0)       AS SecUnfunded_Change,

    p.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    c.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(c.Recalculated_SecUnfunded,0) - ISNULL(p.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM Curr c
LEFT JOIN Prev p
  ON p.CreditLineNumber = c.CreditLineNumber;





IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- === PREVIOUS MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === CURRENT MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === COMPARE (numeric math only; no FORMAT anywhere) ===
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- show raw values
    pm.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    cm.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(cm.NetBorrowingBase,0)  - ISNULL(pm.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    pm.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    cm.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(cm.GrossLineAmount,0)   - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    pm.NetLineAmount     AS PrevMonth_NetLineAmount,
    cm.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(cm.NetLineAmount,0)     - ISNULL(pm.NetLineAmount,0)     AS NetLineAmount_Change,

    pm.NetUtilized       AS PrevMonth_NetUtilized,
    cm.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(cm.NetUtilized,0)       - ISNULL(pm.NetUtilized,0)       AS NetUtilized_Change,

    pm.SecUnfunded       AS PrevMonth_SecUnfunded,
    cm.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(cm.SecUnfunded,0)       - ISNULL(pm.SecUnfunded,0)       AS SecUnfunded_Change,

    pm.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    cm.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);








IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- PREVIOUS MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- CURRENT MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- COMPARE (math on numerics; optional FORMAT for display)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- optional pretty display of raw values
    FORMAT(pm.NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    ISNULL(cm.NetBorrowingBase,0) - ISNULL(pm.NetBorrowingBase,0) AS NetBorrowingBase_Change,

    FORMAT(pm.GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    ISNULL(cm.GrossLineAmount,0) - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    FORMAT(pm.NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    ISNULL(cm.NetLineAmount,0) - ISNULL(pm.NetLineAmount,0)       AS NetLineAmount_Change,

    FORMAT(pm.NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    ISNULL(cm.NetUtilized,0) - ISNULL(pm.NetUtilized,0)           AS NetUtilized_Change,

    FORMAT(pm.SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    ISNULL(cm.SecUnfunded,0) - ISNULL(pm.SecUnfunded,0)           AS SecUnfunded_Change,

    -- recalculated sec unfunded comparison (numeric)
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);






IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- Previous month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS PrevMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS PrevMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS PrevMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS PrevMonth_NetUtilized, 
    CAST(b.SecUnfunded          AS decimal(19,2)) AS PrevMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS PrevMonth_Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-07-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Current month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS CurrMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS CurrMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS CurrMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS CurrMonth_NetUtilized,
    CAST(b.SecUnfunded          AS decimal(19,2)) AS CurrMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS CurrMonth_Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-08-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Compare (do math on numerics; format at the end if desired)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- Optional pretty display
    FORMAT(pm.PrevMonth_NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.CurrMonth_NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    cm.CurrMonth_NetBorrowingBase - pm.PrevMonth_NetBorrowingBase AS NetBorrowingBase_Change,

    FORMAT(pm.PrevMonth_GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.CurrMonth_GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    cm.CurrMonth_GrossLineAmount - pm.PrevMonth_GrossLineAmount   AS GrossLineAmount_Change,

    FORMAT(pm.PrevMonth_NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.CurrMonth_NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    cm.CurrMonth_NetLineAmount - pm.PrevMonth_NetLineAmount       AS NetLineAmount_Change,

    FORMAT(pm.PrevMonth_NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.CurrMonth_NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    cm.CurrMonth_NetUtilized - pm.PrevMonth_NetUtilized           AS NetUtilized_Change,

    FORMAT(pm.PrevMonth_SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.CurrMonth_SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    cm.CurrMonth_SecUnfunded - pm.PrevMonth_SecUnfunded           AS SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);







IF OBJECT_ID('tempdb..#PrevMonth')   IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth')  IS NOT NULL DROP TABLE #CurrMonth;

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as PrevMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as PrevMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as PrevMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as PrevMonth_NetUtilized_fmtd, 
	format(b.SecUnfunded,'N2') as PrevMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as PrevMonth_Recalculated_SecUnfunded
into #PrevMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '7/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as CurrMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as CurrMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as CurrMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as CurrMonth_NetUtilized_fmtd,
	format(b.SecUnfunded,'N2') as CurrMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as CurrMonth_Recalculated_SecUnfunded
into #CurrMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '8/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select
	cm.LoadDate,
	cm.Cif,
	cm.CreditLineNumber,
	cm.RevolvingFlag,
	cm.FormulaLine,
	pm.PrevMonth_NetBorrowingBase_fmtd,
	cm.CurrMonth_NetBorrowingBase_fmtd,
	(cm.CurrMonth_NetBorrowingBase_fmtd - pm.PrevMonth_NetBorrowingBase_fmtd) as NetBorrowingBase_Change,
	pm.PrevMonth_GrossLineAmount_fmtd,
	cm.CurrMonth_GrossLineAmount_fmtd,
	(cm.CurrMonth_GrossLineAmount_fmtd - pm.PrevMonth_GrossLineAmount_fmtd) as GrossLineAmount_Change,
	pm.PrevMonth_NetLineAmount_fmtd,
	cm.CurrMonth_NetLineAmount_fmtd,
	(cm.CurrMonth_NetLineAmount_fmtd - pm.PrevMonth_NetLineAmount_fmtd) as NetLineAmount_Change,
	pm.PrevMonth_NetUtilized_fmtd,
	cm.CurrMonth_NetUtilized_fmtd,
	(cm.CurrMonth_NetUtilized_fmtd - pm.PrevMonth_NetUtilized_fmtd) as NetUtilized_Change,
	pm.PrevMonth_SecUnfunded_fmtd,
	cm.CurrMonth_SecUnfunded_fmtd,
	(cm.CurrMonth_SecUnfunded_fmtd - pm.PrevMonth_SecUnfunded_fmtd) as SecUnfunded_Change
from #CurrMonth cm
left join #PrevMonth pm
on cm.LoadDate = pm.LoadDate and cm.CreditLineNumber = pm.CreditLineNumber






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;
