import pandas as pd

tbl = "KDE_Summary3"  # <-- make sure this matches Table Design > Table Name exactly
df = xl(tbl).copy()

print("shape:", df.shape)
print("columns (as Excel passes them):", list(df.columns))
df.head(3)



Error:Python
KeyError: "Couldn't find a KDE identifier column. Expected one of ['kde_name', 'kde', 'key_data_element', 'field_name', 'attribute_name', 'attribute']. Got: ['next_rate_change_date', '2025-09-30_00:00:00', '71809863129.06', '100970', '0.583402', '173071', '171867', '-1204', '-0.006957', '92887577678.95', '93253920099.4', '366342420.45', '0.003944', '-1085822458.44966', '70338547296.7333', '7053855244.00191', '0.208583218882717', '1']"





import pandas as pd
import numpy as np

df_raw = xl("KDE_Summary").copy()
print("raw rows:", len(df_raw))

# If headers came through as numbers, promote first row to headers
if all(isinstance(c, (int, float)) for c in df_raw.columns):
    header = df_raw.iloc[0].tolist()
    df = df_raw.iloc[1:].copy()
    df.columns = [str(x).strip() if pd.notna(x) else f"col_{i}" for i, x in enumerate(header)]
else:
    df = df_raw.copy()

# normalize headers
def norm(c): return str(c).replace("\n"," ").strip().lower().replace(" ", "_")
df.columns = [norm(c) for c in df.columns]
print("normalized columns:", list(df.columns))
print("rows after normalization:", len(df))

# find key columns
kde_candidates  = ["kde_name","kde","key_data_element","field_name","attribute_name","attribute"]
date_candidates = ["this_eom","end_of_month_date","end_of_month","month_end","eom","eom_date","as_of_eom","as_of_date"]

kde_col  = next((c for c in kde_candidates if c in df.columns), None)
date_col = next((c for c in date_candidates if c in df.columns), None)

if kde_col is None:
    raise KeyError(f"Couldn't find a KDE identifier column. Expected one of {kde_candidates}. Got: {list(df.columns)}")

if date_col is None:
    # try auto-detect a date-like column
    for c in df.columns:
        s = pd.to_datetime(df[c], errors="coerce")
        if s.notna().sum() >= max(3, int(0.5*len(s))):
            df["this_eom"] = s
            date_col = "this_eom"
            break
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

# type-cast numerics where present
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# sort for readability
df = df.sort_values([kde_col, "this_eom"]).reset_index(drop=True)

print("kde column:", kde_col, "| date column:", "this_eom")
print("final row count:", len(df))

# IMPORTANT: return the full DataFrame (no .head() / .tail())
df





import pandas as pd
import numpy as np

# ---- 1) Load the Excel table ----
# If your table name isn't KDE_Summary, change it here:
df = xl("KDE_Summary").copy()

# Show raw headers (helps debugging)
print("Raw columns:", list(df.columns))

# ---- 2) Normalize headers safely (handles non-string headers) ----
def to_str(x):
    try:
        return "_".join(map(str, x)).strip() if isinstance(x, tuple) else str(x).strip()
    except Exception:
        return str(x)

df.columns = [to_str(c) for c in df.columns]
df.columns = [c.replace("\n"," ") for c in df.columns]  # remove line breaks from header cells
df.columns = [c.lower().replace(" ", "_") for c in df.columns]

print("Normalized columns:", list(df.columns))

# ---- 3) Find the EOM/date column (handles THIS_EOM and common aliases) ----
aliases = [
    "this_eom","end_of_month_date","end_of_month","month_end",
    "eom","eom_date","as_of_eom","as_of_date","report_eom"
]
date_col = next((c for c in aliases if c in df.columns), None)

# If not found by name, try to detect a date-like column
if date_col is None:
    name_candidates = [c for c in df.columns if any(k in c for k in ["date","eom","month"])]
    parsed = []
    for c in name_candidates + list(df.columns):
        try:
            s = pd.to_datetime(df[c], errors="coerce")
            if s.notna().sum() >= max(3, int(0.5*len(s))):  # at least half the rows look like dates
                parsed.append((c, s))
        except Exception:
            pass
    if parsed:
        date_col, s = parsed[0]
        df["this_eom"] = s
    else:
        raise KeyError(f"Could not find a date column to use as 'this_eom'. "
                       f"Available columns: {list(df.columns)}")
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

print("Using date column as this_eom:", date_col)

# ---- 4) Make sure key numeric columns are numeric (skip if absent) ----
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ---- 5) Sort & preview ----
key_name = "kde_name" if "kde_name" in df.columns else (next((c for c in df.columns if "kde" in c and "name" in c), None))
if key_name is None:
    print("Warning: couldn't find KDE name column (expected 'KDE_NAME'). Continuing without it.")
    df = df.sort_values(["this_eom"]).reset_index(drop=True)
else:
    df = df.sort_values([key_name, "this_eom"]).reset_index(drop=True)

df.tail(10)



import pandas as pd
import numpy as np

df = xl("KDE_Summary").copy()

# convert all headers to lowercase
df.columns = [c.lower() for c in df.columns]

# now you can safely reference 'this_eom'
df['this_eom'] = pd.to_datetime(df['this_eom'], errors='coerce')

# continue with your numeric conversions, sorting, etc.
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct",
            "exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["kde_name","this_eom"]).reset_index(drop=True)
df.tail(10)




import pandas as pd
import numpy as np

# Pull the Excel table into pandas
df = xl("KDE_Summary").copy()

# Basic typing & ordering
df["this_eom"] = pd.to_datetime(df["this_eom"])
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["KDE_NAME","this_eom"]).reset_index(drop=True)

# Show a peek
df.tail(10)





import matplotlib.pyplot as plt

kde = xl("SelectedKDE") if "SelectedKDE" in dir() else None
if not kde:
    kde = df_feat["KDE_NAME"].iloc[0]

g = df_feat[df_feat["KDE_NAME"]==kde].sort_values("this_eom")

plt.figure()
plt.plot(g["this_eom"], g["exp_changed"], label="exp_changed")
if g["exp_changed_ma12"].notna().any():
    plt.plot(g["this_eom"], g["exp_changed_ma12"], linestyle=":", label="MA12")
# add a straight trend line from the slope if you want a visual guide
if len(g) >= 2 and np.isfinite(g["exp_changed"]).sum() >= 2:
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].astype(float).values
    # reconstruct fit using mean-centered form with the slope we computed
    slope = g["exp_changed_trend_slope"].iloc[-1]
    y_hat = (t - t.mean()) * slope + np.nanmean(y)
    plt.plot(g["this_eom"], y_hat, linestyle="--", label="trend")

plt.title(f"{kde} â€” exp_changed, MA12 & trend")
plt.xlabel("Month End")
plt.ylabel("Exposure changed")
plt.legend()
plt.tight_layout()





import pandas as pd
from sklearn.linear_model import LinearRegression

df = dataset
df = df.groupby('KDE_NAME', as_index=False)['exp_changed'].mean()
model = LinearRegression().fit(df.index.values.reshape(-1,1), df['exp_changed'])
df['trend'] = model.coef_[0]






-- HISTORY + TRENDS (Netezza-safe, no POWER(), no analytic REGR_*)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)

WITH
params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

/* Month index across the window and its prior month */
months AS (
  SELECT DISTINCT t.End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date) AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

/* Base pull: choose exposure and carry all KDEs */
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

/* UNPIVOT via UNION ALL, cast all KDEs to VARCHAR to align types */
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

/* Pair each current month with its previous month using months_seq */
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.End_of_Month_Date
),

/* Compare prev vs curr at (Account, KDE, month) grain */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

/* Row-level flags and attributions */
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,
    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,
    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,
    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

/* Monthly KDE rollups */
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom) AS this_eom,
    SUM(changed_flag) AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag) AS cnt_prev,
    SUM(curr_flag) AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END) AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END) AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

/* MoM metrics per KDE per month */
metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

/* Linear trend slope of exp_changed across the window (per KDE) â€” no POWER() */
trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
            - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION)))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION))) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

/* Rolling 12-means and stdev for exp_changed (uses multiplications, no POWER()) */
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - (
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          *
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - (
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            *
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),

/* Join trend + rolling stats back to monthly metrics */
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

/* Latest month only + ranking */
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  /* ranking keys */
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  /* MoM context */
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  /* trend context */
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;



base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'     -- ðŸ”¹ added filter
),






trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
            - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
          - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION)) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),




rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            CAST(2.0 AS DOUBLE PRECISION)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              CAST(2.0 AS DOUBLE PRECISION)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),




[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            2
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(NUMERIC, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






-- ***** REPLACE trend_all CTE *****
trend_all AS (
  /* slope = Cov(x,y) / Var(x)
     = ( n*Î£(xy) - Î£x*Î£y ) / ( n*Î£(x^2) - (Î£x)^2 ) */
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM( (t_idx*1.0) * (exp_changed*1.0) )
          - (SUM(t_idx*1.0) * SUM(exp_changed*1.0)) )
        /
        ( COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


-- ***** REPLACE rolling_stats CTE *****
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    /* rolling mean over last 12 (or fewer for early months) */
    AVG(exp_changed*1.0)
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    /* rolling stdev using sqrt(E[x^2] - (E[x])^2) */
    CASE
      WHEN
        ( AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        ) < 0
        THEN 0  -- guard against tiny negative from floating error
      ELSE
        SQRT(
          AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'REGR_SLOPE(NUMERIC, NUMERIC)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





-- KDE Changes-Only History + Trend (Netezza-safe, patched)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)
-- Window: set your start/end month-ends below

WITH params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

-- Distinct month-ends in range, and previous month for each
months AS (
  SELECT DISTINCT End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date)           AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

-- Base rows (exposure: Derived -> Amortized)
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,

    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

-- UNPIVOT via UNION ALL (cast to VARCHAR for type alignment)
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

-- Pair each month with its previous month
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.End_of_Month_Date
),

-- *** FIXED joined CTE (no GROUP BY; no stray attrs) ***
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

-- Row-level flags & attribution
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,

    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,

    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,

    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

-- Monthly KDE rollups
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom)                                             AS this_eom,
    SUM(changed_flag)                                         AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag)                                            AS cnt_prev,
    SUM(curr_flag)                                            AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END)   AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END)   AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

-- ***** FIX: compute regression as an aggregate (no OVER) *****
trend_all AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(exp_changed * 1.0, t_idx * 1.0) AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

-- Rolling 12-month stats (still analytic â€” supported in Netezza)
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(exp_changed)    OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    STDDEV_SAMP(exp_changed) OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_sd12
  FROM metrics_monthly
),

-- Join trend + rolling stats back to the monthly metrics
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

-- Latest month only + ranking by changes-only exposure, then by count %
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  -- changes-only (ranking keys)
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  -- MoM context
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  -- Trend features
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;
