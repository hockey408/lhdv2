df = xl("tblPrecomputed[#All]", headers=True).copy()
df.columns = df.columns.astype(str).str.strip()




import numpy as np

# Ensure numeric
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# Robust Z (median & MAD over prev 12 months, optional)
# Needs historical data → skip if you only have 1 row/line
df["RobustZ"] = np.nan  # placeholder for now





import pandas as pd
import numpy as np

# 1) Pull your table into a DataFrame.
#    Change the table name if yours is different.
#    headers=True tells Python that the first row contains headers.
df = xl("tblPrecomputed[#All]", headers=True).copy()

# 2) Light sanity check
df.columns = df.columns.astype(str).str.strip()
print("Rows x Cols:", df.shape)
print("First 10 cols:", df.columns.tolist()[:10])

# 3) Expect the precomputed SQL columns (one row per credit line)
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        f"Missing columns: {missing}\n"
        f"Found: {sorted(df.columns.tolist())}\n"
        "Check your header row and table name."
    )

# 4) Fast severity score + Top 25
for c in ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
          "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]:
    df[c] = pd.to_numeric(df[c], errors="coerce")

W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct
out = df.sort_values(
    ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).head(25).copy()

out.insert(0, "SeverityRank", np.arange(1, len(out)+1))
out[[
    "SeverityRank","SeverityScore","CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]]






import pandas as pd
df = args[0]
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()
df.head()







import pandas as pd

df = args[0]  # take the first argument passed in (your range or table)
df = pd.DataFrame(df) if not isinstance(df, pd.DataFrame) else df.copy()

print("Shape:", df.shape)
print("First 5 columns:", df.columns.tolist()[:5])
df.head(5)






# Robust Top-25 review from precomputed SQL result
# Call this cell with a range/table that INCLUDES the header row, e.g.:
#   =PY(tblPrecomputed[#All])    or    =PY(Sheet1!A1:K5000)

import pandas as pd
import numpy as np
import re

TOP_N = 25
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0  # severity weights

# ---------- ingest ----------
if len(args) == 0:
    raise RuntimeError(
        "No input provided. Call like: =PY(tblPrecomputed[#All]) or =PY(Sheet1!A1:K5000) (headers included)."
    )

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# If columns aren't strings (e.g., 0..N), assume first row contains headers and promote it
if not all(isinstance(c, str) for c in df.columns):
    first = df.iloc[0].astype(str).tolist()
    df = df.iloc[1:].reset_index(drop=True)
    df.columns = first

# Normalize headers: strip, lower, replace spaces/dots/dashes with underscores, squeeze repeats
def norm(s):
    s = str(s).strip().lower()
    s = re.sub(r"[ \t\-.]+", "_", s)
    s = re.sub(r"_+", "_", s)
    return s.strip("_")

df.columns = [norm(c) for c in df.columns]

# Build a lookup from normalized name -> original column name
norm_to_orig = {norm(c): c for c in df.columns}  # after norm, norm(c)==c; we’ll keep for clarity

# Required canonical columns and acceptable aliases (normalized)
aliases = {
    "loaddate_curr": {"loaddate_curr","loaddate","load_date_curr","loaddate_current","load_date"},
    "creditlinenumber": {"creditlinenumber","credit_line_number","cln","line_number"},
    "secunfunded_curr": {"secunfunded_curr","secunfunded","sec_unfunded_curr","secured_unfunded_curr"},
    "prev_secunfunded": {"prev_secunfunded","prev_sec_unfunded","previous_secunfunded","secunfunded_prev"},
    "mom_diff": {"mom_diff","mom$","delta","change","mom_change"},
    "mom_pct": {"mom_pct","mom%","pct_change","percent_change","mom_percent"},
    "mean_prev12": {"mean_prev12","avg_prev12","mean_12","rolling_mean_12"},
    "stdev_prev12": {"stdev_prev12","std_prev12","stddev_prev12","rolling_std_12","stdev"},
    "cnt_prev12": {"cnt_prev12","count_prev12","n_prev12","count_12"},
    "z_prev12": {"z_prev12","zscore","z_score_prev12","z"},
}

# Resolve each canonical column by checking aliases against normalized df columns
resolved = {}
missing = []
for canon, opts in aliases.items():
    found = None
    for opt in opts:
        if opt in df.columns:
            found = opt
            break
    if found:
        resolved[canon] = found
    else:
        missing.append(canon)

# If many are missing, show diagnostics to help fix the input
if missing:
    # Show what we do have (first 20 normalized headers)
    have = ", ".join(list(df.columns)[:20])
    raise ValueError(
        "Some expected columns were not found.\n"
        f"Missing (canonical names): {missing}\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and the header row is included.\n"
        f"Detected (normalized) headers: {have}\n"
        "Tip: If your headers look different, rename them in Excel to the expected names."
    )

# For convenience, get original names (they're equal to normalized now, but left here for clarity)
c = resolved  # shorthand

# Make numerics numeric
num_cols = [c["secunfunded_curr"], c["prev_secunfunded"], c["mom_diff"], c["mom_pct"],
            c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"]]
for col in num_cols:
    df[col] = pd.to_numeric(df[col], errors="coerce")

# Severity score (simple & fast)
abs_z   = df[c["z_prev12"]].abs().fillna(0.0)
abs_amt = df[c["mom_diff"]].abs().fillna(0.0)
abs_pct = (df[c["mom_pct"]].abs() * 100.0).fillna(0.0)

df["severity_score"] = W_Z*abs_z + W_AMT*np.log10(abs_amt + 1.0) + W_PCT*abs_pct

# Sort & take Top N
order = ["severity_score", c["z_prev12"], c["mom_diff"], c["mom_pct"], c["creditlinenumber"]]
out = df.sort_values(order, ascending=[False, False, False, False, True]).head(TOP_N).copy()
out.insert(0, "severity_rank", np.arange(1, len(out)+1))

# Build tidy output (include common metadata if present)
cols = [
    "severity_rank","severity_score",
    c["creditlinenumber"], c["loaddate_curr"],
    c["secunfunded_curr"], c["prev_secunfunded"],
    c["mom_diff"], c["mom_pct"],
    c["mean_prev12"], c["stdev_prev12"], c["cnt_prev12"], c["z_prev12"],
]
# Try to add nice-to-have metadata if columns exist with common names
for extra in ["cif","clientname","applid","formulaline","revolvingflag","line_status",
              "netlineamount","netutilized","netdisbursed","netborrowingbase","business_unit"]:
    if extra in df.columns:
        cols.append(extra)

# Drop any that aren't present (shouldn't be necessary but safe)
cols = [col for col in cols if col in out.columns]

# Return to Excel
out[cols]






# --- DIAGNOSTIC: just tell me what you passed in ---
import pandas as pd

if len(args) == 0:
    raise RuntimeError("No input given. Call like: =PY(<cell>, Sheet1!A1:Q50000) or =PY(<cell>, MyTable[#All])")

raw = args[0]
df = pd.DataFrame(raw) if not isinstance(raw, pd.DataFrame) else raw.copy()

# Try to detect if the FIRST ROW contains your headers; if so, promote it.
first_row = df.iloc[0].astype(str).str.strip().tolist()
expected_any = {"CreditLineNumber","LoadDate_Curr","SecUnfunded_Curr"}  # from precompute SQL
headers_look_ok = len(set(first_row) & expected_any) > 0

if headers_look_ok and "CreditLineNumber" not in df.columns:
    df.columns = [str(x).strip() for x in first_row]
    df = df.iloc[1:].reset_index(drop=True)

# Always strip column whitespace
df.columns = df.columns.astype(str).str.strip()

print("Shape (rows, cols):", df.shape)
print("First 12 column names:", df.columns.tolist()[:12])

# Show the first 5 rows so we can see if headers are correct
df.head(5)







# Python in Excel — Range-Passed Review (fast, no name lookup)
# Call pattern:
#   =PY(<this_cell>, Sheet1!A1:Q50000)
#   =PY(<this_cell>, tblPrecomputed[#All])

import numpy as np
import pandas as pd

# ---------- CONFIG ----------
TOP_N = 25                 # rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold (still ranked by score)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0   # severity weights

# ---------- INPUT ----------
if len(args) == 0:
    raise RuntimeError(
        "No input range provided. In the formula bar, pass a range or table, e.g.:\n"
        "  =PY(<this_cell>, Sheet1!A1:Q50000)\n"
        "  =PY(<this_cell>, tblPrecomputed[#All])"
    )

df = args[0].copy()
if not isinstance(df, pd.DataFrame):
    # If Excel passed a numpy array, convert to DataFrame
    df = pd.DataFrame(df)

# Normalize headers (first row must be headers in the passed range/table)
df.columns = df.columns.astype(str).str.strip()

# ---------- REQUIRED COLUMNS (from the precompute SQL) ----------
required = [
    "LoadDate_Curr","CreditLineNumber","SecUnfunded_Curr",
    "Prev_SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"
]
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError(
        "Missing required columns: %s\n"
        "Found columns: %s\n"
        "Make sure you passed the PRECOMPUTE SQL output (one row per credit line) and included the header row in the range."
        % (missing, sorted(df.columns.tolist()))
    )

# ---------- TYPES ----------
num_cols = ["SecUnfunded_Curr","Prev_SecUnfunded","MoM_Diff","MoM_Pct",
            "Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12"]
for c in num_cols:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# ---------- SEVERITY SCORE (very light) ----------
abs_z   = df["Z_Prev12"].abs().fillna(0.0)
abs_amt = df["MoM_Diff"].abs().fillna(0.0)
abs_pct = (df["MoM_Pct"].abs() * 100.0).fillna(0.0)

df["SeverityScore"] = (
    W_Z * abs_z +
    W_AMT * np.log10(abs_amt + 1.0) +
    W_PCT * abs_pct
)

# Optional: force-include Z outliers (|Z| >= threshold)
mask_z = abs_z >= Z_THRESHOLD

# Final ranking
order_cols = ["SeverityScore","Z_Prev12","MoM_Diff","MoM_Pct","CreditLineNumber"]
review = df.sort_values(order_cols, ascending=[False, False, False, False, True]).copy()

# If you want to *only* include Z-outliers + top-N by SeverityScore, uncomment below:
# review = review[mask_z].copy() if mask_z.any() else review

# Keep top N
review = review.head(TOP_N).reset_index(drop=True)

# Build clean output
cols = [
    "CreditLineNumber","LoadDate_Curr",
    "SecUnfunded_Curr","Prev_SecUnfunded",
    "MoM_Diff","MoM_Pct","Mean_Prev12","StDev_Prev12","Cnt_Prev12","Z_Prev12",
    "SeverityScore"
]
# Only include those that exist (in case extra columns came through)
cols = [c for c in cols if c in review.columns]

# Add a 1-based rank
review.insert(0, "SeverityRank", np.arange(1, len(review)+1))

# Return to Excel
review[["SeverityRank"] + cols]





# Minimal check that Python can see your table and how big it is.
TABLE_NAME = "tblPrecomputed"  # <- change if your table has a different name

df = xl(TABLE_NAME)
print("Rows x Cols:", df.shape)
df.columns = df.columns.str.strip()
print("Sample cols:", df.columns.tolist()[:12])
df.head(3)



# ==============================
# Clean Review Builder (fast)
# Works with *precomputed* SQL output per line (latest month)
# ==============================

import re
import numpy as np
import pandas as pd

# ---- Set this to your Excel Table / Named Range ----
TABLE_NAME = "tblPrecomputed"   # <-- change to your actual table name

# ---- Tunable parameters ----
TOP_N = 50                 # number of rows to return
Z_THRESHOLD = 2.0          # optional: include rows with |Z| >= threshold
DOLLAR_ALWAYS_INCLUDE = None  # e.g., 250000 to always include very large $ moves

# Severity weights
W_Z   = 100.0    # per 1.0 of |Z|
W_AMT = 10.0     # per log10(|$|+1)
W_PCT = 1.0      # per percentage point (100 * |MoM_Pct|)

# Z stdev floor (Fix A) used if we need to recompute Z
MIN_HISTORY = 6
STD_FLOOR_ABS = 250.0
STD_FLOOR_PCT_OF_MEAN = 0.005  # 0.5% of mean

# ---- Load data from Excel ----
df = xl(TABLE_NAME)

# Normalize column names: strip spaces
df.columns = df.columns.str.strip()

# Helper: pick a column by preferred name, falling back to suffixed variants (e.g., "Z_Prev12.1")
def pick(colname: str) -> str | None:
    if colname in df.columns:
        return colname
    # exact suffix like .1 or .2
    matches = [c for c in df.columns if re.fullmatch(fr"{re.escape(colname)}(\.\d+)?", str(c))]
    return matches[0] if matches else None

# Map required columns (accept a couple of common variants)
col_LoadDate   = pick("LoadDate_Curr") or pick("LoadDate")
col_CLN        = pick("CreditLineNumber")
col_SecCurr    = pick("SecUnfunded_Curr") or pick("SecUnfunded")
col_SecPrev    = pick("Prev_SecUnfunded")
col_Mean       = pick("Mean_Prev12")
col_StDev      = pick("StDev_Prev12")
col_Cnt        = pick("Cnt_Prev12")
col_MoMdiff    = pick("MoM_Diff")
col_MoMpct     = pick("MoM_Pct")
col_Z          = pick("Z_Prev12")

required = {
    "CreditLineNumber": col_CLN,
    "LoadDate (Curr or generic)": col_LoadDate,
    "SecUnfunded (Curr or generic)": col_SecCurr,
}
missing_core = [k for k,v in required.items() if v is None]
if missing_core:
    raise ValueError(
        "Your table is missing core columns needed for ranking.\n"
        f"Missing: {missing_core}\n"
        f"Columns found: {sorted(df.columns.tolist())}"
    )

# Ensure numeric types for calculations
for c in [col_SecCurr, col_SecPrev, col_Mean, col_StDev, col_Cnt, col_MoMdiff, col_MoMpct, col_Z]:
    if c and c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Compute MoM fields if they’re missing but we have current/prev
if col_MoMdiff is None and col_SecPrev:
    df["MoM_Diff"] = (df[col_SecCurr] - df[col_SecPrev]).round(2)
    col_MoMdiff = "MoM_Diff"

if col_MoMpct is None and col_SecPrev:
    with np.errstate(divide="ignore", invalid="ignore"):
        df["MoM_Pct"] = np.where(
            df[col_SecPrev].fillna(0) == 0,
            np.nan,
            (df[col_SecCurr] - df[col_SecPrev]) / np.abs(df[col_SecPrev])
        )
    col_MoMpct = "MoM_Pct"

# Recompute Z if missing and inputs exist (uses same stdev floor logic you asked for)
if col_Z is None and all(x is not None for x in [col_Mean, col_StDev, col_Cnt]):
    mean = df[col_Mean].astype(float)
    stdev = df[col_StDev].astype(float)
    cnt = df[col_Cnt].astype(float)
    curr = df[col_SecCurr].astype(float)

    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(mean) * STD_FLOOR_PCT_OF_MEAN)
    ok = (cnt >= MIN_HISTORY) & stdev.notna() & (stdev >= eff_floor)
    df["Z_Prev12"] = np.where(ok, (curr - mean) / stdev, np.nan)
    col_Z = "Z_Prev12"

# Build severity components (handle nulls)
df["AbsZ"]          = df[col_Z].abs() if col_Z else 0.0
df["AbsAmt"]        = df[col_MoMdiff].abs() if col_MoMdiff else 0.0
df["AbsPctPoints"]  = (df[col_MoMpct].abs() * 100.0).fillna(0) if col_MoMpct else 0.0

# Composite SeverityScore
df["SeverityScore"] = (
    W_Z   * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1.0) +
    W_PCT * df["AbsPctPoints"]
)

# Candidate filters (fast)
mask_z   = (df["AbsZ"].notna()) & (df["AbsZ"] >= Z_THRESHOLD) if col_Z else False
mask_top = df["AbsAmt"].rank(method="first", ascending=False) <= TOP_N if col_MoMdiff else False
mask_big = (df["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE) if DOLLAR_ALWAYS_INCLUDE is not None else False

# If none of the masks exist (e.g., missing MoM), just sort everything and take TOP_N
if (isinstance(mask_z, bool) and isinstance(mask_top, bool) and isinstance(mask_big, bool)):
    review = df.copy()
else:
    review = df[ mask_z | mask_top | mask_big ].copy()
    if review.empty:
        # Fallback: take top-N by SeverityScore
        review = df.copy()

# Final ordering & rank
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints", col_CLN],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)

# Build clean output with whatever columns are available
cols_keep = [
    "SeverityRank","SeverityScore",
    col_LoadDate, col_CLN,
    "AbsAmt","AbsPctPoints","AbsZ",
]
# Add common fields if present
for c in [
    col_SecPrev, col_SecCurr, col_MoMdiff, col_MoMpct,
    col_Mean, col_StDev, col_Cnt, col_Z,
    "CIF","ClientName","ApplID","FormulaLine","RevolvingFlag","Line_Status",
    "NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "BUSINESS_UNIT"
]:
    if c and c in review.columns and c not in cols_keep:
        cols_keep.append(c)

# Make nicer header names (optional)
rename_map = {
    col_LoadDate: "LoadDate",
    col_CLN: "CreditLineNumber",
    col_SecCurr: "SecUnfunded_Curr",
    col_SecPrev: "Prev_SecUnfunded",
    col_MoMdiff: "MoM_Diff",
    col_MoMpct:  "MoM_Pct",
    col_Mean:    "Mean_Prev12",
    col_StDev:   "StDev_Prev12",
    col_Cnt:     "Cnt_Prev12",
    col_Z:       "Z_Prev12",
}
review_out = review[cols_keep].rename(columns={k:v for k,v in rename_map.items() if k})

# Return only the top N rows to Excel (fast)
review_out.head(TOP_N)







df = xl("tblPrecomputed")  # the result of the SQL above
df["AbsZ"] = df["Z_Prev12"].abs()
df["AbsAmt"] = df["MoM_Diff"].abs()
df["AbsPctPoints"] = (df["MoM_Pct"].abs() * 100).fillna(0)

# Simple severity score (same weights as before)
W_Z, W_AMT, W_PCT = 100.0, 10.0, 1.0
df["SeverityScore"] = (
    W_Z * df["AbsZ"].fillna(0) +
    W_AMT * np.log10(df["AbsAmt"].fillna(0) + 1) +
    W_PCT * df["AbsPctPoints"]
)

review = df.sort_values(
    ["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review)+1)
review.head(50)  # return top 50 only




/*==============================================================
  Portfolio Variance Precompute (hand-off to Python/Excel)
  - Population from CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
  - SecUnfunded from CALCULATED_UNFUNDED
  - Current EOM = last day of previous month
  - Output: ONE row per CreditLineNumber (latest ≤ @CurrEOM) with:
      Prev_SecUnfunded, Mean_Prev12, StDev_Prev12 (prev-12 only),
      Z_Prev12 (with stdev floor), MoM_Diff, MoM_Pct,
      and requested CLM metadata/amounts
==============================================================*/

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13; -- current + prior 12
-- Current EOM without EOMONTH(): last day of previous month
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

-- Z-score floor (Fix A)
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean
DECLARE @MinHistory          int           = 6;       -- min months in prev window to compute Z

;WITH base AS (
    /* Pull last 13 months for BUS00 population from CLM, join SecUnfunded from CU */
    SELECT
        cl.LoadDate,
        cl.CreditLineNumber,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BUSINESS_UNIT,
        cl.RevolvingFlag,
        cl.Line_Status,

        CAST(cl.NetLineAmount    AS decimal(38,2)) AS NetLineAmount,
        CAST(cl.NetUtilized      AS decimal(38,2)) AS NetUtilized,
        CAST(cl.NetDisbursed     AS decimal(38,2)) AS NetDisbursed,
        CAST(cl.NetBorrowingBase AS decimal(38,2)) AS NetBorrowingBase,

        CAST(cu.SecUnfunded      AS decimal(38,2)) AS SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
           ON cu.LoadDate         = cl.LoadDate
          AND cu.CreditLineNumber = cl.CreditLineNumber
    WHERE cl.BUSINESS_UNIT = 'BUS00'
      AND cl.LoadDate >= @StartEOM
      AND cl.LoadDate <= @CurrEOM
),
series AS (
    /* Compute per-line rolling (prev-12) stats and prev month */
    SELECT
        b.*,

        LAG(b.SecUnfunded, 1) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
        ) AS Prev_SecUnfunded,

        /* prev-12 window excludes the current row via ... AND 1 PRECEDING */
        AVG(b.SecUnfunded)   OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Mean_Prev12,

        STDEV(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS StDev_Prev12,

        COUNT(b.SecUnfunded) OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS Cnt_Prev12,

        ROW_NUMBER() OVER (
            PARTITION BY b.CreditLineNumber
            ORDER BY b.LoadDate DESC
        ) AS rn_desc
    FROM base b
),
calc AS (
    /* Keep latest available month per line; compute MoM, Z with stdev floor */
    SELECT
        s.LoadDate                       AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF,
        s.ClientName,
        s.ApplID,
        s.FormulaLine,
        s.BUSINESS_UNIT,
        s.RevolvingFlag,
        s.Line_Status,

        s.NetLineAmount,
        s.NetUtilized,
        s.NetDisbursed,
        s.NetBorrowingBase,

        s.SecUnfunded                   AS SecUnfunded_Curr,
        s.Prev_SecUnfunded,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(
            CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                 ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
            END AS decimal(38,6)
        ) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4)) AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
        s.Cnt_Prev12,

        /* Z-score with stdev floor (Fix A):
           floor = MAX(@StdFloorAbs, ABS(Mean_Prev12) * @StdFloorPctOfMean).
           If StDev_Prev12 < floor OR insufficient history => Z = NULL.
        */
        CAST(
            CASE
              WHEN s.Cnt_Prev12 < @MinHistory THEN NULL
              WHEN s.StDev_Prev12 IS NULL THEN NULL
              WHEN s.StDev_Prev12 <
                   CASE
                     WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                     ELSE CASE
                            WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                                 THEN @StdFloorAbs
                                 ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                          END
                   END
                   THEN NULL
              ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
            END AS decimal(38,4)
        ) AS Z_Prev12
    FROM series s
    WHERE s.rn_desc = 1
)
SELECT
    c.LoadDate_Curr,
    c.CreditLineNumber,
    c.CIF,
    c.ClientName,
    c.ApplID,
    c.FormulaLine,
    c.BUSINESS_UNIT,
    c.RevolvingFlag,
    c.Line_Status,

    c.NetLineAmount,
    c.NetUtilized,
    c.NetDisbursed,
    c.NetBorrowingBase,

    c.Prev_SecUnfunded,
    c.SecUnfunded_Curr,
    c.MoM_Diff,
    c.MoM_Pct,

    c.Mean_Prev12,
    c.StDev_Prev12,
    c.Cnt_Prev12,
    c.Z_Prev12
FROM calc c
ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber;






# Python in Excel: Portfolio variance & outlier review
# Requirements: your SQL extract is in an Excel Table named "tblCreditLines"

import pandas as pd
import numpy as np
from datetime import date
try:
    # Python in Excel function to pull an Excel Table by name
    df = xl("tblCreditLines")
except NameError:
    # Fallback for testing outside Excel: df must be defined externally
    raise RuntimeError("In Python in Excel, rename your data table to 'tblCreditLines' and re-run this cell.")

# -------------------------
# Tunable parameters
# -------------------------
LOOKBACK = 12                # trailing months (excluding current month)
MIN_HISTORY = 6              # minimum months to compute any Z/Robust Z
Z_THRESHOLD = 2.0            # notable Z
ROBUST_Z_THRESHOLD = 2.5     # optional robust Z threshold for review
TOP_N = 25                   # top N by $ move (abs)
DOLLAR_ALWAYS_INCLUDE = None # e.g., 250000 to always include very large $ moves

# Stdev floor (Fix A)
STD_FLOOR_ABS = 250.0        # absolute $ floor
STD_FLOOR_PCT_OF_MEAN = 0.005 # 0.5% of trailing mean

# SeverityScore weights
W_Z = 100.0                  # weight per 1.0 of |Z|
W_AMT = 10.0                 # weight per log10(|$|+1)
W_PCT = 1.0                  # weight per percentage point (100 * |MoM_Pct|)

# -------------------------
# Prep & sanity checks
# -------------------------
# Ensure expected columns exist
expected_cols = {
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "BusinessUnit","RevolvingFlag","Line_Status","NetLineAmount","NetUtilized",
    "NetDisbursed","NetBorrowingBase","SecUnfunded"
}
missing = sorted(list(expected_cols - set(df.columns)))
if missing:
    raise ValueError(f"Missing columns in Excel table: {missing}")

# Filter to BusinessUnit='BUS00' (population per your requirement)
df = df[df["BusinessUnit"] == "BUS00"].copy()

# Parse dates and sort
df["LoadDate"] = pd.to_datetime(df["LoadDate"]).dt.date
df = df.sort_values(["CreditLineNumber","LoadDate"]).reset_index(drop=True)

# Latest month-end anchor = last day of previous month relative to "today"
today = date.today()
curr_eom = (pd.Timestamp(today).to_period("M") - 1).to_timestamp("M").date()
df = df[df["LoadDate"] <= curr_eom].copy()

# -----------------------------------------
# Per-line rolling stats (exclude current)
# -----------------------------------------
def compute_metrics(g: pd.DataFrame) -> pd.DataFrame:
    g = g.sort_values("LoadDate").copy()
    s = g["SecUnfunded"].astype(float)

    # Prior month
    g["Prev_SecUnfunded"] = s.shift(1)

    # Trailing (prev-12) windows built on the *shifted* series so current is excluded
    prev = s.shift(1)

    roll = prev.rolling(window=LOOKBACK, min_periods=MIN_HISTORY)
    g["Mean_Prev12"] = roll.mean()
    g["StDev_Prev12"] = roll.std(ddof=1)

    # Z with stdev floor
    eff_floor = np.maximum(STD_FLOOR_ABS, np.abs(g["Mean_Prev12"]) * STD_FLOOR_PCT_OF_MEAN)
    z_num = (s - g["Mean_Prev12"])
    z_den = g["StDev_Prev12"]
    z_ok = (g["StDev_Prev12"].notna()) & (g["StDev_Prev12"] >= eff_floor) & (roll.count() >= MIN_HISTORY)
    g["Z_Prev12"] = np.where(z_ok, z_num / z_den, np.nan)

    # Robust Z: median & MAD on prev-12 (exclude current)
    med_prev12 = roll.median()
    # MAD: median of |prev - median|
    mad_prev12 = (prev - med_prev12).abs().rolling(window=LOOKBACK, min_periods=MIN_HISTORY).median()
    robust_den_ok = (mad_prev12.notna()) & (mad_prev12 > 0) & (roll.count() >= MIN_HISTORY)
    g["RobustZ_Prev12"] = np.where(
        robust_den_ok, 0.6745 * (s - med_prev12) / mad_prev12, np.nan
    )

    # MoM diffs
    g["MoM_Diff"] = (s - g["Prev_SecUnfunded"]).round(2)
    with np.errstate(divide="ignore", invalid="ignore"):
        g["MoM_Pct"] = np.where(
            g["Prev_SecUnfunded"].fillna(0) == 0,
            np.nan,
            (s - g["Prev_SecUnfunded"]) / np.abs(g["Prev_SecUnfunded"])
        )

    return g

df_metrics = df.groupby("CreditLineNumber", group_keys=False).apply(compute_metrics)

# -----------------------------------------
# Latest month per credit line (on/before curr_eom)
# -----------------------------------------
idx_latest = df_metrics.groupby("CreditLineNumber")["LoadDate"].transform("max") == df_metrics["LoadDate"]
latest = df_metrics[idx_latest].copy()

# SeverityScore & Rank
latest["AbsZ"] = latest["Z_Prev12"].abs()
latest["AbsAmt"] = latest["MoM_Diff"].abs()
latest["AbsPctPoints"] = (latest["MoM_Pct"].abs() * 100.0).fillna(0)

latest["SeverityScore"] = (
    W_Z * latest["AbsZ"].fillna(0)
    + W_AMT * np.log10(latest["AbsAmt"].fillna(0) + 1.0)
    + W_PCT * latest["AbsPctPoints"]
)

# Candidate sets: Z outliers, Top-N $ movers, optional dollar threshold
mask_z = (latest["AbsZ"].notna()) & (latest["AbsZ"] >= Z_THRESHOLD)
top_n_idx = latest["AbsAmt"].rank(method="first", ascending=False) <= TOP_N
if DOLLAR_ALWAYS_INCLUDE is not None:
    mask_big = latest["AbsAmt"] >= DOLLAR_ALWAYS_INCLUDE
else:
    mask_big = pd.Series(False, index=latest.index)

review = latest[mask_z | top_n_idx | mask_big].copy()

# Rank rows for review
review = review.sort_values(
    by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
    ascending=[False, False, False, False, True]
).reset_index(drop=True)
review["SeverityRank"] = np.arange(1, len(review) + 1)

# Optional: also include RobustZ thresholding (uncomment if you want it to force include)
# mask_robust = review["RobustZ_Prev12"].abs() >= ROBUST_Z_THRESHOLD
# review.loc[mask_robust & ~mask_z, "SeverityScore"] += 50.0  # small bump for robust-only outliers
# review = review.sort_values(by=["SeverityScore","AbsZ","AbsAmt","AbsPctPoints","CreditLineNumber"],
#                             ascending=[False, False, False, False, True]).reset_index(drop=True)
# review["SeverityRank"] = np.arange(1, len(review) + 1)

# Select final columns for Excel
cols_out = [
    "SeverityRank","SeverityScore",
    "LoadDate","CreditLineNumber","CIF","ClientName","ApplID","FormulaLine",
    "RevolvingFlag","Line_Status","NetLineAmount","NetUtilized","NetDisbursed","NetBorrowingBase",
    "Prev_SecUnfunded","SecUnfunded","MoM_Diff","MoM_Pct",
    "Mean_Prev12","StDev_Prev12","Z_Prev12","RobustZ_Prev12"
]
review_out = review[cols_out]

# Return the review table back to Excel (spills into the sheet)
review_out



-- Base extract for Python-in-Excel variance analysis
-- Population = CREDIT_LINE_MONTHLY (BUSINESS_UNIT='BUS00')
-- SecUnfunded pulled from CALCULATED_UNFUNDED

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Latest month-end (works without EOMONTH)
DECLARE @CurrEOM  date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cl.LoadDate,
    cl.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BUSINESS_UNIT,
    cl.RevolvingFlag,
    cl.Line_Status,

    -- Amounts from CREDIT_LINE_MONTHLY
    CAST(cl.NetLineAmount     AS decimal(38,2)) AS NetLineAmount,
    CAST(cl.NetUtilized       AS decimal(38,2)) AS NetUtilized,
    CAST(cl.NetDisbursed      AS decimal(38,2)) AS NetDisbursed,
    CAST(cl.NetBorrowingBase  AS decimal(38,2)) AS NetBorrowingBase,

    -- Only SecUnfunded from CALCULATED_UNFUNDED
    CAST(cu.SecUnfunded       AS decimal(38,2)) AS SecUnfunded

FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY      cl
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
       ON cu.LoadDate         = cl.LoadDate
      AND cu.CreditLineNumber = cl.CreditLineNumber

WHERE cl.LoadDate >= @StartEOM
  AND cl.LoadDate <= @CurrEOM
  AND cl.BUSINESS_UNIT = 'BUS00'

-- Optional scope refinements (uncomment as needed):
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
--   AND cl.Line_Status IN ('Active','Open')

ORDER BY cl.LoadDate, cl.CreditLineNumber;





-- Base extract for Python-in-Excel variance analysis
-- One row per (LoadDate, CreditLineNumber)

SET NOCOUNT ON;

DECLARE @LookbackMonths int  = 13;  -- current + 12 back
-- Compute latest month end (works without EOMONTH)
DECLARE @CurrEOM date = DATEADD(DAY, -DAY(CAST(GETDATE() AS date)), CAST(GETDATE() AS date));
DECLARE @StartEOM date = DATEADD(MONTH, -(@LookbackMonths - 1), @CurrEOM);

SELECT
    cu.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
       ON cl.LoadDate = cu.LoadDate
      AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate >= @StartEOM
  AND cu.LoadDate <= @CurrEOM
-- Optional scope filters:
--   AND cl.ApplID = 'LN'
--   AND cl.FormulaLine = 1
ORDER BY cu.LoadDate, cu.CreditLineNumber;






/*==============================================================
  Base extract for Python-in-Excel variance analysis
  - SQL Server (CRDLMTUFCALC)
  - Pulls current EOM (as of today) + trailing @LookbackMonths-1 EOMs
  - One row per (LoadDate, CreditLineNumber)
==============================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM         date = EOMONTH(GETDATE(), -1);  -- e.g., today 2025-09-05 -> 2025-08-31
DECLARE @LookbackMonths  int  = 13;  -- current + prior 12 (adjust if you want more history)

;WITH rng AS (
    SELECT
        /* Start at the earliest month we want to include */
        EOMONTH(DATEADD(MONTH, -( @LookbackMonths - 1 ), @CurrEOM)) AS StartEOM,
        @CurrEOM AS EndEOM
),
-- Pull SecUnfunded + join line metadata
raw AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM

    /* Optional: scope filters (uncomment as desired)
       AND cl.ApplID = 'LN'
       AND cl.FormulaLine = 1
       -- AND cl.ClientName IS NOT NULL
       -- AND cu.CreditLineNumber IN ('123456','789012')
    */
),
/* If your source can have duplicates per (LoadDate, CreditLineNumber)
   (e.g., multiple calc runs without RunID scoping), keep a deterministic
   single record. MAX() is a safe choice for balances that should end
   the month at a single figure. Switch to SUM() if your data model
   expects summation across fragments. */
dedup AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        MAX(SecUnfunded) AS SecUnfunded,   -- or SUM(SecUnfunded)
        MAX(CIF)         AS CIF,
        MAX(ClientName)  AS ClientName,
        MAX(ApplID)      AS ApplID,
        MAX(FormulaLine) AS FormulaLine
    FROM raw
    GROUP BY LoadDate, CreditLineNumber
)
SELECT
    LoadDate,
    CreditLineNumber,
    SecUnfunded,      -- numeric, cast already applied
    CIF,
    ClientName,
    ApplID,
    FormulaLine
FROM dedup
ORDER BY LoadDate, CreditLineNumber;








/*=============================================================================
  Portfolio-Wide Review with StDev Floor (Fix A) + SeverityScore/Rank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Rolling Z vs trailing 12 months (excluding current), with stdev floor
  - Returns union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;   -- notable outlier
DECLARE @TopN             int           = 25;       -- top-N abs $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;     -- e.g., 250000 to always include big $ moves

-- Severity weights (tune as you like)
DECLARE @wZ   float = 100.0;   -- per 1.0 of |Z|
DECLARE @wAmt float = 10.0;    -- per log10(|$|+1)
DECLARE @wPct float = 1.0;     -- per percentage point (100×|MoM_Pct|)

-- *** Fix A: StDev floor parameters ***
DECLARE @StdFloorAbs         decimal(38,6) = 250.0;   -- absolute $ floor
DECLARE @StdFloorPctOfMean   decimal(9,6)  = 0.005;   -- 0.5% of trailing mean

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        /* -------- Fix A: Z with stdev floor --------
           Effective floor = MAX(@StdFloorAbs, |Mean_Prev12| * @StdFloorPctOfMean)
           If StDev_Prev12 < floor => Z = NULL (unreliable)
        */
        CAST(
          CASE 
            WHEN s.Cnt_Prev12 < 6 THEN NULL  -- require minimum history
            WHEN s.StDev_Prev12 IS NULL THEN NULL
            WHEN s.StDev_Prev12 <
                 CASE 
                   WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
                   ELSE
                     CASE 
                       WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                            THEN @StdFloorAbs
                            ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                     END
                 END
              THEN NULL
            ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
          END AS decimal(38,4)
        ) AS Z_Prev12

    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        ABS(ISNULL(rs.Z_Prev12, 0))             AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0) AS LogAmt,
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0       AS AbsPctPoints,

        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0)) AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;









DECLARE @StdFloorAbs       decimal(38,6) = 250.0;   -- absolute stdev floor in $
DECLARE @StdFloorPctOfMean decimal(9,6)  = 0.005;   -- 0.5% of trailing mean




-- Effective floor = max(abs floor, % of mean)
CAST(
  CASE
    WHEN s.Cnt_Prev12 < 6 THEN NULL
    ELSE
      CASE 
        WHEN s.StDev_Prev12 IS NULL THEN NULL
        WHEN s.StDev_Prev12 < 
             CASE 
               WHEN s.Mean_Prev12 IS NULL THEN @StdFloorAbs
               ELSE 
                 CASE 
                   WHEN @StdFloorAbs > (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                        THEN @StdFloorAbs
                        ELSE (ABS(s.Mean_Prev12) * @StdFloorPctOfMean)
                 END
             END
          THEN NULL
        ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
      END
  END AS decimal(38,4)
) AS Z_Prev12







/*=============================================================================
  Portfolio-Wide Review with SeverityScore + SeverityRank
  - Latest anchor = EOMONTH(GETDATE(), -1)
  - Per credit line: evaluate latest available month on/before anchor
  - Compute MoM change + Z vs trailing 12 months (excluding current)
  - Return union of:
      (a) Top @TopN by |MoM_Diff| and
      (b) All with |Z| >= @ZThreshold (min history)
  - Compute SeverityScore and SeverityRank for the final set
=============================================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM          date          = EOMONTH(GETDATE(), -1);
DECLARE @LookbackMonths   int           = 12;
DECLARE @ZThreshold       decimal(10,4) = 2.0000;  -- notable outlier
DECLARE @TopN             int           = 25;      -- top-N absolute $ movers
DECLARE @DollarThreshold  decimal(38,2) = NULL;    -- e.g., 250000 to always include big $ moves

-- Severity weights (tune these)
DECLARE @wZ   float = 100.0;  -- impact per 1.0 of |Z|
DECLARE @wAmt float = 10.0;   -- impact per log10(|$|+1)
DECLARE @wPct float = 1.0;    -- impact per percentage point of |MoM_Pct| (i.e., 100 * fraction)

;WITH rng AS (
    SELECT DATEADD(MONTH, -@LookbackMonths, @CurrEOM) AS StartEOM,
           @CurrEOM                                   AS EndEOM
),
base AS (
    SELECT
        cu.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
           ON cl.LoadDate = cu.LoadDate
          AND cl.CreditLineNumber = cu.CreditLineNumber
    CROSS JOIN rng
    WHERE cu.LoadDate BETWEEN rng.StartEOM AND rng.EndEOM
),
series AS (
    SELECT
        b.*,
        LAG(b.SecUnfunded, 1) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate) AS Prev_SecUnfunded,
        AVG(b.SecUnfunded)   OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12,
        COUNT(b.SecUnfunded) OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate
                                   ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Cnt_Prev12,
        ROW_NUMBER() OVER (PARTITION BY b.CreditLineNumber ORDER BY b.LoadDate DESC) AS rn_desc
    FROM base b
),
calc AS (
    SELECT
        s.LoadDate                                AS LoadDate_Curr,
        s.CreditLineNumber,
        s.CIF, s.ClientName, s.ApplID, s.FormulaLine,

        s.SecUnfunded                              AS SecUnfunded_Curr,
        s.Prev_SecUnfunded                         AS SecUnfunded_Prev,

        CAST(s.SecUnfunded - ISNULL(s.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
        CAST(CASE WHEN ISNULL(s.Prev_SecUnfunded,0.00)=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Prev_SecUnfunded) / NULLIF(ABS(s.Prev_SecUnfunded),0.00)
             END AS decimal(38,6)) AS MoM_Pct,

        CAST(s.Mean_Prev12  AS decimal(38,4))  AS Mean_Prev12,
        CAST(s.StDev_Prev12 AS decimal(38,4))  AS StDev_Prev12,
        s.Cnt_Prev12,

        CAST(CASE WHEN s.StDev_Prev12 IS NULL OR s.StDev_Prev12=0 THEN NULL
                  ELSE (s.SecUnfunded - s.Mean_Prev12) / s.StDev_Prev12
             END AS decimal(38,4)) AS Z_Prev12,

        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)=0 AND ISNULL(s.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
        CASE WHEN ISNULL(s.Prev_SecUnfunded,0)<>0 AND ISNULL(s.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
    FROM series s
    WHERE s.rn_desc = 1  -- latest available per line
),
ranked_absdiff AS (
    SELECT
        c.*,
        ROW_NUMBER() OVER (ORDER BY ABS(c.MoM_Diff) DESC, c.CreditLineNumber) AS rn_absdiff
    FROM calc c
),
review_set AS (
    SELECT *
    FROM ranked_absdiff r
    WHERE
           (r.Cnt_Prev12 >= 6 AND r.Z_Prev12 IS NOT NULL AND ABS(r.Z_Prev12) >= @ZThreshold)
        OR (r.rn_absdiff <= @TopN)
        OR (@DollarThreshold IS NOT NULL AND ABS(r.MoM_Diff) >= @DollarThreshold)
),
scored AS (
    SELECT
        rs.*,
        -- Components for scoring
        ABS(ISNULL(rs.Z_Prev12, 0))                    AS AbsZ,
        LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)        AS LogAmt,               -- stable scale for $ moves
        ABS(ISNULL(rs.MoM_Pct,0)) * 100.0              AS AbsPctPoints,         -- convert fraction to pct points

        -- Final SeverityScore (tunable weights)
        (@wZ   * ABS(ISNULL(rs.Z_Prev12, 0))) +
        (@wAmt * LOG10(ABS(ISNULL(rs.MoM_Diff,0)) + 1.0)) +
        (@wPct * (ABS(ISNULL(rs.MoM_Pct,0)) * 100.0))  AS SeverityScore
    FROM review_set rs
)
SELECT
    s.CreditLineNumber,
    s.CIF,
    s.ClientName,
    s.ApplID,
    s.FormulaLine,

    s.LoadDate_Curr,
    s.SecUnfunded_Prev,
    s.SecUnfunded_Curr,

    s.MoM_Diff,
    s.MoM_Pct,

    s.Mean_Prev12,
    s.StDev_Prev12,
    s.Cnt_Prev12,
    s.Z_Prev12,

    s.Flag_ZeroToNonZero,
    s.Flag_NonZeroToZero,

    s.SeverityScore,

    ROW_NUMBER() OVER (
        ORDER BY
            s.SeverityScore DESC,
            ABS(ISNULL(s.Z_Prev12,0)) DESC,
            ABS(s.MoM_Diff) DESC,
            ABS(ISNULL(s.MoM_Pct,0)) DESC,
            s.CreditLineNumber
    ) AS SeverityRank
FROM scored s
ORDER BY SeverityRank;







/*==========================================================
  Single-CreditLine Variance Analysis (12M history + Z-score)
  - Anchors current EOM to latest month-end relative to today
    (e.g., if today is 2025-09-04 -> current EOM = 2025-08-31)
  - Pulls up to 12 prior EOMs (plus current), handles gaps
  - Computes MoM diffs, trailing-12 mean/stdev (prev-12 only),
    and Z-score vs trailing 12 (statistically sound)
==========================================================*/

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line
DECLARE @LookbackMonths    int        = 12;
DECLARE @NaturalCurrEOM    date       = EOMONTH(GETDATE(), -1);

/* Latest available EOM for this line on/before @NaturalCurrEOM */
DECLARE @Anchor date =
(
  SELECT MAX(cu.LoadDate)
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  WHERE cu.CreditLineNumber = @CreditLineNumber
    AND cu.LoadDate <= @NaturalCurrEOM
);

IF @Anchor IS NULL
BEGIN
    DECLARE @msg nvarchar(200) =
        CONCAT('No data found on or before ',
               CONVERT(varchar(10), @NaturalCurrEOM, 120),
               ' for CreditLine ', @CreditLineNumber, '.');
    RAISERROR(@msg, 16, 1);
    RETURN;
END;

/* =========================
   A) Full 13-row Panel
   ========================= */
;WITH spine AS (
    -- generate current anchor + 12 prior EOMs
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1,
           EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT
        s.LoadDate,
        cu.CreditLineNumber,
        CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT
        h.LoadDate,
        COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
        h.SecUnfunded,
        cl.CIF,
        cl.ClientName,
        cl.ApplID,
        cl.FormulaLine,
        cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,

        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- trailing statistics over the *previous* 12 months (excludes current)
        AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(b.Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN NULL
              ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(
             CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12=0 THEN 0
                  ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
             END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base b
ORDER BY b.LoadDate
OPTION (MAXRECURSION 200);

/* =========================
   B) Latest-month Spotlight
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           CIF, ClientName, ApplID, FormulaLine, BankCode,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT TOP (1)
    LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode,
    SecUnfunded, Prev_SecUnfunded,
    CAST(SecUnfunded - ISNULL(Prev_SecUnfunded,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE WHEN ISNULL(Prev_SecUnfunded,0.00)=0 THEN NULL
              ELSE (SecUnfunded - Prev_SecUnfunded) / NULLIF(ABS(Prev_SecUnfunded),0.00)
         END AS decimal(38,6)) AS MoM_Pct,
    CAST(Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,
    CAST(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN NULL
              ELSE (SecUnfunded - Mean_Prev12) / StDev_Prev12
         END AS decimal(38,4)) AS Z_Prev12,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,
    CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
FROM base
ORDER BY LoadDate DESC
OPTION (MAXRECURSION 200);

/* =========================
   C) Quick Summary (Panel)
   ========================= */
;WITH spine AS (
    SELECT 0 AS n, @Anchor AS LoadDate
    UNION ALL
    SELECT n+1, EOMONTH(DATEADD(MONTH, -(n+1), @Anchor))
    FROM spine
    WHERE n < @LookbackMonths
),
hist AS (
    SELECT s.LoadDate, cu.CreditLineNumber, CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
    FROM spine s
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
      ON cu.LoadDate = s.LoadDate
     AND cu.CreditLineNumber = @CreditLineNumber
),
histmeta AS (
    SELECT h.LoadDate, COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
           h.SecUnfunded, cl.CIF, cl.ClientName, cl.ApplID, cl.FormulaLine, cl.BankCode
    FROM hist h
    LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
      ON cl.LoadDate = h.LoadDate
     AND cl.CreditLineNumber = @CreditLineNumber
),
base AS (
    SELECT LoadDate, CreditLineNumber, SecUnfunded,
           LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,
           AVG(SecUnfunded)   OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
           STDEV(SecUnfunded) OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM histmeta
)
SELECT
    COUNT(*)                                                       AS Rows_In_Panel,
    SUM(CASE WHEN Prev_SecUnfunded IS NULL THEN 0 ELSE 1 END)      AS Rows_With_Prior,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)=0 AND ISNULL(SecUnfunded,0)<>0 THEN 1 ELSE 0 END) AS Cnt_ZeroToNonZero,
    SUM(CASE WHEN ISNULL(Prev_SecUnfunded,0)<>0 AND ISNULL(SecUnfunded,0)=0 THEN 1 ELSE 0 END) AS Cnt_NonZeroToZero,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 2 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_2plus,
    SUM(CASE WHEN ABS(CASE WHEN StDev_Prev12 IS NULL OR StDev_Prev12=0 THEN 0 ELSE (SecUnfunded - Mean_Prev12)/StDev_Prev12 END) >= 3 THEN 1 ELSE 0 END) AS Cnt_Z_Abs_3plus
FROM base
OPTION (MAXRECURSION 200);



/* ==========================================================
   Drill-Down Variance Analysis for ONE CreditLine
   - Pulls last 12 EOM snapshots (plus one extra to get MoM)
   - Computes MoM_Diff / MoM_Pct
   - Rolling (prev-12) mean & stdev
   - Z-score per month vs trailing 12 (excludes the month itself)
   - Flags: |Z|≥2 (moderate), |Z|≥3 (severe), zero↔nonzero switches

   Assumed tables (SQL Server):
     CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED   (LoadDate, CreditLineNumber, SecUnfunded)
     CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY   (LoadDate, CreditLineNumber, CIF, ClientName, ApplID, FormulaLine, BankCode)

   >>> Set @CreditLineNumber below
========================================================== */

SET NOCOUNT ON;

DECLARE @CreditLineNumber  varchar(64) = '1234567890';  -- << plug your line here
DECLARE @CurrEOM          date        = EOMONTH(GETDATE(), -1);  -- latest month-end as of "today"
DECLARE @LookbackMonths    int        = 12;             -- trailing window

/* 0) Resolve current/prior month-ends that actually exist for this line */
IF OBJECT_ID('tempdb..#LineEOM') IS NOT NULL DROP TABLE #LineEOM;

;WITH d AS (
    SELECT DISTINCT LoadDate
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
    WHERE CreditLineNumber = @CreditLineNumber
      AND LoadDate <= @CurrEOM
),
ranked AS (
    SELECT LoadDate,
           ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
    FROM d
)
SELECT
    MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM_Available,
    MAX(CASE WHEN rn = @LookbackMonths + 1 THEN LoadDate END) AS OldestNeededEOM
INTO #LineEOM
FROM ranked;

/* 1) Build a month-end spine (dates) for the last @LookbackMonths + 1 months up to the available current EOM */
IF OBJECT_ID('tempdb..#Spine') IS NOT NULL DROP TABLE #Spine;

DECLARE @Anchor date = (SELECT CurrEOM_Available FROM #LineEOM);
IF @Anchor IS NULL
BEGIN
    RAISERROR('No data found on or before %s for CreditLine %s.', 16, 1, CONVERT(varchar(10), @CurrEOM, 120), @CreditLineNumber);
    RETURN;
END

;WITH spine AS (
    SELECT @Anchor AS LoadDate, 0 AS step
    UNION ALL
    SELECT EOMONTH(DATEADD(MONTH, -1, LoadDate)), step + 1
    FROM spine
    WHERE step < @LookbackMonths
)
SELECT LoadDate
INTO #Spine
FROM spine
OPTION (MAXRECURSION 200);

/* 2) Pull SecUnfunded history for that line, aligned to the spine (left join → preserves missing months) */
IF OBJECT_ID('tempdb..#Hist') IS NOT NULL DROP TABLE #Hist;

SELECT
    s.LoadDate,
    cu.CreditLineNumber,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
INTO #Hist
FROM #Spine s
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
    ON cu.LoadDate = s.LoadDate
   AND cu.CreditLineNumber = @CreditLineNumber;

/* 3) Attach some metadata (from CREDIT_LINE_MONTHLY at the same LoadDate, if available) */
IF OBJECT_ID('tempdb..#HistMeta') IS NOT NULL DROP TABLE #HistMeta;

SELECT
    h.LoadDate,
    COALESCE(h.CreditLineNumber, @CreditLineNumber) AS CreditLineNumber,
    h.SecUnfunded,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode
INTO #HistMeta
FROM #Hist h
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = h.LoadDate
 AND cl.CreditLineNumber = @CreditLineNumber;

/* 4) Compute MoM diffs and rolling stats; Z-score vs trailing 12 (excluding current) */
IF OBJECT_ID('tempdb..#Stats') IS NOT NULL DROP TABLE #Stats;

;WITH base AS (
    SELECT
        LoadDate,
        CreditLineNumber,
        SecUnfunded,
        CIF, ClientName, ApplID, FormulaLine, BankCode,
        LAG(SecUnfunded, 1) OVER (ORDER BY LoadDate) AS Prev_SecUnfunded,

        -- Rolling (prev-12) mean & stdev; excludes the current month by framing to 1 PRECEDING
        AVG(SecUnfunded)  OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS Mean_Prev12,
        STDEV(SecUnfunded)OVER (ORDER BY LoadDate ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS StDev_Prev12
    FROM #HistMeta
)
SELECT
    b.LoadDate,
    b.CreditLineNumber,
    b.CIF, b.ClientName, b.ApplID, b.FormulaLine, b.BankCode,

    b.SecUnfunded,
    b.Prev_SecUnfunded,

    CAST(b.SecUnfunded - ISNULL(b.Prev_SecUnfunded, 0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
        CASE WHEN ISNULL(b.Prev_SecUnfunded, 0.00) = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Prev_SecUnfunded) / NULLIF(ABS(b.Prev_SecUnfunded), 0.00)
        END AS decimal(38,6)
    ) AS MoM_Pct,

    CAST(b.Mean_Prev12 AS decimal(38,4))  AS Mean_Prev12,
    CAST(b.StDev_Prev12 AS decimal(38,4)) AS StDev_Prev12,

    CAST(
        CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN NULL
             ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12
        END AS decimal(38,4)
    ) AS Z_Prev12,

    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)=0 AND ISNULL(b.SecUnfunded,0)<>0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(b.Prev_SecUnfunded,0)<>0 AND ISNULL(b.SecUnfunded,0)=0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 2 THEN 1 ELSE 0 END AS Flag_Z_2plus,

    CASE WHEN ABS(
            CASE WHEN b.StDev_Prev12 IS NULL OR b.StDev_Prev12 = 0 THEN 0
                 ELSE (b.SecUnfunded - b.Mean_Prev12) / b.StDev_Prev12 END
        ) >= 3 THEN 1 ELSE 0 END AS Flag_Z_3plus
INTO #Stats
FROM base b;

/* 5) Final outputs
      A) Full 13-row panel (oldest … latest)
      B) Latest-month spotlight (most recent EOM available)
      C) Quick anomaly summary counts across the panel
*/
-- A) Panel
SELECT *
FROM #Stats
ORDER BY LoadDate;

-- B) Latest-month spotlight
SELECT TOP (1) *
FROM #Stats
ORDER BY LoadDate DESC;

-- C) Summary (counts across panel)
SELECT
    COUNT(*)                                           AS Rows_In_Panel,
    SUM(CASE WHEN MoM_Diff IS NULL THEN 0 ELSE 1 END)  AS Rows_With_Prior,
    SUM(Flag_ZeroToNonZero)                            AS Cnt_ZeroToNonZero,
    SUM(Flag_NonZeroToZero)                            AS Cnt_NonZeroToZero,
    SUM(Flag_Z_2plus)                                  AS Cnt_Z_Abs_2plus,
    SUM(Flag_Z_3plus)                                  AS Cnt_Z_Abs_3plus
FROM #Stats;





/*==========================================================
  MoM SecUnfunded Variance @ CreditLine
  Current month = 08/31/2025
  Prior month   = 07/31/2025
==========================================================*/

SET NOCOUNT ON;

DECLARE @CurrEOM date = '2025-08-31';
DECLARE @PrevEOM date = '2025-07-31';

/* Current snapshot */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Curr
INTO #Curr
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @CurrEOM
  AND cl.LoadDate = @CurrEOM;

/* Prior snapshot */
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

SELECT
    cu.CreditLineNumber,
    cl.CIF,
    cl.ClientName,
    cl.ApplID,
    cl.FormulaLine,
    cl.BankCode,
    CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded_Prev
INTO #Prev
FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
LEFT JOIN CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  ON cl.LoadDate = cu.LoadDate
 AND cl.CreditLineNumber = cu.CreditLineNumber
WHERE cu.LoadDate = @PrevEOM
  AND cl.LoadDate = @PrevEOM;

/* MoM Variance */
SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,
    COALESCE(c.CIF, p.CIF)           AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID, p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine, p.FormulaLine) AS FormulaLine,
    COALESCE(c.BankCode, p.BankCode) AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr,0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev,0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(
      CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                 / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
      END AS decimal(38,6)
    ) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber
ORDER BY ABS(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00)) DESC;






/*==========================================================
  MoM SecUnfunded Variance @ CreditLine (no RunID)
  - Auto-detects the latest two LoadDates from CALCULATED_UNFUNDED
  - Joins optional line metadata from CREDIT_LINE_MONTHLY (current/prior)
  - Safe math, zero↔nonzero flags
==========================================================*/

SET NOCOUNT ON;

/* 1) Identify the latest two LoadDates present in CALCULATED_UNFUNDED */
IF OBJECT_ID('tempdb..#EOM') IS NOT NULL DROP TABLE #EOM;
WITH DistinctDates AS (
  SELECT DISTINCT LoadDate
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED
),
Ranked AS (
  SELECT LoadDate,
         ROW_NUMBER() OVER (ORDER BY LoadDate DESC) AS rn
  FROM DistinctDates
)
SELECT
  MAX(CASE WHEN rn = 1 THEN LoadDate END) AS CurrEOM,
  MAX(CASE WHEN rn = 2 THEN LoadDate END) AS PrevEOM
INTO #EOM
FROM Ranked
WHERE rn IN (1,2);

-- Optional: quick sanity check
-- SELECT * FROM #EOM;

/* 2) Build current & prior SecUnfunded snapshots */
IF OBJECT_ID('tempdb..#Curr') IS NOT NULL DROP TABLE #Curr;
IF OBJECT_ID('tempdb..#Prev') IS NOT NULL DROP TABLE #Prev;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Curr AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.CurrEOM
), CL_Curr AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT CurrEOM FROM #EOM) d
  WHERE cl.LoadDate = d.CurrEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    c.SecUnfunded AS SecUnfunded_Curr
INTO #Curr
FROM CU_Curr c
LEFT JOIN CL_Curr m
  ON m.LoadDate = c.LoadDate
 AND m.CreditLineNumber = c.CreditLineNumber;

;WITH E AS (
  SELECT CurrEOM, PrevEOM FROM #EOM
), CU_Prev AS (
  SELECT cu.LoadDate,
         cu.CreditLineNumber,
         CAST(cu.SecUnfunded AS decimal(38,2)) AS SecUnfunded
  FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED cu
  CROSS JOIN E
  WHERE cu.LoadDate = E.PrevEOM
), CL_Prev AS (
  SELECT cl.LoadDate,
         cl.CreditLineNumber,
         cl.CIF,
         cl.ClientName,
         cl.ApplID,
         cl.FormulaLine,
         cl.BankCode
  FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY cl
  CROSS JOIN (SELECT PrevEOM FROM #EOM) d
  WHERE cl.LoadDate = d.PrevEOM
  -- Optional business scope (uncomment to narrow):
  -- AND cl.ApplID = 'LN'
  -- AND cl.FormulaLine = 1
)
SELECT
    p.LoadDate,
    p.CreditLineNumber,
    m.CIF,
    m.ClientName,
    m.ApplID,
    m.FormulaLine,
    m.BankCode,
    p.SecUnfunded AS SecUnfunded_Prev
INTO #Prev
FROM CU_Prev p
LEFT JOIN CL_Prev m
  ON m.LoadDate = p.LoadDate
 AND m.CreditLineNumber = p.CreditLineNumber;

/* 3) Compute MoM */
IF OBJECT_ID('tempdb..#MoM') IS NOT NULL DROP TABLE #MoM;

DECLARE @CurrEOM date = (SELECT CurrEOM FROM #EOM);
DECLARE @PrevEOM date = (SELECT PrevEOM FROM #EOM);

SELECT
    COALESCE(c.CreditLineNumber, p.CreditLineNumber) AS CreditLineNumber,

    -- Prefer current metadata if present
    COALESCE(c.CIF,        p.CIF)        AS CIF,
    COALESCE(c.ClientName, p.ClientName) AS ClientName,
    COALESCE(c.ApplID,     p.ApplID)     AS ApplID,
    COALESCE(c.FormulaLine,p.FormulaLine)AS FormulaLine,
    COALESCE(c.BankCode,   p.BankCode)   AS BankCode,

    @CurrEOM AS LoadDate_Curr,
    @PrevEOM AS LoadDate_Prev,

    ISNULL(c.SecUnfunded_Curr, 0.00) AS SecUnfunded_Curr,
    ISNULL(p.SecUnfunded_Prev, 0.00) AS SecUnfunded_Prev,

    CAST(ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00) AS decimal(38,2)) AS MoM_Diff,
    CAST(CASE
           WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 THEN NULL
           ELSE (ISNULL(c.SecUnfunded_Curr,0.00) - ISNULL(p.SecUnfunded_Prev,0.00))
                / NULLIF(ABS(p.SecUnfunded_Prev),0.00)
         END AS decimal(38,6)) AS MoM_Pct,

    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) = 0 AND ISNULL(c.SecUnfunded_Curr,0.00) <> 0 THEN 1 ELSE 0 END AS Flag_ZeroToNonZero,
    CASE WHEN ISNULL(p.SecUnfunded_Prev,0.00) <> 0 AND ISNULL(c.SecUnfunded_Curr,0.00) = 0 THEN 1 ELSE 0 END AS Flag_NonZeroToZero
INTO #MoM
FROM #Curr c
FULL OUTER JOIN #Prev p
  ON c.CreditLineNumber = p.CreditLineNumber;

/* 4) Results */
-- Detailed variances
SELECT *
FROM #MoM
ORDER BY ABS(MoM_Diff) DESC, CreditLineNumber;

-- Quick top movers
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff DESC, CreditLineNumber; -- biggest increases
SELECT TOP 25 * FROM #MoM ORDER BY MoM_Diff ASC,  CreditLineNumber; -- biggest decreases

-- Optional rollups (uncomment as needed):
-- SELECT BankCode, SUM(SecUnfunded_Prev) AS Prev_, SUM(SecUnfunded_Curr) AS Curr_, SUM(MoM_Diff) AS MoM_Diff
-- FROM #MoM GROUP BY BankCode ORDER BY ABS(SUM(MoM_Diff)) DESC;






-- === Define the two months once ===
DECLARE @PrevDate date = DATEFROMPARTS(2025,7,31);
DECLARE @CurrDate date = DATEFROMPARTS(2025,8,31);

WITH Prev AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @PrevDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
),
Curr AS (
    SELECT 
        CAST(a.LoadDate AS date)                                AS LoadDate,
        a.Cif,
        a.CreditLineNumber,
        a.RevolvingFlag,
        a.FormulaLine,
        CAST(a.NetBorrowingBase AS decimal(19,2))               AS NetBorrowingBase,
        CAST(a.GrossLineAmount  AS decimal(19,2))               AS GrossLineAmount,
        CAST(a.NetLineAmount    AS decimal(19,2))               AS NetLineAmount,
        CAST(a.NetUtilized      AS decimal(19,2))               AS NetUtilized,
        CAST(b.SecUnfunded      AS decimal(19,2))               AS SecUnfunded,
        CAST(CASE
            WHEN a.NetBorrowingBase < a.NetLineAmount 
                 THEN (a.NetBorrowingBase - a.NetUtilized)
            ELSE      (a.NetLineAmount   - a.NetUtilized)
        END AS decimal(19,2))                                   AS Recalculated_SecUnfunded
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
        ON a.LoadDate = b.LoadDate
       AND a.CreditLineNumber = b.CreditLineNumber
    WHERE a.LoadDate = @CurrDate
      AND a.CreditLineNumber IN (
        '200147535IMXARLINE1',
        '200082386IMXARLINE2',
        '200287492IMXARLINE1',
        '200093013IMXARLINE1',
        '200056647IMXARLINE1')
)

SELECT
    c.LoadDate,
    c.Cif,
    c.CreditLineNumber,
    c.RevolvingFlag,
    c.FormulaLine,

    p.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    c.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(c.NetBorrowingBase,0)  - ISNULL(p.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    p.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    c.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(c.GrossLineAmount,0)   - ISNULL(p.GrossLineAmount,0)   AS GrossLineAmount_Change,

    p.NetLineAmount     AS PrevMonth_NetLineAmount,
    c.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(c.NetLineAmount,0)     - ISNULL(p.NetLineAmount,0)     AS NetLineAmount_Change,

    p.NetUtilized       AS PrevMonth_NetUtilized,
    c.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(c.NetUtilized,0)       - ISNULL(p.NetUtilized,0)       AS NetUtilized_Change,

    p.SecUnfunded       AS PrevMonth_SecUnfunded,
    c.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(c.SecUnfunded,0)       - ISNULL(p.SecUnfunded,0)       AS SecUnfunded_Change,

    p.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    c.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(c.Recalculated_SecUnfunded,0) - ISNULL(p.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM Curr c
LEFT JOIN Prev p
  ON p.CreditLineNumber = c.CreditLineNumber;





IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- === PREVIOUS MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === CURRENT MONTH: keep raw numeric column names ===
SELECT 
    CAST(a.LoadDate AS date)                  AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2)) AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2)) AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2)) AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2)) AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2)) AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                     AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- === COMPARE (numeric math only; no FORMAT anywhere) ===
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- show raw values
    pm.NetBorrowingBase  AS PrevMonth_NetBorrowingBase,
    cm.NetBorrowingBase  AS CurrMonth_NetBorrowingBase,
    ISNULL(cm.NetBorrowingBase,0)  - ISNULL(pm.NetBorrowingBase,0)  AS NetBorrowingBase_Change,

    pm.GrossLineAmount   AS PrevMonth_GrossLineAmount,
    cm.GrossLineAmount   AS CurrMonth_GrossLineAmount,
    ISNULL(cm.GrossLineAmount,0)   - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    pm.NetLineAmount     AS PrevMonth_NetLineAmount,
    cm.NetLineAmount     AS CurrMonth_NetLineAmount,
    ISNULL(cm.NetLineAmount,0)     - ISNULL(pm.NetLineAmount,0)     AS NetLineAmount_Change,

    pm.NetUtilized       AS PrevMonth_NetUtilized,
    cm.NetUtilized       AS CurrMonth_NetUtilized,
    ISNULL(cm.NetUtilized,0)       - ISNULL(pm.NetUtilized,0)       AS NetUtilized_Change,

    pm.SecUnfunded       AS PrevMonth_SecUnfunded,
    cm.SecUnfunded       AS CurrMonth_SecUnfunded,
    ISNULL(cm.SecUnfunded,0)       - ISNULL(pm.SecUnfunded,0)       AS SecUnfunded_Change,

    pm.Recalculated_SecUnfunded AS PrevMonth_Recalc_SecUnfunded,
    cm.Recalculated_SecUnfunded AS CurrMonth_Recalc_SecUnfunded,
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);








IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- PREVIOUS MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized, 
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,7,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- CURRENT MONTH (keep numeric, original names)
SELECT 
    CAST(a.LoadDate AS date)                      AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase AS decimal(19,2))     AS NetBorrowingBase, 
    CAST(a.GrossLineAmount  AS decimal(19,2))     AS GrossLineAmount, 
    CAST(a.NetLineAmount    AS decimal(19,2))     AS NetLineAmount, 
    CAST(a.NetUtilized      AS decimal(19,2))     AS NetUtilized,
    CAST(b.SecUnfunded      AS decimal(19,2))     AS SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount 
             THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE      (a.NetLineAmount   - a.NetUtilized)
    END AS decimal(19,2))                          AS Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = DATEFROMPARTS(2025,8,31)
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- COMPARE (math on numerics; optional FORMAT for display)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- optional pretty display of raw values
    FORMAT(pm.NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    ISNULL(cm.NetBorrowingBase,0) - ISNULL(pm.NetBorrowingBase,0) AS NetBorrowingBase_Change,

    FORMAT(pm.GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    ISNULL(cm.GrossLineAmount,0) - ISNULL(pm.GrossLineAmount,0)   AS GrossLineAmount_Change,

    FORMAT(pm.NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    ISNULL(cm.NetLineAmount,0) - ISNULL(pm.NetLineAmount,0)       AS NetLineAmount_Change,

    FORMAT(pm.NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    ISNULL(cm.NetUtilized,0) - ISNULL(pm.NetUtilized,0)           AS NetUtilized_Change,

    FORMAT(pm.SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    ISNULL(cm.SecUnfunded,0) - ISNULL(pm.SecUnfunded,0)           AS SecUnfunded_Change,

    -- recalculated sec unfunded comparison (numeric)
    ISNULL(cm.Recalculated_SecUnfunded,0) - ISNULL(pm.Recalculated_SecUnfunded,0) AS Recalc_SecUnfunded_Change
FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);






IF OBJECT_ID('tempdb..#PrevMonth') IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth') IS NOT NULL DROP TABLE #CurrMonth;

-- Previous month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS PrevMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS PrevMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS PrevMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS PrevMonth_NetUtilized, 
    CAST(b.SecUnfunded          AS decimal(19,2)) AS PrevMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS PrevMonth_Recalculated_SecUnfunded
INTO #PrevMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-07-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Current month (numeric, not formatted)
SELECT 
    CAST(a.LoadDate AS date)                     AS LoadDate, 
    a.Cif, 
    a.CreditLineNumber, 
    a.RevolvingFlag, 
    a.FormulaLine, 
    CAST(a.NetBorrowingBase     AS decimal(19,2)) AS CurrMonth_NetBorrowingBase, 
    CAST(a.GrossLineAmount      AS decimal(19,2)) AS CurrMonth_GrossLineAmount, 
    CAST(a.NetLineAmount        AS decimal(19,2)) AS CurrMonth_NetLineAmount, 
    CAST(a.NetUtilized          AS decimal(19,2)) AS CurrMonth_NetUtilized,
    CAST(b.SecUnfunded          AS decimal(19,2)) AS CurrMonth_SecUnfunded, 
    CAST(CASE
        WHEN a.NetBorrowingBase < a.NetLineAmount THEN (a.NetBorrowingBase - a.NetUtilized)
        ELSE (a.NetLineAmount - a.NetUtilized)
    END AS decimal(19,2))                         AS CurrMonth_Recalculated_SecUnfunded
INTO #CurrMonth
FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
LEFT JOIN CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
  ON a.LoadDate = b.LoadDate 
 AND a.CreditLineNumber = b.CreditLineNumber
WHERE a.LoadDate = '2025-08-31'
  AND a.CreditLineNumber IN (
    '200147535IMXARLINE1',
    '200082386IMXARLINE2',
    '200287492IMXARLINE1',
    '200093013IMXARLINE1',
    '200056647IMXARLINE1');

-- Compare (do math on numerics; format at the end if desired)
SELECT
    cm.LoadDate,
    cm.Cif,
    cm.CreditLineNumber,
    cm.RevolvingFlag,
    cm.FormulaLine,

    -- Optional pretty display
    FORMAT(pm.PrevMonth_NetBorrowingBase, 'N2') AS PrevMonth_NetBorrowingBase_fmtd,
    FORMAT(cm.CurrMonth_NetBorrowingBase, 'N2') AS CurrMonth_NetBorrowingBase_fmtd,
    cm.CurrMonth_NetBorrowingBase - pm.PrevMonth_NetBorrowingBase AS NetBorrowingBase_Change,

    FORMAT(pm.PrevMonth_GrossLineAmount, 'N2')  AS PrevMonth_GrossLineAmount_fmtd,
    FORMAT(cm.CurrMonth_GrossLineAmount, 'N2')  AS CurrMonth_GrossLineAmount_fmtd,
    cm.CurrMonth_GrossLineAmount - pm.PrevMonth_GrossLineAmount   AS GrossLineAmount_Change,

    FORMAT(pm.PrevMonth_NetLineAmount, 'N2')    AS PrevMonth_NetLineAmount_fmtd,
    FORMAT(cm.CurrMonth_NetLineAmount, 'N2')    AS CurrMonth_NetLineAmount_fmtd,
    cm.CurrMonth_NetLineAmount - pm.PrevMonth_NetLineAmount       AS NetLineAmount_Change,

    FORMAT(pm.PrevMonth_NetUtilized, 'N2')      AS PrevMonth_NetUtilized_fmtd,
    FORMAT(cm.CurrMonth_NetUtilized, 'N2')      AS CurrMonth_NetUtilized_fmtd,
    cm.CurrMonth_NetUtilized - pm.PrevMonth_NetUtilized           AS NetUtilized_Change,

    FORMAT(pm.PrevMonth_SecUnfunded, 'N2')      AS PrevMonth_SecUnfunded_fmtd,
    FORMAT(cm.CurrMonth_SecUnfunded, 'N2')      AS CurrMonth_SecUnfunded_fmtd,
    cm.CurrMonth_SecUnfunded - pm.PrevMonth_SecUnfunded           AS SecUnfunded_Change

FROM #CurrMonth cm
LEFT JOIN #PrevMonth pm
  ON pm.CreditLineNumber = cm.CreditLineNumber
 AND pm.LoadDate = DATEADD(MONTH, -1, cm.LoadDate);







IF OBJECT_ID('tempdb..#PrevMonth')   IS NOT NULL DROP TABLE #PrevMonth;
IF OBJECT_ID('tempdb..#CurrMonth')  IS NOT NULL DROP TABLE #CurrMonth;

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as PrevMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as PrevMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as PrevMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as PrevMonth_NetUtilized_fmtd, 
	format(b.SecUnfunded,'N2') as PrevMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as PrevMonth_Recalculated_SecUnfunded
into #PrevMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '7/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select 
	cast(a.LoadDate as date) as LoadDate, 
	a.Cif, 
	a.CreditLineNumber, 
	a.RevolvingFlag, 
	a.FormulaLine, 
	format(a.NetBorrowingBase,'N2') as CurrMonth_NetBorrowingBase_fmtd, 
	format(a.GrossLineAmount,'N2') as CurrMonth_GrossLineAmount_fmtd, 
	format(a.NetLineAmount,'N2') as CurrMonth_NetLineAmount_fmtd, 
	format(a.NetUtilized,'N2') as CurrMonth_NetUtilized_fmtd,
	format(b.SecUnfunded,'N2') as CurrMonth_SecUnfunded_fmtd, 
	case
		when a.NetBorrowingBase < a.NetLineAmount then (a.NetBorrowingBase - a.NetUtilized)
		else (a.NetLineAmount - a.NetUtilized)
		end as CurrMonth_Recalculated_SecUnfunded
into #CurrMonth
from CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
left join CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
on a.LoadDate = b.LoadDate and a.CreditLineNumber = b.CreditLineNumber
where a.LoadDate = '8/31/2025' and a.CreditLineNumber in (
	'200147535IMXARLINE1',
	'200082386IMXARLINE2',
	'200287492IMXARLINE1',
	'200093013IMXARLINE1',
	'200056647IMXARLINE1')

select
	cm.LoadDate,
	cm.Cif,
	cm.CreditLineNumber,
	cm.RevolvingFlag,
	cm.FormulaLine,
	pm.PrevMonth_NetBorrowingBase_fmtd,
	cm.CurrMonth_NetBorrowingBase_fmtd,
	(cm.CurrMonth_NetBorrowingBase_fmtd - pm.PrevMonth_NetBorrowingBase_fmtd) as NetBorrowingBase_Change,
	pm.PrevMonth_GrossLineAmount_fmtd,
	cm.CurrMonth_GrossLineAmount_fmtd,
	(cm.CurrMonth_GrossLineAmount_fmtd - pm.PrevMonth_GrossLineAmount_fmtd) as GrossLineAmount_Change,
	pm.PrevMonth_NetLineAmount_fmtd,
	cm.CurrMonth_NetLineAmount_fmtd,
	(cm.CurrMonth_NetLineAmount_fmtd - pm.PrevMonth_NetLineAmount_fmtd) as NetLineAmount_Change,
	pm.PrevMonth_NetUtilized_fmtd,
	cm.CurrMonth_NetUtilized_fmtd,
	(cm.CurrMonth_NetUtilized_fmtd - pm.PrevMonth_NetUtilized_fmtd) as NetUtilized_Change,
	pm.PrevMonth_SecUnfunded_fmtd,
	cm.CurrMonth_SecUnfunded_fmtd,
	(cm.CurrMonth_SecUnfunded_fmtd - pm.PrevMonth_SecUnfunded_fmtd) as SecUnfunded_Change
from #CurrMonth cm
left join #PrevMonth pm
on cm.LoadDate = pm.LoadDate and cm.CreditLineNumber = pm.CreditLineNumber






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;
