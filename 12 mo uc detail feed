-- ================== Synthetic Detail (latest 2 ME) + History Summary ==================
-- No tables, no temp tables. Cat1/Cat2 logic + GL_ACCOUNT_HIER_LEVEL_4='Total Loans'.
-- DETAIL: latest two month-ends (row-level, includes GL_ACCOUNT_DESCRIPTION)
-- SUMMARY: older months grouped (tiny result set for Excel/PBI)
-- ================================================================================

WITH
/* ---- Base filtered to Total Loans ------------------------------------------------ */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure,
    ACCOUNT_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* ---- Month ranking to get latest two month-ends --------------------------------- */
months AS (
  SELECT
    month_end,
    ROW_NUMBER() OVER (ORDER BY month_end DESC) AS rn
  FROM (SELECT DISTINCT month_end FROM base) d
),

/* ---- Categories ----------------------------------------------------------------- */
/* Cat 1: CSS in list OR like '%EXCPTN%' (case-insensitive) */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN
           ('FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN')
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0 END AS cat1_flag
  FROM base b
),
/* Cat 2: GL in list AND CSS='ALL' */
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0 END AS cat2_flag
  FROM cat1 c1
),
labeled AS (
  SELECT
    c2.*,
    CASE
      WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
      WHEN cat1_flag=1 THEN 'Cat1'
      WHEN cat2_flag=1 THEN 'Cat2'
      ELSE NULL
    END AS synthetic_category
  FROM cat2 c2
),
flags_only AS (
  SELECT l.*
  FROM labeled l
  WHERE l.synthetic_category IS NOT NULL
),

/* ---- Split into DETAIL (latest 2 ME) vs SUMMARY (older) ------------------------- */
with_rank AS (
  SELECT f.*, m.rn
  FROM flags_only f
  JOIN months m ON m.month_end = f.month_end
),

detail_rows AS (
  SELECT
    'DETAIL'                         AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,
    ACCOUNT_IDENTIFIER,
    exposure,
    ACCOUNT_DESCRIPTION,
    /* summary fields null for detail */
    CAST(NULL AS INTEGER)            AS rows_flagged,
    CAST(NULL AS INTEGER)            AS accounts_flagged,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_sum,
    CAST(NULL AS NUMERIC(20,2))      AS exposure_abs_avg
  FROM with_rank
  WHERE rn <= 2   -- latest two month-ends
),

summary_rows AS (
  SELECT
    'SUMMARY'                        AS view_type,
    month_end,
    synthetic_category,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    MAX(GL_ACCOUNT_DESCRIPTION)      AS GL_ACCOUNT_DESCRIPTION, -- optional
    CAST(NULL AS VARCHAR(64))        AS ACCOUNT_IDENTIFIER,
    CAST(NULL AS FLOAT8)             AS exposure,
    CAST(NULL AS VARCHAR(4000))      AS ACCOUNT_DESCRIPTION,
    COUNT(*)                         AS rows_flagged,
    COUNT(DISTINCT ACCOUNT_IDENTIFIER) AS accounts_flagged,
    SUM(exposure)                    AS exposure_sum,
    SUM(ABS(exposure))               AS exposure_abs_sum,
    AVG(ABS(exposure))               AS exposure_abs_avg
  FROM with_rank
  WHERE rn > 2   -- all older months summarized
  GROUP BY month_end, synthetic_category, CONTRACT_SOURCE_SYSTEM, GL_ACCOUNT_CODE
)

/* ---- Final union --------------------------------------------------------------- */
SELECT *
FROM detail_rows
UNION ALL
SELECT *
FROM summary_rows
ORDER BY
  CASE view_type WHEN 'DETAIL' THEN 0 ELSE 1 END,
  month_end DESC,
  synthetic_category,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  -- for DETAIL, show largest exposures first
  CASE WHEN view_type='DETAIL' THEN ABS(exposure) END DESC NULLS LAST,
  ACCOUNT_IDENTIFIER;





-- ===================== Synthetic Identification (Cat1 / Cat2) =====================
-- No tables, no temp tables. Edit lists below as needed.
-- Filters to GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans' and returns readable fields.
-- ================================================================================

WITH
/* -------- Optional window (edit or remove) ------------------------------------ */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_month_end,
    CURRENT_DATE::DATE                  AS max_month_end
),

/* -------- Base pulled from your monthly view ---------------------------------- */
base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)               AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    GL_ACCOUNT_DESCRIPTION,                       -- for readability
    GL_ACCOUNT_HIER_LEVEL_4,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8   AS exposure,
    ACCOUNT_DESCRIPTION
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME   -- swap to your canonical monthly view if different
  WHERE CAST(END_OF_MONTH_DATE AS DATE) BETWEEN (SELECT min_month_end FROM params)
                                            AND   (SELECT max_month_end FROM params)
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* -------- Category flags ------------------------------------------------------- */
/* Cat 1: CONTRACT_SOURCE_SYSTEM in list OR like '%EXCPTN%' */
cat1 AS (
  SELECT
    b.*,
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN (
        'FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN'
      )
        OR UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%'
      THEN 1 ELSE 0
    END AS cat1_flag,
    /* Reason text for readability */
    CASE
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) LIKE '%EXCPTN%' THEN 'CSS like %EXCPTN%'
      WHEN UPPER(CONTRACT_SOURCE_SYSTEM) IN (
        'FRDS_EXCPTN','SYN','ALL','GL','LJ','ADJ','LNIQ01-EXCPTN','INFL05-EXCPTN'
      ) THEN 'CSS explicit list'
      ELSE NULL
    END AS cat1_reason
  FROM base b
),

/* Cat 2: GL_ACCOUNT_CODE in list AND CONTRACT_SOURCE_SYSTEM = 'ALL' */
cat2 AS (
  SELECT
    c1.*,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 1 ELSE 0
    END AS cat2_flag,
    CASE
      WHEN CONTRACT_SOURCE_SYSTEM = 'ALL'
       AND GL_ACCOUNT_CODE IN (
            1041210,1142067,1042213,1042368,1042409,1042424,1042886,
            1043008,1142048,1051872,1061833,1041211,1041344,1041364
          )
      THEN 'GL in Cat2 list with CSS=ALL'
      ELSE NULL
    END AS cat2_reason
  FROM cat1 c1
)

/* -------- Final output --------------------------------------------------------- */
SELECT
  month_end,
  ACCOUNT_IDENTIFIER,
  CONTRACT_SOURCE_SYSTEM,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  exposure,
  /* Synthetic category label */
  CASE
    WHEN cat1_flag=1 AND cat2_flag=1 THEN 'Cat1+Cat2'
    WHEN cat1_flag=1 THEN 'Cat1'
    WHEN cat2_flag=1 THEN 'Cat2'
    ELSE NULL
  END AS synthetic_category,
  /* Human-readable reasons (only where applicable) */
  cat1_reason,
  cat2_reason
FROM cat2
WHERE (cat1_flag=1 OR cat2_flag=1)
ORDER BY month_end DESC, synthetic_category, ABS(exposure) DESC, ACCOUNT_IDENTIFIER;










FRDS_EXCPTN
SYN
ALL
GL
LJ
ADJ
LNIQ01-EXCPTN
INFL05-EXCPTN

1041210
1142067
1042213
1042368
1042409
1042424
1042886
1043008
1142048
1051872
1061833
1041211
1041344
1041364








-- ========================= Synthetic Tracking (CTE-only) =========================
-- Purpose: Flag synthetic/internal/plug-like records without creating tables/views.
-- How to use:
--   1) Edit the RULES_* blocks below to match your environment (CSS values, GL LIKEs, text markers).
--   2) Optional: set date filter in [params].
--   3) Run. Output returns one row per account_identifier x month with a risk_score and reasons.
-- ================================================================================

WITH
/* --------------------------- PARAMETERS --------------------------------------- */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_month_end,  -- rolling window start
    CURRENT_DATE::DATE                AS max_month_end
),

/* --------------------------- RULES (edit here) --------------------------------
   Keep all rules in CTEs so no tables/views are required.
   You can also externalize these to Power BI (Enter Data) and merge them instead.
---------------------------------------------------------------------------------*/
rules_css AS (
  -- CONTRACT_SOURCE_SYSTEM patterns: exact or LIKE
  -- match_type: 'EQ' or 'LIKE'
  SELECT * FROM (
    VALUES
      ('FRDS_EXCPTN','EQ','Exception feed (synthetic)', 40, TRUE),
      ('FRDS-EXCPTN','EQ','Exception feed (synthetic)', 40, TRUE),
      ('TOPSIDE',    'EQ','Topside adjustment',         50, TRUE),
      ('MANUAL',     'EQ','Manual journal/plug',        40, TRUE),
      ('ALL',        'EQ','Consolidated host (use GL)', 10, TRUE),
      ('ICC%',     'LIKE','Intercompany/clearing',      40, TRUE)
  ) AS t(css_pattern, match_type, reason, weight, is_active)
),
rules_gl AS (
  -- GL LIKE patterns (replace with your true suspense/clearing/due-to ranges)
  SELECT * FROM (
    VALUES
      ('2999%', 'Suspense/Clearing',                 45, TRUE),
      ('2199%', 'Due To/Due From',                   40, TRUE),
      ('1399%', 'Plug/Unassigned asset',             35, TRUE),
      ('1041%', 'Loan GL aggregate (check synthetic)', 25, TRUE)
  ) AS t(gl_like, reason, weight, is_active)
),
rules_text AS (
  -- DESCRIPTION markers; case-insensitive match via UPPER()
  -- field_name currently supports ACCOUNT_DESCRIPTION (extend below if needed)
  SELECT * FROM (
    VALUES
      ('%PLUG%',       'ACCOUNT_DESCRIPTION', 'Plug marker',        30, TRUE),
      ('%INTERCO%',    'ACCOUNT_DESCRIPTION', 'Intercompany',       30, TRUE),
      ('%DUE TO%',     'ACCOUNT_DESCRIPTION', 'Due To/Due From',    25, TRUE),
      ('%CLEARING%',   'ACCOUNT_DESCRIPTION', 'Clearing',           25, TRUE)
  ) AS t(text_like, field_name, reason, weight, is_active)
),
whitelist_accounts AS (
  -- Optional: add known-good aggregator accounts you never want flagged
  -- Keep empty if not used.
  SELECT * FROM (
    VALUES
      -- ('ACCOUNT_ID_123','Legit aggregator – exclude')
  ) AS t(account_identifier, reason)
),

/* --------------------------- BASE --------------------------------------------- */
syn_base AS (
  SELECT
    CAST(END_OF_MONTH_DATE AS DATE)                      AS month_end,
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    GL_ACCOUNT_CODE,
    COALESCE(SOURCE_SYSTEM_BALANCE,0.0)::FLOAT8          AS exposure,
    ACCOUNT_DESCRIPTION,
    BUS_UNIT_CODE,
    RC_CODE,
    ACCOUNT_OFFICER_NAME
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE CAST(END_OF_MONTH_DATE AS DATE) BETWEEN (SELECT min_month_end FROM params)
                                            AND (SELECT max_month_end FROM params)
),

/* --------------------------- RULE HITS ---------------------------------------- */
rule_hits_css AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'CSS' AS rule_type,
         r.css_pattern AS pattern
  FROM syn_base b
  JOIN rules_css r
    ON r.is_active
   AND (
       (r.match_type = 'EQ'   AND b.contract_source_system = r.css_pattern)
    OR (r.match_type = 'LIKE' AND b.contract_source_system LIKE r.css_pattern)
   )
),
rule_hits_gl AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'GL' AS rule_type,
         r.gl_like AS pattern
  FROM syn_base b
  JOIN rules_gl r
    ON r.is_active AND b.gl_account_code LIKE r.gl_like
),
rule_hits_text AS (
  SELECT b.month_end, b.account_identifier, b.contract_source_system, b.gl_account_code,
         r.reason, r.weight, 'TEXT' AS rule_type,
         r.text_like AS pattern
  FROM syn_base b
  JOIN rules_text r
    ON r.is_active
   AND (
        (r.field_name='ACCOUNT_DESCRIPTION'
         AND UPPER(COALESCE(b.account_description,'')) LIKE UPPER(r.text_like))
       -- Extend here for more fields if needed
   )
),
rule_hits AS (
  SELECT * FROM rule_hits_css
  UNION ALL
  SELECT * FROM rule_hits_gl
  UNION ALL
  SELECT * FROM rule_hits_text
),

/* --------------------------- BEHAVIORAL SIGNALS ------------------------------- */
behavior_signals AS (
  SELECT
    month_end, account_identifier, contract_source_system, gl_account_code, exposure,
    LAG(exposure)  OVER (PARTITION BY account_identifier ORDER BY month_end) AS prev_exp,
    LEAD(exposure) OVER (PARTITION BY account_identifier ORDER BY month_end) AS next_exp
  FROM syn_base
),
behavior_flags AS (
  SELECT
    month_end, account_identifier,
    MAX(
      CASE WHEN prev_exp IS NOT NULL AND next_exp IS NOT NULL
            AND ABS(exposure - COALESCE(prev_exp,0)) >= 50000
            AND ABS(next_exp - COALESCE(prev_exp,0)) <= 0.05 * GREATEST(1, ABS(prev_exp))
           THEN 1 ELSE 0 END
    ) AS spike_reverse_flag,
    MAX(
      CASE WHEN ABS(exposure) IN (10000,25000,50000,100000,250000,500000,1000000)
            OR MOD(ABS(exposure),10000)=0
           THEN 1 ELSE 0 END
    ) AS round_flag,
    MAX(
      CASE WHEN (ACCOUNT_OFFICER_NAME IS NULL OR TRIM(ACCOUNT_OFFICER_NAME)='')
                OR RC_CODE IN ('RC999','UNCLASS','UNKNOWN')
           THEN 1 ELSE 0 END
    ) AS no_ctx_flag
  FROM behavior_signals
  GROUP BY month_end, account_identifier
),

/* --------------------------- INTERNAL TRANSFER PAIRS -------------------------- */
xfer_pairs AS (
  SELECT
    a.month_end,
    a.BUS_UNIT_CODE,
    a.RC_CODE,
    ABS(a.exposure) AS abs_amt
  FROM syn_base a
),
xfer_pairs_flag AS (
  SELECT month_end, 1 AS transfer_pair_flag
  FROM (
    SELECT
      p.month_end, p.BUS_UNIT_CODE, p.RC_CODE, p.abs_amt,
      SUM(CASE WHEN s.exposure >= 0 THEN 1 ELSE 0 END) AS plus_cnt,
      SUM(CASE WHEN s.exposure  < 0 THEN 1 ELSE 0 END) AS minus_cnt,
      COUNT(*) AS pair_size
    FROM xfer_pairs p
    JOIN syn_base s
      ON s.month_end = p.month_end
     AND s.BUS_UNIT_CODE = p.BUS_UNIT_CODE
     AND s.RC_CODE = p.RC_CODE
     AND ABS(s.exposure) = p.abs_amt
    GROUP BY p.month_end, p.BUS_UNIT_CODE, p.RC_CODE, p.abs_amt
  ) z
  WHERE plus_cnt >= 1 AND minus_cnt >= 1 AND pair_size >= 2
  GROUP BY month_end
),

/* --------------------------- AGGREGATE RULES ---------------------------------- */
rules_agg AS (
  SELECT
    month_end, account_identifier,
    MIN(contract_source_system) AS contract_source_system,
    MIN(gl_account_code)        AS gl_account_code,
    SUM(weight)                 AS rule_weight_sum,
    COUNT(*)                    AS rule_hits,
    LISTAGG(rule_type||':'||pattern||' ('||reason||')', '; ') 
      WITHIN GROUP (ORDER BY rule_type, pattern) AS reasons
  FROM rule_hits
  GROUP BY month_end, account_identifier
),

/* --------------------------- EXPOSURE SNAPSHOT -------------------------------- */
exp_agg AS (
  SELECT month_end, account_identifier, MAX(exposure) AS exposure_amount
  FROM syn_base
  GROUP BY month_end, account_identifier
)

/* --------------------------- FINAL OUTPUT ------------------------------------- */
SELECT
  b.month_end,
  b.account_identifier,
  COALESCE(r.contract_source_system, sb.contract_source_system) AS contract_source_system,
  COALESCE(r.gl_account_code,        sb.gl_account_code)        AS gl_account_code,
  e.exposure_amount,
  COALESCE(r.rule_hits,0)        AS rule_hits,
  COALESCE(r.rule_weight_sum,0)  AS rule_weight_sum,
  COALESCE(f.spike_reverse_flag,0)  AS spike_reverse_flag,
  COALESCE(f.round_flag,0)          AS round_flag,
  COALESCE(f.no_ctx_flag,0)         AS no_ctx_flag,
  COALESCE(x.transfer_pair_flag,0)  AS transfer_pair_flag,
  /* Composite risk score (cap at 100). Tune weights below. */
  LEAST(
    100,
    COALESCE(r.rule_weight_sum,0)
    + 15*COALESCE(f.spike_reverse_flag,0)
    + 10*COALESCE(f.round_flag,0)
    + 10*COALESCE(f.no_ctx_flag,0)
    + 20*COALESCE(x.transfer_pair_flag,0)
  ) AS risk_score,
  /* Reasons text */
  COALESCE(r.reasons,'') ||
    CASE WHEN COALESCE(f.spike_reverse_flag,0)=1 THEN '; BEHAV:Spike&Reverse' END ||
    CASE WHEN COALESCE(f.round_flag,0)=1        THEN '; BEHAV:Round'          END ||
    CASE WHEN COALESCE(f.no_ctx_flag,0)=1       THEN '; BEHAV:NoContext'      END ||
    CASE WHEN COALESCE(x.transfer_pair_flag,0)=1 THEN '; BEHAV:InternalTransfer' END
    AS reasons
FROM (
  -- driving set: all account×month present in window
  SELECT DISTINCT month_end, account_identifier, contract_source_system, gl_account_code
  FROM syn_base
) sb
LEFT JOIN rules_agg r
  ON r.month_end = sb.month_end AND r.account_identifier = sb.account_identifier
LEFT JOIN exp_agg e
  ON e.month_end = sb.month_end AND e.account_identifier = sb.account_identifier
LEFT JOIN behavior_flags f
  ON f.month_end = sb.month_end AND f.account_identifier = sb.account_identifier
LEFT JOIN xfer_pairs_flag x
  ON x.month_end = sb.month_end
LEFT JOIN whitelist_accounts w
  ON w.account_identifier = sb.account_identifier
LEFT JOIN syn_base b
  ON b.month_end = sb.month_end AND b.account_identifier = sb.account_identifier
WHERE w.account_identifier IS NULL
ORDER BY month_end DESC, risk_score DESC, account_identifier;





-- ==================== KDE MoM Changes — Changes-Only (Upgraded) ====================
-- - 13-month rolling window (tune in params)
-- - Unpivot to (kde_name, kde_val) via UNION ALL
-- - Detect MoM changes per Account×KDE with LAG (incl. NULL flips)
-- - Aggregate ONLY changed rows: counts, exposure deltas, MoM%
-- - Flip-type breakdown: NULL→VAL, VAL→NULL, VAL→VAL (counts & $ deltas)
-- - Per-month ranks by |$Δ| and by #accounts changed
-- - Optional materiality gates (min accounts OR min |$Δ|) to suppress noise
-- ===================================================================================

WITH
/* 0) Parameters (tune thresholds here) */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me,
    5::INTEGER                         AS min_accts_gate,         -- keep rows with ≥ this many changed accts
    1000000.0::FLOAT8                  AS min_abs_exp_delta_gate  -- OR with ≥ this absolute $ change
),

/* 1) Base rows (Total Loans, 13-month window) */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me
),

/* 2) Long-form (UNION ALL) for selected KDEs; cast to stable VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure, CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* 3) LAG previous month state/value/exposure for change detection */
lagged AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    kde_val,
    LAG(kde_val)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)  OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end) OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* 4) Only rows that changed value vs prior month (including NULL flips) */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure AS this_exp,
    prev_exp,
    CASE
      WHEN prev_val IS NULL AND kde_val IS NOT NULL THEN 'NULL→VAL'
      WHEN prev_val IS NOT NULL AND kde_val IS NULL THEN 'VAL→NULL'
      ELSE 'VAL→VAL'
    END AS flip_type
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,'~NULL~') <> COALESCE(prev_val,'~NULL~')
),

/* 5) Aggregate change-only rows + flip-type breakdowns */
agg AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*) AS accounts_changed,
    SUM(COALESCE(prev_exp,0))                        AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                        AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed,

    -- Flip counts
    SUM(CASE WHEN flip_type='NULL→VAL' THEN 1 ELSE 0 END) AS cnt_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN 1 ELSE 0 END) AS cnt_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN 1 ELSE 0 END) AS cnt_val_to_val,

    -- Flip exposure deltas
    SUM(CASE WHEN flip_type='NULL→VAL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_null_to_val,
    SUM(CASE WHEN flip_type='VAL→NULL' THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_null,
    SUM(CASE WHEN flip_type='VAL→VAL'  THEN COALESCE(this_exp,0) - COALESCE(prev_exp,0) ELSE 0 END) AS exp_delta_val_to_val
  FROM changed
  GROUP BY kde_name, month_end
),

/* 6) Final metrics + MoM% on changed population */
final_raw AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE (exposure_delta_on_changed / exposure_prev_on_changed)
    END::FLOAT8 AS exposure_mom_pct_on_changed,

    cnt_null_to_val, cnt_val_to_null, cnt_val_to_val,
    exp_delta_null_to_val, exp_delta_val_to_null, exp_delta_val_to_val
  FROM agg
),

/* 7) Apply optional materiality gates (keep noise out upstream) */
final_gated AS (
  SELECT fr.*
  FROM final_raw fr, params p
  WHERE (fr.accounts_changed >= p.min_accts_gate)
     OR (ABS(fr.exposure_delta_on_changed) >= p.min_abs_exp_delta_gate)
)

SELECT
  f.*,
  -- Per-month ranks
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY ABS(f.exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY f.month_end ORDER BY f.accounts_changed DESC)               AS rk_by_accounts
FROM final_gated f
ORDER BY f.month_end DESC, rk_by_abs_exposure, rk_by_accounts;









-- ==================== KDE MoM Changes — Changes-Only ==========================
-- - Filters to a rolling window (set win_months)
-- - Detects MoM changes with LAG per Account×KDE (incl. NULL flips)
-- - Aggregates only changed rows to produce exposure/count deltas and MoM%
-- - Ranks by exposure change, then by count %
-- ==============================================================================

WITH params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -13)::DATE AS min_me
),

base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- KDE columns (add/remove as needed)
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me 
),

kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

lagged AS (
  SELECT
    kde_name, Account_Identifier, month_end, exposure,
    kde_val,
    LAG(kde_val)     OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)    OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure           AS this_exp,
    prev_exp           AS prev_exp,
    CASE WHEN COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~') THEN 1 ELSE 0 END AS is_changed
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~')
),

agg_changed AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*)                                   AS accounts_changed,      -- one row per acct×kde change
    SUM(COALESCE(prev_exp,0))                  AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                  AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed
  FROM changed
  GROUP BY kde_name, month_end
),

final AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE exposure_delta_on_changed / exposure_prev_on_changed
    END::FLOAT8 AS exposure_mom_pct_on_changed
  FROM agg_changed
)

SELECT
  f.*,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY ABS(exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY accounts_changed DESC)               AS rk_by_accounts
FROM final f
ORDER BY month_end DESC, rk_by_abs_exposure, rk_by_accounts;









-- Latest month anchor (already in your model, shown for completeness)
LM Date (Selected) :=
EOMONTH(
    MAXX(ALLSELECTED('RC_Code_Model_Base'[month_end]),
         'RC_Code_Model_Base'[month_end]),
    0
)

Actual (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE(
    SUM('RC_Code_Model_Base'[bal_num]),
    TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
)

Forecast (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE(
    SUM('RC_Code_Model_Base'[Forecast_Selected]),
    TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
)

Residual % (LM, per RC) :=      -- + = over-forecast; adjust if you prefer opposite sign
DIVIDE( [Forecast (LM, per RC)] - [Actual (LM, per RC)],
        [Actual (LM, per RC)] )

MoM % (Actual, LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR pm  = EOMONTH(lm, -1)
VAR aLM = [Actual (LM, per RC)]
VAR aPM = CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
                     TREATAS({ pm }, 'RC_Code_Model_Base'[month_end]) )
RETURN DIVIDE(aLM - aPM, aPM)

YoY % (Actual, LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR ly  = EOMONTH(lm, -12)
VAR aLM = [Actual (LM, per RC)]
VAR aLY = CALCULATE( SUM('RC_Code_Model_Base'[bal_num]),
                     TREATAS({ ly }, 'RC_Code_Model_Base'[month_end]) )
RETURN DIVIDE(aLM - aLY, aLY)





Residual % (Mean6 at LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR rng = CALCULATETABLE(
            DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
          )
RETURN
AVERAGEX(
  rng,
  CALCULATE(        -- evaluate residual% at each date d in rng
    DIVIDE(
      SUM('RC_Code_Model_Base'[Forecast_Selected]) - SUM('RC_Code_Model_Base'[bal_num]),
      SUM('RC_Code_Model_Base'[bal_num])
    )
  )
)

Residual % (SD6 at LM, per RC) :=
VAR lm  = [LM Date (Selected)]
VAR rng = CALCULATETABLE(
            DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
          )
RETURN
STDEVX.P(
  rng,
  CALCULATE(
    DIVIDE(
      SUM('RC_Code_Model_Base'[Forecast_Selected]) - SUM('RC_Code_Model_Base'[bal_num]),
      SUM('RC_Code_Model_Base'[bal_num])
    )
  )
)



-- Parameter helpers (or hardcode 0.08 / 0.10 / 3.0)
Param MoM %  := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="MOM_Pct")
Param YoY %  := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="YOY_Pct")
Param SigmaK := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param]="SigmaK")

Variance Class (LM) :=
VAR r   = [Residual % (LM, per RC)]
VAR m6  = [Residual % (Mean6 at LM, per RC)]
VAR s6  = [Residual % (SD6 at LM, per RC)]
VAR mom = [MoM % (Actual, LM, per RC)]
VAR yoy = [YoY % (Actual, LM, per RC)]
VAR k   = [Param SigmaK]
VAR t_m = [Param MoM %]
VAR t_y = [Param YoY %]
RETURN
SWITCH(TRUE(),
  ISBLANK(r), BLANK(),
  s6 > 0 && ABS(r - m6) >= k * s6,                           "Outlier Spike",
  NOT ISBLANK(yoy) && ABS(yoy) >= t_y && SIGN(yoy)=SIGN(r),   "Possible Level/Trend Shift",
  NOT ISBLANK(mom) && ABS(mom) >= t_m && SIGN(mom)=SIGN(r),   "Short-term Shock",
  ABS(r) >= 0.05 && (ISBLANK(yoy) || ABS(yoy) < t_y),         "Model Miss (Non-seasonal)",
  "Within Expected Range"
)


Is Monitorable (LM, per RC) :=
VAR lm=[LM Date (Selected)]
VAR m = CALCULATE([Monitorable Flag (Measure)],
                  TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
VAR act = [Actual (LM, per RC)]
VAR floor = [Exposure Floor Amount (Safe)]
RETURN IF( m=1 && NOT ISBLANK(act) && ABS(act) >= floor, 1 )

Count – Outlier Spike (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Outlier Spike"
  )
)

Count – Trend/Level Shift (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Possible Level/Trend Shift"
  )
)

Count – Short-term Shock (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Short-term Shock"
  )
)

Count – Model Miss (LM) :=
COUNTROWS(
  FILTER(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    [Is Monitorable (LM, per RC)] = 1 &&
    [Variance Class (LM)] = "Model Miss (Non-seasonal)"
  )
)





Show – Small Multiples TopN (3M Severity) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR N = SELECTEDVALUE('TopN Parm'[N], 4)
VAR pool =
    ADDCOLUMNS(
        ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
        "Mon",
            CALCULATE(
                [Monitorable Flag (Measure)],
                TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
            ),
        "ActLM",
            CALCULATE(
                [Actual],
                TREATAS({ lm }, 'RC_Code_Model_Base'[month_end])
            ),
        "Sev3",
            CALCULATE([Severity (3M Avg)])
    )
VAR cand =
    FILTER(
        pool,
        [Mon] = 1 &&
        ABS([ActLM]) >= floor &&
        NOT ISBLANK([Sev3])
    )
VAR TopSet = TOPN(N, cand, [Sev3], DESC)
RETURN
IF(
    HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
    CONTAINS(TopSet, 'RC_Code_Model_Base'[RC_DESCRIPTION], SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])),
    1
)





VarianceParms =
DATATABLE(
  "Param", STRING, "Value", DOUBLE,
  { {"MOM_Pct", 0.08},   -- 8% MoM threshold
    {"YOY_Pct", 0.10},   -- 10% YoY threshold
    {"SigmaK", 3.0} }    -- 3-sigma
)


Param MoM % := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "MOM_Pct")
Param YoY % := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "YOY_Pct")
Param SigmaK := CALCULATE( MAX(VarianceParms[Value]), VarianceParms[Param] = "SigmaK")

-- Monthly residual % (portfolio sign convention: + = over-forecast)
Residual % (At Month – RC) :=
DIVIDE( [Forecast] - [Actual], [Actual] )  -- use your existing Forecast/Actual measures

-- MoM and YoY actual changes (per RC, at the axis month)
MoM % (Actual) :=
VAR me = MAX('RC_Code_Model_Base'[month_end])
VAR pm = EOMONTH(me, -1)
VAR a_me = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = me )
VAR a_pm = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = pm )
RETURN DIVIDE( a_me - a_pm, a_pm )

YoY % (Actual) :=
VAR me = MAX('RC_Code_Model_Base'[month_end])
VAR ym = EOMONTH(me, -12)
VAR a_me = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = me )
VAR a_ym = CALCULATE( [Actual], 'RC_Code_Model_Base'[month_end] = ym )
RETURN DIVIDE( a_me - a_ym, a_ym )

-- Rolling baseline for residual%
Residual % (Mean6) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE( [Residual % (At Month – RC)] ) )

Residual % (SD6) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN STDEVX.P( rng, CALCULATE( [Residual % (At Month – RC)] ) )


Variance Class :=
VAR r   = [Residual % (At Month – RC)]
VAR m6  = [Residual % (Mean6)]
VAR s6  = [Residual % (SD6)]
VAR mom = [MoM % (Actual)]
VAR yoy = [YoY % (Actual)]
VAR k   = [Param SigmaK]
VAR t_m = [Param MoM %]
VAR t_y = [Param YoY %]
RETURN
SWITCH(TRUE(),
  ISBLANK(r), BLANK(),
  s6 > 0 && ABS(r - m6) >= k * s6,         "Outlier Spike",
  NOT ISBLANK(yoy) && ABS(yoy) >= t_y
     && SIGN(yoy) = SIGN(r),               "Possible Level/Trend Shift",
  NOT ISBLANK(mom) && ABS(mom) >= t_m
     && SIGN(mom) = SIGN(r),               "Short-term Shock",
  ABS(r) >= 0.05 && (ISBLANK(yoy) || ABS(yoy) < t_y), "Model Miss (Non-seasonal)",
  "Within Expected Range"
)


Residual Sign (±1) :=
VAR r = [Residual % (At Month – RC)]
RETURN IF( ISBLANK(r), BLANK(), IF(r >= 0, 1, -1) )

Bias Persistence (3M Same Sign) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -3, MONTH)
VAR sum3 = SUMX( rng, CALCULATE( [Residual Sign (±1)] ) )
RETURN IF( ABS(sum3) = 3, 1, 0 )


Severity (Monthly) := AVERAGE('RC_Code_Model_Base'[Severity_0_100])  -- or your existing monthly severity measure

Severity (3M Avg) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], [LM Date (Selected)], -3, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Severity (Monthly)]) )

Show – Small Multiples TopN (3M Severity) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR N = SELECTEDVALUE('TopN Parm'[N], 4)          -- reuse your TopN parm if you have it
VAR pool =
  ADDCOLUMNS(
    ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",  CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
    "ActLM",CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
    "Sev3", CALCULATE([Severity (3M Avg)])
  )
VAR cand = FILTER(pool, [Mon]=1 && ABS([ActLM]) >= floor && NOT ISBLANK([Sev3]))
VAR topN = TOPN(N, cand, [Sev3], DESC)
RETURN IF( HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
           CONTAINS(topN, 'RC_Code_Model_Base'[RC_DESCRIPTION], SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])), 1)


Abs Error := ABS( [Actual] - [Forecast] )
Bias %    := DIVIDE( [Forecast] - [Actual], [Actual] )
APE %     := DIVIDE( ABS([Actual] - [Forecast]), [Actual] )

MAE (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Abs Error]) )

MAPE (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([APE %]) )

Bias % (6M, per RC) :=
VAR rng = DATESINPERIOD('RC_Code_Model_Base'[month_end], MAX('RC_Code_Model_Base'[month_end]), -6, MONTH)
RETURN AVERAGEX( rng, CALCULATE([Bias %]) )

Alert – High Severity & Miss (LM) :=
VAR sev = [Severity (Weighted, Latest – RC)]
VAR res = [Residual % (At Month – RC)]
RETURN IF( sev >= 80 && ABS(res) >= 0.05, 1, 0 )

Alert – Persistent Bias (3M) :=
[Bias Persistence (3M Same Sign)]











Forecast Ratio (At Month – Monitorable) :=
VAR me    = MAX ( 'RC_Code_Model_Base'[month_end] )     -- the axis month
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",
            CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",
            CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",
            CALCULATE ( [Monitorable Flag (Measure)],
                        'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil =
    FILTER (
        perRC,
        [Mon] = 1 &&
        NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
        ABS ( [Act] ) >= floor
    )
VAR num = SUMX ( fil, [Fcst] )
VAR den = SUMX ( fil, [Act] )
RETURN DIVIDE ( num, den )





Exposure (Latest) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE(
    SUM( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] )
)


-- R² at latest month in RC context
R2 (LM, per RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( [R2_By_Model],
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Cap to a sensible display range for portfolio KPIs
R2 (LM, per RC – Capped) :=
VAR r = [R2 (LM, per RC)]
RETURN
IF ( ISBLANK(r), BLANK(),
     MAX ( -1.0, MIN ( 1.0, r ) )
)

Avg R2 (Exp-Weighted, Latest – Robust) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR t =
    ADDCOLUMNS(
        VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
        "R2C",  [R2 (LM, per RC – Capped)],
        "Act",  [Actual (LM, per RC)],
        "Mon",  [Monitorable (LM, per RC)]
    )
VAR fil = FILTER( t, [Mon] = 1 && NOT ISBLANK([R2C]) && ABS([Act]) >= floor )
VAR num = SUMX( fil, [R2C] * ABS([Act]) )
VAR den = SUMX( fil, ABS([Act]) )
RETURN DIVIDE( num, den )







Exposure Δ MoM (per RC) := [Actual (LM, per RC)] - [Actual (PrevM, per RC)]
Exposure Δ MoM | Abs (per RC) := ABS( [Exposure Δ MoM (per RC)] )






Total Exposure % Delta MoM (Monitorable, Latest) :=
VAR lm    = [LM Date (Selected)]
VAR prev  = EOMONTH( lm, -1 )
VAR floor = [Exposure Floor Amount (Safe)]

VAR T =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "MonLM",   CALCULATE ( [Monitorable Flag (Measure)],
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev", CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR F =
    FILTER (
        T,
        [MonLM] = 1 &&
        NOT ISBLANK ( [ActLM] ) &&
        NOT ISBLANK ( [ActPrev] ) &&
        ABS ( [ActLM] ) >= floor
    )

VAR SumLM   = SUMX ( F, [ActLM] )
VAR SumPrev = SUMX ( F, [ActPrev] )
RETURN DIVIDE ( SumLM - SumPrev, SumPrev )





Total Exposure Delta MoM (Monitorable, Latest) :=
VAR lm    = [LM Date (Selected)]
VAR prev  = EOMONTH(lm, -1)
VAR floor = [Exposure Floor Amount (Safe)]

/* Build one row per RC with LM & PrevM facts */
VAR T =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "MonLM",   CALCULATE ( [Monitorable Flag (Measure)],
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM",   CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev", CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                               TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )

/* Keep only monitorable + above floor + has both months */
VAR F =
    FILTER (
        T,
        [MonLM] = 1 &&
        NOT ISBLANK ( [ActLM] ) &&
        NOT ISBLANK ( [ActPrev] ) &&
        ABS ( [ActLM] ) >= floor
    )

RETURN
SUMX ( F, [ActLM] - [ActPrev] )







LM Date (Selected) :=
EOMONTH(
    MAXX(ALLSELECTED('RC_Code_Model_Base'[month_end]),
         'RC_Code_Model_Base'[month_end]), 0)

PrevM Date (Selected) := EOMONTH([LM Date (Selected)], -1)

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount] RETURN IF(ISBLANK(v), 0, v)

Actual := SUM('RC_Code_Model_Base'[bal_num])
Forecast := SUM('RC_Code_Model_Base'[Forecast_Selected])


Actual (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Actual (PrevM, per RC) :=
VAR pm=[PrevM Date (Selected)]
RETURN CALCULATE([Actual], TREATAS({pm}, 'RC_Code_Model_Base'[month_end]))

Forecast (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Forecast], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

R2 (LM, per RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([R2_By_Model], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Monitorable (LM, per RC) :=
VAR lm=[LM Date (Selected)]
VAR m=CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
RETURN IF(m=1,1,0)


Exposure Δ MoM (per RC) :=
[Actual (LM, per RC)] - [Actual (PrevM, per RC)]

Exposure %Δ MoM (per RC) :=
DIVIDE([Exposure Δ MoM (per RC)], [Actual (PrevM, per RC)])

Abs Error (LM, per RC) :=
VAR a=[Actual (LM, per RC)]
VAR f=[Forecast (LM, per RC)]
RETURN IF(AND(NOT ISBLANK(a), NOT ISBLANK(f)), ABS(a-f))

Residual % (LM, per RC) :=  -- (Actual−Forecast)/Forecast
DIVIDE([Actual (LM, per RC)] - [Forecast (LM, per RC)], [Forecast (LM, per RC)])


Severity (Weighted, Latest – RC) :=
VAR lm=[LM Date (Selected)]
RETURN CALCULATE([Severity (Weighted, Latest)],
                 TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))

Severity Δ MoM (per RC) :=
VAR lm=[LM Date (Selected)]
VAR pm=[PrevM Date (Selected)]
VAR curr = CALCULATE([Severity (Weighted, Latest)],
                     TREATAS({lm}, 'RC_Code_Model_Base'[month_end]))
VAR prev = CALCULATE([Severity (Weighted, Latest)],
                     TREATAS({pm}, 'RC_Code_Model_Base'[month_end]))
RETURN curr - prev


Contribution Score (LM, per RC) :=
-- material MoM move * current severity
ABS([Exposure Δ MoM (per RC)]) * DIVIDE([Severity (Weighted, Latest – RC)], 100)

Show – Top4 by Contribution (Selected) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR rc = SELECTEDVALUE('RC_Code_Model_Base'[RC_DESCRIPTION])
VAR pool =
    ADDCOLUMNS(
      ALLSELECTED('RC_Code_Model_Base'[RC_DESCRIPTION]),
      "Mon",  CALCULATE([Monitorable Flag (Measure)], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
      "Act",  CALCULATE([Actual], TREATAS({lm}, 'RC_Code_Model_Base'[month_end])),
      "Score", CALCULATE([Contribution Score (LM, per RC)])
    )
VAR cand = FILTER(pool, [Mon]=1 && NOT ISBLANK([Score]) && ABS([Act])>=floor)
VAR top4 = TOPN(4, cand, [Score], DESC)
RETURN IF(HASONEVALUE('RC_Code_Model_Base'[RC_DESCRIPTION]) &&
          CONTAINS(top4, 'RC_Code_Model_Base'[RC_DESCRIPTION], rc), 1)


Total Exposure Δ MoM (Monitorable, Latest) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR set =
  ADDCOLUMNS(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",[Monitorable (LM, per RC)],
    "ActLM",[Actual (LM, per RC)],
    "Δ",[Exposure Δ MoM (per RC)]
  )
RETURN SUMX(FILTER(set, [Mon]=1 && ABS([ActLM])>=floor), [Δ])

Avg Residual % (Exp-Weighted, LM) :=
VAR lm=[LM Date (Selected)]
VAR floor=[Exposure Floor Amount (Safe)]
VAR set =
  ADDCOLUMNS(
    VALUES('RC_Code_Model_Base'[RC_DESCRIPTION]),
    "Mon",[Monitorable (LM, per RC)],
    "ActLM",[Actual (LM, per RC)],
    "ResPct",[Residual % (LM, per RC)]
  )
VAR fil = FILTER(set, [Mon]=1 && ABS([ActLM])>=floor && NOT ISBLANK([ResPct]))
VAR num = SUMX(fil, [ResPct] * ABS([ActLM]))
VAR den = SUMX(fil, ABS([ActLM]))
RETURN DIVIDE(num, den)










-- Changes-only exposure Δ by KDE at latest month
KDE Exposure Δ (Changes-only, LM) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'KDE_MoM'[exp_changed] ),
    TREATAS ( { lm }, 'KDE_MoM'[month_end] )
)

-- Changes-only count Δ by KDE at latest month
KDE Count Δ (Changes-only, LM) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'KDE_MoM'[cnt_changed] ),
    TREATAS ( { lm }, 'KDE_MoM'[month_end] )
)

-- Flip diagnostics (null/value churn) at latest month
KDE Flips: NULL→Value (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[null_to_val] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Flips: Value→NULL (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[val_to_null] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Flips: Value→Value (LM) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'KDE_MoM'[val_to_val] ), TREATAS ( { lm }, 'KDE_MoM'[month_end] ) )

KDE Exposure Δ (LM – for Waterfall) := [KDE Exposure Δ (Changes-only, LM)]


-- Severity at latest month per RC
Severity (Weighted, Latest – RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( [Severity (Weighted, Latest)],
                   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Latest exposure per RC (for weighting/filters)
ActLM (Latest, RC) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Monitorable gate at latest month per RC
Monitorable (LM, RC) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)],
                     TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1 )









ActLM (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Actual], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

R2 (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [R2_By_Model], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Abs Error (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR act = CALCULATE ( [Actual],   TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR fc  = CALCULATE ( [Forecast], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( NOT ISBLANK ( act ) && NOT ISBLANK ( fc ), ABS ( act - fc ) )

Monitorable (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1 )


Avg R2 (Exposure-Weighted, Latest) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2LM",  [R2 (Latest, per RC – Selected)],
        "ActLM", [ActLM (Latest, per RC – Selected)],
        "MonLM", [Monitorable (Latest, per RC – Selected)]
    )
VAR fil = FILTER ( perRC, [MonLM] = 1 && NOT ISBLANK ( [R2LM] ) && ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [R2LM] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Avg RMSE (Exposure-Weighted, Latest) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ErrLM", [Abs Error (Latest, per RC – Selected)],
        "ActLM", [ActLM (Latest, per RC – Selected)],
        "MonLM", [Monitorable (Latest, per RC – Selected)]
    )
VAR fil = FILTER ( perRC, [MonLM] = 1 && NOT ISBLANK ( [ErrLM] ) && ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [ErrLM] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Avg R2 (Exp-Weighted, Latest-1) :=
VAR lm  = [LM Date (Selected)]
VAR prev = EOMONTH ( lm, -1 )
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRCPrev =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "R2Prev",
            CALCULATE ( [R2_By_Model], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActPrev",
            CALCULATE ( [Actual], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonPrev",
            CALCULATE ( [Monitorable Flag (Measure)], TREATAS ( { prev }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR filPrev = FILTER ( perRCPrev, [MonPrev] = 1 && NOT ISBLANK ( [R2Prev] ) && ABS ( [ActPrev] ) >= floor )
VAR numPrev = SUMX ( filPrev, [R2Prev] * ABS ( [ActPrev] ) )
VAR denPrev = SUMX ( filPrev, ABS ( [ActPrev] ) )
RETURN DIVIDE ( numPrev, denPrev )

Avg R2 Δ MoM (Exp-Weighted) :=
VAR curr = [Avg R2 (Exposure-Weighted, Latest)]
VAR prev = [Avg R2 (Exp-Weighted, Latest-1)]
RETURN DIVIDE ( curr - prev, prev )






Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR rc    = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )

-- Build candidate pool across all RCs under current slicers
VAR pool_with_stats =
    ADDCOLUMNS (
        ALLSELECTED ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

-- Keep ONLY monitorable, non-trivial exposure, with a severity value
VAR candidates =
    FILTER (
        pool_with_stats,
        [MonLM] = 1 &&
        NOT ISBLANK ( [SevLM] ) &&
        ABS ( [ExpLM] ) >= floor
    )

-- Top 4 by severity (within current slicers)
VAR top4 = TOPN ( 4, candidates, [SevLM], DESC )

-- Is the current RC one of those top 4?
VAR inTop4 =
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION], rc )

RETURN
IF (
    HASONEVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )  -- only emit inside an RC tile/row
        && NOT ISBLANK ( rc )
        && inTop4,
    1
)



-- Latest month inside the current selection
LM Date (Selected) :=
MAXX (
    ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[month_end]
)

-- Per-RC stats at the selected latest month
Severity_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    [Severity (Weighted, Latest)],
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

ActLM_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Monitorable_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
VAR m  =
    CALCULATE (
        [Monitorable Flag (Measure)],
        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN IF ( m = 1, 1, 0 )

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount]
RETURN IF ( ISBLANK ( v ), 0, v )

-- Rank all RCs (monitorable + floor) by latest severity within current slicers
Rank_Severity_Latest_Selected_MonOnly :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
-- build the candidate set ACROSS all RCs under current slicers
VAR candidates =
    ADDCOLUMNS (
        ALLSELECTED ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR filtered =
    FILTER ( candidates,
        [MonLM] = 1 &&
        NOT ISBLANK ( [SevLM] ) &&
        ABS ( [ExpLM] ) >= floor
    )
-- rank by severity (ties are fine; DENSE keeps ranks 1..n)
VAR rThis =
    RANKX (
        filtered,
        [SevLM],
        CALCULATE ( [Severity_Latest_RC_Selected] ),
        DESC,
        DENSE
    )
RETURN
    -- return BLANK if we're not in an RC row/tile
    IF (
        HASONEVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        rThis
    )

-- Gate: only Top 4
Show_SmallMultiples_Top4_Selected :=
VAR r = [Rank_Severity_Latest_Selected_MonOnly]
RETURN IF ( NOT ISBLANK ( r ) && r <= 4, 1 )




Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR rc    = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )

VAR pool_with_stats =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER ( pool_with_stats,
             [MonLM] = 1 &&
             NOT ISBLANK ( [SevLM] ) &&
             ABS ( [ExpLM] ) >= floor )

VAR top4 = TOPN ( 4, candidates, [SevLM], DESC )

RETURN
IF (
    ISINSCOPE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ) &&
    NOT ISBLANK ( rc ) &&
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION], rc ),
    1
)




Severity_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Severity (Weighted, Latest)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

ActLM_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable_Latest_RC_Selected :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE ( [Monitorable Flag (Measure)],
                     TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF ( m = 1, 1, 0 )


Show_SmallMultiples_Top4_Selected :=
VAR lm    = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]

VAR pool_with_stats =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ExpLM",
            CALCULATE ( SUM ( 'RC_Code_Model_Base'[bal_num] ),
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER ( pool_with_stats,
             [MonLM] = 1 &&
             NOT ISBLANK ( [SevLM] ) &&
             ABS ( [ExpLM] ) >= floor )

VAR top4 =
    TOPN ( 4, candidates, [SevLM], DESC )

VAR isThisRCInTop4 =
    CONTAINS ( top4,
               'RC_Code_Model_Base'[RC_DESCRIPTION],
               SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ) )

RETURN IF ( isThisRCInTop4, 1 )










Severity (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( [Severity (Weighted, Latest)],
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

ActLM (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE( SUM( 'RC_Code_Model_Base'[bal_num] ),
                  TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable (Latest, per RC – Selected) :=
VAR lm = [LM Date (Selected)]
VAR m  = CALCULATE( [Monitorable Flag (Measure)],
                    TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )
RETURN IF( m = 1, 1, 0 )




Rank – Severity (Latest – Selected, Monitorable only) :=
VAR lm     = [LM Date (Selected)]
VAR floor  = [Exposure Floor Amount (Safe)]
VAR currSev = [Severity (Latest, per RC – Selected)]
VAR currExp = ABS( [ActLM (Latest, per RC – Selected)] )
VAR currMon = [Monitorable (Latest, per RC – Selected)]

VAR pool =
    ADDCOLUMNS(
        VALUES( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Sev",  CALCULATE( [Severity (Weighted, Latest)],
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "Exp",  CALCULATE( SUM( 'RC_Code_Model_Base'[bal_num] ),
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "Mon",  CALCULATE( [Monitorable Flag (Measure)],
                           TREATAS( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )

VAR candidates =
    FILTER( pool,
        [Mon] = 1 &&
        NOT ISBLANK([Sev]) &&
        ABS([Exp]) >= floor
    )

/* Tie-breaker: exposure scaled tiny so severity dominates */
VAR rankVal =
    RANKX( candidates,
           [Sev] + (ABS([Exp]) / 1e15),
           currSev + (currExp / 1e15),
           DESC, SKIP )

RETURN IF( currMon = 1 && NOT ISBLANK(currSev) && currExp >= floor, rankVal )

Show – Small Multiples Top4 (Selected) :=
VAR r = [Rank – Severity (Latest – Selected, Monitorable only)]
RETURN IF( NOT ISBLANK(r) && r <= 4, 1 )



-- Assumes:
--   Actual := SUM('RC_Code_Model_Base'[bal_num])
--   Quarter Num = QUARTER('RC_Code_Model_Base'[month_end])  (calculated column)

Seasonal Volatility (Per RC – Matrix Safe) :=
VAR quarters =
    CALCULATETABLE (
        VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )   -- keep RC filters, drop quarter filter
    )
VAR liftsPerQ =
    ADDCOLUMNS (
        quarters,
        "lift",
            VAR q = 'RC_Code_Model_Base'[Quarter Num]
            VAR NumAvg =
                CALCULATE (
                    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                    KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = q )
                )
            VAR DenAvg =
                CALCULATE (
                    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                    REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
                )
            RETURN DIVIDE ( NumAvg, DenAvg )
    )
VAR valid = FILTER ( liftsPerQ, NOT ISBLANK ( [lift] ) )
VAR n = COUNTROWS ( valid )
RETURN IF ( n >= 2, STDEVX.P ( valid, [lift] ) )




TopN Parm =
DATATABLE (
    "N", INTEGER,
    {
        {5},
        {10},
        {15},
        {20}
    }
)




-- Average of the quarterly lifts (Q1..Q4) for the RC in context
Seasonal Lift (Avg Q per RC) :=
AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
           [Seasonal Lift (Q vs All – Matrix)] )

-- Population stdev of the quarterly lifts (how “seasonal” the RC is)
Seasonal Volatility (Per RC) :=
VAR qs = VALUES ( 'RC_Code_Model_Base'[Quarter Num] )
RETURN STDEVX.P ( qs, [Seasonal Lift (Q vs All – Matrix)] )

-- Mean absolute deviation from 1.0 (sometimes more intuitive than stdev)
Seasonal Intensity (|Lift-1|) :=
AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
           ABS ( [Seasonal Lift (Q vs All – Matrix)] - 1.0 ) )

-- How many quarters have data (helps judge reliability)
Quarters Covered (Count) :=
COUNTROWS ( VALUES ( 'RC_Code_Model_Base'[Quarter Num] ) )


ActLM (Latest, Selected) :=
VAR lm = [LM Date (Selected)]
RETURN CALCULATE ( [Actual], TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Monitorable (Latest, RC – Selected) :=
VAR lm  = [LM Date (Selected)]
VAR mon = CALCULATE ( [Monitorable Flag (Measure)],
                      TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR act = [ActLM (Latest, Selected)]
RETURN IF ( mon = 1 && NOT ISBLANK ( act ) && ABS ( act ) >= [Exposure Floor Amount (Safe)], 1 )


-- Rank RCs by strongest seasonality (higher volatility first)
Rank by Seasonal Volatility :=
RANKX ( ALL ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        [Seasonal Volatility (Per RC)], , DESC, DENSE )

-- Show only Top N (parameterized). If you don’t have a parameter, hardcode 10.
TopN Value (Disconnected) := SELECTEDVALUE ( 'TopN Parm'[N], 10 )

Show – TopN Seasonal RCs :=
VAR r = [Rank by Seasonal Volatility]
VAR n = [TopN Value (Disconnected)]
RETURN IF ( NOT ISBLANK ( r ) && r <= n, 1 )











Realized Ratio (At Month – Monitorable) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )          -- axis month
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",   CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",  CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil = FILTER ( perRC,
                   [Mon] = 1 &&
                   NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
                   ABS ( [Act] ) >= floor )
VAR num = SUMX ( fil, [Act] )
VAR den = SUMX ( fil, [Fcst] )
RETURN DIVIDE ( num, den )


LM Date (Selected) :=
MAXX ( ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
       'RC_Code_Model_Base'[month_end] )

Realized Ratio (Latest – Monitorable) :=
VAR lm = [LM Date (Selected)]
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "ActLM",  CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = lm ),
        "FcstLM", CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = lm ),
        "MonLM",  CALCULATE ( [Monitorable Flag (Measure)],
                              'RC_Code_Model_Base'[month_end] = lm )
    )
VAR fil = FILTER ( perRC,
                   [MonLM] = 1 &&
                   NOT ISBLANK ( [ActLM] ) && NOT ISBLANK ( [FcstLM] ) &&
                   ABS ( [ActLM] ) >= floor )
VAR num = SUMX ( fil, [ActLM] )
VAR den = SUMX ( fil, [FcstLM] )
RETURN DIVIDE ( num, den )


Residual % (At Month – Monitorable) :=
VAR me = MAX ( 'RC_Code_Model_Base'[month_end] )
VAR floor = [Exposure Floor Amount (Safe)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Act",   CALCULATE ( [Actual],   'RC_Code_Model_Base'[month_end] = me ),
        "Fcst",  CALCULATE ( [Forecast], 'RC_Code_Model_Base'[month_end] = me ),
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             'RC_Code_Model_Base'[month_end] = me )
    )
VAR fil = FILTER ( perRC,
                   [Mon] = 1 &&
                   NOT ISBLANK ( [Act] ) && NOT ISBLANK ( [Fcst] ) &&
                   ABS ( [Act] ) >= floor )
VAR num = SUMX ( fil, [Act] - [Fcst] )
VAR den = SUMX ( fil, [Fcst] )
RETURN DIVIDE ( num, den )






LM Date (Selected) :=
MAXX ( ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
       'RC_Code_Model_Base'[month_end] )

Exposure Floor Amount (Safe) :=
VAR v = [Exposure Floor Amount]
RETURN IF ( ISBLANK ( v ), 0, v )

ActLM (Latest, Selected) :=
VAR lm = [LM Date (Selected)]
RETURN
CALCULATE ( [Actual],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

Seasonal Lift (Selected Q – Card Safe) :=
VAR qSel = SELECTEDVALUE ( 'RC_Code_Model_Base'[Quarter Num] )
VAR qEff = COALESCE ( qSel, QUARTER ( [LM Date (Selected)] ) )
VAR Num :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = qEff )
    )
VAR Den :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
    )
RETURN DIVIDE ( Num, Den )



Avg Seasonal Lift (Selected Q – Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Lift] ) )
RETURN AVERAGEX ( fil, [Lift] )


Avg Seasonal Lift (Selected Q – Exp Weighted, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Lift] ) )
VAR num = SUMX ( fil, [Lift] * ABS ( [ActLM] ) )
VAR den = SUMX ( fil, ABS ( [ActLM] ) )
RETURN DIVIDE ( num, den )


Seasonal Volatility (Per RC) :=
VAR qs =
    CALCULATETABLE (
        VALUES ( 'RC_Code_Model_Base'[Quarter Num] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
    )
VAR lifts =
    ADDCOLUMNS (
        qs,
        "lift",
            VAR q = [Quarter Num]
            RETURN
                DIVIDE (
                    CALCULATE (
                        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                        KEEPFILTERS ( 'RC_Code_Model_Base'[Quarter Num] = q )
                    ),
                    CALCULATE (
                        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
                        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
                    )
                )
    )
VAR n = COUNTROWS ( lifts )
RETURN IF ( n >= 2, STDEVX.P ( lifts, [lift] ) )


Avg Seasonal Volatility (Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Vol",  [Seasonal Volatility (Per RC)],
        "Mon",  CALCULATE ( [Monitorable Flag (Measure)],
                            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR fil = FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && NOT ISBLANK ( [Vol] ) )
RETURN AVERAGEX ( fil, [Vol] )


RCs Lift > +10% (Selected Q, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
RETURN
COUNTROWS ( FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && [Lift] > 1.10 ) )

RCs Lift < –10% (Selected Q, Monitorable) :=
VAR floor = [Exposure Floor Amount (Safe)]
VAR lm    = [LM Date (Selected)]
VAR perRC =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "Lift",  [Seasonal Lift (Selected Q – Card Safe)],
        "Mon",   CALCULATE ( [Monitorable Flag (Measure)],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "ActLM", CALCULATE ( [Actual],
                             TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
RETURN
COUNTROWS ( FILTER ( perRC, [Mon] = 1 && ABS ( [ActLM] ) >= floor && [Lift] < 0.90 ) )












-- core facts
Actual := SUM('RC_Code_Model_Base'[bal_num])

-- X-axis: lift for the selected quarter vs all quarters, per RC (scatter-safe)
Seasonal Lift (Scatter – Selected Q) :=
VAR qSel = SELECTEDVALUE('RC_Code_Model_Base'[Quarter Num])  -- slicer
VAR num :=
    CALCULATE(
        AVERAGEX(VALUES('RC_Code_Model_Base'[month_end]), [Actual]),
        KEEPFILTERS('RC_Code_Model_Base'[Quarter Num] = qSel)
    )
VAR den :=
    CALCULATE(
        AVERAGEX(VALUES('RC_Code_Model_Base'[month_end]), [Actual]),
        REMOVEFILTERS('RC_Code_Model_Base'[Quarter Num])          -- drop ONLY quarter
    )
RETURN DIVIDE(num, den)



-- Uses your existing lift measure that works in matrix context:
--   [Seasonal Lift (Q vs All – Matrix)]

Seasonal Volatility (Q vs All) :=
VAR qs =
    VALUES ( 'RC_Code_Model_Base'[Quarter Num] )      -- quarters present under current filters
VAR series =
    ADDCOLUMNS (
        qs,
        "lift",
            CALCULATE (
                [Seasonal Lift (Q vs All – Matrix)],
                -- force eval per quarter value in this iterator row
                TREATAS ( { SELECTEDVALUE ( 'RC_Code_Model_Base'[Quarter Num] ) },
                          'RC_Code_Model_Base'[Quarter Num] )
            )
    )
VAR n = COUNTROWS ( series )
RETURN IF ( n >= 2, STDEVX.P ( series, [lift] ) )




-- tweak the bounds if you want
CF Min := 0.90
CF Max := 1.10

Seasonal Lift (for CF – Clamped) :=
VAR v = [Seasonal Lift (Q vs All – Matrix)]
VAR mn = [CF Min]
VAR mx = [CF Max]
RETURN IF( ISBLANK(v), BLANK(), MIN( mx, MAX( mn, v ) ) )



Seasonal Volatility = STDEVX.P(VALUES(Quarter Num), [Seasonal Lift (Q vs All – Matrix])), sort DESC




DBG NumAvg :=
CALCULATE ( AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ) )

DBG DenAvg :=
CALCULATE (
    AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
    REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )
)




-- Core measures you already have:
Actual := SUM ( 'RC_Code_Model_Base'[bal_num] )
-- (Forecast not needed here)

-- Seasonal Lift (Quarter vs All) – Matrix Safe
Seasonal Lift (Q vs All – Matrix) :=
VAR NumAvg :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] )
        -- uses the current matrix cell's filters, including Quarter Num and RC_DESCRIPTION
    )
VAR DenAvg :=
    CALCULATE (
        AVERAGEX ( VALUES ( 'RC_Code_Model_Base'[month_end] ), [Actual] ),
        REMOVEFILTERS ( 'RC_Code_Model_Base'[Quarter Num] )   -- drop quarter only; keep RC filter
    )
RETURN DIVIDE ( NumAvg, DenAvg )



Seasonal Lift (Quarter vs All) :=
VAR CurrQ = SELECTEDVALUE( 'RC_Code_Model_Base'[Quarter Num] )
VAR CurrRC = SELECTEDVALUE( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR CurrY  = SELECTEDVALUE( 'RC_Code_Model_Base'[Year] )

-- numerator: this RC in this quarter
VAR Num =
    CALCULATE(
        AVERAGE('RC_Code_Model_Base'[Actual]),
        'RC_Code_Model_Base'[Quarter Num] = CurrQ,
        'RC_Code_Model_Base'[RC_DESCRIPTION] = CurrRC
    )

-- denominator: same RC, all quarters (removes quarter filter)
VAR Den =
    CALCULATE(
        AVERAGE('RC_Code_Model_Base'[Actual]),
        ALL('RC_Code_Model_Base'[Quarter Num]),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = CurrRC
    )

RETURN DIVIDE(Num, Den)




Quarter Num := QUARTER( 'RC_Code_Model_Base'[month_end] )        -- 1..4
Year := YEAR( 'RC_Code_Model_Base'[month_end] )
Year–Quarter := FORMAT( 'RC_Code_Model_Base'[month_end], "YYYY" ) & " Q" & QUARTER( 'RC_Code_Model_Base'[month_end] )


Actual := SUM( 'RC_Code_Model_Base'[bal_num] )
Forecast := SUM( 'RC_Code_Model_Base'[Forecast_Selected] )
LM Date := MAXX( ALL( 'RC_Code_Model_Base' ), 'RC_Code_Model_Base'[month_end] )


Axis Quarter :=
QUARTER( MAX( 'RC_Code_Model_Base'[month_end] ) )


Seasonal Lift (Quarter vs All) :=
VAR q =
    IF( HASONEVALUE( 'RC_Code_Model_Base'[Quarter Num] ),
        SELECTEDVALUE( 'RC_Code_Model_Base'[Quarter Num] ),
        QUARTER( MAX( 'RC_Code_Model_Base'[month_end] ) )
    )
VAR num :=
    CALCULATE( [Actual], 'RC_Code_Model_Base'[Quarter Num] = q )
VAR den :=
    CALCULATE( [Actual], ALL( 'RC_Code_Model_Base'[Quarter Num] ) )
/* use averages so scale doesn’t bias: avg per month in numerator/denominator */
VAR mon_num :=
    CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ), 'RC_Code_Model_Base'[Quarter Num] = q )
VAR mon_den :=
    CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ), ALL( 'RC_Code_Model_Base'[Quarter Num] ) )
RETURN
DIVIDE( DIVIDE(num, mon_num), DIVIDE(den, mon_den) )


Seasonal Lift (SameQ, 3Y) :=
VAR me  = MAX( 'RC_Code_Model_Base'[month_end] )
VAR st  = EDATE( me, -36 )
VAR q   = QUARTER( me )
VAR num = CALCULATE( [Actual],
            'RC_Code_Model_Base'[Quarter Num] = q,
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR den = CALCULATE( [Actual],
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR mon_num = CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[Quarter Num] = q,
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
VAR mon_den = CALCULATE( DISTINCTCOUNT( 'RC_Code_Model_Base'[month_end] ),
            'RC_Code_Model_Base'[month_end] >= st, 'RC_Code_Model_Base'[month_end] <= me )
RETURN DIVIDE( DIVIDE(num,mon_num), DIVIDE(den,mon_den) )


Seasonal Gap % :=
DIVIDE( [Actual] - [Forecast], [Forecast] )












-- A. Severity at Latest (per RC) – explicit, for ranking
Severity (Latest, per RC) :=
VAR lm = [LM Date]
RETURN
CALCULATE ( [Severity (Weighted, Latest)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- B. Monitorable at Latest (per RC) – explicit
Monitorable (Latest, per RC) :=
VAR lm = [LM Date]
RETURN
CALCULATE ( [Monitorable Flag (Measure)],
            TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- C. Rank among monitorable RCs (by Severity at Latest)
Rank – Monitorable by Severity (Latest) :=
VAR lm = [LM Date]
VAR currSev =
    CALCULATE ( [Severity (Weighted, Latest)],
                TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
VAR currMon =
    CALCULATE ( [Monitorable Flag (Measure)],
                TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )

-- Build the candidate list (only monitorable RCs with a severity value)
VAR rcList =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "SevLM",
            CALCULATE ( [Severity (Weighted, Latest)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) ),
        "MonLM",
            CALCULATE ( [Monitorable Flag (Measure)],
                        TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ) )
    )
VAR candidates = FILTER ( rcList, [MonLM] = 1 && NOT ISBLANK ( [SevLM] ) )

-- Rank current RC among the candidates
VAR r = RANKX ( candidates, [SevLM], currSev, DESC, DENSE )
RETURN IF ( currMon = 1 && NOT ISBLANK ( currSev ), r )

-- D. Gate for Top 4 monitorable RCs at Latest (use this in the visual filter)
Show in Small Multiples – Top4 Monitorable (Latest) :=
VAR r = [Rank – Monitorable by Severity (Latest)]
RETURN IF ( NOT ISBLANK ( r ) && r <= 4, 1 )




Monitorable (LM per RC – Selected) :=
VAR rc   = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_DESCRIPTION] )
VAR lmRC =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[month_end] ),
        ALLSELECTED ( 'RC_Code_Model_Base'[month_end] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc
    )
VAR actLM =
    CALCULATE (
        SUM ( 'RC_Code_Model_Base'[bal_num] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
        'RC_Code_Model_Base'[month_end] = lmRC
    )
VAR isIntCol =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
        'RC_Code_Model_Base'[month_end] = lmRC
    )

-- text fallback if column is missing/blank
VAR descUpper =
    UPPER (
        COALESCE (
            CALCULATE (
                MAX ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
                'RC_Code_Model_Base'[month_end] = lmRC
            ),
            ""
        )
    )
VAR codeUpper =
    UPPER (
        COALESCE (
            CALCULATE (
                MAX ( 'RC_Code_Model_Base'[RC_CODE] ),
                'RC_Code_Model_Base'[RC_DESCRIPTION] = rc,
                'RC_Code_Model_Base'[month_end] = lmRC
            ),
            ""
        )
    )
VAR isIntText =
    IF (
        CONTAINSSTRING ( descUpper, "CORPORATE" ) ||
        CONTAINSSTRING ( descUpper, "HOLDING" ) ||
        CONTAINSSTRING ( descUpper, "INTERCOMPANY" ) ||
        CONTAINSSTRING ( descUpper, "INTERNAL" ) ||
        CONTAINSSTRING ( descUpper, "ADMIN" ) ||
        CONTAINSSTRING ( codeUpper, "CORP" ) ||
        CONTAINSSTRING ( codeUpper, "HOLD" ) ||
        CONTAINSSTRING ( codeUpper, "INTCO" ),
        1, 0
    )
VAR isInt = COALESCE ( isIntCol, isIntText )
VAR floor = [Exposure Floor Amount (Safe)]
RETURN IF ( NOT ISBLANK ( lmRC ) && isInt = 0 && NOT ISBLANK ( actLM ) && ABS ( actLM ) >= floor, 1 )



Trend Debug – Included RC Count :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        "IsInternal", MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "Act",        [Actual]
    )
RETURN
COUNTROWS ( FILTER ( t, [IsInternal] = 0 && ABS([Act]) >= [Exposure Floor Amount] ) )




-- Exposure-weighted avg severity by month (works on the chart axis month)
Avg Weighted Severity (Exposure-Weighted, Trend) :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        // per-RC values in the CURRENT month context (from the axis)
        "IsInternal", MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "Act",        [Actual],   -- your measure
        "SevW",
            VAR sev := AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] )    -- raw 0–100
            VAR act := [Actual]
            VAR w   := IF ( ABS ( act ) <= 1, 0.10, MIN ( 1, MAX ( 0.10, LOG10 ( ABS ( act ) ) / 6 ) ) )
            RETURN IF ( NOT ISBLANK ( sev ), sev * w )
    )
VAR fil =
    FILTER ( t,
        [IsInternal] = 0
        && ABS ( [Act] ) >= [Exposure Floor Amount]          -- e.g., 1,000,000
        && NOT ISBLANK ( [SevW] )
    )
VAR num := SUMX ( fil, [SevW] * ABS ( [Act] ) )  -- weight by ABS(exposure)
VAR den := SUMX ( fil, ABS ( [Act] ) )
RETURN DIVIDE ( num, den, 0 )





-- Exposure-weighted average severity by month (trend line)
Avg Weighted Severity (Exposure-Weighted, Trend) :=
VAR t =
    ADDCOLUMNS (
        VALUES ( 'RC_Code_Model_Base'[RC_DESCRIPTION] ),
        // per-RC values in the current month context (from the axis)
        "Act",
            SUM ( 'RC_Code_Model_Base'[Actual] ),
        "IsInternal",
            MAX ( 'RC_Code_Model_Base'[Is_Internal_RC] ),
        "SevW",
            VAR sev = AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] )
            VAR act = SUM ( 'RC_Code_Model_Base'[Actual] )
            VAR w   = IF ( ABS ( act ) <= 1, 0.10, MIN ( 1, MAX ( 0.10, LOG10 ( ABS ( act ) ) / 6 ) ) )
            RETURN IF ( NOT ISBLANK ( sev ), sev * w )
    )
VAR fil =
    FILTER ( t,
        [IsInternal] = 0
        && ABS ( [Act] ) >= [Exposure Floor Amount]        -- uses your floor (e.g., 1,000,000)
        && NOT ISBLANK ( [SevW] )
    )
VAR num = SUMX ( fil, [SevW] * [Act] )   -- exposure-weighted numerator
VAR den = SUMX ( fil, [Act] )            -- exposure sum
RETURN COALESCE ( DIVIDE ( num, den ), 0 )





-- ==================== KDE MoM Changes — Changes-Only & Fast ====================
-- - Filters to a rolling window (set win_months)
-- - Detects MoM changes with LAG per Account×KDE (incl. NULL flips)
-- - Aggregates only changed rows to produce exposure/count deltas and MoM%
-- - Ranks by exposure change, then by count %
-- ==============================================================================

-- >>> tune this window to your need (e.g., 13 or 18 months) <<<
WITH params AS (
  SELECT ADD_MONTHS(CURRENT_DATE, -18)::DATE AS min_me
),

base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    -- KDE columns (add/remove as needed)
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, params p
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND END_OF_MONTH_DATE >= p.min_me   -- 🔥 critical for zone maps
),

/* Unpivot only once. Keep VARCHAR size modest for speed. */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(64)) AS kde_val FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(64)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(64)) FROM base
),

/* Detect MoM changes per Account×KDE using LAG; include NULL flips.
   Require prev row to be exactly previous month to keep it MoM. */
lagged AS (
  SELECT
    kde_name, Account_Identifier, month_end, exposure,
    kde_val,
    LAG(kde_val)     OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_val,
    LAG(exposure)    OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_exp,
    LAG(month_end)   OVER (PARTITION BY kde_name, Account_Identifier ORDER BY month_end) AS prev_me
  FROM kde_flat
),

/* Keep only rows where the value changed vs last month (including NULL↔value) and prev month exists */
changed AS (
  SELECT
    kde_name,
    month_end,
    Account_Identifier,
    exposure           AS this_exp,
    prev_exp           AS prev_exp,
    CASE WHEN COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~') THEN 1 ELSE 0 END AS is_changed
  FROM lagged
  WHERE prev_me = ADD_MONTHS(month_end, -1)
    AND COALESCE(kde_val,   '~NULL~') <> COALESCE(prev_val, '~NULL~')
),

/* Aggregate changes-only per KDE × month */
agg_changed AS (
  SELECT
    kde_name,
    month_end,
    COUNT(*)                                   AS accounts_changed,      -- one row per acct×kde change
    SUM(COALESCE(prev_exp,0))                  AS exposure_prev_on_changed,
    SUM(COALESCE(this_exp,0))                  AS exposure_cur_on_changed,
    SUM(COALESCE(this_exp,0) - COALESCE(prev_exp,0)) AS exposure_delta_on_changed
  FROM changed
  GROUP BY kde_name, month_end
),

/* Compute % changes; guard divide-by-zero */
final AS (
  SELECT
    kde_name,
    month_end,
    accounts_changed,
    exposure_prev_on_changed,
    exposure_cur_on_changed,
    exposure_delta_on_changed,
    CASE
      WHEN exposure_prev_on_changed = 0 THEN NULL
      ELSE exposure_delta_on_changed / exposure_prev_on_changed
    END::FLOAT8 AS exposure_mom_pct_on_changed
  FROM agg_changed
)

SELECT
  f.*,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY ABS(exposure_delta_on_changed) DESC) AS rk_by_abs_exposure,
  DENSE_RANK() OVER (PARTITION BY month_end ORDER BY accounts_changed DESC)               AS rk_by_accounts
FROM final f
ORDER BY month_end DESC, rk_by_abs_exposure, rk_by_accounts;




/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),





Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] )
- AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )


Band_Height (Per RC) :=
VAR rc = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_CODE] )
RETURN
CALCULATE(
    AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] ) - AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] ),
    KEEPFILTERS ( 'RC_Code_Model_Base'[RC_CODE] = rc )
)








Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGEX (
    'RC_Code_Model_Base',
    VAR hi = 'RC_Code_Model_Base'[PI_Hi]
    VAR lo = 'RC_Code_Model_Base'[PI_Lo]
    RETURN IF ( NOT ( ISBLANK ( hi ) || ISBLANK ( lo ) ), hi - lo )
)





Dynamic Y Min :=
VAR lo =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Lo]
    )
VAR act =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MIN(lo, act)


Dynamic Y Max :=
VAR hi =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Hi]
    )
VAR act =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MAX(hi, act)








R2_Scatter =
VAR SS_Total =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLSELECTED ( RC_Code_Model_Base ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )



R2_By_Model =
VAR SS_Total =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Actual] ) ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLEXCEPT ( RC_Code_Model_Base, RC_Code_Model_Base[RC_Code], RC_Code_Model_Base[Model_Type] ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )


RMSE_By_Model =
VAR Count_Obs =
    COUNTROWS ( FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ) )
VAR Sum_Squared_Errors =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
SQRT ( DIVIDE ( Sum_Squared_Errors, Count_Obs ) )











Avg MoM % Abs (3M) :=
VAR currentMonth = MAX('RC_Code_Model_Base'[month_end])
RETURN
AVERAGEX(
    FILTER(
        ALL('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[RC_CODE] = SELECTEDVALUE('RC_Code_Model_Base'[RC_CODE])
        && 'RC_Code_Model_Base'[month_end] <= currentMonth
        && 'RC_Code_Model_Base'[month_end] > EDATE(currentMonth, -3)
    ),
    'RC_Code_Model_Base'[MoM_Pct_Abs]
)





Latest Month :=
CALCULATE( MAX('RC_Code_Model_Base'[month_end]), ALL('RC_Code_Model_Base') )

Selected Months := DISTINCTCOUNT('RC_Code_Model_Base'[month_end])

RMSE :=
VAR sse =
    SUMX(
        'RC_Code_Model_Base',
        VAR r = 'RC_Code_Model_Base'[Resid]
        RETURN r * r
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN IF(n>0, SQRT( sse / n ))

MAE :=
AVERAGEX( 'RC_Code_Model_Base', ABS('RC_Code_Model_Base'[Resid]) )

MAPE :=
AVERAGEX(
    'RC_Code_Model_Base',
    VAR f = 'RC_Code_Model_Base'[Forecast_Selected]
    VAR a = 'RC_Code_Model_Base'[bal_num]
    RETURN IF( NOT ISBLANK(f) && f<>0, ABS( (a - f) / f ), BLANK() )
)


Inside PI % :=
VAR hits =
    SUMX(
        'RC_Code_Model_Base',
        VAR a = 'RC_Code_Model_Base'[bal_num]
        VAR lo = 'RC_Code_Model_Base'[PI_Lo]
        VAR hi = 'RC_Code_Model_Base'[PI_Hi]
        RETURN IF( NOT(ISBLANK(lo)||ISBLANK(hi)) && a>=lo && a<=hi, 1, 0 )
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN DIVIDE(hits,n)

RMSE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [RMSE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAE],  TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAPE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAPE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

Inside PI % (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [Inside PI %], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )


RMSE Last 6 :=
VAR lm = [Latest Month]
VAR period =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period)
    )
RETURN IF(n>0, SQRT(sse/n))

RMSE Prev 12 (excl last 6) :=
VAR lm = [Latest Month]
VAR last6 = DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
VAR prev12 =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], MAXX(last6,[Value])-1, -12, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        ),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        )
    )
RETURN IF(n>0, SQRT(sse/n))

Break Ratio (Err Vol) :=
DIVIDE( [RMSE Last 6], [RMSE Prev 12 (excl last 6)] )


RMSE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [RMSE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )

MAE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [MAE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )


Resid Mean := AVERAGE('RC_Code_Model_Base'[Resid])
Resid SD   := STDEVX.S('RC_Code_Model_Base', 'RC_Code_Model_Base'[Resid])

+2 SD := [Resid Mean] + 2*[Resid SD]
-2 SD := [Resid Mean] - 2*[Resid SD]





-- Severity (latest)
Avg Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

RC Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

High Severity Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE ( [High Severity Count (Latest)], [RC Count (Latest)] )





-- Anchor
Latest Month :=
CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )

Is Latest Month :=
VAR lm = [Latest Month]
RETURN IF ( MAX ( 'RC_Code_Model_Base'[month_end] ) = lm, 1, 0 )


-- Portfolio totals (latest)
Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE ( [Total Residual (Latest)], [Total Forecast (Latest)] )



-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] > 0
)


Top Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Severity Tier (Latest) :=
VAR sev =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
        TREATAS ( { [Latest Month] }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN
SWITCH (
    TRUE (),
    ISBLANK ( sev ), BLANK (),
    sev >= 80, "Critical",
    sev >= 60, "High",
    sev >= 40, "Moderate",
    "Stable"
)






Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )




-- Reusable anchor
Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

-- Boolean-as-1/0 flag for visuals that need it
Is Latest Month :=
IF (
    MAX ( 'RC_Code_Model_Base'[month_end] ) = [Latest Month],
    1, 0
)


-- Totals (latest)
Total Balance (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Forecast (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )

-- Severity (latest)
Avg Severity (Latest) :=
CALCULATE(
    AVERAGE('RC_Code_Model_Base'[Severity_0_100]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

RC Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

High Severity Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE( [High Severity Count (Latest)], [RC Count (Latest)] )

-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] > 0
)





/* --- rank top components WITHOUT LISTAGG --- */
exp_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_exp_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_exp_component) DESC
    ) AS rn_exp
  FROM psi_calc p
),
cnt_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_cnt_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_cnt_component) DESC
    ) AS rn_cnt
  FROM psi_calc p
),

/* pivot top 3 exposure drivers */
exp_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_exp=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp1,
    MAX(CASE WHEN rn_exp=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp2,
    MAX(CASE WHEN rn_exp=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp3
  FROM exp_rank
  WHERE rn_exp <= 3
  GROUP BY kde_name, month_end
),

/* pivot top 3 count drivers */
cnt_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_cnt=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt1,
    MAX(CASE WHEN rn_cnt=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt2,
    MAX(CASE WHEN rn_cnt=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt3
  FROM cnt_rank
  WHERE rn_cnt <= 3
  GROUP BY kde_name, month_end
)

/* --- final result (no LISTAGG) --- */
SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,

  /* build comma-separated strings manually */
  TRIM(BOTH ', ' FROM
      COALESCE(e.exp1,'') ||
      CASE WHEN e.exp1 IS NOT NULL AND e.exp2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp2,'') ||
      CASE WHEN (e.exp1 IS NOT NULL OR e.exp2 IS NOT NULL) AND e.exp3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp3,'')
  ) AS top_exp_drivers,

  TRIM(BOTH ', ' FROM
      COALESCE(c.cnt1,'') ||
      CASE WHEN c.cnt1 IS NOT NULL AND c.cnt2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt2,'') ||
      CASE WHEN (c.cnt1 IS NOT NULL OR c.cnt2 IS NOT NULL) AND c.cnt3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt3,'')
  ) AS top_cnt_drivers

FROM psi_tot t
LEFT JOIN exp_top3 e ON e.kde_name = t.kde_name AND e.month_end = t.month_end
LEFT JOIN cnt_top3 c ON c.kde_name = t.kde_name AND c.month_end = t.month_end
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;




/* ================= KDE Distribution Drift (PSI) ==================== */
/* Filters portfolio, maps long tails to _OTHER, computes PSI Count/Exposure */
/* =================================================================== */

WITH
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* Flatten per KDE as categories (explicit VARCHAR sizes for Netezza) */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(255)) FROM base
),

/* Define the 12-month window and pick Top 20 values per KDE by exposure */
max_me AS ( SELECT MAX(month_end) AS max_me FROM kde_flat ),
last12 AS (
  SELECT * FROM kde_flat, max_me WHERE month_end >= ADD_MONTHS(max_me, -11)
),
topvals AS (
  SELECT kde_name, kde_value,
         ROW_NUMBER() OVER (PARTITION BY kde_name ORDER BY SUM(exposure) DESC) AS rn
  FROM last12
  GROUP BY kde_name, kde_value
),
value_map AS (
  SELECT f.kde_name, f.Account_Identifier, f.month_end, f.exposure,
         CASE WHEN t.rn IS NOT NULL AND t.rn <= 20
              THEN f.kde_value ELSE '_OTHER' END AS kde_bucket
  FROM kde_flat f
  LEFT JOIN topvals t
    ON t.kde_name = f.kde_name AND t.kde_value = f.kde_value
),

/* Current distributions (per KDE x month x bucket) */
dist_cur AS (
  SELECT kde_name, month_end, kde_bucket,
         COUNT(DISTINCT Account_Identifier)            AS cnt,
         SUM(exposure)                                 AS exp
  FROM value_map
  GROUP BY kde_name, month_end, kde_bucket
),
dist_tot AS (
  SELECT kde_name, month_end,
         SUM(cnt) AS cnt_tot,
         SUM(exp) AS exp_tot
  FROM dist_cur
  GROUP BY kde_name, month_end
),
dist_cur_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         c.cnt, c.exp, t.cnt_tot, t.exp_tot,
         CASE WHEN t.cnt_tot=0 THEN 0 ELSE c.cnt::FLOAT8 / t.cnt_tot END AS p_cnt,
         CASE WHEN t.exp_tot=0 THEN 0 ELSE c.exp::FLOAT8 / t.exp_tot END AS p_exp
  FROM dist_cur c
  JOIN dist_tot t USING (kde_name, month_end)
),

/* Previous month distributions aligned to current month_end */
dist_prev_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         COALESCE(p.p_cnt, 0) AS q_cnt,
         COALESCE(p.p_exp, 0) AS q_exp
  FROM dist_cur_p c
  LEFT JOIN dist_cur_p p
    ON p.kde_name = c.kde_name
   AND p.kde_bucket = c.kde_bucket
   AND p.month_end = ADD_MONTHS(c.month_end, -1)
),

/* PSI components and totals */
psi_calc AS (
  SELECT
    c.kde_name, c.month_end, c.kde_bucket,
    c.p_cnt, v.q_cnt,
    c.p_exp, v.q_exp,
    /* Small epsilon to avoid ln(0) */
    ( (c.p_cnt - v.q_cnt)
      * LN( (CASE WHEN c.p_cnt <= 0 THEN 1e-9 ELSE c.p_cnt END)
          / (CASE WHEN v.q_cnt <= 0 THEN 1e-9 ELSE v.q_cnt END) )
    ) AS psi_cnt_component,
    ( (c.p_exp - v.q_exp)
      * LN( (CASE WHEN c.p_exp <= 0 THEN 1e-9 ELSE c.p_exp END)
          / (CASE WHEN v.q_exp <= 0 THEN 1e-9 ELSE v.q_exp END) )
    ) AS psi_exp_component
  FROM dist_cur_p c
  JOIN dist_prev_p v
    ON v.kde_name = c.kde_name
   AND v.kde_bucket = c.kde_bucket
   AND v.month_end = c.month_end
),
psi_tot AS (
  SELECT
    kde_name, month_end,
    SUM(psi_cnt_component) AS psi_count,
    SUM(psi_exp_component) AS psi_exposure
  FROM psi_calc
  GROUP BY kde_name, month_end
),
/* Rank top contributing buckets each month */
psi_top_components AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket,
    psi_cnt_component, psi_exp_component,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_exp_component) DESC) AS rk_exp,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_cnt_component) DESC) AS rk_cnt
  FROM psi_calc p
)

SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,
  /* Optional: top 3 exposure-contributing buckets for explainability */
  LISTAGG(CASE WHEN c.rk_exp <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_exp_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_exp) AS top_exp_drivers,
  LISTAGG(CASE WHEN c.rk_cnt <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_cnt_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_cnt) AS top_cnt_drivers
FROM psi_tot t
LEFT JOIN psi_top_components c
  ON c.kde_name = t.kde_name AND c.month_end = t.month_end
GROUP BY t.kde_name, t.month_end, t.psi_count, t.psi_exposure
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;






/* 1) Flatten per KDE (UNION ALL) with explicit VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value,
         LAG(CAST(CRE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL
  SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         CAST(PD_GRADE AS VARCHAR(255)),
         LAG(CAST(PD_GRADE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         CAST(FDIC_CALL_CODE AS VARCHAR(255)),
         LAG(CAST(FDIC_CALL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)),
         LAG(CAST(NON_ACCRUAL_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         CAST(INDUSTRY_CODE AS VARCHAR(255)),
         LAG(CAST(INDUSTRY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'LTV', Account_Identifier, month_end, exposure,
         CAST(LTV AS VARCHAR(255)),
         LAG(CAST(LTV AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         CAST(GL_ACCOUNT_CODE AS VARCHAR(255)),
         LAG(CAST(GL_ACCOUNT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         CAST(DAYS_PAST_DUE AS VARCHAR(255)),
         LAG(CAST(DAYS_PAST_DUE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         CAST(RBC_CODE AS VARCHAR(255)),
         LAG(CAST(RBC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         CAST(MATURITY_DATE AS VARCHAR(255)),
         LAG(CAST(MATURITY_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         CAST(NAICS_CODE AS VARCHAR(255)),
         LAG(CAST(NAICS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         CAST(RC_CODE AS VARCHAR(255)),
         LAG(CAST(RC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         CAST(REVOLVING_CODE AS VARCHAR(255)),
         LAG(CAST(REVOLVING_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)),
         LAG(CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)),
         LAG(CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         CAST(BOOK_DATE AS VARCHAR(255)),
         LAG(CAST(BOOK_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         CAST(BUS_UNIT_CODE AS VARCHAR(255)),
         LAG(CAST(BUS_UNIT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         CAST(COLLATERAL_CODE AS VARCHAR(255)),
         LAG(CAST(COLLATERAL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         CAST(ISSUE_DATE AS VARCHAR(255)),
         LAG(CAST(ISSUE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         CAST(OCCUPANCY_CODE AS VARCHAR(255)),
         LAG(CAST(OCCUPANCY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         CAST(PAST_DUE_FLAG AS VARCHAR(255)),
         LAG(CAST(PAST_DUE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)),
         LAG(CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         CAST(PURPOSE_CODE AS VARCHAR(255)),
         LAG(CAST(PURPOSE_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         CAST(STATUS_CODE AS VARCHAR(255)),
         LAG(CAST(STATUS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         CAST(RISK_UNIT AS VARCHAR(255)),
         LAG(CAST(RISK_UNIT AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
)





/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* 1) Flatten per KDE (UNION ALL pattern) with current & previous values and exposures */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CRE_FLAG::VARCHAR AS kde_value,
         LAG(CRE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure)        OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         PD_GRADE::VARCHAR,
         LAG(PD_GRADE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         FDIC_CALL_CODE::VARCHAR,
         LAG(FDIC_CALL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         NON_ACCRUAL_FLAG::VARCHAR,
         LAG(NON_ACCRUAL_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                  OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         INDUSTRY_CODE::VARCHAR,
         LAG(INDUSTRY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure,
         LTV::VARCHAR,
         LAG(LTV::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)     OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         GL_ACCOUNT_CODE::VARCHAR,
         LAG(GL_ACCOUNT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         DAYS_PAST_DUE::VARCHAR,
         LAG(DAYS_PAST_DUE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         RBC_CODE::VARCHAR,
         LAG(RBC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         MATURITY_DATE::VARCHAR,
         LAG(MATURITY_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         NAICS_CODE::VARCHAR,
         LAG(NAICS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         RC_CODE::VARCHAR,
         LAG(RC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)         OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         REVOLVING_CODE::VARCHAR,
         LAG(REVOLVING_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         NEXT_RATE_CHANGE_DATE::VARCHAR,
         LAG(NEXT_RATE_CHANGE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                       OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         ACCOUNT_OFFICER_NAME::VARCHAR,
         LAG(ACCOUNT_OFFICER_NAME::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                      OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         BOOK_DATE::VARCHAR,
         LAG(BOOK_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         BUS_UNIT_CODE::VARCHAR,
         LAG(BUS_UNIT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         COLLATERAL_CODE::VARCHAR,
         LAG(COLLATERAL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         ISSUE_DATE::VARCHAR,
         LAG(ISSUE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         OCCUPANCY_CODE::VARCHAR,
         LAG(OCCUPANCY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         PAST_DUE_FLAG::VARCHAR,
         LAG(PAST_DUE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         PROD_HIER_LEVEL_5::VARCHAR,
         LAG(PROD_HIER_LEVEL_5::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                   OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         PURPOSE_CODE::VARCHAR,
         LAG(PURPOSE_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)              OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         STATUS_CODE::VARCHAR,
         LAG(STATUS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)             OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         RISK_UNIT::VARCHAR,
         LAG(RISK_UNIT::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
),

/* 2) Row-level changed flag (NULL-safe) + exposure delta */
chg_rows AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    prev_exposure,
    kde_value,
    prev_kde_value,
    CASE
      WHEN (kde_value IS NULL AND prev_kde_value IS NULL) THEN 0
      WHEN (kde_value IS NULL AND prev_kde_value IS NOT NULL) THEN 1
      WHEN (kde_value IS NOT NULL AND prev_kde_value IS NULL) THEN 1
      WHEN (kde_value <> prev_kde_value) THEN 1
      ELSE 0
    END AS changed_flag,
    (exposure - COALESCE(prev_exposure,0.0))::FLOAT8 AS delta_exposure
  FROM kde_flat
),

/* 3) Aggregate per KDE x month: totals and changes-only */
agg_m AS (
  SELECT
    kde_name,
    month_end,
    COUNT(DISTINCT Account_Identifier)                                   AS total_accts,
    SUM(exposure)                                                        AS total_exposure,
    COUNT(DISTINCT CASE WHEN changed_flag=1 THEN Account_Identifier END) AS chg_accts,
    SUM(CASE WHEN changed_flag=1 THEN delta_exposure ELSE 0.0 END)       AS chg_exposure
  FROM chg_rows
  GROUP BY kde_name, month_end
),

/* 4) Add prior totals, MoM %, and rolling 12m stats */
with_mom AS (
  SELECT
    a.*,
    LAG(total_accts)    OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_accts,
    LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_exposure,

    /* Overall MoM % (relative to prior total exposure) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE (total_exposure - LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end))
                / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS total_exp_mom_pct,

    /* Changes-only % (relative to prior total exposure/accounts) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_exposure / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_exp_mom_pct,

    CASE WHEN LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_accts::FLOAT8 / NULLIF(LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_cnt_mom_pct,

    /* Rolling 12m stats on changes-only exposure & count (levels) */
    AVG(chg_exposure)  OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_ma12,
    STDDEV_SAMP(chg_exposure) OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_sd12,
    AVG(chg_accts)     OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_ma12,
    STDDEV_SAMP(chg_accts)    OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_sd12
  FROM agg_m a
),

/* 5) Z-scores and severity */
scored AS (
  SELECT
    w.*,
    CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
         ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END AS z_chg_exposure,
    CASE WHEN w.chg_cnt_sd12 IS NULL OR w.chg_cnt_sd12 = 0 THEN NULL
         ELSE (w.chg_accts   - w.chg_cnt_ma12) / w.chg_cnt_sd12 END AS z_chg_count,

    ( 0.55 * ABS(COALESCE(
          CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
               ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END, 0))
    + 0.30 * ABS(COALESCE(w.chg_exp_mom_pct,0))
    + 0.15 * ABS(COALESCE(w.chg_cnt_mom_pct,0))
    ) AS severity_raw
  FROM with_mom w
),

/* 6) KDE grouping for visuals */
labeled AS (
  SELECT
    s.*,
    CASE
      WHEN kde_name IN ('RC_CODE','RBC_CODE','RISK_UNIT','STATUS_CODE') THEN 'Risk/Reg'
      WHEN kde_name IN ('LTV','COLLATERAL_CODE','OCCUPANCY_CODE') THEN 'Collateral'
      WHEN kde_name IN ('PROD_HIER_LEVEL_5','PURPOSE_CODE','GL_ACCOUNT_CODE','REVOLVING_CODE') THEN 'Product'
      WHEN kde_name IN ('PD_GRADE','NON_ACCRUAL_FLAG','PAST_DUE_FLAG','DAYS_PAST_DUE') THEN 'Credit Quality'
      WHEN kde_name IN ('NAICS_CODE','INDUSTRY_CODE','BUS_UNIT_CODE','ACCOUNT_OFFICER_NAME') THEN 'Org/Segment'
      WHEN kde_name IN ('MATURITY_DATE','BOOK_DATE','ISSUE_DATE','NEXT_RATE_CHANGE_DATE') THEN 'Dates'
      ELSE 'Other'
    END AS kde_group
  FROM scored s
),

/* 7) Final compute: severity squash + per-month ranks */
final AS (
  SELECT
    l.*,
    /* 0..100 severity via 1 - exp(-x) */
    ROUND(100 * (1 - EXP(-COALESCE(l.severity_raw,0))), 0)::INT AS severity_0_100,

    /* Per-month ranks (null-safe using COALESCE) */
    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY ABS(COALESCE(l.chg_exposure, -1e308)) DESC
    ) AS rank_exp_abs,

    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY COALESCE(l.chg_cnt_mom_pct, -1e308) DESC
    ) AS rank_cnt_pct
  FROM labeled l
)

SELECT
  kde_name,
  kde_group,
  month_end,
  /* Totals */
  total_accts,
  total_exposure,
  prev_total_accts,
  prev_total_exposure,
  total_exp_mom_pct,
  /* Changes-only */
  chg_accts,
  chg_exposure,
  chg_cnt_mom_pct,
  chg_exp_mom_pct,
  /* Rolling & Z */
  chg_exp_ma12, chg_exp_sd12, z_chg_exposure,
  chg_cnt_ma12, chg_cnt_sd12, z_chg_count,
  /* Severity & ranks */
  severity_0_100,
  rank_exp_abs,
  rank_cnt_pct
FROM final
-- Optional history limiter (e.g., last 36 months):
-- WHERE month_end >= ADD_MONTHS(CURRENT_DATE, -36)
ORDER BY month_end DESC, rank_exp_abs ASC;





import pandas as pd

latest = df["month_end"].max()
d = df[df["month_end"]==latest].copy()
top = d.sort_values("severity_0_100", ascending=False).head(5)

lines = [f"Month: {latest.date()}"]
lines.append(f"Outside PI: {int((d['outside_pi']).sum())} of {len(d)} RCs")
lines.append(f"Persistent (3 of 6): {int((d['persistent_outlier_3of6']==1).sum())}")

for _, r in top.iterrows():
    lines.append(f"- {r['rc_code']}: Sev {int(r['severity_0_100'])} — {r.get('reason_code','')}; "
                 f\"Δ vs Fcst = {r['actual']-r['forecast_selected']:.0f}; "
                 f"MoM=$ {r.get('mom_abs',float('nan')):.0f}; Outside PI={bool(r['outside_pi'])}\")

"\n".join(lines)




import pandas as pd
import numpy as np

# assumes df already loaded/cleaned from Step 1 and has lowercase headers
d = df.copy()

# --- correlations per RC (safe even if some columns are missing) ---
def _corr(a, b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a": a, "b": b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs  = "absresid" in d.columns
have_mom  = "mom_abs" in d.columns
have_momp = "mom_pct_abs" in d.columns

rows = []
for rc, g in d.groupby("rc_code"):
    rows.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(rows)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (flat index) ---
dd = d.sort_values(["rc_code", "month_end"]).copy()
dd["se"] = (pd.to_numeric(dd["actual"], errors="coerce") - pd.to_numeric(dd["forecast_selected"], errors="coerce"))**2

dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick the latest row per RC (no droplevel needed)
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code", "break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




import pandas as pd
import numpy as np

# assume df already loaded/cleaned from Step 1
d = df.copy()

# --- correlations per RC ---
def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs   = "absresid" in d.columns
have_mom$  = "mom_abs" in d.columns
have_momp  = "mom_pct_abs" in d.columns

parts = []
for rc, g in d.groupby("rc_code"):
    parts.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom$) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(parts)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (no MultiIndex) ---
dd = d.sort_values(["rc_code","month_end"]).copy()
dd["se"] = (dd["actual"] - dd["forecast_selected"])**2

# rolling means via transform (keeps a flat index)
dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick latest row per RC without droplevel
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code","break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




Error:Python
ValueError: Cannot remove 1 levels from an index with 1 levels: at least one level must be left.




import pandas as pd

d = df.copy()
latest = d["month_end"].max()
top = (
    d[d["month_end"]==latest]
    .sort_values("severity_0_100", ascending=False)
    .loc[:, ["rc_code","rc_description","month_end","severity_0_100","outside_pi",
             "persistent_outlier_3of6","reason_code","z_resid","z_mom_abs","mom_abs"]]
    .head(25)
    .reset_index(drop=True)
)
top



import pandas as pd
import numpy as np

g = df.groupby("rc_code", as_index=False)

def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce"); b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3: return np.nan
    return m["a"].corr(m["b"])

diag = g.apply(lambda x: pd.Series({
    "corr_resid_momabs": _corr(x["absresid"], x["mom_abs"]) if "absresid" in x and "mom_abs" in x else np.nan,
    "corr_resid_mompct": _corr(x["absresid"], x["mom_pct_abs"]) if "mom_pct_abs" in x else np.nan
})).reset_index(drop=True)

# Drift signal: 3-mo MSE / prior 9-mo MSE
df_sorted = df.sort_values(["rc_code","month_end"]).copy()
df_sorted["se"] = (df_sorted["actual"] - df_sorted["forecast_selected"])**2
df_sorted["mse_curr3"] = df_sorted.groupby("rc_code")["se"].rolling(3, min_periods=2).mean().reset_index(level=0, drop=True)
df_sorted["mse_prev9"] = df_sorted.groupby("rc_code")["se"].rolling(12, min_periods=10).mean().reset_index(level=0, drop=True).shift(3)
drift = (df_sorted
         .assign(break_ratio=lambda x: np.where((x["mse_prev9"]>0)&np.isfinite(x["mse_prev9"]),
                                                x["mse_curr3"]/x["mse_prev9"], np.nan))
         .groupby("rc_code", as_index=False)
         .apply(lambda x: x.loc[x["month_end"].idxmax(), ["rc_code","break_ratio"]])
         .droplevel(0)
)
diag = diag.merge(drift, on="rc_code", how="left")
diag




import pandas as pd
import numpy as np

# If you created RC_Anom_Clean, read that; otherwise reuse df from above cell
try:
    df2 = xl("RC_Anom_Clean").copy()
    df2.columns = [str(c).strip().lower().replace(" ","_") for c in df2.columns]
    df2["month_end"] = pd.to_datetime(df2["month_end"], errors="coerce")
    df2["severity_0_100"] = pd.to_numeric(df2["severity_0_100"], errors="coerce")
    df2["outside_pi"] = df2["outside_pi"].astype(bool)
except:
    df2 = df.copy()

thresholds = list(range(55, 91, 5))  # 55,60,...,90
rows = []
for thr in thresholds:
    pred = df2["severity_0_100"] >= thr
    tp = int((pred & df2["outside_pi"]).sum())
    fp = int((pred & ~df2["outside_pi"]).sum())
    fn = int((~pred & df2["outside_pi"]).sum())
    alerts = int(pred.sum())
    prec = tp / (tp + fp) if (tp+fp) else np.nan
    rec  = tp / (tp + fn) if (tp+fn) else np.nan
    rows.append((thr, alerts, tp, fp, fn, prec, rec))

cal = pd.DataFrame(rows, columns=["threshold","alerts","true_pos","false_pos","false_neg","precision","recall"])

# Add avg alerts per latest month (how noisy will it be?)
latest = df2["month_end"].max()
latest_alerts = df2.loc[df2["month_end"]==latest, ["rc_code","severity_0_100"]]
cal["alerts_latest"] = cal["threshold"].map(lambda t: int((latest_alerts["severity_0_100"]>=t).sum()))

cal




import pandas as pd
import numpy as np

# Read the whole table (headers + data), then promote first row as headers
raw = xl("RC_Anomaly_all").copy()
hdr = raw.iloc[0].astype(str).tolist()
df  = raw.iloc[1:].copy()
df.columns = [h.strip().lower().replace(" ","_") for h in hdr]

# Types
num_cols = ["actual","forecast_selected","pi_lo","pi_hi","severity_0_100","absresid","mom_abs","z_resid","z_mom_abs"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")
df["month_end"] = pd.to_datetime(df["month_end"], errors="coerce")

# Helpful boolean: outside prediction interval
df["outside_pi"] = (df["actual"] < df["pi_lo"]) | (df["actual"] > df["pi_hi"])

# (Optional) persist back to Excel visually
df






/* Clean up temp tables */
IF OBJECT_ID('tempdb..#FLUX')   IS NOT NULL DROP TABLE #FLUX;
IF OBJECT_ID('tempdb..#CARDS')  IS NOT NULL DROP TABLE #CARDS;

/* Params */
DECLARE @system NVARCHAR(150);
DECLARE @current_period DATETIME = '2025-08-31';
DECLARE @prior_period   DATETIME = '2025-07-31';

/* Cards for system tagging */
SELECT DISTINCT LOADDT, CUST_LINE_NBR
INTO #CARDS
FROM CRDADMPRD.CRDADMPRD.dbo.CDM_CARDS_LOAN
WHERE CAST(LOADDT AS DATE) IN (@current_period, @prior_period);

/* === Latest row per table, per date & credit line === */
WITH CLM AS (
    SELECT
        CAST(a.LoadDate AS DATE) AS LoadDate,
        a.CreditLineNumber,
        a.NetUtilized,
        a.ApplID,
        a.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(a.LoadDate AS DATE), a.CreditLineNumber
            ORDER BY a.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    WHERE CAST(a.LoadDate AS DATE) IN (@current_period, @prior_period)
),
CLM_Latest AS (
    SELECT * FROM CLM WHERE rn = 1
),
UF AS (
    SELECT
        CAST(b.LoadDate AS DATE) AS LoadDate,
        b.CreditLineNumber,
        b.SecUnfunded,
        b.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(b.LoadDate AS DATE), b.CreditLineNumber
            ORDER BY b.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
    WHERE CAST(b.LoadDate AS DATE) IN (@current_period, @prior_period)
),
UF_Latest AS (
    SELECT * FROM UF WHERE rn = 1
)

/* Build flux set (one row per date & credit line) */
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    (c.NetUtilized + COALESCE(u.SecUnfunded, 0)) AS commitment,
    c.NetUtilized,
    COALESCE(u.SecUnfunded, 0) AS SecUnfunded,
    c.ApplID,
    @system AS [system]
INTO #FLUX
FROM CLM_Latest c
LEFT JOIN UF_Latest u
  ON u.LoadDate = c.LoadDate
 AND u.CreditLineNumber = c.CreditLineNumber;

/* System tagging (date-scoped) */
UPDATE f
SET    [system] = 'Cards'
FROM   #FLUX f
JOIN   #CARDS c
  ON   c.CUST_LINE_NBR = f.CreditLineNumber
 AND   CAST(c.LOADDT AS DATE) = f.LoadDate
WHERE  f.[system] IS NULL;

UPDATE #FLUX SET [system] = 'CFD'            WHERE ApplID IN ('CF')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Lines'    WHERE ApplID IN ('ML')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Mortgage' WHERE ApplID IN ('MO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'iMX'            WHERE CreditLineNumber LIKE '%iMX%' AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'CBS'            WHERE ApplID IN ('LN')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'UBS'            WHERE ApplID IN ('LO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'LJ'             WHERE ApplID IN ('LJ')         AND [system] IS NULL;

/* Results */
SELECT *
FROM #FLUX;




/* ================= RC_Code Anomaly Detection — PBI-safe (no views, no POWER) ================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages (then restrict) */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 5 PRECEDING AND CURRENT ROW)::FLOAT8  AS fc_ma6,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means/SST per window */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics */
metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM (SELECT DISTINCT RC_CODE FROM idx_tm) x
  LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
  LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) In-sample best model (fallback) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality (unchanged from your logic) */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT RC_CODE, AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT RC_CODE, qnum,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
         SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT RC_CODE,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE, q.qnum,
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE q.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q q
  LEFT JOIN seasonal_all a ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE, l.qnum,
    CASE WHEN l.lift_raw IS NULL THEN 1.0
         WHEN l.lift_raw < 0.85 THEN 0.85
         WHEN l.lift_raw > 1.15 THEN 1.15
         ELSE l.lift_raw END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE, f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0))::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36', fc_reg36
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6',   fc_ma6
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12',  fc_ma12
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Attach prev_bal and pos3_count */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residual/MoM stats per (RC,Model) */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,
    CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for PI */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) OOS MSE (last 3 months) */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
/* Pivot OOS to columns to avoid correlated subqueries */
oos_pivot AS (
  SELECT
    RC_CODE,
    MAX(CASE WHEN model='REG12' THEN mse_oos END) AS mse_reg12,
    MAX(CASE WHEN model='REG36' THEN mse_oos END) AS mse_reg36,
    MAX(CASE WHEN model='MA6'   THEN mse_oos END) AS mse_ma6,
    MAX(CASE WHEN model='MA12'  THEN mse_oos END) AS mse_ma12
  FROM oos
  GROUP BY RC_CODE
),
best_model_oos AS (
  SELECT
    m.RC_CODE,
    CASE
      /* prefer regressions only if their R2 gate passes */
      WHEN m.r2_reg12 >= 0.5 AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_reg36,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG12'
      WHEN m.r2_reg36 >= 0.5 AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG36'
      /* otherwise choose the better moving average */
      WHEN COALESCE(o.mse_ma6,9e99) <= COALESCE(o.mse_ma12,9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_OOS
  FROM metrics m
  LEFT JOIN oos_pivot o ON o.RC_CODE = m.RC_CODE
),

/* 18) Final model: OOS if present else in-sample */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows with PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    CASE WHEN z.prev_bal IS NULL THEN NULL ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid, z.Z_MoM_Abs, z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 via rank (no percentile func) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT RC_CODE, AbsResid,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT RC_CODE, MoM_Abs,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                    AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity (robust scaling) */
sev AS (
  SELECT
    f.*,
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - CASE WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0 ELSE s.Severity_Raw END )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier (3 of last 6 months, threshold 70) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code without GREATEST */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= CASE
                               WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0)) THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
                               ELSE ABS(COALESCE(p.MoM_Abs,0.0))
                             END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






/* ======================== RC_Code Anomaly Detection (Enhanced, single query) =========================
   - Models: REG12, REG36, MA6, MA12 with best model chosen by out-of-sample (last 3 months) RMSE,
             falling back to your original in-sample rule if needed.
   - Seasonality: Quarterly lifts from non-spike months, capped & shrunken, damped if recent spikes.
   - Residual / MoM metrics & Z-scores (per RC, per chosen model window).
   - Prediction Intervals: ±1.96 * RMSE (per-RC, per-model).
   - Severity: uses per-RC P95 scale for AbsResid and MoM_Abs (no POWER; no percentile functions).
               P95 is computed via rank logic: the first value at or above 95th percentile.
   - Flags: Persistent outlier (3 of last 6) and Reason_Code for explainability.
   - No views; no POWER().
   ================================================================================================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (arithmetic only) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Original best-model rule (fallback if OOS cannot be computed) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT
    RC_CODE,
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT
    RC_CODE,
    qnum,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT
    RC_CODE,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE,
    q.qnum,
    CASE
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
      ELSE q.avg_q_nospike / a.avg_all_nospike
    END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q   q
  LEFT JOIN seasonal_all a
    ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts by model (limit rows to each model's window) */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift to forecast */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Add prev_bal & "active last 3 months" flag */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for prediction intervals */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) Out-of-sample (last 3 months of each model) selection */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
best_model_oos AS (
  /* Pick lowest OOS MSE, with R2 ≥ 0.5 gates for regressions; else fall back to MA6/MA12 */
  SELECT d.RC_CODE,
         CASE
           WHEN (SELECT r2_reg12 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o1.mse_oos,9e99) FROM oos o1 WHERE o1.RC_CODE=d.RC_CODE AND o1.model='REG12')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='REG36'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG12'

           WHEN (SELECT r2_reg36 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o2.mse_oos,9e99) FROM oos o2 WHERE o2.RC_CODE=d.RC_CODE AND o2.model='REG36')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG36'

           WHEN COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99)
                <= COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
           THEN 'MA6'
           ELSE 'MA12'
         END AS Best_Model_OOS
  FROM (SELECT DISTINCT RC_CODE FROM union_with_z) d
),

/* 18) Choose final best model: OOS if available else in-sample rule */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows for chosen model; attach RMSE and PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    /* MoM absolute & percent (already abs for pct) */
    CASE WHEN z.prev_bal IS NULL THEN NULL
         ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    /* 95% prediction interval (no POWER) */
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 scales for AbsResid and MoM_Abs (computed via rank, no percentile fn) */
p95_abs AS (
  SELECT RC_CODE,
         MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid)                      AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                         AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE,
         MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs)                        AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                          AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity using robust (per-RC) P95 scales */
sev AS (
  SELECT
    f.*,
    /* robust components: guard denominators with NULLIF */
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  /* Exponential squash to 0..100; no POWER used */
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - GREATEST(0.0, COALESCE(s.Severity_Raw,0.0)) )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier: 3 of last 6 months (threshold 70, adjust as needed) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code (simple dominance logic) */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= GREATEST(ABS(COALESCE(p.Z_MoM_Abs,0.0)), ABS(COALESCE(p.MoM_Abs,0.0))) THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






--QUERY 1										
/* ======================== RC_Code Anomaly Detection =========================										
   - Runs Seasonally Adjusted Regression (12mo, 36mo) and Moving Average (6mo, 12mo), selecting model w/ best fit										
   - Assigns severity score based on various Z-Scores and materiality										
   ============================================================================ */										
WITH										
/* 0) Base */										
base AS (										
  SELECT										
    RC_CODE,										
    RC_DESCRIPTION,										
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,										
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num										
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB										
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL										
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'										
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)										
),										
										
/* 1) Index and tmax; also prev_bal and Month/Quarter tags */										
idx AS (										
  SELECT										
    b.*,										
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t										
  FROM base b										
),										
idx_tm AS (										
  SELECT										
    i.*,										
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,										
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,										
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,										
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum										
  FROM idx i										
),										
										
/* 2) Evaluation windows */										
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),										
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),										
										
/* 3) Regression params (grouped) */										
reg12_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n12,										
    SUM(t)::FLOAT8           AS sumx12,										
    SUM(bal_num)::FLOAT8     AS sumy12,										
    SUM(t*bal_num)::FLOAT8   AS sumxy12,										
    SUM(t*t)::FLOAT8         AS sumx2_12										
  FROM last12										
  GROUP BY RC_CODE										
),										
reg36_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n36,										
    SUM(t)::FLOAT8           AS sumx36,										
    SUM(bal_num)::FLOAT8     AS sumy36,										
    SUM(t*bal_num)::FLOAT8   AS sumxy36,										
    SUM(t*t)::FLOAT8         AS sumx2_36										
  FROM last36										
  GROUP BY RC_CODE										
),										
										
/* 4) Regression fits over their windows */										
reg12_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0										
      THEN										
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t										
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg12										
  FROM last12 l										
  JOIN reg12_params p USING (RC_CODE)										
),										
reg36_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0										
      THEN										
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t										
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg36										
  FROM last36 l										
  JOIN reg36_params p USING (RC_CODE)										
),										
										
/* 5) Moving averages once, then restrict to windows */										
ma_all AS (										
  SELECT										
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma6,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma12										
  FROM idx_tm i										
),										
ma6_last12 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6										
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma6 IS NOT NULL										
),										
ma12_last36 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12										
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma12 IS NOT NULL										
),										
										
/* 6) Means and SST per window (grouped) */										
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),										
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),										
										
sst12 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12										
  FROM last12 l JOIN mean12 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
sst36 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36										
  FROM last36 l JOIN mean36 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
										
/* 7) SSE + counts per model/window (grouped) */										
agg_reg12 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,										
         COUNT(*) AS n_reg12										
  FROM reg12_fit f										
  WHERE f.fc_reg12 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_reg36 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,										
         COUNT(*) AS n_reg36										
  FROM reg36_fit f										
  WHERE f.fc_reg36 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_ma6_12 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,										
         COUNT(*) AS n_ma6										
  FROM ma6_last12 m										
  GROUP BY m.RC_CODE										
),										
agg_ma12_36 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,										
         COUNT(*) AS n_ma12										
  FROM ma12_last36 m										
  GROUP BY m.RC_CODE										
),										
										
/* 8) Metrics (arithmetic only) */										
metrics AS (										
  SELECT										
    x.RC_CODE,										
										
    s12.sst12,  s36.sst36,										
    ar12.sse_reg12, ar12.n_reg12,										
    ar36.sse_reg36, ar36.n_reg36,										
    am6.sse_ma6,    am6.n_ma6,										
    am12.sse_ma12,  am12.n_ma12,										
										
    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,										
										
    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,										
										
    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,										
										
    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12										
  FROM										
    (SELECT DISTINCT RC_CODE FROM idx_tm) x										
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE										
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE										
),										
										
/* 9) Best model pick (no aggregates) */										
best_model AS (										
  SELECT										
    m.RC_CODE,										
    CASE										
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG12'										
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG36'										
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'										
      ELSE 'MA12'										
    END AS Best_Model										
  FROM metrics m										
),										
										
/* 10) --- Robust seasonality: compute spike-aware quarterly lifts --- */										
										
/* 10a) Build MoM (on full series) and spike flags per RC */										
mom_base AS (										
  SELECT										
    t.*,										
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,										
    CASE										
      WHEN t.prev_bal IS NULL THEN NULL										
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0										
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)										
    END::FLOAT8 AS mom_pct										
  FROM idx_tm t										
),										
mom_stats AS (										
  SELECT										
    RC_CODE,										
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs										
  FROM mom_base										
  GROUP BY RC_CODE										
),										
mom_flag AS (										
  /* spike = big percentage change OR big absolute jump relative to typical */										
  SELECT										
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,										
    CASE										
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1										
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1										
      ELSE 0										
    END AS is_spike										
  FROM mom_base b										
  LEFT JOIN mom_stats s USING (RC_CODE)										
),										
/* 10b) recent spike signal (last 6 months relative to series max month) */										
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),										
recent_spike AS (										
  SELECT f.RC_CODE,										
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike										
  FROM mom_flag f										
  JOIN max_me m USING (RC_CODE)										
  GROUP BY f.RC_CODE										
),										
										
/* 10c) Seasonal lifts per RC×Quarter using NON-spike months (revised) */										
seasonal_q AS (										
  SELECT										
    RC_CODE,										
    qnum,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,										
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q										
  FROM mom_flag										
  GROUP BY RC_CODE, qnum										
),										
seasonal_all AS (										
  SELECT										
    RC_CODE,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike										
  FROM mom_flag										
  GROUP BY RC_CODE										
),										
seasonal_lifts AS (										
  SELECT										
    q.RC_CODE,										
    q.qnum,										
    /* raw lift */										
    CASE										
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0										
      ELSE q.avg_q_nospike / a.avg_all_nospike										
    END::FLOAT8 AS lift_raw,										
    q.n_q										
  FROM seasonal_q   q										
  LEFT JOIN seasonal_all a										
    ON a.RC_CODE = q.RC_CODE										
),										
										
/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes (unchanged) */										
seasonal_final AS (										
  SELECT										
    l.RC_CODE,										
    l.qnum,										
    /* cap to [0.85, 1.15] */										
    CASE										
      WHEN l.lift_raw IS NULL THEN 1.0										
      WHEN l.lift_raw < 0.85 THEN 0.85										
      WHEN l.lift_raw > 1.15 THEN 1.15										
      ELSE l.lift_raw										
    END::FLOAT8 AS lift_capped,										
    /* history-based shrink 0..1 (min points to fully trust ≈ 8) */										
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight										
  FROM seasonal_lifts l										
),										
seasonal_ready AS (										
  SELECT										
    f.RC_CODE,										
    f.qnum,										
    /* extra damp if recent spikes: halve the effect */										
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)										
          * f.hist_weight * (f.lift_capped - 1.0)										
    )::FLOAT8 AS lift_final										
  FROM seasonal_final f										
  LEFT JOIN recent_spike r USING (RC_CODE)										
),										
/* 11) Union forecasts by model (limit rows to each model's window) */										
fits_union AS (										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast										
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast										
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast										
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast										
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL										
),										
										
/* 12) Apply seasonal lift to forecast */										
fits_seasonal AS (										
  SELECT										
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,										
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj										
  FROM fits_union u										
  LEFT JOIN seasonal_ready s										
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum										
),										
										
/* 13) Add prev_bal & "active last 3 months" flag */										
union_with_prev AS (										
  SELECT										
    f.*,										
    t.prev_bal,										
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)										
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count										
  FROM fits_seasonal f										
  JOIN idx_tm t										
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end										
),										
										
/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */										
union_enriched AS (										
  SELECT										
    x.*,										
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,										
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,										
										
    CASE WHEN x.prev_bal IS NULL THEN NULL										
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,										
										
    CASE										
      WHEN x.prev_bal IS NULL THEN NULL										
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
    END::FLOAT8 AS mom_pct_abs,										
										
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,										
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,										
										
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,										
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,										
										
    AVG(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,										
    STDDEV_SAMP(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct										
  FROM union_with_prev x										
),										
										
/* 15) Z-scores */										
union_with_z AS (										
  SELECT										
    e.*,										
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0										
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,										
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0										
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,										
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0										
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct										
  FROM union_enriched e										
),										
										
/* 16) Portfolio-wide scales for severity */										
port_scales AS (										
  SELECT										
    MAX(abs_resid) AS max_abs_resid,										
    MAX(mom_abs)   AS max_mom_abs										
  FROM union_with_z										
),										
										
/* 17) Best model decided earlier; join and return FULL history inside chosen window */										
final AS (										
  SELECT										
    z.RC_CODE,										
    z.RC_DESCRIPTION,										
    z.month_end,										
    bm.Best_Model,										
    z.prev_bal,										
    z.forecast_adj       AS Forecast_Selected,										
    z.bal_num            AS Actual,										
    z.resid              AS Resid,										
    z.abs_resid          AS AbsResid,										
    z.mom_abs            AS MoM_Abs,										
    z.mom_pct_abs        AS MoM_Pct_Abs,										
    z.Z_Resid,										
    z.Z_MoM_Abs,										
    z.Z_MoM_Pct,										
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos										
  FROM union_with_z z										
  JOIN best_model bm										
    ON bm.RC_CODE = z.RC_CODE										
  WHERE z.model = bm.Best_Model										
)										
										
SELECT										
  f.*,										
  /* Severity emphasizing AbsResid and Z_Resid */										
  (										
    0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
  + 0.65 * ABS(f.Z_Resid)										
  + 0.07 * ABS(f.Z_MoM_Abs)										
  + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
  )::FLOAT8 AS Severity_Raw,										
										
  ROUND(										
    100.0 * (1.0 - EXP(										
      -(										
        0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
      + 0.65 * ABS(f.Z_Resid)										
      + 0.07 * ABS(f.Z_MoM_Abs)										
      + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
      )										
    )),										
0										
  )::INTEGER AS Severity_0_100										
FROM final f										
CROSS JOIN port_scales ps										
ORDER BY f.RC_CODE, f.month_end;										





import pandas as pd
import numpy as np

# Read the whole table (headers + data) via the named range
raw = xl("KDE_Clean_all").copy()

# Promote first row to headers
header = raw.iloc[0].astype(str).tolist()
df = raw.iloc[1:].copy()
df.columns = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header]

# Sanity check
print("rows:", len(df))
print("cols:", list(df.columns))

# Types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple slope
    t = np.arange(len(g), dtype=float); y = g["exp_changed"].astype(float).to_numpy()
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c, y_c = t - t.mean(), y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c*y_c).sum()/denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)
df_feat





import pandas as pd

df = xl("KDE_Clean").copy()
print("rows:", len(df))
print("columns:", list(df.columns))
df.head()



import pandas as pd
import numpy as np

df = xl("KDE_Clean").copy()
# normalize in case of variations
df.columns = [str(c).strip().lower().replace(" ", "_") for c in df.columns]

# required
for col in ["kde_name","this_eom","exp_changed"]:
    if col not in df.columns:
        raise KeyError(f"Missing column: {col}. Got: {list(df.columns)}")

# types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
df["exp_changed"] = pd.to_numeric(df["exp_changed"], errors="coerce")

# rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple OLS slope (no sklearn): slope = cov(t,y)/var(t)
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].to_numpy(dtype=float)
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c = t - t.mean()
        y_c = y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c * y_c).sum() / denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)

# return full table; convert to an Excel Table named KDE_Features after it renders
df_feat




import pandas as pd

# get data body
dat = xl("KDE_Summary3").copy()

# get header row from the new named range
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols
print("rows:", len(dat), "| cols:", cols)
dat




import pandas as pd

# data body (no headers) comes from the table name
dat = xl("KDE_Summary3").copy()

# headers come from the named range you just created
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols

print("rows:", len(dat), "| cols:", cols)
dat  # returns full table with proper headers




import pandas as pd

TBL = "KDE_Summary3"   # exact Table Name from Table Design

# Read the header row and the data body separately
hdr = xl(f"{TBL}[#Headers]").copy()
dat = xl(f"{TBL}[#Data]").copy()

# Convert the single header row to a list of strings, then clean the names
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

# Apply headers to the data body
dat.columns = cols

# Show a quick summary and the FULL dataframe (no .head/.tail)
print("rows:", len(dat), "cols:", cols)
dat





import pandas as pd
df = xl("KDE_Summary3").copy()
print(list(df.columns))
df.head(3)




tbl = "KDE_Summary3[#All]"   # note the [#All]
df = xl(tbl).copy()
print(df.shape, list(df.columns))


df = xl("KDE_Summary3").copy()




import pandas as pd

tbl = "KDE_Summary3"  # <-- make sure this matches Table Design > Table Name exactly
df = xl(tbl).copy()

print("shape:", df.shape)
print("columns (as Excel passes them):", list(df.columns))
df.head(3)



Error:Python
KeyError: "Couldn't find a KDE identifier column. Expected one of ['kde_name', 'kde', 'key_data_element', 'field_name', 'attribute_name', 'attribute']. Got: ['next_rate_change_date', '2025-09-30_00:00:00', '71809863129.06', '100970', '0.583402', '173071', '171867', '-1204', '-0.006957', '92887577678.95', '93253920099.4', '366342420.45', '0.003944', '-1085822458.44966', '70338547296.7333', '7053855244.00191', '0.208583218882717', '1']"





import pandas as pd
import numpy as np

df_raw = xl("KDE_Summary").copy()
print("raw rows:", len(df_raw))

# If headers came through as numbers, promote first row to headers
if all(isinstance(c, (int, float)) for c in df_raw.columns):
    header = df_raw.iloc[0].tolist()
    df = df_raw.iloc[1:].copy()
    df.columns = [str(x).strip() if pd.notna(x) else f"col_{i}" for i, x in enumerate(header)]
else:
    df = df_raw.copy()

# normalize headers
def norm(c): return str(c).replace("\n"," ").strip().lower().replace(" ", "_")
df.columns = [norm(c) for c in df.columns]
print("normalized columns:", list(df.columns))
print("rows after normalization:", len(df))

# find key columns
kde_candidates  = ["kde_name","kde","key_data_element","field_name","attribute_name","attribute"]
date_candidates = ["this_eom","end_of_month_date","end_of_month","month_end","eom","eom_date","as_of_eom","as_of_date"]

kde_col  = next((c for c in kde_candidates if c in df.columns), None)
date_col = next((c for c in date_candidates if c in df.columns), None)

if kde_col is None:
    raise KeyError(f"Couldn't find a KDE identifier column. Expected one of {kde_candidates}. Got: {list(df.columns)}")

if date_col is None:
    # try auto-detect a date-like column
    for c in df.columns:
        s = pd.to_datetime(df[c], errors="coerce")
        if s.notna().sum() >= max(3, int(0.5*len(s))):
            df["this_eom"] = s
            date_col = "this_eom"
            break
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

# type-cast numerics where present
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# sort for readability
df = df.sort_values([kde_col, "this_eom"]).reset_index(drop=True)

print("kde column:", kde_col, "| date column:", "this_eom")
print("final row count:", len(df))

# IMPORTANT: return the full DataFrame (no .head() / .tail())
df





import pandas as pd
import numpy as np

# ---- 1) Load the Excel table ----
# If your table name isn't KDE_Summary, change it here:
df = xl("KDE_Summary").copy()

# Show raw headers (helps debugging)
print("Raw columns:", list(df.columns))

# ---- 2) Normalize headers safely (handles non-string headers) ----
def to_str(x):
    try:
        return "_".join(map(str, x)).strip() if isinstance(x, tuple) else str(x).strip()
    except Exception:
        return str(x)

df.columns = [to_str(c) for c in df.columns]
df.columns = [c.replace("\n"," ") for c in df.columns]  # remove line breaks from header cells
df.columns = [c.lower().replace(" ", "_") for c in df.columns]

print("Normalized columns:", list(df.columns))

# ---- 3) Find the EOM/date column (handles THIS_EOM and common aliases) ----
aliases = [
    "this_eom","end_of_month_date","end_of_month","month_end",
    "eom","eom_date","as_of_eom","as_of_date","report_eom"
]
date_col = next((c for c in aliases if c in df.columns), None)

# If not found by name, try to detect a date-like column
if date_col is None:
    name_candidates = [c for c in df.columns if any(k in c for k in ["date","eom","month"])]
    parsed = []
    for c in name_candidates + list(df.columns):
        try:
            s = pd.to_datetime(df[c], errors="coerce")
            if s.notna().sum() >= max(3, int(0.5*len(s))):  # at least half the rows look like dates
                parsed.append((c, s))
        except Exception:
            pass
    if parsed:
        date_col, s = parsed[0]
        df["this_eom"] = s
    else:
        raise KeyError(f"Could not find a date column to use as 'this_eom'. "
                       f"Available columns: {list(df.columns)}")
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

print("Using date column as this_eom:", date_col)

# ---- 4) Make sure key numeric columns are numeric (skip if absent) ----
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ---- 5) Sort & preview ----
key_name = "kde_name" if "kde_name" in df.columns else (next((c for c in df.columns if "kde" in c and "name" in c), None))
if key_name is None:
    print("Warning: couldn't find KDE name column (expected 'KDE_NAME'). Continuing without it.")
    df = df.sort_values(["this_eom"]).reset_index(drop=True)
else:
    df = df.sort_values([key_name, "this_eom"]).reset_index(drop=True)

df.tail(10)



import pandas as pd
import numpy as np

df = xl("KDE_Summary").copy()

# convert all headers to lowercase
df.columns = [c.lower() for c in df.columns]

# now you can safely reference 'this_eom'
df['this_eom'] = pd.to_datetime(df['this_eom'], errors='coerce')

# continue with your numeric conversions, sorting, etc.
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct",
            "exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["kde_name","this_eom"]).reset_index(drop=True)
df.tail(10)




import pandas as pd
import numpy as np

# Pull the Excel table into pandas
df = xl("KDE_Summary").copy()

# Basic typing & ordering
df["this_eom"] = pd.to_datetime(df["this_eom"])
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["KDE_NAME","this_eom"]).reset_index(drop=True)

# Show a peek
df.tail(10)





import matplotlib.pyplot as plt

kde = xl("SelectedKDE") if "SelectedKDE" in dir() else None
if not kde:
    kde = df_feat["KDE_NAME"].iloc[0]

g = df_feat[df_feat["KDE_NAME"]==kde].sort_values("this_eom")

plt.figure()
plt.plot(g["this_eom"], g["exp_changed"], label="exp_changed")
if g["exp_changed_ma12"].notna().any():
    plt.plot(g["this_eom"], g["exp_changed_ma12"], linestyle=":", label="MA12")
# add a straight trend line from the slope if you want a visual guide
if len(g) >= 2 and np.isfinite(g["exp_changed"]).sum() >= 2:
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].astype(float).values
    # reconstruct fit using mean-centered form with the slope we computed
    slope = g["exp_changed_trend_slope"].iloc[-1]
    y_hat = (t - t.mean()) * slope + np.nanmean(y)
    plt.plot(g["this_eom"], y_hat, linestyle="--", label="trend")

plt.title(f"{kde} — exp_changed, MA12 & trend")
plt.xlabel("Month End")
plt.ylabel("Exposure changed")
plt.legend()
plt.tight_layout()





import pandas as pd
from sklearn.linear_model import LinearRegression

df = dataset
df = df.groupby('KDE_NAME', as_index=False)['exp_changed'].mean()
model = LinearRegression().fit(df.index.values.reshape(-1,1), df['exp_changed'])
df['trend'] = model.coef_[0]






-- HISTORY + TRENDS (Netezza-safe, no POWER(), no analytic REGR_*)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)

WITH
params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

/* Month index across the window and its prior month */
months AS (
  SELECT DISTINCT t.End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date) AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

/* Base pull: choose exposure and carry all KDEs */
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

/* UNPIVOT via UNION ALL, cast all KDEs to VARCHAR to align types */
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

/* Pair each current month with its previous month using months_seq */
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.End_of_Month_Date
),

/* Compare prev vs curr at (Account, KDE, month) grain */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

/* Row-level flags and attributions */
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,
    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,
    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,
    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

/* Monthly KDE rollups */
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom) AS this_eom,
    SUM(changed_flag) AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag) AS cnt_prev,
    SUM(curr_flag) AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END) AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END) AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

/* MoM metrics per KDE per month */
metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

/* Linear trend slope of exp_changed across the window (per KDE) — no POWER() */
trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
            - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION)))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION))) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

/* Rolling 12-means and stdev for exp_changed (uses multiplications, no POWER()) */
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - (
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          *
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - (
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            *
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),

/* Join trend + rolling stats back to monthly metrics */
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

/* Latest month only + ranking */
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  /* ranking keys */
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  /* MoM context */
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  /* trend context */
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;



base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'     -- 🔹 added filter
),






trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
            - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
          - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION)) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),




rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            CAST(2.0 AS DOUBLE PRECISION)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              CAST(2.0 AS DOUBLE PRECISION)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),




[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            2
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(NUMERIC, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






-- ***** REPLACE trend_all CTE *****
trend_all AS (
  /* slope = Cov(x,y) / Var(x)
     = ( n*Σ(xy) - Σx*Σy ) / ( n*Σ(x^2) - (Σx)^2 ) */
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM( (t_idx*1.0) * (exp_changed*1.0) )
          - (SUM(t_idx*1.0) * SUM(exp_changed*1.0)) )
        /
        ( COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


-- ***** REPLACE rolling_stats CTE *****
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    /* rolling mean over last 12 (or fewer for early months) */
    AVG(exp_changed*1.0)
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    /* rolling stdev using sqrt(E[x^2] - (E[x])^2) */
    CASE
      WHEN
        ( AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        ) < 0
        THEN 0  -- guard against tiny negative from floating error
      ELSE
        SQRT(
          AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'REGR_SLOPE(NUMERIC, NUMERIC)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





-- KDE Changes-Only History + Trend (Netezza-safe, patched)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)
-- Window: set your start/end month-ends below

WITH params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

-- Distinct month-ends in range, and previous month for each
months AS (
  SELECT DISTINCT End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date)           AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

-- Base rows (exposure: Derived -> Amortized)
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,

    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

-- UNPIVOT via UNION ALL (cast to VARCHAR for type alignment)
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

-- Pair each month with its previous month
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.End_of_Month_Date
),

-- *** FIXED joined CTE (no GROUP BY; no stray attrs) ***
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

-- Row-level flags & attribution
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,

    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,

    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,

    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

-- Monthly KDE rollups
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom)                                             AS this_eom,
    SUM(changed_flag)                                         AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag)                                            AS cnt_prev,
    SUM(curr_flag)                                            AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END)   AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END)   AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

-- ***** FIX: compute regression as an aggregate (no OVER) *****
trend_all AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(exp_changed * 1.0, t_idx * 1.0) AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

-- Rolling 12-month stats (still analytic — supported in Netezza)
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(exp_changed)    OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    STDDEV_SAMP(exp_changed) OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_sd12
  FROM metrics_monthly
),

-- Join trend + rolling stats back to the monthly metrics
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

-- Latest month only + ranking by changes-only exposure, then by count %
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  -- changes-only (ranking keys)
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  -- MoM context
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  -- Trend features
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;
