import numpy as np, pandas as pd
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing; _HAS_SM=True
except Exception:
    _HAS_SM=False
SP=12; H=1; Z80=1.2816; Z95=1.9599; WZ,WP,WI=0.5,0.3,0.2
df=args[0].copy()
df.columns=[c.strip().upper() for c in df.columns]
req={'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
mis=req-set(df.columns)
if mis: raise ValueError(f'Missing required columns: {mis}')
df['END_OF_MONTH_DATE']=pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE']=pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df=df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df=(df.groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'],as_index=False)['SOURCE_SYSTEM_BALANCE'].sum()
       .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))
def rstd(r):
    if r.size==0: return np.nan
    med=np.nanmedian(r); mad=np.nanmedian(np.abs(r-med))
    return 1.4826*mad if mad and mad>0 else (np.nanstd(r) if r.size>1 else np.nan)
def s_naive(y,h,sp):
    n=len(y); out=[]
    for k in range(1,h+1):
        out.append(y.iloc[n-sp] if n-sp>=0 else y.iloc[-1])
    return pd.Series(out,index=range(h))
def fit_fc(y,h,sp):
    y=pd.Series(y.astype(float).values)
    name='SeasonalNaive'; fit=None
    if _HAS_SM:
        try:
            if len(y)>=2*sp:
                fit=ExponentialSmoothing(y,trend='add',seasonal='add',seasonal_periods=sp,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,A)'
            elif len(y)>=6:
                fit=ExponentialSmoothing(y,trend='add',seasonal=None,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,N)'
            else:
                fit=ExponentialSmoothing(y,trend=None,seasonal=None,initialization_method='estimated').fit(optimized=True); name='SES'
        except Exception:
            fit=None
        if fit is not None:
            fv=pd.Series(fit.fittedvalues); fc=pd.Series(fit.forecast(H).values,index=range(H))
            return name,fv,fc
    fc=s_naive(y,H,sp)
    fv=pd.Series(index=y.index,dtype=float)
    if len(y)>sp:
        fv.iloc[:sp]=y.values[0]; fv.iloc[sp:]=y.values[:-sp]
    else:
        fv[:]=np.nanmean(y.values)
    return name,fv,fc
rows=[]
for sys,g in df.groupby('CONTRACT_SOURCE_SYSTEM',sort=False):
    g=g.sort_values('END_OF_MONTH_DATE'); y=g['SOURCE_SYSTEM_BALANCE']
    name,fv,fc=fit_fc(y,H,SP)
    n=min(len(y),len(fv)); resid=(y.iloc[:n].values-np.nan_to_num(fv.iloc[:n].values,nan=np.nan)).astype(float)
    resid=resid[~np.isnan(resid)]; sig=rstd(resid)
    last_d=g['END_OF_MONTH_DATE'].iloc[-1]; last_a=float(y.iloc[-1]); med=float(np.nanmedian(y.values)) if len(y) else 1.0
    for step in range(len(fc)):
        f=float(fc.iloc[step]); next_d=last_d+pd.offsets.MonthEnd(step+1)
        if sig is not None and np.isfinite(sig):
            lo80,hi80=f-Z80*sig,f+Z80*sig; lo95,hi95=f-Z95*sig,f+Z95*sig
        else:
            lo80=hi80=lo95=hi95=np.nan
        dev_abs=last_a-f; dev_pct=(dev_abs/f) if f!=0 else np.nan; z=(dev_abs/sig) if (sig is not None and np.isfinite(sig) and sig>0) else np.nan
        zt=min(abs(z)/3.0,1.0) if pd.notna(z) else 0.0; pt=min(abs(dev_pct)/0.1,1.0) if pd.notna(dev_pct) else 0.0; it=min((abs(dev_abs)/(med*0.1)) if med>0 else 0.0,1.0)
        sev=100.0*(WZ*zt+WP*pt+WI*it); flag95=(pd.notna(last_a) and pd.notna(lo95) and (last_a<lo95 or last_a>hi95))
        rows.append({'CONTRACT_SOURCE_SYSTEM':sys,'MODEL':name,'LAST_PERIOD':last_d,'NEXT_PERIOD':next_d,'STEP_AHEAD':step+1,'ACTUAL_LAST':last_a,'FORECAST':f,'PI80_LO':lo80,'PI80_HI':hi80,'PI95_LO':lo95,'PI95_HI':hi95,'DEV_ABS_vs_LAST':dev_abs,'DEV_PCT_vs_LAST':dev_pct,'Z_SCORE_vs_LAST':z,'SEVERITY_0_100':sev,'OUTSIDE_95_BAND_vs_LAST':bool(flag95)})
res=pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'],ascending=[True,False])
return res






=PY("import numpy as np, pandas as pd
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing; _HAS_SM=True
except Exception:
    _HAS_SM=False
SP=12; H=1; Z80=1.2816; Z95=1.9599; WZ,WP,WI=0.5,0.3,0.2
df=args[0].copy()
df.columns=[c.strip().upper() for c in df.columns]
req={'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
mis=req-set(df.columns)
if mis: raise ValueError(f'Missing required columns: {mis}')
df['END_OF_MONTH_DATE']=pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE']=pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df=df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df=(df.groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'],as_index=False)['SOURCE_SYSTEM_BALANCE'].sum()
       .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))
def rstd(r):
    if r.size==0: return np.nan
    med=np.nanmedian(r); mad=np.nanmedian(np.abs(r-med))
    return 1.4826*mad if mad and mad>0 else (np.nanstd(r) if r.size>1 else np.nan)
def s_naive(y,h,sp):
    n=len(y); out=[]
    for k in range(1,h+1):
        out.append(y.iloc[n-sp] if n-sp>=0 else y.iloc[-1])
    return pd.Series(out,index=range(h))
def fit_fc(y,h,sp):
    y=pd.Series(y.astype(float).values)
    name='SeasonalNaive'; fit=None; fcast=None
    if _HAS_SM:
        try:
            if len(y)>=2*sp:
                fit=ExponentialSmoothing(y,trend='add',seasonal='add',seasonal_periods=sp,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,A)'
            elif len(y)>=6:
                fit=ExponentialSmoothing(y,trend='add',seasonal=None,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,N)'
            else:
                fit=ExponentialSmoothing(y,trend=None,seasonal=None,initialization_method='estimated').fit(optimized=True); name='SES'
        except Exception: fit=None
        if fit is not None:
            fv=pd.Series(fit.fittedvalues); fc=pd.Series(fit.forecast(h).values,index=range(h))
            return name,fv,fc
    fc=s_naive(y,h,sp)
    fv=pd.Series(index=y.index,dtype=float)
    if len(y)>sp:
        fv.iloc[:sp]=y.values[0]; fv.iloc[sp:]=y.values[:-sp]
    else:
        fv[:]=np.nanmean(y.values)
    return name,fv,fc
rows=[]
for sys,g in df.groupby('CONTRACT_SOURCE_SYSTEM',sort=False):
    g=g.sort_values('END_OF_MONTH_DATE'); y=g['SOURCE_SYSTEM_BALANCE']
    name,fv,fc=fit_fc(y,H,SP)
    n=min(len(y),len(fv)); resid=(y.iloc[:n].values-np.nan_to_num(fv.iloc[:n].values,nan=np.nan)).astype(float)
    resid=resid[~np.isnan(resid)]; sig=rstd(resid)
    last_d=g['END_OF_MONTH_DATE'].iloc[-1]; last_a=float(y.iloc[-1]); med=float(np.nanmedian(y.values)) if len(y) else 1.0
    for step in range(len(fc)):
        f=float(fc.iloc[step]); next_d=last_d+pd.offsets.MonthEnd(step+1)
        if sig is not None and np.isfinite(sig):
            lo80,hi80=f-Z80*sig,f+Z80*sig; lo95,hi95=f-Z95*sig,f+Z95*sig
        else:
            lo80=hi80=lo95=hi95=np.nan
        dev=f-last_a; pct=(dev/f) if f!=0 else np.nan; z=(dev/sig) if (sig is not None and np.isfinite(sig) and sig>0) else np.nan
        zt=min(abs(z)/3.0,1.0) if pd.notna(z) else 0.0; pt=min(abs(pct)/0.1,1.0) if pd.notna(pct) else 0.0; it=min((abs(dev)/(med*0.1)) if med>0 else 0.0,1.0)
        sev=100.0*(WZ*zt+WP*pt+WI*it); flag95=(pd.notna(last_a) and pd.notna(lo95) and (last_a<lo95 or last_a>hi95))
        rows.append({'CONTRACT_SOURCE_SYSTEM':sys,'MODEL':name,'LAST_PERIOD':last_d,'NEXT_PERIOD':next_d,'STEP_AHEAD':step+1,'ACTUAL_LAST':last_a,'FORECAST':f,'PI80_LO':lo80,'PI80_HI':hi80,'PI95_LO':lo95,'PI95_HI':hi95,'DEV_ABS_vs_LAST':last_a-f,'DEV_PCT_vs_LAST':(last_a-f)/f if f!=0 else np.nan,'Z_SCORE_vs_LAST':(last_a-f)/sig if (sig is not None and np.isfinite(sig) and sig>0) else np.nan,'SEVERITY_0_100':sev,'OUTSIDE_95_BAND_vs_LAST':bool(flag95)})
res=pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'],ascending=[True,False])
return res
", tblSSB[#All])





-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (fixed PREV_TOT_GL and RC_DESCRIPTION)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,
        0.40::FLOAT  AS w_zscore,
        0.30::FLOAT  AS w_pct,
        0.20::FLOAT  AS w_abs,
        0.10::FLOAT  AS w_share,
        2.00::FLOAT  AS z_cap,
        0.25::FLOAT  AS pct_cap,
        100000::FLOAT AS abs_cap,
        0.02::FLOAT  AS share_cap,
        2.00::FLOAT  AS z_thresh,
        0.25::FLOAT  AS pct_thresh,
        100000::FLOAT AS abs_thresh
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RC_DESCRIPTION,                          -- <-- renamed
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS & PRIOR-MONTH TOTAL AT MONTH GRAIN ======== */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),
tot_with_prev AS (
    SELECT
        EOM,
        TOT_GL AS CURR_TOT_GL,
        LAG(TOT_GL) OVER (ORDER BY EOM) AS PREV_TOT_GL
    FROM tot
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RC_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL
    FROM base b
),

/* ====== 5) ENRICH WITH MONTH TOTALS, Z-SCORE, SHARE METRICS ============== */
enriched AS (
    SELECT
        c.*,
        t.CURR_TOT_GL,
        t.PREV_TOT_GL,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN t.CURR_TOT_GL > 0 THEN c.GL_BALANCE / t.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN t.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN t.CURR_TOT_GL > 0 AND t.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / t.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
    JOIN tot_with_prev t
      ON t.EOM = c.EOM
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RC_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE WHEN Z_SCORE_12_EXCL IS NULL THEN 0 ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1) END AS z_norm,
        CASE WHEN MOM_PCT_CHANGE IS NULL THEN 0 ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1) END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE WHEN SHARE_DELTA IS NULL THEN 0 ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1) END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RC_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;






-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (Run as a single query)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,   -- months of history (e.g., 12)
        /* Severity weighting (roughly sum to 1.0) */
        0.40::FLOAT  AS w_zscore,          -- weight for Z-score
        0.30::FLOAT  AS w_pct,             -- weight for MoM % change
        0.20::FLOAT  AS w_abs,             -- weight for MoM $ change
        0.10::FLOAT  AS w_share,           -- weight for portfolio share shift
        /* Normalization caps for 0..1 scaling */
        2.00::FLOAT  AS z_cap,             -- cap for |Z| (e.g., 2σ)
        0.25::FLOAT  AS pct_cap,           -- cap for |MoM %| (e.g., 25%)
        100000::FLOAT AS abs_cap,          -- cap for |MoM $| (materiality)
        0.02::FLOAT  AS share_cap,         -- cap for |share delta| (2% of total)
        /* Anomaly trip wires for IS_ANOMALY */
        2.00::FLOAT  AS z_thresh,          -- flag if |Z| >= 2.0
        0.25::FLOAT  AS pct_thresh,        -- with $ threshold
        100000::FLOAT AS abs_thresh        -- with % threshold
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RV_DESCRIPTION,
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS BY MONTH (for share calculations) ========= */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RV_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL,

        t.TOT_GL AS CURR_TOT_GL,
        LAG(t.TOT_GL) OVER (ORDER BY b.EOM) AS PREV_TOT_GL
    FROM base b
    JOIN tot  t ON t.EOM = b.EOM
),

/* ====== 5) ENRICH WITH Z-SCORE & PORTFOLIO SHARE / SHARE DELTA ========== */
enriched AS (
    SELECT
        c.*,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN c.CURR_TOT_GL > 0 THEN c.GL_BALANCE / c.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN c.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN c.CURR_TOT_GL > 0 AND c.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / c.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RV_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE
            WHEN Z_SCORE_12_EXCL IS NULL THEN 0
            ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1)
        END AS z_norm,
        CASE
            WHEN MOM_PCT_CHANGE IS NULL THEN 0
            ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1)
        END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE
            WHEN SHARE_DELTA IS NULL THEN 0
            ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1)
        END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RV_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    /* Rounded/clipped severity for presentation */
    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    /* Rank within each month (highest score = rank 1) */
    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    /* Tiering */
    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;







/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)








/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;