MoM $ Change =
VAR CurrentSystem = tblVariance[CONTRACT_SOURCE_SYSTEM]
VAR CurrentDate   = tblVariance[period_date]
VAR PriorActual   =
    CALCULATE (
        MAX ( tblVariance[actual] ),
        FILTER (
            tblVariance,
            tblVariance[CONTRACT_SOURCE_SYSTEM] = CurrentSystem &&
            tblVariance[period_date] = EOMONTH ( CurrentDate, -1 )
        )
    )
RETURN
IF ( NOT ISBLANK (PriorActual), tblVariance[actual] - PriorActual )




MoM % Change =
VAR CurrentSystem = tblVariance[CONTRACT_SOURCE_SYSTEM]
VAR CurrentDate   = tblVariance[period_date]
VAR PriorActual   =
    CALCULATE (
        MAX ( tblVariance[actual] ),
        FILTER (
            tblVariance,
            tblVariance[CONTRACT_SOURCE_SYSTEM] = CurrentSystem &&
            tblVariance[period_date] = EOMONTH ( CurrentDate, -1 )
        )
    )
RETURN
IF (
    NOT ISBLANK (PriorActual) && PriorActual <> 0,
    (tblVariance[actual] - PriorActual) / PriorActual
)





WITH
measures AS (...),
month_totals AS (...),
kde_month AS (...),
kde_chg AS (...),
pd_cast AS (...),
pd_cast_valid AS (...),

kde_changes_a AS ( ...your working Part 1 block... ),
kde_changes_dates AS ( ...from Step 2... ),
kde_changes_cats  AS ( ...from Step 3... ),

kde_changes AS (
  SELECT * FROM kde_changes_a
  UNION ALL SELECT * FROM kde_changes_dates
  UNION ALL SELECT * FROM kde_changes_cats
),
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
kde_with_denoms AS (
  SELECT
    m.*,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
)
SELECT *
FROM kde_with_denoms
ORDER BY END_OF_MONTH_DATE DESC, KDE
LIMIT 100;







WITH
measures AS (...same as before...),
month_totals AS (...same...),
kde_month AS (...same...),
kde_chg AS (...same...),

kde_changes_cats AS (
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT'               AS KDE, CURR_SSB, 0 AS bool_on, 0 AS bool_off, NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
    WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_cats
GROUP BY KDE
ORDER BY KDE;





, -- Step 2: dates only
kde_changes_dates AS (
  -- MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_dates
GROUP BY KDE
ORDER BY KDE;




WITH
/* ---------------- population: pos balance per acct x system ----- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),

pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
)





WITH
-- reuse your working CTEs verbatim:
measures AS (...same as you ran...),
month_totals AS (...same...),
kde_month AS (...same...),
kde_chg AS (...same...),
pd_cast AS (...same...),
pd_cast_valid AS (...same...),

kde_changes_a AS (
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- PD_GRADE (validated numeric set)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_a
GROUP BY KDE
ORDER BY KDE;





WITH
measures AS (...), month_totals AS (...), kde_month AS (...), kde_chg AS (...),

kde_changes_dates AS (
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )
)
SELECT KDE, COUNT(*) AS change_rows, SUM(CURR_SSB) AS exposure_sum
FROM kde_changes_dates
GROUP BY KDE
ORDER BY KDE;





WITH
/* ---------------------------- config ---------------------------- */
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::FLOAT8 AS weight_trend,
    0.30::FLOAT8 AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::FLOAT8 AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),
/* ------------------------ date range bounds --------------------- */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),
/* ---------------- population: pos balance per acct x system ----- */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
/* -------------------- denominators (per month) ------------------ */
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
/* --------------- snapshot KDEs joined to population ------------- */
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw (no normalization)
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
/* ------------------- prior-month values via LAG ----------------- */
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
/* ---- PD_GRADE parse → validate set (0–14, 98); keep others NULL ---- */
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,
    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
),
/* ------------- UNPIVOT to per-KDE change events (type-aware) ------------- */
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG', kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END,
    NULL::FLOAT8, NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE (valid set only)
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE', kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8
  FROM kde_chg kc
  JOIN pd_cast_valid p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE', kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)),
    NULL::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE (moved days)
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE (moved days)
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE', kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
/* ---------------- Month × KDE rollup (actuals) ----------------- */
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
/* ------------- join denominators; compute rates/shares ---------- */
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
/* -------------------- MoM deltas and %s ------------------------ */
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,
    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),
/* ---- rolling trends (6/12 mo) & same-month seasonality -------- */
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),
/* -------- expected rates/shares + stddevs + expected count/$ ---- */
expected AS (
  SELECT
    b.*,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)
/* --------------------------- final ------------------------------ */
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive surprises + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;





pd_cast AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,

    /* Parse PD_GRADE text → INT only if it is purely digits */
    CASE
      WHEN REGEXP_LIKE(TRIM(PD_GRADE), '^[0-9]+$')
           THEN CAST(TRIM(PD_GRADE) AS INTEGER)
      ELSE NULL
    END AS pd_int_raw,

    CASE
      WHEN REGEXP_LIKE(TRIM(prev_pd), '^[0-9]+$')
           THEN CAST(TRIM(prev_pd) AS INTEGER)
      ELSE NULL
    END AS prev_pd_int_raw
  FROM kde_chg
),
/* Validate allowed set and expose as FLOAT8 for math */
pd_cast_valid AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    ACCOUNT_KEY,
    CASE WHEN pd_int_raw BETWEEN 0 AND 14 OR pd_int_raw = 98
         THEN pd_int_raw::FLOAT8 END AS PD_NUM,
    CASE WHEN prev_pd_int_raw BETWEEN 0 AND 14 OR prev_pd_int_raw = 98
         THEN prev_pd_int_raw::FLOAT8 END AS PREV_PD_NUM
  FROM pd_cast
)



JOIN pd_cast_valid p
  ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
 AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
 AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY




WITH ...measures..., ...month_totals..., ...kde_month..., ...kde_chg...,
pd_cast AS ( /* first CTE above */ ),
pd_cast_valid AS ( /* second CTE above */ )
SELECT
  COUNT(*) AS rows_all,
  SUM(CASE WHEN PD_NUM IS NOT NULL OR PREV_PD_NUM IS NOT NULL THEN 1 ELSE 0 END) AS rows_valid_pd,
  SUM(CASE WHEN PD_NUM IS NULL  AND PREV_PD_NUM IS NULL  THEN 1 ELSE 0 END) AS rows_dropped
FROM pd_cast_valid;





WITH
...same measures, month_totals, kde_month, kde_chg...,
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN PD_GRADE::FLOAT8 ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN prev_pd::FLOAT8 ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
)
SELECT
  COUNT(*) AS rows_pd_cast,
  SUM(CASE WHEN PD_NUM IS NOT NULL OR PREV_PD_NUM IS NOT NULL THEN 1 ELSE 0 END) AS rows_valid_pd
FROM pd_cast;




WITH
measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
month_totals AS (
  SELECT m.END_OF_MONTH_DATE,
         COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
         SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
kde_month AS (
  SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
         m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
         MAX(t.PD_GRADE)      AS PD_GRADE,
         MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
         MAX(t.MATURITY_DATE) AS MATURITY_DATE,
         MAX(t.BOOK_DATE)     AS BOOK_DATE,
         MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
         MAX(t.CRE_FLAG)                AS CRE_FLAG,
         MAX(t.RISK_UNIT)               AS RISK_UNIT,
         MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
         MAX(t.LIFESTAGE)               AS LIFESTAGE,
         MAX(t.NICHE_CD)                AS NICHE_CD,
         MAX(t.RBC_CODE)                AS RBC_CODE,
         MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
         MAX(t.RC_CODE)                 AS RC_CODE,
         MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
)
SELECT
  COUNT(*) AS rows_kde_chg,
  SUM(CASE WHEN prev_eom IS NOT NULL THEN 1 ELSE 0 END) AS rows_with_prev,
  MIN(END_OF_MONTH_DATE) AS min_eom,
  MAX(END_OF_MONTH_DATE) AS max_eom
FROM kde_chg;





WITH
measures AS (...same as before...),
month_totals AS (...same as above...),
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE
    -- (you can add more KDE fields here, but start small to debug)
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
)
SELECT * FROM kde_month LIMIT 20;





WITH measures AS (
  SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
         SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
)
SELECT COUNT(*) AS cnt, MIN(END_OF_MONTH_DATE) AS min_eom, MAX(END_OF_MONTH_DATE) AS max_eom
FROM measures;





WITH
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),
-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),
-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),
-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),
-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),
-- 4b) PD_GRADE numeric validation (0–14, 98)
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN PD_GRADE::FLOAT8 ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN prev_pd::FLOAT8 ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),
-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    NULL::FLOAT8 AS numeric_mag, NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(kc.DAYS_PAST_DUE::FLOAT8,0) - COALESCE(kc.prev_dpd::FLOAT8,0)) AS numeric_mag,
    NULL::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    NULL::FLOAT8 AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::FLOAT8 AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::FLOAT8, NULL::FLOAT8 FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),
-- 6) Month × KDE rollup
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                        AS change_count,
    SUM(CURR_SSB)                   AS exposure_dollars,
    SUM(bool_on)                    AS flag_on_count,
    SUM(bool_off)                   AS flag_off_count,
    SUM(numeric_mag)                AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
    SUM(days_mag)                   AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),
-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::FLOAT8 END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::FLOAT8 END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),
-- 8) MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,
    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::FLOAT8 OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),
-- 9) Rolling trends (6 & 12 mo) & same-month seasonality
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),
-- 10) Expected rates/shares + stddevs; expected count/$
expected AS (
  SELECT
    b.*,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)
-- Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count, exposure_dollars,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share,
  flag_on_count, flag_off_count,
  sum_numeric_magnitude, avg_numeric_magnitude,
  sum_days_moved, avg_days_moved,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  prev_flag_on_count, mom_flag_on_delta,
  prev_flag_off_count, mom_flag_off_delta,
  prev_sum_numeric_magnitude, mom_sum_numeric_mag_delta,
  prev_sum_days_moved, mom_sum_days_moved_delta,
  expected_count, expected_exposure, expected_rate, expected_share,
  (change_count - expected_count)           AS resid_count,
  (exposure_dollars - expected_exposure)    AS resid_exposure,
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate - expected_rate) / std_rate_12 END  AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG
FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







CREATE TABLE KDE_TMP_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

SELECT COUNT(*) FROM KDE_TMP_MEASURES;






CREATE VIEW KDE_V_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  -- force floating type without nested CAST on the aggregate
  (SUM(t.SOURCE_SYSTEM_BALANCE) * 1.0)::FLOAT8 AS SOURCE_SYSTEM_BALANCE
FROM CIDPR..V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;









CREATE OR REPLACE VIEW CIDPR..KDE_V_MEASURES AS
SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
       CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

CREATE OR REPLACE VIEW CIDPR..KDE_V_MONTH_TOTALS AS
SELECT END_OF_MONTH_DATE,
       COUNT(DISTINCT (CONTRACT_SOURCE_SYSTEM || '|' || ACCOUNT_KEY)) AS month_total_accounts,
       SUM(SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_V_MEASURES
GROUP BY 1;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_MONTH AS
SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
       m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
       MAX(t.PD_GRADE) PD_GRADE, MAX(t.DAYS_PAST_DUE) DAYS_PAST_DUE,
       MAX(t.MATURITY_DATE) MATURITY_DATE, MAX(t.BOOK_DATE) BOOK_DATE,
       MAX(t.NON_ACCRUAL_FLAG) NON_ACCRUAL_FLAG, MAX(t.CRE_FLAG) CRE_FLAG,
       MAX(t.RISK_UNIT) RISK_UNIT, MAX(t.FDIC_CALL_CODE) FDIC_CALL_CODE,
       MAX(t.LIFESTAGE) LIFESTAGE, MAX(t.NICHE_CD) NICHE_CD,
       MAX(t.RBC_CODE) RBC_CODE, MAX(t.REVOLVING_NON_REVOLVING) REVOLVING_NON_REVOLVING,
       MAX(t.RC_CODE) RC_CODE, MAX(t.RATE_TYPE) RATE_TYPE
FROM CIDPR..KDE_V_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_CHG AS
SELECT k.*,
       LAG(k.END_OF_MONTH_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
       LAG(k.PD_GRADE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
       LAG(k.DAYS_PAST_DUE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
       LAG(k.MATURITY_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
       LAG(k.BOOK_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
       LAG(k.NON_ACCRUAL_FLAG) OVER (...) AS prev_na,
       LAG(k.CRE_FLAG)        OVER (...) AS prev_cre,
       LAG(k.RISK_UNIT)       OVER (...) AS prev_risk_unit,
       LAG(k.FDIC_CALL_CODE)  OVER (...) AS prev_fcc,
       LAG(k.LIFESTAGE)       OVER (...) AS prev_lifestage,
       LAG(k.NICHE_CD)        OVER (...) AS prev_niche,
       LAG(k.RBC_CODE)        OVER (...) AS prev_rbc,
       LAG(k.REVOLVING_NON_REVOLVING) OVER (...) AS prev_revolver,
       LAG(k.RC_CODE)         OVER (...) AS prev_rc,
       LAG(k.RATE_TYPE)       OVER (...) AS prev_rate_type
FROM CIDPR..KDE_V_KDE_MONTH k;





CREATE OR REPLACE VIEW CIDPR..KDE_V_MEASURES AS
SELECT t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM, t.ACCOUNT_KEY,
       CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

CREATE OR REPLACE VIEW CIDPR..KDE_V_MONTH_TOTALS AS
SELECT END_OF_MONTH_DATE,
       COUNT(DISTINCT (CONTRACT_SOURCE_SYSTEM || '|' || ACCOUNT_KEY)) AS month_total_accounts,
       SUM(SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_V_MEASURES
GROUP BY 1;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_MONTH AS
SELECT m.END_OF_MONTH_DATE, m.CONTRACT_SOURCE_SYSTEM, m.ACCOUNT_KEY,
       m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
       MAX(t.PD_GRADE) PD_GRADE, MAX(t.DAYS_PAST_DUE) DAYS_PAST_DUE,
       MAX(t.MATURITY_DATE) MATURITY_DATE, MAX(t.BOOK_DATE) BOOK_DATE,
       MAX(t.NON_ACCRUAL_FLAG) NON_ACCRUAL_FLAG, MAX(t.CRE_FLAG) CRE_FLAG,
       MAX(t.RISK_UNIT) RISK_UNIT, MAX(t.FDIC_CALL_CODE) FDIC_CALL_CODE,
       MAX(t.LIFESTAGE) LIFESTAGE, MAX(t.NICHE_CD) NICHE_CD,
       MAX(t.RBC_CODE) RBC_CODE, MAX(t.REVOLVING_NON_REVOLVING) REVOLVING_NON_REVOLVING,
       MAX(t.RC_CODE) RC_CODE, MAX(t.RATE_TYPE) RATE_TYPE
FROM CIDPR..KDE_V_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

CREATE OR REPLACE VIEW CIDPR..KDE_V_KDE_CHG AS
SELECT k.*,
       LAG(k.END_OF_MONTH_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
       LAG(k.PD_GRADE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
       LAG(k.DAYS_PAST_DUE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
       LAG(k.MATURITY_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
       LAG(k.BOOK_DATE) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,
       LAG(k.NON_ACCRUAL_FLAG) OVER (...) AS prev_na,
       LAG(k.CRE_FLAG)        OVER (...) AS prev_cre,
       LAG(k.RISK_UNIT)       OVER (...) AS prev_risk_unit,
       LAG(k.FDIC_CALL_CODE)  OVER (...) AS prev_fcc,
       LAG(k.LIFESTAGE)       OVER (...) AS prev_lifestage,
       LAG(k.NICHE_CD)        OVER (...) AS prev_niche,
       LAG(k.RBC_CODE)        OVER (...) AS prev_rbc,
       LAG(k.REVOLVING_NON_REVOLVING) OVER (...) AS prev_revolver,
       LAG(k.RC_CODE)         OVER (...) AS prev_rc,
       LAG(k.RATE_TYPE)       OVER (...) AS prev_rate_type
FROM CIDPR..KDE_V_KDE_MONTH k;






-- ================================================================
-- KDE Monthly Monitor (Netezza, single statement)
-- ================================================================

WITH
params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- tune thresholds/weights here
  SELECT
    1  AS use_trend6,                 -- 1 = 6-mo trend, 0 = 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 4b) PD_GRADE numeric validation (0–14, 98); ignore others in magnitude
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE, 'CRE_FLAG' AS KDE, kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE, 'DAYS_PAST_DUE' AS KDE, kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'MATURITY_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE, 'BOOK_DATE' AS KDE, kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality
baselines AS (
  SELECT
    x.*,

    -- exclude current row
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; expected count/$
expected AS (
  SELECT
    b.*,

    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







-- Clean up prior runs (safe if first time)
DROP TABLE IF EXISTS CIDPR..KDE_TMP_MEASURES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_MONTH_TOTALS;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_MONTH;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_CHG;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_PD_CAST;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_CHANGES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_KDE_MONTHLY;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_WITH_DENOMS;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_WITH_MOM;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_BASELINES;
DROP TABLE IF EXISTS CIDPR..KDE_TMP_EXPECTED;

-- A) measures
CREATE TABLE CIDPR..KDE_TMP_MEASURES AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

-- B) month_totals
CREATE TABLE CIDPR..KDE_TMP_MONTH_TOTALS AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR..KDE_TMP_MEASURES m
GROUP BY 1;

-- C) kde_month
CREATE TABLE CIDPR..KDE_TMP_KDE_MONTH AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
  MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM CIDPR..KDE_TMP_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

-- D) kde_chg (add LAGs)
CREATE TABLE CIDPR..KDE_TMP_KDE_CHG AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM CIDPR..KDE_TMP_KDE_MONTH k;

-- E) pd_cast (PD_GRADE valid 0–14, 98)
CREATE TABLE CIDPR..KDE_TMP_PD_CAST AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98
       THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98
       THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM CIDPR..KDE_TMP_KDE_CHG;

-- F) kde_changes (UNION ALL)
CREATE TABLE CIDPR..KDE_TMP_KDE_CHANGES AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  JOIN CIDPR..KDE_TMP_PD_CAST p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR..KDE_TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL (count-only)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR..KDE_TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);

-- G) kde_monthly
CREATE TABLE CIDPR..KDE_TMP_KDE_MONTHLY AS
SELECT
  END_OF_MONTH_DATE,
  KDE,
  COUNT(*)                                      AS change_count,
  SUM(CURR_SSB)                                 AS exposure_dollars,
  SUM(bool_on)                                  AS flag_on_count,
  SUM(bool_off)                                 AS flag_off_count,
  SUM(numeric_mag)                               AS sum_numeric_magnitude,
  AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
  SUM(days_mag)                                  AS sum_days_moved,
  AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
FROM CIDPR..KDE_TMP_KDE_CHANGES
GROUP BY 1,2;

-- H) with_denoms
CREATE TABLE CIDPR..KDE_TMP_WITH_DENOMS AS
SELECT
  m.END_OF_MONTH_DATE,
  m.KDE,
  m.change_count,
  m.exposure_dollars,
  t.month_total_accounts,
  t.month_total_ssb,
  CASE WHEN t.month_total_accounts > 0
       THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
  CASE WHEN t.month_total_ssb > 0
       THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
  m.flag_on_count, m.flag_off_count,
  m.sum_numeric_magnitude, m.avg_numeric_magnitude,
  m.sum_days_moved,        m.avg_days_moved,
  EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
FROM CIDPR..KDE_TMP_KDE_MONTHLY m
JOIN CIDPR..KDE_TMP_MONTH_TOTALS t USING (END_OF_MONTH_DATE);

-- I) with_mom
CREATE TABLE CIDPR..KDE_TMP_WITH_MOM AS
SELECT
  w.*,
  LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
  LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
  LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
  LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
  LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
  LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

  (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
  (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

  CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
       THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

  CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
       THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
FROM CIDPR..KDE_TMP_WITH_DENOMS w;

-- J) baselines
CREATE TABLE CIDPR..KDE_TMP_BASELINES AS
SELECT
  x.*,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
  AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
  AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
FROM CIDPR..KDE_TMP_WITH_MOM x;

-- K) expected
CREATE TABLE CIDPR..KDE_TMP_EXPECTED AS
SELECT
  b.*,
  /* choose 6-mo trend (1) vs 12-mo (0) */
  CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
  CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

  0.70::DOUBLE PRECISION AS weight_trend,
  0.30::DOUBLE PRECISION AS weight_seasonal,

  COALESCE(0.70 * (CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END) + 0.30 * same_month_rate,
           (CASE WHEN 1=1 THEN trend_rate_6  ELSE trend_rate_12  END),
           same_month_rate) AS expected_rate,

  COALESCE(0.70 * (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30 * same_month_share,
           (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
           same_month_share) AS expected_share,

  STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
  STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

  CASE WHEN month_total_accounts IS NOT NULL THEN
    COALESCE(0.70*(CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) + 0.30*same_month_rate,
             (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
             same_month_rate) * month_total_accounts END AS expected_count,

  CASE WHEN month_total_ssb IS NOT NULL THEN
    COALESCE(0.70*(CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30*same_month_share,
             (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
             same_month_share) * month_total_ssb END AS expected_exposure
FROM CIDPR..KDE_TMP_BASELINES b;

-- L) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count, exposure_dollars,
  month_total_accounts, month_total_ssb,
  change_rate, exposure_share,
  flag_on_count, flag_off_count,
  sum_numeric_magnitude, avg_numeric_magnitude,
  sum_days_moved, avg_days_moved,
  prev_change_count, mom_change_count_delta, mom_change_count_pct,
  prev_exposure_dollars, mom_exposure_dollars_delta, mom_exposure_dollars_pct,
  prev_flag_on_count, mom_flag_on_delta,
  prev_flag_off_count, mom_flag_off_delta,
  prev_sum_numeric_magnitude, mom_sum_numeric_mag_delta,
  prev_sum_days_moved, mom_sum_days_moved_delta,
  expected_count, expected_exposure, expected_rate, expected_share,
  (change_count - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= 2.5
       OR ABS(exposure_dollars - expected_exposure) >= 50000000
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= 0.15)
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= 50000000
       OR ABS(COALESCE(mom_change_count_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG
FROM CIDPR..KDE_TMP_EXPECTED
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;




-- ======================================================================
-- CONFIG
-- ======================================================================
-- Change this if your writable scratch schema is different:
SET SCHEMA 'CIDPR.DATAHUB';

-- Optional: clean up any leftovers from prior runs
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_MEASURES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_MONTH_TOTALS;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_MONTH;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_CHG;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_PD_CAST;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_CHANGES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_KDE_MONTHLY;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_WITH_DENOMS;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_WITH_MOM;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_BASELINES;
DROP TABLE IF EXISTS CIDPR.DATAHUB.TMP_EXPECTED;

-- ======================================================================
-- A) measures  (positive-balance population)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_MEASURES
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;

SELECT COUNT(*) AS CNT_MEASURES FROM CIDPR.DATAHUB.TMP_MEASURES;

-- ======================================================================
-- B) month_totals (denominators)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_MONTH_TOTALS
DISTRIBUTE ON (END_OF_MONTH_DATE) AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM CIDPR.DATAHUB.TMP_MEASURES m
GROUP BY 1;

SELECT COUNT(*) AS CNT_MONTH_TOTALS FROM CIDPR.DATAHUB.TMP_MONTH_TOTALS;

-- ======================================================================
-- C) kde_month (snapshot with KDEs; RC_CODE left raw)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_MONTH
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
  MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM CIDPR.DATAHUB.TMP_MEASURES m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;

SELECT COUNT(*) AS CNT_KDE_MONTH FROM CIDPR.DATAHUB.TMP_KDE_MONTH;

-- ======================================================================
-- D) kde_chg (add prior month snapshots via LAG)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_CHG
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM CIDPR.DATAHUB.TMP_KDE_MONTH k;

SELECT COUNT(*) AS CNT_KDE_CHG FROM CIDPR.DATAHUB.TMP_KDE_CHG;

-- ======================================================================
-- E) pd_cast (PD_GRADE numeric validation: 0–14, 98)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_PD_CAST
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY) AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98
       THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98
       THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM CIDPR.DATAHUB.TMP_KDE_CHG;

SELECT COUNT(*) AS CNT_PD_CAST FROM CIDPR.DATAHUB.TMP_PD_CAST;

-- ======================================================================
-- F) kde_changes  (the UNION ALL — most common parse hotspot)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_CHANGES
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE (valid 0–14, 98 only)
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  JOIN CIDPR.DATAHUB.TMP_PD_CAST p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM CIDPR.DATAHUB.TMP_KDE_CHG kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- CATEGORICAL: (count-only; exposure via CURR_SSB)
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM CIDPR.DATAHUB.TMP_KDE_CHG
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);

SELECT COUNT(*) AS CNT_KDE_CHANGES FROM CIDPR.DATAHUB.TMP_KDE_CHANGES;

-- ======================================================================
-- G) kde_monthly (rollup)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_KDE_MONTHLY
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  END_OF_MONTH_DATE,
  KDE,
  COUNT(*)                                      AS change_count,
  SUM(CURR_SSB)                                 AS exposure_dollars,
  SUM(bool_on)                                  AS flag_on_count,
  SUM(bool_off)                                 AS flag_off_count,
  SUM(numeric_mag)                               AS sum_numeric_magnitude,
  AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,
  SUM(days_mag)                                  AS sum_days_moved,
  AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
FROM CIDPR.DATAHUB.TMP_KDE_CHANGES
GROUP BY 1,2;

SELECT COUNT(*) AS CNT_KDE_MONTHLY FROM CIDPR.DATAHUB.TMP_KDE_MONTHLY;

-- ======================================================================
-- H) with_denoms (join denominators; compute rates/shares)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_WITH_DENOMS
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  m.END_OF_MONTH_DATE,
  m.KDE,
  m.change_count,
  m.exposure_dollars,
  t.month_total_accounts,
  t.month_total_ssb,
  CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
  CASE WHEN t.month_total_ssb > 0 THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
  m.flag_on_count, m.flag_off_count,
  m.sum_numeric_magnitude, m.avg_numeric_magnitude,
  m.sum_days_moved,        m.avg_days_moved,
  EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
FROM CIDPR.DATAHUB.TMP_KDE_MONTHLY m
JOIN CIDPR.DATAHUB.TMP_MONTH_TOTALS t USING (END_OF_MONTH_DATE);

SELECT COUNT(*) AS CNT_WITH_DENOMS FROM CIDPR.DATAHUB.TMP_WITH_DENOMS;

-- ======================================================================
-- I) with_mom (MoM deltas & %)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_WITH_MOM
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  w.*,
  LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
  LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,
  LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
  LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,
  LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
  LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

  (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
  (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

  CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
       THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

  CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
       THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
            / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
FROM CIDPR.DATAHUB.TMP_WITH_DENOMS w;

SELECT COUNT(*) AS CNT_WITH_MOM FROM CIDPR.DATAHUB.TMP_WITH_MOM;

-- ======================================================================
-- J) baselines (6/12-mo trends + same-month seasonality)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_BASELINES
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  x.*,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,
  AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
  AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,
  AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
  AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
FROM CIDPR.DATAHUB.TMP_WITH_MOM x;

SELECT COUNT(*) AS CNT_BASELINES FROM CIDPR.DATAHUB.TMP_BASELINES;

-- ======================================================================
-- K) expected (choose trend window; build expected + stddevs + expected count/$)
-- ======================================================================
CREATE TABLE CIDPR.DATAHUB.TMP_EXPECTED
DISTRIBUTE ON (END_OF_MONTH_DATE, KDE) AS
SELECT
  b.*,

  -- choose 6-mo trend (more reactive) or 12-mo (smoother)
  CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END AS trend_rate_sel,
  CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

  -- weights (tune here if you want without editing above tables)
  0.70::DOUBLE PRECISION AS weight_trend,
  0.30::DOUBLE PRECISION AS weight_seasonal,

  COALESCE(0.70* (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) +
           0.30*  same_month_rate,
           (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
           same_month_rate) AS expected_rate,

  COALESCE(0.70* (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) +
           0.30*  same_month_share,
           (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
           same_month_share) AS expected_share,

  STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
  STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

  CASE WHEN month_total_accounts IS NOT NULL THEN
    COALESCE(0.70* (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END) + 0.30* same_month_rate,
             (CASE WHEN 1=1 THEN trend_rate_6 ELSE trend_rate_12 END),
             same_month_rate) * month_total_accounts END AS expected_count,

  CASE WHEN month_total_ssb IS NOT NULL THEN
    COALESCE(0.70* (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END) + 0.30* same_month_share,
             (CASE WHEN 1=1 THEN trend_share_6 ELSE trend_share_12 END),
             same_month_share) * month_total_ssb END AS expected_exposure
FROM CIDPR.DATAHUB.TMP_BASELINES b;

SELECT COUNT(*) AS CNT_EXPECTED FROM CIDPR.DATAHUB.TMP_EXPECTED;

-- ======================================================================
-- L) Final SELECT (you can materialize if desired)
-- ======================================================================
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (tune thresholds here if you like)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= 2.5
       OR ABS(exposure_dollars - expected_exposure) >= 50000000
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= 0.15)
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= 50000000
       OR ABS(COALESCE(mom_change_count_pct,0)) >= 0.25
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM CIDPR.DATAHUB.TMP_EXPECTED
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;




-- E. pd_cast
DROP TABLE IF EXISTS tmp_pd_cast;
CREATE TEMP TABLE tmp_pd_cast AS
SELECT
  END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
  CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
FROM tmp_kde_chg;
SELECT COUNT(*) AS cnt_pd_cast FROM tmp_pd_cast;

-- F. kde_changes (union)
DROP TABLE IF EXISTS tmp_kde_changes;
CREATE TEMP TABLE tmp_kde_changes AS
(
  -- BOOLEAN: NON_ACCRUAL_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- BOOLEAN: CRE_FLAG (Y/N)
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  UNION ALL
  -- NUMERIC: PD_GRADE
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on, 0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  JOIN tmp_pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- NUMERIC: DPD
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  UNION ALL
  -- DATE: MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.MATURITY_DATE) - DATE(kc.prev_mty)))::DOUBLE PRECISION AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- DATE: BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0, 0,
    CAST(NULL AS DOUBLE PRECISION),
    ABS((DATE(kc.BOOK_DATE) - DATE(kc.prev_book)))::DOUBLE PRECISION AS days_mag
  FROM tmp_kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM tmp_kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
);
SELECT COUNT(*) AS cnt_kde_changes FROM tmp_kde_changes;







-- A. measures
DROP TABLE IF EXISTS tmp_measures;
CREATE TEMP TABLE tmp_measures AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  t.ACCOUNT_KEY,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY 1,2,3
HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0;
SELECT COUNT(*) AS cnt_measures FROM tmp_measures;

-- B. month_totals
DROP TABLE IF EXISTS tmp_month_totals;
CREATE TEMP TABLE tmp_month_totals AS
SELECT
  m.END_OF_MONTH_DATE,
  COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
  SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
FROM tmp_measures m
GROUP BY 1;
SELECT COUNT(*) AS cnt_month_totals FROM tmp_month_totals;

-- C. kde_month
DROP TABLE IF EXISTS tmp_kde_month;
CREATE TEMP TABLE tmp_kde_month AS
SELECT
  m.END_OF_MONTH_DATE,
  m.CONTRACT_SOURCE_SYSTEM,
  m.ACCOUNT_KEY,
  m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

  MAX(t.PD_GRADE)      AS PD_GRADE,
  MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
  MAX(t.MATURITY_DATE) AS MATURITY_DATE,
  MAX(t.BOOK_DATE)     AS BOOK_DATE,

  MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
  MAX(t.CRE_FLAG)                AS CRE_FLAG,

  MAX(t.RISK_UNIT)               AS RISK_UNIT,
  MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
  MAX(t.LIFESTAGE)               AS LIFESTAGE,
  MAX(t.NICHE_CD)                AS NICHE_CD,
  MAX(t.RBC_CODE)                AS RBC_CODE,
  MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
  MAX(t.RC_CODE)                 AS RC_CODE,
  MAX(t.RATE_TYPE)               AS RATE_TYPE
FROM tmp_measures m
JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
  ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
 AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
 AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
GROUP BY 1,2,3,4;
SELECT COUNT(*) AS cnt_kde_month FROM tmp_kde_month;

-- D. kde_chg
DROP TABLE IF EXISTS tmp_kde_chg;
CREATE TEMP TABLE tmp_kde_chg AS
SELECT
  k.*,
  LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

  LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
  LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
  LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
  LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

  LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
  LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

  LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
  LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
  LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
  LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
  LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
  LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
  LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
  LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
FROM tmp_kde_month k;
SELECT COUNT(*) AS cnt_kde_chg FROM tmp_kde_chg;





-- ======================================================================
-- KDE monthly (type-aware) + MoM deltas + Expected vs Actual (SQL-only)
-- Netezza-friendly: DOUBLE PRECISION casts, fixed window frames, RC_CODE raw
-- Assumptions:
--   • *_FLAG fields are Y/N
--   • PD_GRADE is numeric; valid values are 0–14, 98
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- <<< tune these centrally
  SELECT
    1  AS use_trend6,                 -- 1 = use 6-mo trend, 0 = use 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,   -- Y/N
    MAX(t.CRE_FLAG)                AS CRE_FLAG,           -- Y/N

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,            -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 4b) PD_GRADE numeric validation (0–14, 98); ignore others in magnitude
pd_cast AS (
  SELECT
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
    CASE WHEN PD_GRADE BETWEEN 0 AND 14 OR PD_GRADE = 98 THEN CAST(PD_GRADE AS DOUBLE PRECISION) ELSE NULL END AS PD_NUM,
    CASE WHEN prev_pd BETWEEN 0 AND 14 OR prev_pd = 98 THEN CAST(prev_pd AS DOUBLE PRECISION) ELSE NULL END AS PREV_PD_NUM
  FROM kde_chg
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (

  -- --------- BOOLEAN KDEs (Y/N) ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'N' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_na)) = 'Y' AND UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.NON_ACCRUAL_FLAG)) <> UPPER(TRIM(kc.prev_na)) OR ((kc.NON_ACCRUAL_FLAG IS NULL) <> (kc.prev_na IS NULL)))

  UNION ALL
  -- CRE_FLAG
  SELECT
    kc.END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    kc.CURR_SSB,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'N' AND UPPER(TRIM(kc.CRE_FLAG)) = 'Y' THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN UPPER(TRIM(kc.prev_cre)) = 'Y' AND UPPER(TRIM(kc.CRE_FLAG)) = 'N' THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND (UPPER(TRIM(kc.CRE_FLAG)) <> UPPER(TRIM(kc.prev_cre)) OR ((kc.CRE_FLAG IS NULL) <> (kc.prev_cre IS NULL)))

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (valid 0–14, 98 only)
  SELECT
    kc.END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(p.PD_NUM - p.PREV_PD_NUM) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  JOIN pd_cast p
    ON p.END_OF_MONTH_DATE = kc.END_OF_MONTH_DATE
   AND p.CONTRACT_SOURCE_SYSTEM = kc.CONTRACT_SOURCE_SYSTEM
   AND p.ACCOUNT_KEY = kc.ACCOUNT_KEY
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.PD_GRADE <> kc.prev_pd) OR ((kc.PD_GRADE IS NULL) <> (kc.prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    kc.END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(kc.DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(kc.prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.DAYS_PAST_DUE <> kc.prev_dpd) OR ((kc.DAYS_PAST_DUE IS NULL) <> (kc.prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(kc.MATURITY_DATE AS DATE) - CAST(kc.prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.MATURITY_DATE <> kc.prev_mty) OR ((kc.MATURITY_DATE IS NULL) <> (kc.prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    kc.END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    kc.CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(kc.BOOK_DATE AS DATE) - CAST(kc.prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg kc
  WHERE kc.prev_eom IS NOT NULL
    AND ( (kc.BOOK_DATE <> kc.prev_book) OR ((kc.BOOK_DATE IS NULL) <> (kc.prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs (count-only; exposure via CURR_SSB) ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup (type-aware metrics)
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Add MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality (exclude current)
baselines AS (
  SELECT
    x.*,

    -- 6-mo and 12-mo trends (exclude current row)
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    -- same-month seasonality (up to 10y; exclude current)
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; convert to expected count/$
expected AS (
  SELECT
    b.*,

    -- pick trend window
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    -- expected rates/shares (weighted blend; fallback if one part missing)
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    -- rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- convert to expected count and expected $
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output: actuals, MoM, expected, residuals, z-like, severity, flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive standardized residuals + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (stat surprise OR big $ delta OR big MoM)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250  -- tune if needed
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;





-- ======================================================================
-- KDE monthly (type-aware) + MoM deltas + Expected vs Actual (SQL-only)
-- Netezza-friendly: DOUBLE PRECISION casts, fixed window frames, RC_CODE raw
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,                -- history window (months)
    'Total Loans' AS target_lvl4
),
params_flags AS (                     -- <<< tune these in one place
  SELECT
    1  AS use_trend6,                 -- 1 = use 6-mo trend, 0 = use 12-mo trend
    0.70::DOUBLE PRECISION AS weight_trend,
    0.30::DOUBLE PRECISION AS weight_seasonal,
    2.5  AS z_threshold,              -- z-like threshold
    0.25 AS mom_pct_threshold,        -- 25%
    50000000::DOUBLE PRECISION AS abs_dollar_threshold,   -- $50MM
    0.15 AS rel_vs_expected_threshold -- 15%
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population by month × system × account
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Monthly snapshots with KDEs (RC_CODE kept raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 5) UNPIVOT by KDE with type-aware payload
kde_changes AS (

  -- --------- BOOLEAN KDEs ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN (UPPER(TRIM(prev_na)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_na)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> prev_na) OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)) )

  UNION ALL
  -- CRE_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN (UPPER(TRIM(prev_cre)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (CRE_FLAG <> prev_cre) OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)) )

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (numeric-ish)
  SELECT
    END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(CAST(NULLIF(PD_GRADE,'') AS DOUBLE PRECISION) - CAST(NULLIF(prev_pd,'') AS DOUBLE PRECISION)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (PD_GRADE <> prev_pd) OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT
    END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (DAYS_PAST_DUE <> prev_dpd) OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE
  SELECT
    END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(MATURITY_DATE AS DATE) - CAST(prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (MATURITY_DATE <> prev_mty) OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE
  SELECT
    END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    CURR_SSB,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(BOOK_DATE AS DATE) - CAST(prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (BOOK_DATE <> prev_book) OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs (count-only; exposure via CURR_SSB) ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 0,0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup (type-aware metrics)
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  GROUP BY 1,2
),

-- 7) Add denominators and base rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION END AS exposure_share,
    m.flag_on_count, m.flag_off_count,
    m.sum_numeric_magnitude, m.avg_numeric_magnitude,
    m.sum_days_moved,        m.avg_days_moved,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Add MoM deltas & %
with_mom AS (
  SELECT
    w.*,
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
),

-- 9) Rolling trends (6 & 12 mo) & same-month seasonality (exclude current)
baselines AS (
  SELECT
    x.*,

    -- 6-mo and 12-mo trends (exclude current row)
    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_rate_6,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN  6 PRECEDING AND 1 PRECEDING) AS trend_share_6,

    AVG(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate_12,
    AVG(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share_12,

    -- same-month seasonality (up to 10y; exclude current)
    AVG(change_rate)    OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share) OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM with_mom x
),

-- 10) Expected rates/shares (choose 6 or 12) + rolling stddevs; convert to expected count/$
expected AS (
  SELECT
    b.*,

    -- pick trend window
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END AS trend_rate_sel,
    CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END AS trend_share_sel,

    -- expected rates/shares (weighted blend; fallback if one part missing)
    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
      same_month_rate
    ) AS expected_rate,

    COALESCE(
      (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
      (SELECT weight_seasonal FROM params_flags) *  same_month_share,
      (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
      same_month_share
    ) AS expected_share,

    -- rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- convert to expected count and expected $
    CASE WHEN month_total_accounts IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_rate,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_rate_6  ELSE trend_rate_12  END),
        same_month_rate
      ) * month_total_accounts END AS expected_count,

    CASE WHEN month_total_ssb IS NOT NULL THEN
      COALESCE(
        (SELECT weight_trend FROM params_flags)    * (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END) +
        (SELECT weight_seasonal FROM params_flags) *  same_month_share,
        (CASE WHEN (SELECT use_trend6 FROM params_flags)=1 THEN trend_share_6 ELSE trend_share_12 END),
        same_month_share
      ) * month_total_ssb END AS expected_exposure
  FROM baselines b
)

-- 11) Final output: actuals, MoM, expected, residuals, z-like, severity, flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware actuals
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM actuals
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,
  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,
  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta,

  -- Expected (forecast-like)
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- Severity score (positive standardized residuals + MoM intensity + $ materiality)
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                                THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 AND expected_rate  IS NOT NULL
                                  THEN (change_rate - expected_rate) / std_rate_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_dollars_pct), 0.0)
    + (ABS(exposure_dollars - expected_exposure) / NULLIF(month_total_ssb,0)) * 5.0
  ) AS severity_score,

  -- Combined anomaly flag (stat surprise OR big $ delta OR big MoM)
  CASE WHEN
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share)/std_share_12 END) >= (SELECT z_threshold FROM params_flags)
       OR ABS(exposure_dollars - expected_exposure) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure)/NULLIF(expected_exposure,0)) >= (SELECT rel_vs_expected_threshold FROM params_flags))
       OR ABS(COALESCE(mom_exposure_dollars_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_exposure_dollars_delta,0)) >= (SELECT abs_dollar_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_pct,0)) >= (SELECT mom_pct_threshold FROM params_flags)
       OR ABS(COALESCE(mom_change_count_delta,0)) >= 250  -- tune if needed
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG

FROM expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;






-- ======================================================================
-- KDE monthly summary by type + MoM deltas (Netezza-friendly)
--   • Boolean: flag_on_count / flag_off_count
--   • Numeric: sum/avg of absolute magnitude moved
--   • Date:    sum/avg of absolute days moved
--   • Categorical: counted as changes (with $ exposure)
--   • MoM deltas & % for change_count and exposure_dollars (+ type metrics)
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,         -- history window (months)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population per month/account/system
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) One row per month×acct×system with KDEs (RC_CODE left raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,

    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,

    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book,

    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,

    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type
  FROM kde_month k
),

-- 5) UNPIVOT changed rows with type-specific payload
--    Common columns:
--      END_OF_MONTH_DATE, KDE, CURR_SSB,
--      bool_on, bool_off, numeric_mag, days_mag, change_flag
kde_changes AS (

  -- --------- BOOLEAN KDEs ---------
  -- NON_ACCRUAL_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'NON_ACCRUAL_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN
           ( (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE'))::INTEGER
           <> (UPPER(TRIM(prev_na))         IN ('Y','1','TRUE'))::INTEGER )
         THEN 1 ELSE 0 END AS change_flag,
    -- direction
    CASE WHEN (UPPER(TRIM(prev_na)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_na)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(NON_ACCRUAL_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> prev_na) OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)) )

  UNION ALL
  -- CRE_FLAG
  SELECT
    END_OF_MONTH_DATE,
    'CRE_FLAG' AS KDE,
    CURR_SSB,
    CASE WHEN
           ( (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE'))::INTEGER
           <> (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE'))::INTEGER )
         THEN 1 ELSE 0 END AS change_flag,
    CASE WHEN (UPPER(TRIM(prev_cre)) NOT IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_on,
    CASE WHEN (UPPER(TRIM(prev_cre)) IN ('Y','1','TRUE')) AND (UPPER(TRIM(CRE_FLAG)) NOT IN ('Y','1','TRUE')) THEN 1 ELSE 0 END AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (CRE_FLAG <> prev_cre) OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)) )

  -- --------- NUMERIC KDEs ---------
  UNION ALL
  -- PD_GRADE (numeric-ish; map if needed)
  SELECT
    END_OF_MONTH_DATE,
    'PD_GRADE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    ABS(CAST(NULLIF(PD_GRADE,'') AS DOUBLE PRECISION) - CAST(NULLIF(prev_pd,'') AS DOUBLE PRECISION)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (PD_GRADE <> prev_pd) OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT
    END_OF_MONTH_DATE,
    'DAYS_PAST_DUE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    ABS(COALESCE(CAST(DAYS_PAST_DUE AS DOUBLE PRECISION),0) - COALESCE(CAST(prev_dpd AS DOUBLE PRECISION),0)) AS numeric_mag,
    CAST(NULL AS DOUBLE PRECISION) AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (DAYS_PAST_DUE <> prev_dpd) OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)) )

  -- --------- DATE KDEs ---------
  UNION ALL
  -- MATURITY_DATE (days moved, absolute)
  SELECT
    END_OF_MONTH_DATE,
    'MATURITY_DATE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(MATURITY_DATE AS DATE) - CAST(prev_mty AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (MATURITY_DATE <> prev_mty) OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)) )

  UNION ALL
  -- BOOK_DATE (days moved, absolute)
  SELECT
    END_OF_MONTH_DATE,
    'BOOK_DATE' AS KDE,
    CURR_SSB,
    1 AS change_flag,
    0 AS bool_on,
    0 AS bool_off,
    CAST(NULL AS DOUBLE PRECISION) AS numeric_mag,
    ABS((CAST(BOOK_DATE AS DATE) - CAST(prev_book AS DATE)))::DOUBLE PRECISION AS days_mag
  FROM kde_chg
  WHERE prev_eom IS NOT NULL
    AND ( (BOOK_DATE <> prev_book) OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)) )

  -- --------- CATEGORICAL KDEs ---------
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE',          CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD',                CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE',                CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE',                 CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE',               CURR_SSB, 1, 0, 0, NULL::DOUBLE PRECISION, NULL::DOUBLE PRECISION FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
),

-- 6) Month × KDE rollup with type-aware metrics
kde_monthly AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                                      AS change_count,
    SUM(CURR_SSB)                                 AS exposure_dollars,

    -- Boolean metrics (sum where relevant rows)
    SUM(bool_on)                                  AS flag_on_count,
    SUM(bool_off)                                 AS flag_off_count,

    -- Numeric magnitudes
    SUM(numeric_mag)                               AS sum_numeric_magnitude,
    AVG(CASE WHEN numeric_mag IS NOT NULL THEN numeric_mag END) AS avg_numeric_magnitude,

    -- Date magnitudes (days)
    SUM(days_mag)                                  AS sum_days_moved,
    AVG(CASE WHEN days_mag IS NOT NULL THEN days_mag END) AS avg_days_moved
  FROM kde_changes
  WHERE change_flag = 1  -- safety; all rows here are changes
  GROUP BY 1,2
),

-- 7) Add denominators and compute rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,

    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION
         ELSE NULL END AS change_rate,

    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION
         ELSE NULL END AS exposure_share,

    -- carry type-specific metrics
    m.flag_on_count,
    m.flag_off_count,
    m.sum_numeric_magnitude,
    m.avg_numeric_magnitude,
    m.sum_days_moved,
    m.avg_days_moved
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) MoM deltas & percentages
with_mom AS (
  SELECT
    w.*,

    -- Previous month actuals
    LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_change_count,
    LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_exposure_dollars,

    LAG(w.flag_on_count)    OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_on_count,
    LAG(w.flag_off_count)   OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_flag_off_count,

    LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_numeric_magnitude,
    LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) AS prev_sum_days_moved,

    -- MoM deltas
    (w.change_count     - LAG(w.change_count)     OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_change_count_delta,
    (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_exposure_dollars_delta,

    (w.flag_on_count  - LAG(w.flag_on_count)  OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_flag_on_delta,
    (w.flag_off_count - LAG(w.flag_off_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_flag_off_delta,

    (w.sum_numeric_magnitude - LAG(w.sum_numeric_magnitude) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_sum_numeric_mag_delta,
    (w.sum_days_moved        - LAG(w.sum_days_moved)        OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)) AS mom_sum_days_moved_delta,

    -- MoM % (guard divide-by-zero)
    CASE WHEN LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) > 0
         THEN (w.change_count - LAG(w.change_count) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.change_count)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)
    END AS mom_change_count_pct,

    CASE WHEN LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE) <> 0
         THEN (w.exposure_dollars - LAG(w.exposure_dollars) OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE))
              / LAG(w.exposure_dollars)::DOUBLE PRECISION OVER (PARTITION BY w.KDE ORDER BY w.END_OF_MONTH_DATE)
    END AS mom_exposure_dollars_pct
  FROM kde_with_denoms w
)

-- 9) Final output
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Core
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Type-aware metrics
  flag_on_count,
  flag_off_count,
  sum_numeric_magnitude,
  avg_numeric_magnitude,
  sum_days_moved,
  avg_days_moved,

  -- MoM: counts and dollars
  prev_change_count,
  mom_change_count_delta,
  mom_change_count_pct,

  prev_exposure_dollars,
  mom_exposure_dollars_delta,
  mom_exposure_dollars_pct,

  -- MoM: type-aware extras (optional but useful)
  prev_flag_on_count,
  mom_flag_on_delta,
  prev_flag_off_count,
  mom_flag_off_delta,

  prev_sum_numeric_magnitude,
  mom_sum_numeric_mag_delta,
  prev_sum_days_moved,
  mom_sum_days_moved_delta

FROM with_mom
ORDER BY END_OF_MONTH_DATE DESC, KDE;





-- ======================================================================
-- KDE Expected vs Actual + MoM deltas (SQL-only, Netezza-friendly)
--   • Forecasts from rolling trend + same-month seasonality (rates/shares)
--   • Adds MoM $ / % deltas for exposure & count
--   • Standardized residuals (z-like) + materiality + MoM flags
--   • Single output: last N months for all KDEs
-- ======================================================================

WITH params AS (
  SELECT
    36 AS months_back,        -- history window (months)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) Denominators per month
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- 3) Snapshot KDE values (RC_CODE left raw)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- raw
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 4) Derive per-account changes (current vs prior month within system)
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- 5) UNPIVOT: one row per (month, KDE, changed account) carrying exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)))
),

-- 6) Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)        AS change_count,
    SUM(c.CURR_SSB) AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- 7) Add denominators, rates/shares, calendar month; add prior-month actuals for MoM
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0
         THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION
         ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb > 0
         THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION
         ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year,

    -- MoM previous actuals
    LAG(m.exposure_dollars) OVER (PARTITION BY m.KDE ORDER BY m.END_OF_MONTH_DATE) AS prev_exposure_dollars,
    LAG(m.change_count)     OVER (PARTITION BY m.KDE ORDER BY m.END_OF_MONTH_DATE) AS prev_change_count
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- 8) Rolling trend (12-mo, excl current) & same-month seasonal (10y max, excl current)
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING)  AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING)  AS trend_share,
    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- 9) Expected values = 0.5*trend + 0.5*seasonal (fallbacks if NULL)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- 10) Convert expected rates/shares to expected count/$; add rolling stddevs for standardization; compute MoM deltas
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    -- Rolling std devs for standardization (exclude current)
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12,

    -- MoM deltas (actuals)
    (exposure_dollars - prev_exposure_dollars) AS mom_exposure_delta,
    CASE WHEN prev_exposure_dollars IS NOT NULL AND prev_exposure_dollars <> 0
         THEN (exposure_dollars - prev_exposure_dollars) / prev_exposure_dollars::DOUBLE PRECISION END AS mom_exposure_pct,

    (change_count - prev_change_count) AS mom_count_delta,
    CASE WHEN prev_change_count IS NOT NULL AND prev_change_count <> 0
         THEN (change_count - prev_change_count) / prev_change_count::DOUBLE PRECISION END AS mom_count_pct
  FROM expected e
)

-- 11) Final: Actual vs Forecast, residuals, standardized residuals, MoM metrics & flags
SELECT
  END_OF_MONTH_DATE,
  KDE,

  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,

  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,

  -- Residuals (actual - expected)
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,

  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate    - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share - expected_share) / std_share_12 END AS std_resid_share,

  -- MoM actuals
  prev_exposure_dollars,
  mom_exposure_delta,
  mom_exposure_pct,
  prev_change_count,
  mom_count_delta,
  mom_count_pct,

  -- Flags (tune thresholds below)
  CASE WHEN
         -- Statistical surprise on exposure share (z-like)
         ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                  THEN (exposure_share - expected_share) / std_share_12 END) >= 2.5
         -- OR large absolute $ delta vs forecast
         OR ABS(exposure_dollars - expected_exposure) >= 50000000
         -- OR large relative $ delta vs forecast
         OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure) / NULLIF(expected_exposure,0)) >= 0.15)
       THEN 1 ELSE 0 END AS regression_flag,

  CASE WHEN
         -- MoM percent change big
         ABS(COALESCE(mom_exposure_pct,0)) >= 0.25
         -- OR MoM absolute $ change big
         OR ABS(COALESCE(mom_exposure_delta,0)) >= 50000000
       THEN 1 ELSE 0 END AS mom_exposure_flag,

  CASE WHEN
         ABS(COALESCE(mom_count_pct,0)) >= 0.25
         OR ABS(COALESCE(mom_count_delta,0)) >= 250   -- adjust for your scale
       THEN 1 ELSE 0 END AS mom_count_flag,

  -- Combined anomaly flag (trip if any of the above true)
  CASE WHEN
         (CASE WHEN
                 ABS(CASE WHEN std_share_12 > 0 AND expected_share IS NOT NULL
                          THEN (exposure_share - expected_share) / std_share_12 END) >= 2.5
                 OR ABS(exposure_dollars - expected_exposure) >= 50000000
                 OR (expected_exposure IS NOT NULL AND ABS((exposure_dollars - expected_exposure) / NULLIF(expected_exposure,0)) >= 0.15)
               THEN 1 ELSE 0 END) = 1
         OR (CASE WHEN
                   ABS(COALESCE(mom_exposure_pct,0)) >= 0.25
                   OR ABS(COALESCE(mom_exposure_delta,0)) >= 50000000
                 THEN 1 ELSE 0 END) = 1
         OR (CASE WHEN
                   ABS(COALESCE(mom_count_pct,0)) >= 0.25
                   OR ABS(COALESCE(mom_count_delta,0)) >= 250
                 THEN 1 ELSE 0 END) = 1
       THEN 1 ELSE 0 END AS LIKELY_ANOMALY_FLAG,

  -- Simple severity ranker = positive standardized residuals + MoM intensity
  (
    COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate    - expected_rate)  / std_rate_12  END), 0.0)
    + COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share - expected_share) / std_share_12 END), 0.0)
    + COALESCE(GREATEST(0.0, mom_exposure_pct), 0.0)
  ) AS severity_score

FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, severity_score DESC, KDE;







-- ============================================================
-- KDE Monthly Forecast vs Actual (SQL-only, Netezza-friendly)
--  • Forecasts change_count & exposure_dollars from rate/share
--  • Expected = 0.5*rolling_trend + 0.5*same-month-seasonal
--  • Outputs residuals and standardized residuals (z-like)
--  • Single output: full history for last N months
-- ============================================================
WITH params AS (
  SELECT
    36 AS months_back,        -- history window for modeling
    12 AS trend_win,          -- (note: inlined as 12 in window frames below)
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS DOUBLE PRECISION) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- KDE snapshots and changes
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- RC_CODE raw per your direction
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- UNPIVOT per account where a KDE changed; carry exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR ((PD_GRADE IS NULL) <> (prev_pd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR ((NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR ((DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR ((MATURITY_DATE IS NULL) <> (prev_mty IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR ((RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR ((FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR ((LIFESTAGE IS NULL) <> (prev_lifestage IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR ((NICHE_CD IS NULL) <> (prev_niche IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR ((RBC_CODE IS NULL) <> (prev_rbc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR ((REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR ((RC_CODE IS NULL) <> (prev_rc IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR ((RATE_TYPE IS NULL) <> (prev_rate_type IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR ((CRE_FLAG IS NULL) <> (prev_cre IS NULL)))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR ((BOOK_DATE IS NULL) <> (prev_book IS NULL)))
),

-- Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)        AS change_count,
    SUM(c.CURR_SSB) AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- Add denominators and derived rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0 THEN m.change_count / t.month_total_accounts::DOUBLE PRECISION ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb     > 0 THEN m.exposure_dollars / t.month_total_ssb::DOUBLE PRECISION     ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- Rolling trend (12-mo avg excl current), and seasonal same-month avg excl current
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS trend_share,

    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- Expected values = 0.5*trend + 0.5*seasonal (fallback if one side missing)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- Convert expected rates/shares back to counts/$; rolling std devs for standardization
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12
  FROM expected e
)

-- Final: Actual vs Forecast, residuals & standardized residuals
SELECT
  END_OF_MONTH_DATE,
  KDE,
  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,
  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,
  -- Residuals
  (change_count     - expected_count)    AS resid_count,
  (exposure_dollars - expected_exposure) AS resid_exposure,
  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate   - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share- expected_share)/ std_share_12 END AS std_resid_share,
  -- Simple severity (sum of positive standardized residuals)
  COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate   - expected_rate)  / std_rate_12  END),0.0)
  +
  COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share- expected_share)/ std_share_12 END),0.0)
  AS regression_like_severity
FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, regression_like_severity DESC, KDE;






-- ============================================================
-- KDE Monthly Forecast vs Actual (SQL-only, Netezza-friendly)
--  • Forecasts change_count & exposure_dollars from rate/share
--  • Expected = 0.5*rolling_trend + 0.5*same-month-seasonal
--  • Outputs residuals and standardized residuals (z-like)
--  • Single output: full history for last N months
-- ============================================================
WITH params AS (
  SELECT
    36 AS months_back,        -- history window for modeling (increase if you have more)
    12 AS trend_win,          -- rolling months for trend
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- Positive-balance population
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY 1
),

-- KDE snapshots and changes (you can keep these KDEs aligned with your latest set)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,
    MAX(t.NON_ACCRUAL_FLAG)        AS NON_ACCRUAL_FLAG,
    MAX(t.RISK_UNIT)               AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)          AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)               AS LIFESTAGE,
    MAX(t.NICHE_CD)                AS NICHE_CD,
    MAX(t.RBC_CODE)                AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,   -- RC_CODE left raw per your direction
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_eom,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_pd,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_na,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_dpd,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_mty,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_risk_unit,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_fcc,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_lifestage,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_niche,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rbc,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_revolver,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rc,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_rate_type,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_cre,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS prev_book
  FROM kde_month k
),

-- UNPIVOT per account where a KDE changed; carry exposure
kde_changes AS (
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (PD_GRADE <> prev_pd OR (PD_GRADE IS NULL) <> (prev_pd IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NON_ACCRUAL_FLAG <> prev_na OR (NON_ACCRUAL_FLAG IS NULL) <> (prev_na IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (DAYS_PAST_DUE <> prev_dpd OR (DAYS_PAST_DUE IS NULL) <> (prev_dpd IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (MATURITY_DATE <> prev_mty OR (MATURITY_DATE IS NULL) <> (prev_mty IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RISK_UNIT', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RISK_UNIT <> prev_risk_unit OR (RISK_UNIT IS NULL) <> (prev_risk_unit IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (FDIC_CALL_CODE <> prev_fcc OR (FDIC_CALL_CODE IS NULL) <> (prev_fcc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'LIFESTAGE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (LIFESTAGE <> prev_lifestage OR (LIFESTAGE IS NULL) <> (prev_lifestage IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'NICHE_CD', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (NICHE_CD <> prev_niche OR (NICHE_CD IS NULL) <> (prev_niche IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RBC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RBC_CODE <> prev_rbc OR (RBC_CODE IS NULL) <> (prev_rbc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (REVOLVING_NON_REVOLVING <> prev_revolver OR (REVOLVING_NON_REVOLVING IS NULL) <> (prev_revolver IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RC_CODE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RC_CODE <> prev_rc OR (RC_CODE IS NULL) <> (prev_rc IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'RATE_TYPE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (RATE_TYPE <> prev_rate_type OR (RATE_TYPE IS NULL) <> (prev_rate_type IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'CRE_FLAG', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (CRE_FLAG <> prev_cre OR (CRE_FLAG IS NULL) <> (prev_cre IS NULL))
  UNION ALL SELECT END_OF_MONTH_DATE, 'BOOK_DATE', CURR_SSB FROM kde_chg
  WHERE prev_eom IS NOT NULL AND (BOOK_DATE <> prev_book OR (BOOK_DATE IS NULL) <> (prev_book IS NULL))
),

-- Month × KDE actuals
kde_monthly AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)          AS change_count,
    SUM(c.CURR_SSB)   AS exposure_dollars
  FROM kde_changes c
  GROUP BY 1,2
),

-- Add denominators and derived rates/shares
kde_with_denoms AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.KDE,
    m.change_count,
    m.exposure_dollars,
    t.month_total_accounts,
    t.month_total_ssb,
    CASE WHEN t.month_total_accounts > 0 THEN m.change_count::FLOAT8 / t.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN t.month_total_ssb     > 0 THEN m.exposure_dollars     / t.month_total_ssb     ELSE NULL END AS exposure_share,
    EXTRACT(MONTH FROM m.END_OF_MONTH_DATE) AS month_of_year
  FROM kde_monthly m
  JOIN month_totals t USING (END_OF_MONTH_DATE)
),

-- Rolling trend (12-month avg excluding current), and seasonal same-month avg excluding current
baselines AS (
  SELECT
    x.*,
    AVG(change_rate)     OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN (SELECT trend_win FROM params) PRECEDING AND 1 PRECEDING) AS trend_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN (SELECT trend_win FROM params) PRECEDING AND 1 PRECEDING) AS trend_share,

    AVG(change_rate)     OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_rate,
    AVG(exposure_share)  OVER (PARTITION BY KDE, month_of_year ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 120 PRECEDING AND 1 PRECEDING) AS same_month_share
  FROM kde_with_denoms x
),

-- Expected values = 0.5*trend + 0.5*seasonal (fallbacks if one side missing)
expected AS (
  SELECT
    b.*,
    COALESCE(0.5*trend_rate  + 0.5*same_month_rate,  trend_rate,  same_month_rate)  AS expected_rate,
    COALESCE(0.5*trend_share + 0.5*same_month_share, trend_share, same_month_share) AS expected_share
  FROM baselines b
),

-- Convert expected rates/shares back to counts/$; build rolling std devs for standardization
with_expected AS (
  SELECT
    e.*,
    CASE WHEN month_total_accounts IS NOT NULL THEN e.expected_rate  * month_total_accounts END AS expected_count,
    CASE WHEN month_total_ssb     IS NOT NULL THEN e.expected_share * month_total_ssb     END AS expected_exposure,

    -- Rolling std devs (exclude current) for z-like standardization
    STDDEV_SAMP(change_rate)    OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    STDDEV_SAMP(exposure_share) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_share_12
  FROM expected e
)

-- Final: Actual vs Forecast, residuals & standardized residuals
SELECT
  END_OF_MONTH_DATE,
  KDE,
  -- Actuals
  change_count,
  exposure_dollars,
  month_total_accounts,
  month_total_ssb,
  change_rate,
  exposure_share,
  -- Forecasts
  expected_count,
  expected_exposure,
  expected_rate,
  expected_share,
  -- Residuals
  (change_count      - expected_count)     AS resid_count,
  (exposure_dollars  - expected_exposure)  AS resid_exposure,
  -- Standardized residuals (z-like; guard div-by-zero)
  CASE WHEN std_rate_12  IS NOT NULL AND std_rate_12  > 0 AND expected_rate  IS NOT NULL
       THEN (change_rate   - expected_rate)  / std_rate_12  END AS std_resid_rate,
  CASE WHEN std_share_12 IS NOT NULL AND std_share_12 > 0 AND expected_share IS NOT NULL
       THEN (exposure_share- expected_share)/ std_share_12 END AS std_resid_share,
  -- Simple severity (sum of positive standardized residuals)
  COALESCE(GREATEST(0.0, CASE WHEN std_rate_12  > 0 THEN (change_rate   - expected_rate)  / std_rate_12  END),0.0)
  +
  COALESCE(GREATEST(0.0, CASE WHEN std_share_12 > 0 THEN (exposure_share- expected_share)/ std_share_12 END),0.0)
  AS regression_like_severity
FROM with_expected
ORDER BY END_OF_MONTH_DATE DESC, regression_like_severity DESC, KDE;







-- ============================================================
-- Systemic KDE Summary (positive-balance only) — RC_CODE raw
--  • KDE-specific magnitudes
--  • Rates & exposure materiality (exposure_dollars/share)
--  • Z-scores: count_z, rate_z, magnitude_z, exposure_z
--  • SINGLE OUTPUT: full history within lookback
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window (months)
    2.5     AS z_threshold,          -- anomaly threshold (tune 2.0–3.0)
    -- Magnitude caps for normalization to ~0..1
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4     -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Denominators (rates / shares)
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots for positive-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Categoricals / flags (leave RC_CODE RAW as requested)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))        AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))               AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))          AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))               AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))                AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))                AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                               AS RC_CODE,     -- << raw (no normalization)
    MAX(UPPER(TRIM(t.RATE_TYPE)))               AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where a KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha in your data)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical) -- RAW
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)               AS change_count,
    SUM(c.magnitude_raw)   AS sum_magnitude_raw,
    AVG(c.magnitude_raw)   AS avg_magnitude_raw,
    SUM(c.magnitude_norm)  AS sum_magnitude_norm,
    AVG(c.magnitude_norm)  AS avg_magnitude_norm,
    SUM(c.CURR_SSB)        AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators and rates/shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines & z-scores (exclude current month from baseline)
kde_with_stats AS (
  SELECT
    x.*,
    -- counts
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    -- rates
    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    -- magnitudes
    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12,
    -- exposure dollars
    AVG(exposure_dollars)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_exposure_12,
    STDDEV_SAMP(exposure_dollars) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_exposure_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12    IS NOT NULL AND k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12     IS NOT NULL AND k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12      IS NOT NULL AND k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      ELSE NULL END AS magnitude_z,
    CASE WHEN k.std_exposure_12 IS NOT NULL AND k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 ELSE NULL END AS exposure_z,

    -- Combined anomaly score = sum of positive z's (NULL→0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) SINGLE OUTPUT: full history (latest first)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,     3) AS count_z,
  ROUND(rate_z,      3) AS rate_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(exposure_z,  3) AS exposure_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)      >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(exposure_z,0)  >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;






-- ============================================================
-- Systemic KDE Summary (positive-balance only)
--  • KDE-specific magnitudes + RC_CODE normalization
--  • Rates & exposure materiality (exposure_dollars/share)
--  • Z-scores: count_z, rate_z, magnitude_z, exposure_z
--  • SINGLE OUTPUT: full history within lookback
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window
    2.5     AS z_threshold,          -- anomaly threshold (tune)
    -- Magnitude caps for normalization to ~0..1
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4     -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Totals for denominators (rates / shares)
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots for positive-balance population (with hygiene on categoricals)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)      AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Categorical / flags (normalized)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))        AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))               AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))          AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))               AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))                AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))                AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    -- RC_CODE: pad to 3 to collapse '1','01','001'
    MAX(LPAD(UPPER(TRIM(t.RC_CODE)), 3, '0'))   AS RC_CODE,
    MAX(UPPER(TRIM(t.RATE_TYPE)))               AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))                AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (normalized)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE
  SELECT END_OF_MONTH DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)               AS change_count,
    SUM(c.magnitude_raw)   AS sum_magnitude_raw,
    AVG(c.magnitude_raw)   AS avg_magnitude_raw,
    SUM(c.magnitude_norm)  AS sum_magnitude_norm,
    AVG(c.magnitude_norm)  AS avg_magnitude_norm,
    SUM(c.CURR_SSB)        AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators and rates/shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines & z-scores (exclude current month from baseline)
kde_with_stats AS (
  SELECT
    x.*,
    -- counts
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    -- rates
    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,
    -- magnitudes
    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12,
    -- exposure dollars (NEW)
    AVG(exposure_dollars)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_exposure_12,
    STDDEV_SAMP(exposure_dollars) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_exposure_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12    IS NOT NULL AND k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12     IS NOT NULL AND k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12      IS NOT NULL AND k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      ELSE NULL END AS magnitude_z,
    CASE WHEN k.std_exposure_12 IS NOT NULL AND k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 ELSE NULL END AS exposure_z,

    -- Combined anomaly score = sum of positive z's (NULL→0). Exposure_z included.
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12    > 0 THEN (k.change_count       - k.avg_count_12)    / k.std_count_12    END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12     > 0 THEN (k.change_rate        - k.avg_rate_12)     / k.std_rate_12     END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12      > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)      / k.std_mag_12      END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_exposure_12 > 0 THEN (k.exposure_dollars   - k.avg_exposure_12) / k.std_exposure_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) SINGLE OUTPUT: full history (latest first)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,     3) AS count_z,
  ROUND(rate_z,      3) AS rate_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(exposure_z,  3) AS exposure_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)      >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(exposure_z,0)  >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;







-- ============================================================
-- Systemic KDE Summary (positive-balance only) — Patched
--  • RC_CODE normalization to catch '1' vs '01' etc.
--  • Adds change_rate and exposure_share
--  • Z-scores on count, rate, and sum_magnitude_norm (not exposure)
--  • Single output: full history
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    2.5     AS z_threshold,          -- slightly more sensitive than 3.0
    -- Normalization caps (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,
    CAST(730.0 AS FLOAT8) AS cap_mty_days,
    CAST(365.0 AS FLOAT8) AS cap_book_days,
    'Total Loans' AS target_lvl4
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Measures, POSITIVE balances only
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- Totals for rate/share denominators
month_totals AS (
  SELECT
    m.END_OF_MONTH_DATE,
    COUNT(DISTINCT (m.CONTRACT_SOURCE_SYSTEM || '|' || m.ACCOUNT_KEY)) AS month_total_accounts,
    SUM(m.SOURCE_SYSTEM_BALANCE) AS month_total_ssb
  FROM measures m
  GROUP BY m.END_OF_MONTH_DATE
),

-- 2) KDE snapshots restricted to positive-balance accounts
--    Apply hygiene/normalization to high-risk categoricals
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,

    -- Numeric / dates
    MAX(t.PD_GRADE)     AS PD_GRADE,
    MAX(t.DAYS_PAST_DUE) AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE) AS MATURITY_DATE,
    MAX(t.BOOK_DATE)     AS BOOK_DATE,

    -- Flags / categoricals (normalized)
    MAX(UPPER(TRIM(t.NON_ACCRUAL_FLAG)))       AS NON_ACCRUAL_FLAG,
    MAX(UPPER(TRIM(t.RISK_UNIT)))              AS RISK_UNIT,
    MAX(UPPER(TRIM(t.FDIC_CALL_CODE)))         AS FDIC_CALL_CODE,
    MAX(UPPER(TRIM(t.LIFESTAGE)))              AS LIFESTAGE,
    MAX(UPPER(TRIM(t.NICHE_CD)))               AS NICHE_CD,
    MAX(UPPER(TRIM(t.RBC_CODE)))               AS RBC_CODE,
    MAX(UPPER(TRIM(t.REVOLVING_NON_REVOLVING))) AS REVOLVING_NON_REVOLVING,
    -- RC_CODE: pad to 3 and upper/trim to collapse '1','01','001'
    MAX(LPAD(UPPER(TRIM(t.RC_CODE)), 3, '0'))  AS RC_CODE,
    MAX(UPPER(TRIM(t.RATE_TYPE)))              AS RATE_TYPE,
    MAX(UPPER(TRIM(t.CRE_FLAG)))               AS CRE_FLAG
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)       OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)        OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING) OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                 OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)               OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT only where KDE changed; compute magnitude; carry exposure
kde_changes AS (
  -- PD_GRADE
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (normalized)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary + exposure
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                AS change_count,
    SUM(c.magnitude_raw)    AS sum_magnitude_raw,
    AVG(c.magnitude_raw)    AS avg_magnitude_raw,
    SUM(c.magnitude_norm)   AS sum_magnitude_norm,
    AVG(c.magnitude_norm)   AS avg_magnitude_norm,
    SUM(c.CURR_SSB)         AS exposure_dollars
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Add denominators → rates and shares
kde_monthly_with_denoms AS (
  SELECT
    s.*,
    mt.month_total_accounts,
    mt.month_total_ssb,
    CASE WHEN mt.month_total_accounts > 0 THEN s.change_count::FLOAT8 / mt.month_total_accounts ELSE NULL END AS change_rate,
    CASE WHEN mt.month_total_ssb     > 0 THEN s.exposure_dollars     / mt.month_total_ssb     ELSE NULL END AS exposure_share
  FROM kde_monthly_summary s
  LEFT JOIN month_totals mt
    ON mt.END_OF_MONTH_DATE = s.END_OF_MONTH_DATE
),

-- 7) Baselines and z-scores (exclude current month)
kde_with_stats AS (
  SELECT
    x.*,
    AVG(change_count)        OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count)OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,

    AVG(change_rate)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_rate_12,
    STDDEV_SAMP(change_rate) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_rate_12,

    AVG(sum_magnitude_norm)  OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_with_denoms x
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12 ELSE NULL END AS count_z,
    CASE WHEN k.std_rate_12  IS NOT NULL AND k.std_rate_12  > 0
         THEN (k.change_rate  - k.avg_rate_12)  / k.std_rate_12  ELSE NULL END AS rate_z,
    CASE WHEN k.std_mag_12   IS NOT NULL AND k.std_mag_12   > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12 ELSE NULL END AS magnitude_z,

    -- Summed positive z's (NULL→0). Exposure is NOT z-scored; used as tie-breaker.
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_rate_12  > 0 THEN (k.change_rate  - k.avg_rate_12) /k.std_rate_12  END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12   > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 8) Single output: full history
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  change_rate,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,
  exposure_share,
  ROUND(count_z,    3) AS count_z,
  ROUND(rate_z,     3) AS rate_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(rate_z,0)     >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0)>= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;

CASE WHEN exposure_share >= 0.05 OR exposure_dollars >= 25000000 THEN 1 ELSE 0 END AS BIG_$_SPIKE






-- ============================================================
-- Monthly KDE Systemic Summary (positive-balance only)
--  • KDE-specific magnitudes
--  • Z-scores on change_count and sum_magnitude_norm ONLY
--  • exposure_dollars included (no z-score on it)
--  • SINGLE OUTPUT: full history in one result set
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    3.0     AS z_threshold,          -- anomaly flag threshold per z
    -- Magnitude caps to normalize to ~0..1 (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD steps
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD days
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity days (~2y)
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book date days (~1y)
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) KDE snapshots for POSITIVE-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,     -- carry exposure for summary
    -- KDEs (original + added)
    MAX(t.PD_GRADE)                 AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)            AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE,
    MAX(t.RISK_UNIT)                AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)           AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)                AS LIFESTAGE,
    MAX(t.NICHE_CD)                 AS NICHE_CD,
    MAX(t.RBC_CODE)                 AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING)  AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RATE_TYPE)                AS RATE_TYPE,
    MAX(t.CRE_FLAG)                 AS CRE_FLAG,
    MAX(t.BOOK_DATE)                AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)             OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING)    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT rows where a KDE changed; compute magnitude and carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly systemic summary by KDE (+ exposure_dollars)
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                         AS change_count,
    SUM(c.magnitude_raw)             AS sum_magnitude_raw,
    AVG(c.magnitude_raw)             AS avg_magnitude_raw,
    SUM(c.magnitude_norm)            AS sum_magnitude_norm,
    AVG(c.magnitude_norm)            AS avg_magnitude_norm,
    SUM(c.CURR_SSB)                  AS exposure_dollars      -- included (no z-score on it)
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) SINGLE OUTPUT: Full history (within lookback window)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,                   -- exposure impact (no z-score)
  ROUND(count_z,    3) AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;




-- ============================================================
-- Monthly KDE Systemic Summary (positive-balance only)
--  • KDE-specific magnitudes
--  • Z-scores on change_count and sum_magnitude_norm ONLY
--  • Adds exposure_dollars column (no z-score on it)
--  • Latest month ranked by anomaly signal
-- ============================================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback for baselines
    3.0     AS z_threshold,          -- anomaly flag threshold per z
    -- Magnitude caps to normalize to ~0..1 (tune to domain)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD steps
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD days
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity days (~2y)
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book date days (~1y)
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly measures (POSITIVE balance only)
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0
),

-- 2) KDE snapshots for POSITIVE-balance population
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE AS CURR_SSB,     -- carry exposure for summary
    -- KDEs (original + added)
    MAX(t.PD_GRADE)                 AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)            AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE,
    MAX(t.RISK_UNIT)                AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)           AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)                AS LIFESTAGE,
    MAX(t.NICHE_CD)                 AS NICHE_CD,
    MAX(t.RBC_CODE)                 AS RBC_CODE,
    MAX(t.REVOLVING_NON_REVOLVING)  AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RATE_TYPE)                AS RATE_TYPE,
    MAX(t.CRE_FLAG)                 AS CRE_FLAG,
    MAX(t.BOOK_DATE)                AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3,4
),

-- 3) Prior-month values per acct+system
kde_chg AS (
  SELECT
    k.*,
    LAG(k.END_OF_MONTH_DATE)          OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(k.PD_GRADE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(k.NON_ACCRUAL_FLAG)           OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(k.DAYS_PAST_DUE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(k.MATURITY_DATE)              OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(k.RISK_UNIT)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(k.FDIC_CALL_CODE)             OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(k.LIFESTAGE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(k.NICHE_CD)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(k.RBC_CODE)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RBC_CODE,
    LAG(k.REVOLVING_NON_REVOLVING)    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(k.RC_CODE)                    OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(k.RATE_TYPE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_RATE_TYPE,
    LAG(k.CRE_FLAG)                   OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_CRE_FLAG,
    LAG(k.BOOK_DATE)                  OVER (PARTITION BY k.ACCOUNT_KEY, k.CONTRACT_SOURCE_SYSTEM ORDER BY k.END_OF_MONTH_DATE) AS PREV_BOOK_DATE
  FROM kde_month k
),

-- 4) UNPIVOT rows where a KDE changed; compute magnitude and carry exposure
kde_changes AS (
  -- PD_GRADE (numeric-ish; map first if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm,
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE',
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE',
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1.0::FLOAT8, 1.0::FLOAT8, CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE',
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params)),
         CURR_SSB
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly systemic summary by KDE (+ exposure_dollars)
kde_monthly_summary AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.KDE,
    COUNT(*)                         AS change_count,
    SUM(c.magnitude_raw)             AS sum_magnitude_raw,
    AVG(c.magnitude_raw)             AS avg_magnitude_raw,
    SUM(c.magnitude_norm)            AS sum_magnitude_norm,
    AVG(c.magnitude_norm)            AS avg_magnitude_norm,
    SUM(c.CURR_SSB)                  AS exposure_dollars      -- <<< added, no z-score computed
  FROM kde_changes c
  GROUP BY c.END_OF_MONTH_DATE, c.KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month systemic KDE signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  exposure_dollars,                   -- <<< requested column
  ROUND(count_z,    3) AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0)    >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt: full history (uncomment) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  exposure_dollars,                        -- included in history
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/





-- ============================================
-- Monthly KDE Summary (positive-balance only)
--  • KDE-specific magnitude (incl. your new KDEs)
--  • 12-mo baselines & z-scores
--  • Latest month ranked by anomaly signal
-- ============================================
WITH params AS (
  SELECT
    12      AS months_back,          -- lookback window for baseline
    3.0     AS z_threshold,          -- anomaly threshold for z
    -- Normalization caps for magnitudes (scale different KDEs to ~0..1)
    CAST(4.0   AS FLOAT8) AS cap_pd_steps,   -- PD: steps (e.g., 4 steps => full magnitude)
    CAST(60.0  AS FLOAT8) AS cap_dpd_days,   -- DPD: 60 days => full
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- Maturity: 730 days (~2y) => full
    CAST(365.0 AS FLOAT8) AS cap_book_days,  -- Book_Date: 365 days (~1y) => full
    'Total Loans' AS target_lvl4             -- optional layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly MEASURES at acct+system, restricting to POSITIVE balances
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0              -- Positive balance only
),

-- 2) Monthly KDE snapshots ONLY for positive-balance accounts (join back to measures)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- Original KDEs
    MAX(t.PD_GRADE)             AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)     AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)        AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)        AS MATURITY_DATE,
    MAX(t.RISK_UNIT)            AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)       AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)            AS LIFESTAGE,
    MAX(t.NICHE_CD)             AS NICHE_CD,
    MAX(t.RBC_CODE)             AS RBC_CODE,
    -- New KDEs
    MAX(t.REVOLVING_NON_REVOLVING) AS REVOLVING_NON_REVOLVING,
    MAX(t.RC_CODE)                 AS RC_CODE,
    MAX(t.RATE_TYPE)               AS RATE_TYPE,
    MAX(t.CRE_FLAG)                AS CRE_FLAG,
    MAX(t.BOOK_DATE)               AS BOOK_DATE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3
),

-- 3) Add prior-month values per acct+system
kde_chg AS (
  SELECT
    m.*,
    LAG(m.END_OF_MONTH_DATE)   OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(m.PD_GRADE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(m.NON_ACCRUAL_FLAG)    OVER (...) AS PREV_NON_ACCRUAL_FLAG,
    LAG(m.DAYS_PAST_DUE)       OVER (...) AS PREV_DAYS_PAST_DUE,
    LAG(m.MATURITY_DATE)       OVER (...) AS PREV_MATURITY_DATE,
    LAG(m.RISK_UNIT)           OVER (...) AS PREV_RISK_UNIT,
    LAG(m.FDIC_CALL_CODE)      OVER (...) AS PREV_FDIC_CALL_CODE,
    LAG(m.LIFESTAGE)           OVER (...) AS PREV_LIFESTAGE,
    LAG(m.NICHE_CD)            OVER (...) AS PREV_NICHE_CD,
    LAG(m.RBC_CODE)            OVER (...) AS PREV_RBC_CODE,
    LAG(m.REVOLVING_NON_REVOLVING) OVER (...) AS PREV_REVOLVING_NON_REVOLVING,
    LAG(m.RC_CODE)             OVER (...) AS PREV_RC_CODE,
    LAG(m.RATE_TYPE)           OVER (...) AS PREV_RATE_TYPE,
    LAG(m.CRE_FLAG)            OVER (...) AS PREV_CRE_FLAG,
    LAG(m.BOOK_DATE)           OVER (...) AS PREV_BOOK_DATE
  FROM kde_month m
),

-- 4) UNPIVOT: rows only where a KDE changed; compute KDE-specific magnitudes
kde_changes AS (
  -- PD_GRADE (numeric-ish; map if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, 1 AS change_flag,
         ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) AS magnitude_raw,
         LEAST(1.0, ABS(CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8)) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (PD_GRADE <> PREV_PD_GRADE) OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical flip)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  -- DAYS_PAST_DUE (numeric days)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', 1,
         ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0))::FLOAT8,
         LEAST(1.0, ABS(COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0)) / (SELECT cap_dpd_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  -- MATURITY_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', 1,
         ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE))) / (SELECT cap_mty_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (MATURITY_DATE <> PREV_MATURITY_DATE) OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RISK_UNIT <> PREV_RISK_UNIT) OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (LIFESTAGE <> PREV_LIFESTAGE) OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (NICHE_CD <> PREV_NICHE_CD) OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RBC_CODE <> PREV_RBC_CODE) OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )

  UNION ALL
  -- REVOLVING_NON_REVOLVING (categorical)
  SELECT END_OF_MONTH_DATE, 'REVOLVING_NON_REVOLVING', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (REVOLVING_NON_REVOLVING <> PREV_REVOLVING_NON_REVOLVING) OR (REVOLVING_NON_REVOLVING IS NULL AND PREV_REVOLVING_NON_REVOLVING IS NOT NULL) OR (REVOLVING_NON_REVOLVING IS NOT NULL AND PREV_REVOLVING_NON_REVOLVING IS NULL) )

  UNION ALL
  -- RC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RC_CODE <> PREV_RC_CODE) OR (RC_CODE IS NULL AND PREV_RC_CODE IS NOT NULL) OR (RC_CODE IS NOT NULL AND PREV_RC_CODE IS NULL) )

  UNION ALL
  -- RATE_TYPE (categorical)
  SELECT END_OF_MONTH_DATE, 'RATE_TYPE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (RATE_TYPE <> PREV_RATE_TYPE) OR (RATE_TYPE IS NULL AND PREV_RATE_TYPE IS NOT NULL) OR (RATE_TYPE IS NOT NULL AND PREV_RATE_TYPE IS NULL) )

  UNION ALL
  -- CRE_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'CRE_FLAG', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (CRE_FLAG <> PREV_CRE_FLAG) OR (CRE_FLAG IS NULL AND PREV_CRE_FLAG IS NOT NULL) OR (CRE_FLAG IS NOT NULL AND PREV_CRE_FLAG IS NULL) )

  UNION ALL
  -- BOOK_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'BOOK_DATE', 1,
         ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE)))::FLOAT8,
         LEAST(1.0, ABS((CAST(BOOK_DATE AS DATE) - CAST(PREV_BOOK_DATE AS DATE))) / (SELECT cap_book_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND ( (BOOK_DATE <> PREV_BOOK_DATE) OR (BOOK_DATE IS NULL AND PREV_BOOK_DATE IS NOT NULL) OR (BOOK_DATE IS NOT NULL AND PREV_BOOK_DATE IS NULL) )
),

-- 5) Monthly summary by KDE (systemic view across all positive-balance accounts)
kde_monthly_summary AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)            AS change_count,
    SUM(magnitude_raw)  AS sum_magnitude_raw,
    AVG(magnitude_raw)  AS avg_magnitude_raw,
    SUM(magnitude_norm) AS sum_magnitude_norm,
    AVG(magnitude_norm) AS avg_magnitude_norm
  FROM kde_changes
  GROUP BY END_OF_MONTH_DATE, KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current from baseline)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,
    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,
    -- Combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month KDE systemic signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  ROUND(count_z, 3)     AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt view: full history (uncomment) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/






-- ============================================
-- Monthly KDE Summary (positive-balance only)
--  • KDE-specific magnitude
--  • 12-mo baselines & z-scores
--  • Latest month ranked by anomaly signal
-- ============================================
WITH params AS (
  SELECT
    12                AS months_back,        -- lookback window for baseline
    3.0               AS z_threshold,        -- anomaly threshold for z
    -- Normalization caps for magnitude (scale different KDEs to ~0..1)
    CAST(4.0  AS FLOAT8) AS cap_pd_steps,    -- PD steps: 4 steps => full magnitude
    CAST(60.0 AS FLOAT8) AS cap_dpd_days,    -- DPD: 60 days => full magnitude
    CAST(730.0 AS FLOAT8) AS cap_mty_days,   -- maturity: 730 days (~2 yrs) => full magnitude
    'Total Loans'     AS target_lvl4         -- optional GL layer filter
),

latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),

rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- 1) Monthly MEASURES at acct+system, restricting to POSITIVE balances
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
  GROUP BY 1,2,3
  HAVING SUM(t.SOURCE_SYSTEM_BALANCE) > 0               -- <<< positive balance filter
),

-- 2) Monthly KDE snapshots ONLY for positive-balance accounts (join back to measures)
kde_month AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- Your KDEs
    MAX(t.PD_GRADE)            AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)    AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)       AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)       AS MATURITY_DATE,
    MAX(t.RISK_UNIT)           AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)      AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)           AS LIFESTAGE,
    MAX(t.NICHE_CD)            AS NICHE_CD,
    MAX(t.RBC_CODE)            AS RBC_CODE
  FROM measures m
  JOIN V_DPRT_CREDIT_INSTRUMENTS_ME t
    ON t.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND t.ACCOUNT_KEY            = m.ACCOUNT_KEY
  GROUP BY 1,2,3
),

-- 3) Add prior-month values per acct+system
kde_chg AS (
  SELECT
    m.*,
    LAG(m.END_OF_MONTH_DATE)   OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(m.PD_GRADE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(m.NON_ACCRUAL_FLAG)    OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(m.DAYS_PAST_DUE)       OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(m.MATURITY_DATE)       OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(m.RISK_UNIT)           OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(m.FDIC_CALL_CODE)      OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(m.LIFESTAGE)           OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(m.NICHE_CD)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(m.RBC_CODE)            OVER (PARTITION BY m.ACCOUNT_KEY, m.CONTRACT_SOURCE_SYSTEM ORDER BY m.END_OF_MONTH_DATE) AS PREV_RBC_CODE
  FROM kde_month m
),

-- 4) UNPIVOT: rows only where a KDE changed; compute KDE-specific magnitudes
kde_changes AS (
  -- PD_GRADE (assumes numeric-ish; adjust mapping if alpha)
  SELECT END_OF_MONTH_DATE, 'PD_GRADE' AS KDE, 1 AS change_flag,
         ABS( CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8) ) AS magnitude_raw,
         LEAST(1.0, ABS( CAST(NULLIF(PD_GRADE,'') AS FLOAT8) - CAST(NULLIF(PREV_PD_GRADE,'') AS FLOAT8) ) / (SELECT cap_pd_steps FROM params)) AS magnitude_norm
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (PD_GRADE <> PREV_PD_GRADE) OR
      (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL) OR
      (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL)
    )

  UNION ALL
  -- NON_ACCRUAL_FLAG (categorical)
  SELECT END_OF_MONTH_DATE, 'NON_ACCRUAL_FLAG', 1,
         CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG) OR
      (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL) OR
      (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL)
    )

  UNION ALL
  -- DAYS_PAST_DUE (numeric)
  SELECT END_OF_MONTH_DATE, 'DAYS_PAST_DUE', 1,
         ABS( COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0) )::FLOAT8,
         LEAST(1.0, ABS( COALESCE(DAYS_PAST_DUE,0) - COALESCE(PREV_DAYS_PAST_DUE,0) ) / (SELECT cap_dpd_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE) OR
      (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL) OR
      (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL)
    )

  UNION ALL
  -- MATURITY_DATE (days between dates)
  SELECT END_OF_MONTH_DATE, 'MATURITY_DATE', 1,
         ABS( (CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)) )::FLOAT8,
         LEAST(1.0, ABS( (CAST(MATURITY_DATE AS DATE) - CAST(PREV_MATURITY_DATE AS DATE)) ) / (SELECT cap_mty_days FROM params))
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (MATURITY_DATE <> PREV_MATURITY_DATE) OR
      (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL) OR
      (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL)
    )

  UNION ALL
  -- RISK_UNIT (categorical)
  SELECT END_OF_MONTH_DATE, 'RISK_UNIT', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (RISK_UNIT <> PREV_RISK_UNIT) OR
      (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL) OR
      (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL)
    )

  UNION ALL
  -- FDIC_CALL_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'FDIC_CALL_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE) OR
      (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL) OR
      (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL)
    )

  UNION ALL
  -- LIFESTAGE (categorical)
  SELECT END_OF_MONTH_DATE, 'LIFESTAGE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (LIFESTAGE <> PREV_LIFESTAGE) OR
      (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL) OR
      (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL)
    )

  UNION ALL
  -- NICHE_CD (categorical)
  SELECT END_OF_MONTH_DATE, 'NICHE_CD', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (NICHE_CD <> PREV_NICHE_CD) OR
      (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL) OR
      (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL)
    )

  UNION ALL
  -- RBC_CODE (categorical)
  SELECT END_OF_MONTH_DATE, 'RBC_CODE', 1, CAST(1.0 AS FLOAT8), CAST(1.0 AS FLOAT8)
  FROM kde_chg
  WHERE PREV_EOM IS NOT NULL
    AND (
      (RBC_CODE <> PREV_RBC_CODE) OR
      (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL) OR
      (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL)
    )
),

-- 5) Monthly summary by KDE (systemic view across all positive-balance accounts)
kde_monthly_summary AS (
  SELECT
    END_OF_MONTH_DATE,
    KDE,
    COUNT(*)                 AS change_count,
    SUM(magnitude_raw)       AS sum_magnitude_raw,
    AVG(magnitude_raw)       AS avg_magnitude_raw,
    SUM(magnitude_norm)      AS sum_magnitude_norm,
    AVG(magnitude_norm)      AS avg_magnitude_norm
  FROM kde_changes
  GROUP BY END_OF_MONTH_DATE, KDE
),

-- 6) Rolling baselines vs prior 12 months (exclude current in baseline frame)
kde_with_stats AS (
  SELECT
    s.*,
    AVG(change_count)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_count_12,
    STDDEV_SAMP(change_count) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_count_12,

    AVG(sum_magnitude_norm)         OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS avg_mag_12,
    STDDEV_SAMP(sum_magnitude_norm) OVER (PARTITION BY KDE ORDER BY END_OF_MONTH_DATE
                                    ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING) AS std_mag_12
  FROM kde_monthly_summary s
),

scored AS (
  SELECT
    k.*,
    CASE WHEN k.std_count_12 IS NOT NULL AND k.std_count_12 > 0
         THEN (k.change_count - k.avg_count_12) / k.std_count_12
         ELSE NULL END AS count_z,
    CASE WHEN k.std_mag_12 IS NOT NULL AND k.std_mag_12 > 0
         THEN (k.sum_magnitude_norm - k.avg_mag_12) / k.std_mag_12
         ELSE NULL END AS magnitude_z,

    -- Simple combined anomaly score: sum of positive z's (NULL -> 0)
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_count_12 > 0 THEN (k.change_count - k.avg_count_12)/k.std_count_12 END)), 0.0)
    +
    COALESCE(GREATEST(0.0, (CASE WHEN k.std_mag_12  > 0 THEN (k.sum_magnitude_norm - k.avg_mag_12)/k.std_mag_12 END)), 0.0)
    AS anomaly_score
  FROM kde_with_stats k
)

-- 7) Final: Latest month KDE systemic signals (ranked)
SELECT
  END_OF_MONTH_DATE,
  KDE,
  change_count,
  sum_magnitude_raw,
  avg_magnitude_raw,
  sum_magnitude_norm,
  avg_magnitude_norm,
  ROUND(count_z, 3)     AS count_z,
  ROUND(magnitude_z, 3) AS magnitude_z,
  ROUND(anomaly_score, 3) AS anomaly_score,
  CASE
    WHEN (COALESCE(count_z,0) >= (SELECT z_threshold FROM params))
      OR (COALESCE(magnitude_z,0) >= (SELECT z_threshold FROM params))
    THEN 1 ELSE 0 END AS LIKELY_SYSTEMIC_ANOMALY
FROM scored
WHERE END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY LIKELY_SYSTEMIC_ANOMALY DESC, anomaly_score DESC, KDE;

/* ---- Alt view: full history across months (uncomment to use) ----
SELECT
  END_OF_MONTH_DATE, KDE,
  change_count, sum_magnitude_raw, avg_magnitude_raw,
  sum_magnitude_norm, avg_magnitude_norm,
  ROUND(count_z,3) AS count_z,
  ROUND(magnitude_z,3) AS magnitude_z,
  ROUND(anomaly_score,3) AS anomaly_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, anomaly_score DESC, KDE;
*/






-- =========================
-- Parameters (tune freely)
-- =========================
WITH params AS (
  SELECT
    'Total Loans'      AS target_lvl4,     -- optional GL layer filter
    12                 AS months_back,     -- lookback for change log
    CAST(500000.0 AS FLOAT8) AS dollar_anchor, -- scale for "large" $ moves
    CAST(0.15     AS FLOAT8) AS pct_anchor     -- scale for "large" % moves (15%)
),

-- Anchor the window (need N months of points to compute N-1 deltas)
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT
    ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
    l.max_eom AS max_eom
  FROM latest l
),

-- ========================
-- Monthly measures (SSB)
-- ========================
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- OPTIONAL system filter:
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- ==================================
-- Monthly KDE attributes (your 9 KDEs)
-- Use MAX() assuming single-valued per acct/month
-- ==================================
attr AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    MAX(t.PD_GRADE)            AS PD_GRADE,
    MAX(t.NON_ACCRUAL_FLAG)    AS NON_ACCRUAL_FLAG,
    MAX(t.DAYS_PAST_DUE)       AS DAYS_PAST_DUE,
    MAX(t.MATURITY_DATE)       AS MATURITY_DATE,
    MAX(t.RISK_UNIT)           AS RISK_UNIT,
    MAX(t.FDIC_CALL_CODE)      AS FDIC_CALL_CODE,
    MAX(t.LIFESTAGE)           AS LIFESTAGE,
    MAX(t.NICHE_CD)            AS NICHE_CD,
    MAX(t.RBC_CODE)            AS RBC_CODE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- OPTIONAL system filter:
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- Merge measures + KDEs at same grain
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    m.SOURCE_SYSTEM_BALANCE,
    a.PD_GRADE,
    a.NON_ACCRUAL_FLAG,
    a.DAYS_PAST_DUE,
    a.MATURITY_DATE,
    a.RISK_UNIT,
    a.FDIC_CALL_CODE,
    a.LIFESTAGE,
    a.NICHE_CD,
    a.RBC_CODE
  FROM measures m
  LEFT JOIN attr a
    ON a.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY            = m.ACCOUNT_KEY
),

-- Compute prior values and balance deltas (for impact context only)
chg AS (
  SELECT
    b.*,
    LAG(b.END_OF_MONTH_DATE)     OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(b.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_SSB,

    LAG(b.PD_GRADE)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_PD_GRADE,
    LAG(b.NON_ACCRUAL_FLAG)   OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NON_ACCRUAL_FLAG,
    LAG(b.DAYS_PAST_DUE)      OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_DAYS_PAST_DUE,
    LAG(b.MATURITY_DATE)      OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE,
    LAG(b.RISK_UNIT)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RISK_UNIT,
    LAG(b.FDIC_CALL_CODE)     OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_FDIC_CALL_CODE,
    LAG(b.LIFESTAGE)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_LIFESTAGE,
    LAG(b.NICHE_CD)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NICHE_CD,
    LAG(b.RBC_CODE)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RBC_CODE
  FROM base b
),

-- Keep only rows that have a prior month
delta AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.PREV_EOM,
    c.CONTRACT_SOURCE_SYSTEM,
    c.ACCOUNT_KEY,

    -- balances for impact scoring (not for triggering)
    c.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    c.PREV_SSB,
    (COALESCE(c.SOURCE_SYSTEM_BALANCE,0) - COALESCE(c.PREV_SSB,0)) AS DELTA_DOLLAR,
    CASE WHEN c.PREV_SSB IS NULL OR c.PREV_SSB = 0 THEN NULL
         ELSE ((c.SOURCE_SYSTEM_BALANCE - c.PREV_SSB) / c.PREV_SSB) * 100 END AS DELTA_PCT,

    -- KDEs: current/prior
    c.PD_GRADE,             c.PREV_PD_GRADE,
    c.NON_ACCRUAL_FLAG,     c.PREV_NON_ACCRUAL_FLAG,
    c.DAYS_PAST_DUE,        c.PREV_DAYS_PAST_DUE,
    c.MATURITY_DATE,        c.PREV_MATURITY_DATE,
    c.RISK_UNIT,            c.PREV_RISK_UNIT,
    c.FDIC_CALL_CODE,       c.PREV_FDIC_CALL_CODE,
    c.LIFESTAGE,            c.PREV_LIFESTAGE,
    c.NICHE_CD,             c.PREV_NICHE_CD,
    c.RBC_CODE,             c.PREV_RBC_CODE
  FROM chg c
  WHERE c.PREV_EOM IS NOT NULL
),

-- ==========================================
-- UNPIVOT: one row per KDE change (9 UNIONs)
-- ==========================================
kde_changes AS (
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'PD_GRADE' AS KDE,
         CAST(PREV_PD_GRADE AS VARCHAR(200)) AS PREV_VAL,
         CAST(PD_GRADE       AS VARCHAR(200)) AS CURR_VAL,
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (PD_GRADE <> PREV_PD_GRADE)
       OR (PD_GRADE IS NULL AND PREV_PD_GRADE IS NOT NULL)
       OR (PD_GRADE IS NOT NULL AND PREV_PD_GRADE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'NON_ACCRUAL_FLAG',
         CAST(PREV_NON_ACCRUAL_FLAG AS VARCHAR(200)),
         CAST(NON_ACCRUAL_FLAG      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (NON_ACCRUAL_FLAG <> PREV_NON_ACCRUAL_FLAG)
       OR (NON_ACCRUAL_FLAG IS NULL AND PREV_NON_ACCRUAL_FLAG IS NOT NULL)
       OR (NON_ACCRUAL_FLAG IS NOT NULL AND PREV_NON_ACCRUAL_FLAG IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'DAYS_PAST_DUE',
         CAST(PREV_DAYS_PAST_DUE AS VARCHAR(200)),
         CAST(DAYS_PAST_DUE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (DAYS_PAST_DUE <> PREV_DAYS_PAST_DUE)
       OR (DAYS_PAST_DUE IS NULL AND PREV_DAYS_PAST_DUE IS NOT NULL)
       OR (DAYS_PAST_DUE IS NOT NULL AND PREV_DAYS_PAST_DUE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'MATURITY_DATE',
         CAST(PREV_MATURITY_DATE AS VARCHAR(200)),
         CAST(MATURITY_DATE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (MATURITY_DATE <> PREV_MATURITY_DATE)
       OR (MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL)
       OR (MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'RISK_UNIT',
         CAST(PREV_RISK_UNIT AS VARCHAR(200)),
         CAST(RISK_UNIT      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (RISK_UNIT <> PREV_RISK_UNIT)
       OR (RISK_UNIT IS NULL AND PREV_RISK_UNIT IS NOT NULL)
       OR (RISK_UNIT IS NOT NULL AND PREV_RISK_UNIT IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'FDIC_CALL_CODE',
         CAST(PREV_FDIC_CALL_CODE AS VARCHAR(200)),
         CAST(FDIC_CALL_CODE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (FDIC_CALL_CODE <> PREV_FDIC_CALL_CODE)
       OR (FDIC_CALL_CODE IS NULL AND PREV_FDIC_CALL_CODE IS NOT NULL)
       OR (FDIC_CALL_CODE IS NOT NULL AND PREV_FDIC_CALL_CODE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'LIFESTAGE',
         CAST(PREV_LIFESTAGE AS VARCHAR(200)),
         CAST(LIFESTAGE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (LIFESTAGE <> PREV_LIFESTAGE)
       OR (LIFESTAGE IS NULL AND PREV_LIFESTAGE IS NOT NULL)
       OR (LIFESTAGE IS NOT NULL AND PREV_LIFESTAGE IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'NICHE_CD',
         CAST(PREV_NICHE_CD AS VARCHAR(200)),
         CAST(NICHE_CD      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (NICHE_CD <> PREV_NICHE_CD)
       OR (NICHE_CD IS NULL AND PREV_NICHE_CD IS NOT NULL)
       OR (NICHE_CD IS NOT NULL AND PREV_NICHE_CD IS NULL) )

  UNION ALL
  SELECT END_OF_MONTH_DATE, PREV_EOM, CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
         'RBC_CODE',
         CAST(PREV_RBC_CODE AS VARCHAR(200)),
         CAST(RBC_CODE      AS VARCHAR(200)),
         DELTA_DOLLAR, DELTA_PCT, CURR_SSB, PREV_SSB
  FROM delta
  WHERE ( (RBC_CODE <> PREV_RBC_CODE)
       OR (RBC_CODE IS NULL AND PREV_RBC_CODE IS NOT NULL)
       OR (RBC_CODE IS NOT NULL AND PREV_RBC_CODE IS NULL) )
),

-- Rolling z-score on $ delta per acct+system (computed on change rows)
with_z AS (
  SELECT
    k.*,
    AVG(DELTA_DOLLAR) OVER (
      PARTITION BY ACCOUNT_KEY, CONTRACT_SOURCE_SYSTEM
      ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_avg_12,
    STDDEV_SAMP(DELTA_DOLLAR) OVER (
      PARTITION BY ACCOUNT_KEY, CONTRACT_SOURCE_SYSTEM
      ORDER BY END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_std_12
  FROM kde_changes k
),

scored AS (
  SELECT
    w.*,
    CASE WHEN w.delta_std_12 IS NULL OR w.delta_std_12 = 0
         THEN NULL
         ELSE (w.DELTA_DOLLAR - w.delta_avg_12) / w.delta_std_12
    END AS DELTA_Z_12,

    /* Impact score (0..~5):
       - $: normalized by anchor, capped @1
       - %: normalized by anchor, capped @1
       - z: |z| capped @3
    */
    LEAST(1.0, ABS(w.DELTA_DOLLAR) / (SELECT dollar_anchor FROM params)) +
    LEAST(1.0, COALESCE(ABS(w.DELTA_PCT)/100.0, 0.0) / (SELECT pct_anchor FROM params)) +
    LEAST(3.0, ABS(COALESCE(
        CASE WHEN w.delta_std_12 IS NULL OR w.delta_std_12 = 0 THEN NULL
             ELSE (w.DELTA_DOLLAR - w.delta_avg_12) / w.delta_std_12
        END, 0.0))
    ) AS impact_score
  FROM with_z w
)

-- ======================================================
-- B) Most-recent-month KDE-change "suspects" (default)
--    Sort by impact_score, then $ move.
-- ======================================================
SELECT
  s.END_OF_MONTH_DATE,
  s.CONTRACT_SOURCE_SYSTEM,
  s.ACCOUNT_KEY,
  s.KDE,
  s.PREV_VAL,
  s.CURR_VAL,
  s.CURR_SSB, s.PREV_SSB,
  s.DELTA_DOLLAR, s.DELTA_PCT, s.DELTA_Z_12,
  ROUND(s.impact_score, 3) AS impact_score
FROM scored s
WHERE s.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
ORDER BY impact_score DESC, ABS(DELTA_DOLLAR) DESC, KDE, ACCOUNT_KEY;

/* ======================================================
-- A) Full 12-month KDE change log (uncomment to use)
SELECT
  END_OF_MONTH_DATE, PREV_EOM,
  CONTRACT_SOURCE_SYSTEM, ACCOUNT_KEY,
  KDE, PREV_VAL, CURR_VAL,
  CURR_SSB, PREV_SSB, DELTA_DOLLAR, DELTA_PCT, DELTA_Z_12,
  ROUND(impact_score, 3) AS impact_score
FROM scored
ORDER BY END_OF_MONTH_DATE DESC, impact_score DESC, KDE, ACCOUNT_KEY;
====================================================== */





-- =========================================
-- Params (edit anchors/weights to taste)
-- =========================================
WITH params AS (
  SELECT
    'Total Loans'       AS target_lvl4,     -- GL layer filter (optional)
    12                  AS months_back,     -- lookback window for changes
    1000000.0::FLOAT8   AS dollar_anchor,   -- $ scale: ~$1M => full 25 pts
    0.20::FLOAT8        AS pct_anchor,      -- % scale: 20% => full 25 pts
    5.0::FLOAT8         AS w_na_flip,       -- KDE weights (max sum = 22)
    4.0::FLOAT8         AS w_rc_code,
    3.0::FLOAT8         AS w_gl_l4,
    3.0::FLOAT8         AS w_gl_code,
    1.0::FLOAT8         AS w_gl_desc,
    3.0::FLOAT8         AS w_facility,
    2.0::FLOAT8         AS w_status_desc,
    1.0::FLOAT8         AS w_maturity
),

-- Latest month and window start (need 13 months to compute 12 deltas)
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(l.max_eom, -(SELECT months_back FROM params)) AS start_eom,
         l.max_eom AS max_eom
  FROM latest l
),

-- =========================================
-- Measures per (account_key, system, month)
-- =========================================
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Optional: limit to research systems
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- =========================================
-- KDE attributes per (account_key, system, month)
-- Use MAX() assuming single-valued per acct/month; safe & fast.
-- If attributes can vary within month, switch to ROW_NUMBER() snapshot.
-- =========================================
attr AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,
    MAX(t.FACILITY_ID)              AS FACILITY_ID,
    MAX(t.RC_CODE)                  AS RC_CODE,
    MAX(t.RC_DESCRIPTION)           AS RC_DESCRIPTION,
    MAX(t.GL_ACCOUNT_HIER_LEVEL_4)  AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(t.GL_ACCOUNT_CODE)          AS GL_ACCOUNT_CODE,
    MAX(t.GL_ACCOUNT_DESCRIPTION)   AS GL_ACCOUNT_DESCRIPTION,
    MAX(t.NON_ACCRUAL_FLAG)         AS NON_ACCRUAL_FLAG,
    MAX(t.STATUS_CODE_DESCRIPTION)  AS STATUS_CODE_DESCRIPTION,
    MAX(t.MATURITY_DATE)            AS MATURITY_DATE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Optional: same system filter as measures
    -- AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')
  GROUP BY 1,2,3
),

-- Base: measures + attributes at same grain
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,
    -- KDEs
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,
    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr a
    ON a.END_OF_MONTH_DATE      = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY            = m.ACCOUNT_KEY
),

-- =========================================
-- Compute MoM prev values and change flags
-- =========================================
changes AS (
  SELECT
    b.*,
    LAG(b.END_OF_MONTH_DATE)        OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_EOM,
    LAG(b.SOURCE_SYSTEM_BALANCE)    OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_SSB,
    LAG(b.FACILITY_ID)              OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_FACILITY_ID,
    LAG(b.RC_CODE)                  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RC_CODE,
    LAG(b.RC_DESCRIPTION)           OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_RC_DESCRIPTION,
    LAG(b.GL_ACCOUNT_HIER_LEVEL_4)  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_L4,
    LAG(b.GL_ACCOUNT_CODE)          OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_CODE,
    LAG(b.GL_ACCOUNT_DESCRIPTION)   OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_GL_DESC,
    LAG(b.NON_ACCRUAL_FLAG)         OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_NA_FLAG,
    LAG(b.STATUS_CODE_DESCRIPTION)  OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_STATUS_DESC,
    LAG(b.MATURITY_DATE)            OVER (PARTITION BY b.ACCOUNT_KEY, b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS PREV_MATURITY_DATE
  FROM base b
),

-- Only rows that have a prior month within window
delta AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.ACCOUNT_KEY,

    -- Current values
    c.SOURCE_SYSTEM_BALANCE AS CURR_SSB,
    c.FACILITY_ID           AS CURR_FACILITY_ID,
    c.RC_CODE               AS CURR_RC_CODE,
    c.RC_DESCRIPTION        AS CURR_RC_DESCRIPTION,
    c.GL_ACCOUNT_HIER_LEVEL_4 AS CURR_GL_L4,
    c.GL_ACCOUNT_CODE       AS CURR_GL_CODE,
    c.GL_ACCOUNT_DESCRIPTION AS CURR_GL_DESC,
    c.NON_ACCRUAL_FLAG      AS CURR_NA_FLAG,
    c.STATUS_CODE_DESCRIPTION AS CURR_STATUS_DESC,
    c.MATURITY_DATE         AS CURR_MATURITY_DATE,

    -- Prior values
    c.PREV_EOM,
    c.PREV_SSB,
    c.PREV_FACILITY_ID,
    c.PREV_RC_CODE,
    c.PREV_RC_DESCRIPTION,
    c.PREV_GL_L4,
    c.PREV_GL_CODE,
    c.PREV_GL_DESC,
    c.PREV_NA_FLAG,
    c.PREV_STATUS_DESC,
    c.PREV_MATURITY_DATE,

    -- $ and % deltas
    (COALESCE(c.SOURCE_SYSTEM_BALANCE,0) - COALESCE(c.PREV_SSB,0)) AS DELTA_DOLLAR,
    CASE WHEN c.PREV_SSB IS NULL OR c.PREV_SSB = 0
         THEN NULL
         ELSE ((c.SOURCE_SYSTEM_BALANCE - c.PREV_SSB) / c.PREV_SSB) * 100
    END AS DELTA_PCT,

    -- KDE change flags (null-safe comparisons)
    CASE WHEN (c.CURR_FACILITY_ID <> c.PREV_FACILITY_ID)
        OR (c.CURR_FACILITY_ID IS NULL AND c.PREV_FACILITY_ID IS NOT NULL)
        OR (c.CURR_FACILITY_ID IS NOT NULL AND c.PREV_FACILITY_ID IS NULL) THEN 1 ELSE 0 END AS CHG_FACILITY,

    CASE WHEN (c.CURR_RC_CODE <> c.PREV_RC_CODE)
        OR (c.CURR_RC_CODE IS NULL AND c.PREV_RC_CODE IS NOT NULL)
        OR (c.CURR_RC_CODE IS NOT NULL AND c.PREV_RC_CODE IS NULL) THEN 1 ELSE 0 END AS CHG_RC_CODE,

    CASE WHEN (c.CURR_GL_L4 <> c.PREV_GL_L4)
        OR (c.CURR_GL_L4 IS NULL AND c.PREV_GL_L4 IS NOT NULL)
        OR (c.CURR_GL_L4 IS NOT NULL AND c.PREV_GL_L4 IS NULL) THEN 1 ELSE 0 END AS CHG_GL_L4,

    CASE WHEN (c.CURR_GL_CODE <> c.PREV_GL_CODE)
        OR (c.CURR_GL_CODE IS NULL AND c.PREV_GL_CODE IS NOT NULL)
        OR (c.CURR_GL_CODE IS NOT NULL AND c.PREV_GL_CODE IS NULL) THEN 1 ELSE 0 END AS CHG_GL_CODE,

    CASE WHEN (c.CURR_GL_DESC <> c.PREV_GL_DESC)
        OR (c.CURR_GL_DESC IS NULL AND c.PREV_GL_DESC IS NOT NULL)
        OR (c.CURR_GL_DESC IS NOT NULL AND c.PREV_GL_DESC IS NULL) THEN 1 ELSE 0 END AS CHG_GL_DESC,

    CASE WHEN (c.CURR_NA_FLAG <> c.PREV_NA_FLAG)
        OR (c.CURR_NA_FLAG IS NULL AND c.PREV_NA_FLAG IS NOT NULL)
        OR (c.CURR_NA_FLAG IS NOT NULL AND c.PREV_NA_FLAG IS NULL) THEN 1 ELSE 0 END AS CHG_NON_ACCRUAL,

    CASE WHEN (c.CURR_STATUS_DESC <> c.PREV_STATUS_DESC)
        OR (c.CURR_STATUS_DESC IS NULL AND c.PREV_STATUS_DESC IS NOT NULL)
        OR (c.CURR_STATUS_DESC IS NOT NULL AND c.PREV_STATUS_DESC IS NULL) THEN 1 ELSE 0 END AS CHG_STATUS_DESC,

    CASE WHEN (c.CURR_MATURITY_DATE <> c.PREV_MATURITY_DATE)
        OR (c.CURR_MATURITY_DATE IS NULL AND c.PREV_MATURITY_DATE IS NOT NULL)
        OR (c.CURR_MATURITY_DATE IS NOT NULL AND c.PREV_MATURITY_DATE IS NULL) THEN 1 ELSE 0 END AS CHG_MATURITY
  FROM changes c
  WHERE c.PREV_EOM IS NOT NULL
),

-- =========================================
-- Severity scoring and rolling Z-score
-- =========================================
scored AS (
  SELECT
    d.*,
    -- Monetary subscore (0..50): 25 from $ move, 25 from % move (anchors cap)
    (CASE
       WHEN ABS(d.DELTA_DOLLAR) >= (SELECT dollar_anchor FROM params)
       THEN 25.0
       ELSE 25.0 * (ABS(d.DELTA_DOLLAR) / (SELECT dollar_anchor FROM params))
     END)
    +
    (CASE
       WHEN d.DELTA_PCT IS NULL THEN 0.0
       WHEN ABS(d.DELTA_PCT)/100.0 >= (SELECT pct_anchor FROM params)
       THEN 25.0
       ELSE 25.0 * ((ABS(d.DELTA_PCT)/100.0) / (SELECT pct_anchor FROM params))
     END)                                        AS monetary_score_0_50,

    -- KDE subscore (0..50): scale sum of weights by max sum (22)
    50.0 * (
      (d.CHG_NON_ACCRUAL * (SELECT w_na_flip      FROM params)) +
      (d.CHG_RC_CODE     * (SELECT w_rc_code      FROM params)) +
      (d.CHG_GL_L4       * (SELECT w_gl_l4        FROM params)) +
      (d.CHG_GL_CODE     * (SELECT w_gl_code      FROM params)) +
      (d.CHG_GL_DESC     * (SELECT w_gl_desc      FROM params)) +
      (d.CHG_FACILITY    * (SELECT w_facility     FROM params)) +
      (d.CHG_STATUS_DESC * (SELECT w_status_desc  FROM params)) +
      (d.CHG_MATURITY    * (SELECT w_maturity     FROM params))
    ) / 22.0                                      AS kde_score_0_50,

    -- Rolling 12 (including current) Z-score of $ delta per acct+system
    AVG(d.DELTA_DOLLAR) OVER (
      PARTITION BY d.ACCOUNT_KEY, d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_avg_12,
    STDDEV_SAMP(d.DELTA_DOLLAR) OVER (
      PARTITION BY d.ACCOUNT_KEY, d.CONTRACT_SOURCE_SYSTEM
      ORDER BY d.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS delta_std_12
  FROM delta d
),

final AS (
  SELECT
    s.*,
    CASE
      WHEN s.delta_std_12 IS NULL OR s.delta_std_12 = 0 THEN NULL
      ELSE (s.DELTA_DOLLAR - s.delta_avg_12) / s.delta_std_12
    END AS delta_z_12,
    ROUND(s.monetary_score_0_50 + s.kde_score_0_50, 1) AS severity_0_100,

    -- Compact list of changed KDEs
    TRIM(BOTH ',' FROM
      (CASE WHEN CHG_NON_ACCRUAL = 1 THEN ',NON_ACCRUAL' ELSE '' END) ||
      (CASE WHEN CHG_RC_CODE     = 1 THEN ',RC_CODE'     ELSE '' END) ||
      (CASE WHEN CHG_GL_L4       = 1 THEN ',GL_L4'       ELSE '' END) ||
      (CASE WHEN CHG_GL_CODE     = 1 THEN ',GL_CODE'     ELSE '' END) ||
      (CASE WHEN CHG_GL_DESC     = 1 THEN ',GL_DESC'     ELSE '' END) ||
      (CASE WHEN CHG_FACILITY    = 1 THEN ',FACILITY'    ELSE '' END) ||
      (CASE WHEN CHG_STATUS_DESC = 1 THEN ',STATUS'      ELSE '' END) ||
      (CASE WHEN CHG_MATURITY    = 1 THEN ',MATURITY'    ELSE '' END)
    ) AS changed_fields
  FROM scored s
)

SELECT
  END_OF_MONTH_DATE, PREV_EOM,
  CONTRACT_SOURCE_SYSTEM,
  ACCOUNT_KEY,

  -- Balance context
  PREV_SSB, CURR_SSB,
  DELTA_DOLLAR, DELTA_PCT, delta_z_12,

  -- KDE old/new (curr shown here; join back to attr if you also want explicit prev text values)
  CURR_RC_CODE, CURR_RC_DESCRIPTION,
  CURR_GL_L4,   CURR_GL_CODE, CURR_GL_DESC,
  CURR_FACILITY_ID, CURR_STATUS_DESC, CURR_NA_FLAG, CURR_MATURITY_DATE,

  -- KDE flags
  CHG_RC_CODE, CHG_GL_L4, CHG_GL_CODE, CHG_GL_DESC,
  CHG_FACILITY, CHG_STATUS_DESC, CHG_NON_ACCRUAL, CHG_MATURITY,
  changed_fields,

  -- Scores
  ROUND(monetary_score_0_50, 1) AS monetary_score_0_50,
  ROUND(kde_score_0_50, 1)      AS kde_score_0_50,
  severity_0_100

FROM final
-- Focus on real movement or any KDE change; comment WHERE to see all rows
WHERE (COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0))
   OR (CHG_RC_CODE + CHG_GL_L4 + CHG_GL_CODE + CHG_GL_DESC
     + CHG_FACILITY + CHG_STATUS_DESC + CHG_NON_ACCRUAL + CHG_MATURITY) > 0
ORDER BY severity_0_100 DESC, ABS(DELTA_DOLLAR) DESC, END_OF_MONTH_DATE DESC;








/* 2) Snapshot ATTRIBUTES per (account, month) — no UPDATE_TS/LOAD_TS needed */
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,

      -- Attributes you want
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,

      -- Heuristic tie-breaker: prefer rows that are more "material"/informative
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY
          CASE WHEN t.NON_ACCRUAL_FLAG = 'Y' THEN 1 ELSE 0 END DESC,
          COALESCE(t.GL_BALANCE,0)           DESC,
          COALESCE(t.COMMITMENT_BALANCE,0)   DESC,
          COALESCE(t.AVAILABLE_BALANCE,0)    DESC,
          COALESCE(t.MATURITY_DATE, DATE '1900-01-01') DESC,
          t.RC_CODE,
          t.GL_ACCOUNT_CODE
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN ('L-FCB_CORE','L-CIT_CORE','L-SVB_CORE')  -- edit
  ) s
  WHERE rn = 1
)






-- ========= Parameters you edit =========
-- Put the systems you want to research here
WITH params AS (
  SELECT 'Total Loans' AS target_lvl4
),

latest_month AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
  FROM latest_month
),

/* 1) Aggregate MEASURES per (account, system, month) */
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,                 -- << unique id
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN latest_month lm
  CROSS JOIN prior_month pm
  WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    AND t.CONTRACT_SOURCE_SYSTEM IN (
      'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
    )
  GROUP BY 1,2,3
),

/* 2) Snapshot ATTRIBUTES per (account, month) */
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,
      -- Attributes
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,
      -- Tiebreakers (avoid NULLS LAST; prefer explicit null handling)
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY
          CASE WHEN t.UPDATE_TS IS NULL THEN 1 ELSE 0 END, t.UPDATE_TS DESC,
          CASE WHEN t.LOAD_TS   IS NULL THEN 1 ELSE 0 END, t.LOAD_TS   DESC
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN (
        'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
      )
  ) s
  WHERE rn = 1
),

/* 3) Join measures + attributes */
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,

    -- Attributes
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,

    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr_snapshot a
    ON a.END_OF_MONTH_DATE       = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM  = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY             = m.ACCOUNT_KEY
),

/* 4) Tag current vs prior */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN 'CURR' ELSE 'PREV' END AS tag
  FROM base b
),

/* 5) Pivot to prev/curr and compute deltas/flags */
final_pivot AS (
  SELECT
    t.ACCOUNT_KEY,
    t.CONTRACT_SOURCE_SYSTEM,

    -- attributes: take CURR view; keep PREV for change flags
    MAX(CASE WHEN tag='CURR' THEN FACILITY_ID    END) AS CURR_FACILITY_ID,
    MAX(CASE WHEN tag='PREV' THEN FACILITY_ID    END) AS PREV_FACILITY_ID,

    MAX(CASE WHEN tag='CURR' THEN RC_CODE        END) AS RC_CODE,
    MAX(CASE WHEN tag='CURR' THEN RC_DESCRIPTION END) AS RC_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_HIER_LEVEL_4 END) AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_CODE END) AS GL_ACCOUNT_CODE,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_DESCRIPTION END) AS GL_ACCOUNT_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN NON_ACCRUAL_FLAG END) AS NON_ACCRUAL_FLAG,
    MAX(CASE WHEN tag='CURR' THEN STATUS_CODE_DESCRIPTION END) AS STATUS_CODE_DESCRIPTION,

    MAX(CASE WHEN tag='CURR' THEN MATURITY_DATE END) AS CURR_MATURITY_DATE,
    MAX(CASE WHEN tag='PREV' THEN MATURITY_DATE END) AS PREV_MATURITY_DATE,

    -- measures: keep prev/curr for key balances
    MAX(CASE WHEN tag='CURR' THEN SOURCE_SYSTEM_BALANCE END) AS CURR_SSB,
    MAX(CASE WHEN tag='PREV' THEN SOURCE_SYSTEM_BALANCE END) AS PREV_SSB,

    MAX(CASE WHEN tag='CURR' THEN GL_BALANCE END) AS CURR_GL_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN GL_BALANCE END) AS PREV_GL_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN AVAILABLE_BALANCE END) AS CURR_AVAILABLE_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN AVAILABLE_BALANCE END) AS PREV_AVAILABLE_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN COMMITMENT_BALANCE END) AS CURR_COMMITMENT_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN COMMITMENT_BALANCE END) AS PREV_COMMITMENT_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN CHARGE_OFF_AMOUNT_ITD END) AS CURR_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN CHARGE_OFF_AMOUNT_ITD END) AS PREV_CHARGE_OFF_ITD,

    MAX(CASE WHEN tag='CURR' THEN RECOVERY_AMOUNT_ITD END) AS CURR_RECOVERY_ITD,
    MAX(CASE WHEN tag='PREV' THEN RECOVERY_AMOUNT_ITD END) AS PREV_RECOVERY_ITD,

    MAX(CASE WHEN tag='CURR' THEN NET_CHARGE_OFF_ITD END) AS CURR_NET_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN NET_CHARGE_OFF_ITD END) AS PREV_NET_CHARGE_OFF_ITD
  FROM tagged t
  GROUP BY t.ACCOUNT_KEY, t.CONTRACT_SOURCE_SYSTEM
)

SELECT
  ACCOUNT_KEY,
  CONTRACT_SOURCE_SYSTEM,

  -- attributes (current view)
  RC_CODE,
  RC_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  NON_ACCRUAL_FLAG,
  STATUS_CODE_DESCRIPTION,

  -- facility & maturity (with change flags; null-safe comparisons)
  PREV_FACILITY_ID,
  CURR_FACILITY_ID,
  CASE
    WHEN (CURR_FACILITY_ID <> PREV_FACILITY_ID)
       OR (CURR_FACILITY_ID IS NULL AND PREV_FACILITY_ID IS NOT NULL)
       OR (CURR_FACILITY_ID IS NOT NULL AND PREV_FACILITY_ID IS NULL)
    THEN 1 ELSE 0 END AS FACILITY_CHANGED,

  PREV_MATURITY_DATE,
  CURR_MATURITY_DATE,
  CASE
    WHEN (CURR_MATURITY_DATE <> PREV_MATURITY_DATE)
       OR (CURR_MATURITY_DATE IS NULL AND PREV_MATURITY_DATE IS NOT NULL)
       OR (CURR_MATURITY_DATE IS NOT NULL AND PREV_MATURITY_DATE IS NULL)
    THEN 1 ELSE 0 END AS MATURITY_CHANGED,

  -- measures (prev/curr for the main balances)
  PREV_SSB  AS PREV_SOURCE_SYSTEM_BALANCE,
  CURR_SSB  AS CURR_SOURCE_SYSTEM_BALANCE,
  (COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0))                       AS MOM_SSB_DELTA_DOLLAR,
  CASE WHEN PREV_SSB IS NULL OR PREV_SSB = 0 THEN NULL
       ELSE ((CURR_SSB - PREV_SSB) / PREV_SSB) * 100 END              AS MOM_SSB_DELTA_PCT,

  PREV_GL_BALANCE,
  CURR_GL_BALANCE,

  PREV_AVAILABLE_BALANCE,
  CURR_AVAILABLE_BALANCE,

  PREV_COMMITMENT_BALANCE,
  CURR_COMMITMENT_BALANCE,

  -- ITD metrics (prev/curr)
  PREV_CHARGE_OFF_ITD,
  CURR_CHARGE_OFF_ITD,
  PREV_RECOVERY_ITD,
  CURR_RECOVERY_ITD,
  PREV_NET_CHARGE_OFF_ITD,
  CURR_NET_CHARGE_OFF_ITD,

  -- Account status classification based on SSB visibility
  CASE
    WHEN PREV_SSB IS NULL AND CURR_SSB IS NOT NULL THEN 'NEW'
    WHEN PREV_SSB IS NOT NULL AND CURR_SSB IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
  END AS ACCOUNT_STATUS

FROM final_pivot
-- Only keep movers (by SSB). Remove WHERE if you want everything.
WHERE COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0)
ORDER BY ABS(COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0)) DESC;






-- ========= Parameters you edit =========
-- Put the systems you want to research here
-- Example: 'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'
WITH params AS (
  SELECT
    'Total Loans'::VARCHAR(100) AS target_lvl4
),

latest_month AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
  SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
  FROM latest_month
),

/* 1) Aggregate MEASURES per (account, system, month).
      Use sums to be robust if multiple rows exist per account/month.
*/
measures AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.ACCOUNT_KEY,                 -- << unique id
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(t.GL_BALANCE)           AS FLOAT8) AS GL_BALANCE,
    CAST(SUM(t.AVAILABLE_BALANCE)    AS FLOAT8) AS AVAILABLE_BALANCE,
    CAST(SUM(t.COMMITMENT_BALANCE)   AS FLOAT8) AS COMMITMENT_BALANCE,
    CAST(SUM(t.CHARGE_OFF_AMOUNT_ITD) AS FLOAT8) AS CHARGE_OFF_AMOUNT_ITD,
    CAST(SUM(t.RECOVERY_AMOUNT_ITD)   AS FLOAT8) AS RECOVERY_AMOUNT_ITD,
    CAST(SUM(t.NET_CHARGE_OFF_ITD)    AS FLOAT8) AS NET_CHARGE_OFF_ITD
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN latest_month lm
  CROSS JOIN prior_month pm
  -- Pull only the two months we care about
  WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
    -- OPTIONAL: narrow to total-loans layer; keep or remove as needed
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
    -- Keep only the systems you want to research
    AND t.CONTRACT_SOURCE_SYSTEM IN (
      'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
    )
  GROUP BY 1,2,3
),

/* 2) Snapshot ATTRIBUTES per (account, month).
      Choose one "best" row per account/month to source attributes from,
      avoiding GROUP BY on every attribute.
*/
attr_snapshot AS (
  SELECT *
  FROM (
    SELECT
      t.END_OF_MONTH_DATE,
      t.CONTRACT_SOURCE_SYSTEM,
      t.ACCOUNT_KEY,                              -- << unique id
      -- Attributes you asked for (non-aggregated)
      t.FACILITY_ID,
      t.RC_CODE,
      t.RC_DESCRIPTION,
      t.GL_ACCOUNT_HIER_LEVEL_4,
      t.GL_ACCOUNT_CODE,
      t.GL_ACCOUNT_DESCRIPTION,
      t.NON_ACCRUAL_FLAG,
      t.STATUS_CODE_DESCRIPTION,
      t.MATURITY_DATE,
      -- Tiebreakers to pick the most recent/authoritative row
      ROW_NUMBER() OVER (
        PARTITION BY t.ACCOUNT_KEY, t.END_OF_MONTH_DATE
        ORDER BY t.UPDATE_TS DESC NULLS LAST, t.LOAD_TS DESC NULLS LAST, t.ROWID DESC
      ) AS rn
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = (SELECT target_lvl4 FROM params)
      AND t.CONTRACT_SOURCE_SYSTEM IN (
        'L-FCB_CORE','L-CIT_CORE','L-SVB_CORE'   -- << edit list
      )
  ) s
  WHERE rn = 1
),

/* 3) Join measures + attributes at the same grain (account, system, month). */
base AS (
  SELECT
    m.END_OF_MONTH_DATE,
    m.CONTRACT_SOURCE_SYSTEM,
    m.ACCOUNT_KEY,

    -- Attributes (from snapshot)
    a.FACILITY_ID,
    a.RC_CODE,
    a.RC_DESCRIPTION,
    a.GL_ACCOUNT_HIER_LEVEL_4,
    a.GL_ACCOUNT_CODE,
    a.GL_ACCOUNT_DESCRIPTION,
    a.NON_ACCRUAL_FLAG,
    a.STATUS_CODE_DESCRIPTION,
    a.MATURITY_DATE,

    -- Measures
    m.SOURCE_SYSTEM_BALANCE,
    m.GL_BALANCE,
    m.AVAILABLE_BALANCE,
    m.COMMITMENT_BALANCE,
    m.CHARGE_OFF_AMOUNT_ITD,
    m.RECOVERY_AMOUNT_ITD,
    m.NET_CHARGE_OFF_ITD
  FROM measures m
  LEFT JOIN attr_snapshot a
    ON a.END_OF_MONTH_DATE       = m.END_OF_MONTH_DATE
   AND a.CONTRACT_SOURCE_SYSTEM  = m.CONTRACT_SOURCE_SYSTEM
   AND a.ACCOUNT_KEY             = m.ACCOUNT_KEY
),

/* 4) Tag current vs prior to enable clean pivoting. */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN 'CURR' ELSE 'PREV' END AS tag
  FROM base b
),

/* 5) Pivot to prev/curr columns and compute deltas and flags. */
final_pivot AS (
  SELECT
    t.ACCOUNT_KEY,
    t.CONTRACT_SOURCE_SYSTEM,

    -- attributes: take CURR view by default; also keep prev for change flags
    MAX(CASE WHEN tag='CURR' THEN FACILITY_ID    END) AS CURR_FACILITY_ID,
    MAX(CASE WHEN tag='PREV' THEN FACILITY_ID    END) AS PREV_FACILITY_ID,

    MAX(CASE WHEN tag='CURR' THEN RC_CODE        END) AS RC_CODE,
    MAX(CASE WHEN tag='CURR' THEN RC_DESCRIPTION END) AS RC_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_HIER_LEVEL_4 END) AS GL_ACCOUNT_HIER_LEVEL_4,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_CODE END) AS GL_ACCOUNT_CODE,
    MAX(CASE WHEN tag='CURR' THEN GL_ACCOUNT_DESCRIPTION END) AS GL_ACCOUNT_DESCRIPTION,
    MAX(CASE WHEN tag='CURR' THEN NON_ACCRUAL_FLAG END) AS NON_ACCRUAL_FLAG,
    MAX(CASE WHEN tag='CURR' THEN STATUS_CODE_DESCRIPTION END) AS STATUS_CODE_DESCRIPTION,

    MAX(CASE WHEN tag='CURR' THEN MATURITY_DATE END) AS CURR_MATURITY_DATE,
    MAX(CASE WHEN tag='PREV' THEN MATURITY_DATE END) AS PREV_MATURITY_DATE,

    -- measures: keep prev/curr for key balances
    MAX(CASE WHEN tag='CURR' THEN SOURCE_SYSTEM_BALANCE END) AS CURR_SSB,
    MAX(CASE WHEN tag='PREV' THEN SOURCE_SYSTEM_BALANCE END) AS PREV_SSB,

    MAX(CASE WHEN tag='CURR' THEN GL_BALANCE END) AS CURR_GL_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN GL_BALANCE END) AS PREV_GL_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN AVAILABLE_BALANCE END) AS CURR_AVAILABLE_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN AVAILABLE_BALANCE END) AS PREV_AVAILABLE_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN COMMITMENT_BALANCE END) AS CURR_COMMITMENT_BALANCE,
    MAX(CASE WHEN tag='PREV' THEN COMMITMENT_BALANCE END) AS PREV_COMMITMENT_BALANCE,

    MAX(CASE WHEN tag='CURR' THEN CHARGE_OFF_AMOUNT_ITD END) AS CURR_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN CHARGE_OFF_AMOUNT_ITD END) AS PREV_CHARGE_OFF_ITD,

    MAX(CASE WHEN tag='CURR' THEN RECOVERY_AMOUNT_ITD END) AS CURR_RECOVERY_ITD,
    MAX(CASE WHEN tag='PREV' THEN RECOVERY_AMOUNT_ITD END) AS PREV_RECOVERY_ITD,

    MAX(CASE WHEN tag='CURR' THEN NET_CHARGE_OFF_ITD END) AS CURR_NET_CHARGE_OFF_ITD,
    MAX(CASE WHEN tag='PREV' THEN NET_CHARGE_OFF_ITD END) AS PREV_NET_CHARGE_OFF_ITD
  FROM tagged t
  GROUP BY t.ACCOUNT_KEY, t.CONTRACT_SOURCE_SYSTEM
)

SELECT
  ACCOUNT_KEY,
  CONTRACT_SOURCE_SYSTEM,

  -- attributes (current view)
  RC_CODE,
  RC_DESCRIPTION,
  GL_ACCOUNT_HIER_LEVEL_4,
  GL_ACCOUNT_CODE,
  GL_ACCOUNT_DESCRIPTION,
  NON_ACCRUAL_FLAG,
  STATUS_CODE_DESCRIPTION,

  -- facility & maturity (with change flags)
  PREV_FACILITY_ID,
  CURR_FACILITY_ID,
  CASE WHEN CURR_FACILITY_ID IS DISTINCT FROM PREV_FACILITY_ID THEN 1 ELSE 0 END AS FACILITY_CHANGED,

  PREV_MATURITY_DATE,
  CURR_MATURITY_DATE,
  CASE WHEN CURR_MATURITY_DATE IS DISTINCT FROM PREV_MATURITY_DATE THEN 1 ELSE 0 END AS MATURITY_CHANGED,

  -- measures (prev/curr for the main balances)
  PREV_SSB  AS PREV_SOURCE_SYSTEM_BALANCE,
  CURR_SSB  AS CURR_SOURCE_SYSTEM_BALANCE,
  (COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0))                       AS MOM_SSB_DELTA_DOLLAR,
  CASE WHEN PREV_SSB IS NULL OR PREV_SSB = 0 THEN NULL
       ELSE ((CURR_SSB - PREV_SSB) / PREV_SSB) * 100 END              AS MOM_SSB_DELTA_PCT,

  PREV_GL_BALANCE,
  CURR_GL_BALANCE,

  PREV_AVAILABLE_BALANCE,
  CURR_AVAILABLE_BALANCE,

  PREV_COMMITMENT_BALANCE,
  CURR_COMMITMENT_BALANCE,

  -- ITD metrics (prev/curr)
  PREV_CHARGE_OFF_ITD,
  CURR_CHARGE_OFF_ITD,
  PREV_RECOVERY_ITD,
  CURR_RECOVERY_ITD,
  PREV_NET_CHARGE_OFF_ITD,
  CURR_NET_CHARGE_OFF_ITD,

  -- Account status classification based on SSB visibility
  CASE
    WHEN PREV_SSB IS NULL AND CURR_SSB IS NOT NULL THEN 'NEW'
    WHEN PREV_SSB IS NOT NULL AND CURR_SSB IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
  END AS ACCOUNT_STATUS

FROM final_pivot
-- Only keep movers (by SSB). Remove HAVING if you want everything.
WHERE COALESCE(CURR_SSB,0) <> COALESCE(PREV_SSB,0)
ORDER BY ABS(COALESCE(CURR_SSB,0) - COALESCE(PREV_SSB,0)) DESC;







FACILITY_ID
GL_BALANCE,
AVAILABLE_BALANCE,
COMMITMENT_BALANCE,
RC_CODE,
RC_DESCRIPTION,
GL_ACCOUNT_HIER_LEVEL_4,
GL_ACCOUNT_HIER_LEVEL_4,
GL_ACCOUNT_CODE,
GL_ACCOUNT_DESCRIPTION,
CHARGE_OFF_AMOUNT_ITD,
RECOVERY_AMOUNT_ITD,
NET_CHARGE_OFF_ITD,
NON_ACCRUAL_FLAG





WITH latest_month AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
prior_month AS (
    SELECT ADD_MONTHS(max_eom, -1) AS prev_eom
    FROM latest_month
),

-- 1) Base pull for both months, now at ACCOUNT_IDENTIFIER granularity
base AS (
    SELECT
        t.END_OF_MONTH_DATE,
        t.CONTRACT_SOURCE_SYSTEM,
        t.ACCOUNT_IDENTIFIER,
        CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
        -- >>> PLACEHOLDER: Add additional fields here for research <<<
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN latest_month lm
    CROSS JOIN prior_month pm
    WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND t.END_OF_MONTH_DATE IN (lm.max_eom, pm.prev_eom)
      AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      AND t.CONTRACT_SOURCE_SYSTEM IN (
            -- List only the systems you want to research:
            'L-FCB_CORE', 'L-CIT_CORE', 'L-SVB_CORE'
      )
    GROUP BY 1,2,3
),

-- 2) Pivot into current/prior columns per account
pivoted AS (
    SELECT
        ACCOUNT_IDENTIFIER,
        CONTRACT_SOURCE_SYSTEM,
        MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT max_eom FROM latest_month) THEN SOURCE_SYSTEM_BALANCE END) AS CURR_BAL,
        MAX(CASE WHEN END_OF_MONTH_DATE = (SELECT prev_eom FROM prior_month) THEN SOURCE_SYSTEM_BALANCE END) AS PREV_BAL
    FROM base
    GROUP BY ACCOUNT_IDENTIFIER, CONTRACT_SOURCE_SYSTEM
)

-- 3) Final Output
SELECT
    ACCOUNT_IDENTIFIER,
    CONTRACT_SOURCE_SYSTEM,
    PREV_BAL,
    CURR_BAL,
    (CURR_BAL - PREV_BAL) AS MOM_CHANGE_DOLLAR,
    CASE 
        WHEN PREV_BAL = 0 THEN NULL
        ELSE ((CURR_BAL - PREV_BAL) / PREV_BAL) * 100
    END AS MOM_CHANGE_PCT
FROM pivoted
WHERE (CURR_BAL - PREV_BAL) <> 0 -- only show accounts with change
ORDER BY ABS(CURR_BAL - PREV_BAL) DESC;  -- biggest movers first



CASE 
    WHEN PREV_BAL IS NULL THEN 'NEW'
    WHEN CURR_BAL IS NULL THEN 'CLOSED'
    ELSE 'EXISTING'
END AS ACCOUNT_STATUS






=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_HISTORICAL_ERROR_MAIN",
    tblVariance[period_date],            EDATE([@period_date], -1)
  ),
"")





=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_HISTORICAL_ERROR_MAIN",
    tblVariance[period_date],            EDATE([@period_date],-1)
  ),
"")





=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               "SUMMARY_ANOMALY_DETECTION_MAIN",
    tblVariance[period_date],            EDATE([@period_date],-1)
  ),
"")




=EOMONTH(
  MAX( FILTER( tblVariance[period_date], ISNUMBER(tblVariance[period_date]) ) ),
0)


=EOMONTH(
  MAX(
    FILTER(
      tblVariance[period_date],
      (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
      ISNUMBER(tblVariance[period_date])
    )
  ),
0)




=LET(
  sys, [@CONTRACT_SOURCE_SYSTEM],
  dt,  [@period_date],
  val, SUMPRODUCT(
         (tblVariance[CONTRACT_SOURCE_SYSTEM]=sys) *
         ( (tblVariance[row_type]="HISTORY") + (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN") ) *
         (tblVariance[period_date]=EDATE(dt,-1)) *
         tblVariance[actual]
       ),
  IF(val=0,"",val)
)






=IFERROR(
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date], -1)
  ),
"")





=IF(
  COUNTIFS(
    tblVariance[CONTRACT_SOURCE_SYSTEM],[#This Row],[CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],              [#This Row],[row_type],
    tblVariance[period_date],           EDATE([#This Row],[period_date],-1)
  )=0,
  "",
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM],[#This Row],[CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],              [#This Row],[row_type],
    tblVariance[period_date],           EDATE([#This Row],[period_date],-1)
  )
)




=IF(
  COUNTIFS(
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date],-1)
  )=0,
  "",
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], [@CONTRACT_SOURCE_SYSTEM],
    tblVariance[row_type],               [@row_type],
    tblVariance[period_date],            EDATE([@period_date],-1)
  )
)






=LET(
  sys, [@CONTRACT_SOURCE_SYSTEM],
  dt,  [@period_date],
  SUMIFS(
    tblVariance[actual],
    tblVariance[CONTRACT_SOURCE_SYSTEM], sys,
    tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN",
    tblVariance[period_date], EDATE(dt,-1)
  )
)



=LET(
  prior, [@[Prior month actual]],
  IF(prior="","", [@actual] - prior)
)



=LET(
  prior, [@[Prior month actual]],
  IF(prior<=0,"", [@[MoM Change ($)]] / prior)
)








=XLOOKUP(1,(tblVariance[CONTRACT_SOURCE_SYSTEM]=C3)*(tblVariance[period_date]=C2)*(tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN"),tblVariance[outside_95_band])







=SUMPRODUCT(
   (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
   (tblVariance[period_date]=LatestMonth)*
   (tblVariance[actual]>=tblVariance[pi95_lo])*
   (tblVariance[actual]<=tblVariance[pi95_hi])
)
/
SUMPRODUCT(
   (tblVariance[row_type]="SUMMARY_ANOMALY_DETECTION_MAIN")*
   (tblVariance[period_date]=LatestMonth)
)





=COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth, tblVariance[Abs % Error], "<=0.1") / COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth)
% of systems within ±10%
Coverage %
=COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth, tblVariance[actual], ">=" & tblVariance[pi95_lo], tblVariance[actual], "<=" & tblVariance[pi95_hi]) / COUNTIFS(tblVariance[row_type], "SUMMARY_ANOMALY_DETECTION_MAIN", tblVariance[period_date], LatestMonth)








=AVERAGEIFS(tblVariance[actual],
            tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
            tblVariance[period_date],MAX(tblVariance[period_date]))


=RMSE_Latest / AvgActual_Latest






=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
                 tblVariance[period_date],MAX(tblVariance[period_date])))


=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],{"SUMMARY_ANOMALY_DETECTION_MAIN","SUMMARY_ANOMALY_DETECTION_SYNTH","SUMMARY_ANOMALY_DETECTION_OD"},
                 tblVariance[period_date],MAX(tblVariance[period_date])))


=SQRT(AVERAGEIFS(tblVariance[Squared Error],
                 tblVariance[row_type],"SUMMARY_HISTORICAL_ERROR_MAIN"))












/* ========= ANOMALY / VARIANCE with OUTLIER FILTER + 13 MONTHS + REGRESSION =========
   Excludes: systems with $0 balance for the entire 13-month window (“$0 for over a year”).
   Also excludes: CONTRACT_SOURCE_SYSTEM = 'BPLN'.
   Tags: Overdrafts (TA%, UU%, US) and Synthetic list.
   Output columns (16, fixed order):
   1) row_type  2) CONTRACT_SOURCE_SYSTEM  3) period_date  4) actual
   5) forecast_val  6) sigma_est  7) pi95_lo  8) pi95_hi
   9) dev_abs  10) dev_pct  11) z_score  12) severity_0_100
   13) outside_95_band  14) sigma_recent  15) regr_slope_12  16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- 13-month window (fast), Total Loans, exclude BPLN ---- */
base_raw AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -13)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- OUTLIER FILTER: drop systems with $0 for the entire 13 months ---- */
active_systems AS (
  SELECT CONTRACT_SOURCE_SYSTEM
  FROM base_raw
  GROUP BY CONTRACT_SOURCE_SYSTEM
  HAVING MAX(ABS(SOURCE_SYSTEM_BALANCE)) > 0  -- keep only systems that had any non-zero month
),

base AS (
  SELECT b.*
  FROM base_raw b
  JOIN active_systems a
    ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft (TA%, UU%, US) ---- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling windows (6M stats; 12M regression components) ---- */
win AS (
  SELECT
    i.*,

    /* 6-month rolling sums for mean/std */
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    LEAST(i.rn, 6)  AS n6,

    /* 12-row regression components on (x = rn_f, y = balance) */
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    LEAST(i.rn, 12) AS n12,

    /* anchors / alignment */
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats + regression + forecast(t→t+1) ---- */
calc AS (
  SELECT
    w.*,

    /* 6M mean/std */
    CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN w.n6 > 1 THEN
        SQRT( GREATEST( (w.sum6_y2 - ((w.sum6_y * w.sum6_y) / CAST(w.n6 AS FLOAT8))), 0.0 )
             / CAST(w.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12M regression slope/intercept; guard divide-by-zero */
    CASE
      WHEN w.n12 >= 2
       AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
      THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
           / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN w.n12 >= 1 THEN
        ( w.sum12_y
          - ( COALESCE(
                CASE
                  WHEN w.n12 >= 2
                   AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                  THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                       / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                  ELSE NULL
                END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12,

    /* forecast chooser at t for t+1: regression → lag12 → 6M mean */
    COALESCE(
      CASE
        WHEN w.n12 >= 2
         AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
        THEN
          /* intercept + slope * (rn + 1) */
          ( w.sum12_y
            - ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
              ) * w.sum12_x
          ) / CAST(w.n12 AS FLOAT8)
          +
          ( ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
            / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
          ) * CAST(w.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      w.lag12_balance,
      CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END
    ) AS forecast_val_t1
  FROM win w
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE  AS model_asof_period,  -- t
    c.next_period        AS forecast_period,    -- t+1
    c.actual_next        AS actual,             -- actual at t+1
    c.forecast_val_t1    AS forecast_val,
    c.roll_std_6         AS sigma_est,
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS ===================== */
SELECT * FROM (

  /* Latest-only diagnostics (no forecast), split into MAIN/SYNTH/OD */
  SELECT
    CASE
      WHEN c.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN c.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* Historical error (prior months inside the 13-month slice) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* Latest month anomaly view (key panel) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;




/* ========= SLIM VARIANCE / ANOMALY QUERY (with 12M regression) =========
   Segments: MAIN (non-synth, non-OD), SYNTH, OD (TA%, UU%, US). Excludes BPLN.
   Lookback: 13 months (change to -24/-30 if needed).

   Unified output columns (16):
   1) row_type  2) CONTRACT_SOURCE_SYSTEM  3) period_date  4) actual
   5) forecast_val  6) sigma_est  7) pi95_lo  8) pi95_hi
   9) dev_abs  10) dev_pct  11) z_score  12) severity_0_100
   13) outside_95_band  14) sigma_recent  15) regr_slope_12  16) lag12_balance
*/

WITH
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* --- Aggregate monthly (Total Loans), 13-month slice, exclude BPLN --- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -13)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* --- Tag synthetic + overdraft (TA%, UU%, US) --- */
tagged AS (
  SELECT
    b.*,
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* --- Index per system --- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* --- Lightweight rolling windows (6M stats; 12M regression windows) --- */
win AS (
  SELECT
    i.*,

    /* 6-month rolling sums for mean/std */
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    LEAST(i.rn, 6)  AS n6,

    /* 12-row regression components on (x = rn_f, y = balance) */
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    LEAST(i.rn, 12) AS n12,

    /* anchors / alignment */
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* --- Finish stats + regression + forecast(t→t+1) --- */
calc AS (
  SELECT
    w.*,

    /* 6M mean/std */
    CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN w.n6 > 1 THEN
        SQRT( GREATEST( (w.sum6_y2 - ((w.sum6_y * w.sum6_y) / CAST(w.n6 AS FLOAT8))), 0.0 )
             / CAST(w.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12M regression slope/intercept; guard divide-by-zero */
    CASE
      WHEN w.n12 >= 2
       AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
      THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
           / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN w.n12 >= 1 THEN
        ( w.sum12_y
          - ( COALESCE(
                CASE
                  WHEN w.n12 >= 2
                   AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                  THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                       / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                  ELSE NULL
                END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12,

    /* forecast chooser at t for t+1: regression → lag12 → 6M mean */
    COALESCE(
      CASE
        WHEN (CASE
                WHEN w.n12 >= 2
                 AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                     / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                ELSE NULL
              END) IS NOT NULL
         AND (CASE
                WHEN w.n12 >= 1 THEN
                  ( w.sum12_y
                    - ( COALESCE(
                          CASE
                            WHEN w.n12 >= 2
                             AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                            THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                                 / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                            ELSE NULL
                          END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
                ELSE NULL
              END) IS NOT NULL
        THEN
          /* regr_intercept_12 + regr_slope_12 * (rn + 1) */
          (( w.sum12_y
             - ( COALESCE(
                   CASE
                     WHEN w.n12 >= 2
                      AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
                     THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
                          / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
                     ELSE NULL
                   END, 0.0) * w.sum12_x ) ) / CAST(w.n12 AS FLOAT8)
           )
           + (
              ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
              / NULLIF(((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)), 0.0)
             )
             * CAST(w.rn + 1 AS FLOAT8)
      ELSE NULL
      END,
      w.lag12_balance,
      CASE WHEN w.n6 > 0 THEN w.sum6_y / CAST(w.n6 AS FLOAT8) ELSE NULL END
    ) AS forecast_val_t1
  FROM win w
),

/* --- Backtest rows: forecast made at t, compared to actual at t+1 --- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE  AS model_asof_period,  -- t
    c.next_period        AS forecast_period,    -- t+1
    c.actual_next        AS actual,             -- actual at t+1
    c.forecast_val_t1    AS forecast_val,
    c.roll_std_6         AS sigma_est,
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS ===================== */
SELECT * FROM (

  /* Latest-only diagnostics (no forecast) */
  SELECT
    CASE
      WHEN c.is_overdraft = 1 THEN 'HISTORY_LITE_OD'
      WHEN c.is_synthetic = 1 THEN 'HISTORY_LITE_SYNTH'
      ELSE 'HISTORY_LITE_MAIN'
    END AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    /* expose regression slope (from same row) for context */
    (SELECT
       CASE
         WHEN w.n12 >= 2
          AND ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x)) <> 0.0
         THEN ((CAST(w.n12 AS FLOAT8) * w.sum12_xy) - (w.sum12_x * w.sum12_y))
              / ((CAST(w.n12 AS FLOAT8) * w.sum12_x2) - (w.sum12_x * w.sum12_x))
         ELSE NULL
       END
     ) AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)

  UNION ALL

  /* Historical error (prior months inside slice) */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_HISTORICAL_ERROR_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_HISTORICAL_ERROR_SYNTH'
      ELSE 'SUMMARY_HISTORICAL_ERROR_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom

  UNION ALL

  /* Latest month anomaly view */
  SELECT
    CASE
      WHEN b.is_overdraft = 1 THEN 'SUMMARY_ANOMALY_DETECTION_OD'
      WHEN b.is_synthetic = 1 THEN 'SUMMARY_ANOMALY_DETECTION_SYNTH'
      ELSE 'SUMMARY_ANOMALY_DETECTION_MAIN'
    END AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period           AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8 AS sigma_recent,
    NULL::FLOAT8 AS regr_slope_12,
    NULL::FLOAT8 AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;







Field
Meaning
How to Interpret / Use
row_type
Which panel the row belongs to (HISTORY_LITE_MAIN, SUMMARY_HISTORICAL_ERROR_OD, etc.)
Filter on this to drive visuals. Analysts will mostly focus on SUMMARY_ANOMALY_DETECTION_MAIN.
CONTRACT_SOURCE_SYSTEM
Unique source system identifier
Dimension you’ll pivot on; group by this for system-level review.
period_date
Month-end date for the row
Timeline dimension; order chronologically.
actual
Actual SOURCE_SYSTEM_BALANCE for that system/date
The “truth” — compare to forecast_val to see deviation.
forecast_val
Predicted balance for the period based on prior month model (linear regression preferred, fallback to lag-12 or 6-mo mean)
Used to measure surprise — if far from actual, flag as anomaly.
sigma_est
Estimated standard deviation (6-month rolling)
Used for z-score and 95% confidence band; large sigma = more tolerant model.
pi95_lo / pi95_hi
95% prediction interval around forecast
If actual lies outside, it’s statistically surprising.
dev_abs
Actual − Forecast (dollar variance)
Positive = higher than expected, negative = lower than expected.
dev_pct
(Actual − Forecast) ÷ Forecast
Size of surprise relative to expectation; >+10% or <-10% is material.
z_score
Number of sigmas away from forecast
>3 or <-3 = statistically significant.
severity_0_100
Composite anomaly score (0–100): weighted combination of
Use to rank anomalies. ≥80 = high priority review.
outside_95_band
Boolean if actual outside 95% PI
A simple flag for “statistically significant deviation.”
sigma_recent
Rolling std (6-month) used in latest month only (in HISTORY_LITE)
Helps analysts understand system volatility at current close.
regr_slope_12
12-month regression slope (trend)
Positive = trend up, negative = trend down; can explain whether forecast momentum was reasonable.
lag12_balance
Actual balance from same month prior year
Used as seasonal fallback; good for analysts to cross-check.






/* ========= VARIANCE / ANOMALY QUERY with OD SEGMENTATION + BPLN EXCLUSION =========
   Unified output columns (16 columns, same order in every UNION arm):
   1)  row_type
   2)  CONTRACT_SOURCE_SYSTEM
   3)  period_date
   4)  actual
   5)  forecast_val
   6)  sigma_est
   7)  pi95_lo
   8)  pi95_hi
   9)  dev_abs
   10) dev_pct
   11) z_score
   12) severity_0_100
   13) outside_95_band
   14) sigma_recent
   15) regr_slope_12
   16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Monthly totals (Total Loans) over last 24 months, BPLN excluded ---- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.CONTRACT_SOURCE_SYSTEM <> 'BPLN'      -- EXCLUDE BPLN
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -24)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft systems ---- */
tagged AS (
  SELECT
    b.*,
    /* synthetic flag */
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,

    /* overdraft flag: TA*, UU*, or explicitly 'US' */
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM = 'US' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Row index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                       ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                            ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling components via window frames (fast) ---- */
roll AS (
  SELECT
    i.*,

    -- 6-month rolling stats
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    -- 12-month rolling regression components
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    -- helpers
    LEAST(i.rn, 6)  AS n6,
    LEAST(i.rn, 12) AS n12,

    -- anchors & “next month” alignment
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats & build forecast(t→t+1) ---- */
calc AS (
  SELECT
    r.*,

    /* rolling mean & std (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-month regression (y ~ rn) */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS model_asof_period,  -- t
    c.next_period              AS forecast_period,    -- t+1
    c.actual_next              AS actual,             -- actual at t+1

    /* forecast chooser at t (for t+1): linear → lag12 → 6-mo mean */
    COALESCE(
      CASE
        WHEN c.regr_slope_12 IS NOT NULL AND c.regr_intercept_12 IS NOT NULL
          THEN c.regr_intercept_12 + c.regr_slope_12 * CAST(c.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      c.lag12_balance,
      c.roll_mean_6
    ) AS forecast_val,

    /* sigma estimate (recent 6-mo std) */
    c.roll_std_6 AS sigma_est,

    /* flags & latest marker */
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS (MAIN, SYNTH, OD) ===================== */
SELECT * FROM (

  /* A) Latest-only diagnostics — NON-SYNTH, NON-OD */
  SELECT
    'HISTORY_LITE_MAIN'         AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 0
    AND c.is_overdraft = 0

  UNION ALL

  /* B) Latest-only diagnostics — SYNTH (exclude OD) */
  SELECT
    'HISTORY_LITE_SYNTH'        AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 1
    AND c.is_overdraft = 0

  UNION ALL

  /* C) Historical error (prior months) — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* D) Historical error (prior months) — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  UNION ALL

  /* E) Latest month anomaly — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* F) Latest month anomaly — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  /* -------- OD PANELS (all overdrafts, regardless of synthetic) -------- */

  UNION ALL
  /* G) Latest-only diagnostics — OVERDRAFT */
  SELECT
    'HISTORY_LITE_OD'          AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_overdraft = 1

  UNION ALL
  /* H) Historical error — OVERDRAFT */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period             AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_overdraft = 1

  UNION ALL
  /* I) Latest month anomaly — OVERDRAFT */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period              AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_overdraft = 1

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






/* ========= VARIANCE / ANOMALY QUERY with OVERDRAFT SEGMENTATION =========
   Unified output columns (16 columns, same order in every UNION arm):
   1)  row_type
   2)  CONTRACT_SOURCE_SYSTEM
   3)  period_date
   4)  actual
   5)  forecast_val
   6)  sigma_est
   7)  pi95_lo
   8)  pi95_hi
   9)  dev_abs
   10) dev_pct
   11) z_score
   12) severity_0_100
   13) outside_95_band
   14) sigma_recent
   15) regr_slope_12
   16) lag12_balance
*/

WITH
/* ---- Latest close ---- */
latest AS (
  SELECT MAX(t.END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
),

/* ---- Monthly totals (Total Loans) over last 24 months ---- */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE BETWEEN ADD_MONTHS((SELECT max_eom FROM latest), -24)
                                 AND (SELECT max_eom FROM latest)
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* ---- Tag synthetic + overdraft systems ---- */
tagged AS (
  SELECT
    b.*,
    /* synthetic flag */
    CASE WHEN b.CONTRACT_SOURCE_SYSTEM IN (
      'ACAR01-EXCPTN','HUBFSV-EXCPTN','INFL05-EXCPTN','INFL10-EXCPTN',
      'LNIQ01-EXCPTN','SBO001-EXCPTN','STKY01-EXCPTN','STRAT1-EXCPTN',
      'ALL','GL','LJ','SYN','FRDS_EXCPTN','ADJ'
    ) THEN 1 ELSE 0 END AS is_synthetic,

    /* overdraft flag: TA* or UU* */
    CASE
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'TA%' THEN 1
      WHEN b.CONTRACT_SOURCE_SYSTEM LIKE 'UU%' THEN 1
      ELSE 0
    END AS is_overdraft
  FROM base b
),

/* ---- Row index per system ---- */
idx AS (
  SELECT
    t.*,
    ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                       ORDER BY t.END_OF_MONTH_DATE) AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY t.CONTRACT_SOURCE_SYSTEM
                            ORDER BY t.END_OF_MONTH_DATE) AS FLOAT8) AS rn_f
  FROM tagged t
),

/* ---- Rolling components via window frames (fast) ---- */
roll AS (
  SELECT
    i.*,

    -- 6-month rolling stats
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y,

    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum6_y2,

    -- 12-month rolling regression components
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x,

    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_y,

    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_x2,

    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sum12_xy,

    -- helpers
    LEAST(i.rn, 6)  AS n6,
    LEAST(i.rn, 12) AS n12,

    -- anchors & “next month” alignment
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS lag12_balance,

    LEAD(i.SOURCE_SYSTEM_BALANCE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS actual_next,

    LEAD(i.END_OF_MONTH_DATE, 1) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS next_period
  FROM idx i
),

/* ---- Finish stats & build forecast(t→t+1) ---- */
calc AS (
  SELECT
    r.*,

    /* rolling mean & std (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-month regression (y ~ rn) */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ---- Backtest rows: forecast made at t, compared to actual at t+1 ---- */
backtest AS (
  SELECT
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS model_asof_period,  -- t
    c.next_period              AS forecast_period,    -- t+1
    c.actual_next              AS actual,             -- actual at t+1

    /* forecast chooser at t (for t+1): linear → lag12 → 6-mo mean */
    COALESCE(
      CASE
        WHEN c.regr_slope_12 IS NOT NULL AND c.regr_intercept_12 IS NOT NULL
          THEN c.regr_intercept_12 + c.regr_slope_12 * CAST(c.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      c.lag12_balance,
      c.roll_mean_6
    ) AS forecast_val,

    /* sigma estimate (recent 6-mo std) */
    c.roll_std_6 AS sigma_est,

    /* flags & latest marker */
    c.is_synthetic,
    c.is_overdraft,
    (SELECT max_eom FROM latest) AS max_eom
  FROM calc c
  WHERE c.next_period IS NOT NULL
)

/* ===================== FINAL OUTPUTS (six main panels + three OD panels) ===================== */
SELECT * FROM (

  /* A) Latest-only diagnostics — NON-SYNTH, NON-OD */
  SELECT
    'HISTORY_LITE_MAIN'         AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 0
    AND c.is_overdraft = 0

  UNION ALL

  /* B) Latest-only diagnostics — SYNTH (still exclude OD) */
  SELECT
    'HISTORY_LITE_SYNTH'        AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE         AS period_date,
    c.SOURCE_SYSTEM_BALANCE     AS actual,
    NULL::FLOAT8                AS forecast_val,
    NULL::FLOAT8                AS sigma_est,
    NULL::FLOAT8                AS pi95_lo,
    NULL::FLOAT8                AS pi95_hi,
    NULL::FLOAT8                AS dev_abs,
    NULL::FLOAT8                AS dev_pct,
    NULL::FLOAT8                AS z_score,
    NULL::FLOAT8                AS severity_0_100,
    NULL                        AS outside_95_band,
    c.roll_std_6                AS sigma_recent,
    c.regr_slope_12             AS regr_slope_12,
    c.lag12_balance             AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_synthetic = 1
    AND c.is_overdraft = 0

  UNION ALL

  /* C) Historical error (prior months) — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* D) Historical error (prior months) — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  UNION ALL

  /* E) Latest month anomaly — NON-SYNTH, NON-OD */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 0
    AND b.is_overdraft = 0

  UNION ALL

  /* F) Latest month anomaly — SYNTH (exclude OD) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_synthetic = 1
    AND b.is_overdraft = 0

  /* -------- OD PANELS (all overdrafts, regardless of synthetic) -------- */

  UNION ALL
  /* G) Latest-only diagnostics — OVERDRAFT */
  SELECT
    'HISTORY_LITE_OD'          AS row_type,
    c.CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE        AS period_date,
    c.SOURCE_SYSTEM_BALANCE    AS actual,
    NULL::FLOAT8               AS forecast_val,
    NULL::FLOAT8               AS sigma_est,
    NULL::FLOAT8               AS pi95_lo,
    NULL::FLOAT8               AS pi95_hi,
    NULL::FLOAT8               AS dev_abs,
    NULL::FLOAT8               AS dev_pct,
    NULL::FLOAT8               AS z_score,
    NULL::FLOAT8               AS severity_0_100,
    NULL                       AS outside_95_band,
    c.roll_std_6               AS sigma_recent,
    c.regr_slope_12            AS regr_slope_12,
    c.lag12_balance            AS lag12_balance
  FROM calc c
  WHERE c.END_OF_MONTH_DATE = (SELECT max_eom FROM latest)
    AND c.is_overdraft = 1

  UNION ALL
  /* H) Historical error — OVERDRAFT */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period             AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period < b.max_eom
    AND b.is_overdraft = 1

  UNION ALL
  /* I) Latest month anomaly — OVERDRAFT */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_OD' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM,
    b.forecast_period              AS period_date,
    b.actual,
    b.forecast_val,
    b.sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est  IS NOT NULL AND b.sigma_est > 0
         THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(0.10 * NULLIF(ABS(b.forecast_val),0), 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8  AS sigma_recent,
    NULL::FLOAT8  AS regr_slope_12,
    NULL::FLOAT8  AS lag12_balance
  FROM backtest b
  WHERE b.forecast_period = b.max_eom
    AND b.is_overdraft = 1

) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH
/* ====== PARAMETERS / WINDOW ====== */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ====== SYNTHETIC SYSTEMS (inline list) ====== */
synthetic_list AS (
  SELECT 'ACAR01-EXCPTN' AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'HUBFSV-EXCPTN' UNION ALL
  SELECT 'INFL05-EXCPTN' UNION ALL
  SELECT 'INFL10-EXCPTN' UNION ALL
  SELECT 'LNIQ01-EXCPTN' UNION ALL
  SELECT 'SBO001-EXCPTN' UNION ALL
  SELECT 'STKY01-EXCPTN' UNION ALL
  SELECT 'STRAT1-EXCPTN' UNION ALL
  SELECT 'ALL'           UNION ALL
  SELECT 'GL'            UNION ALL
  SELECT 'LJ'            UNION ALL
  SELECT 'SYN'           UNION ALL
  SELECT 'FRDS_EXCPTN'   UNION ALL
  SELECT 'ADJ'
),

/* ====== 1) Monthly totals (Total Loans) ====== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
),

/* synthetic flag once */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ====== 2) Row index per system ====== */
idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ====== 3) Materialize float index ====== */
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ====== 4) Cumulative sums ====== */
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y2,
    SUM(x.rn_f) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x,
    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x2,
    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_xy,
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ====== 5) Rolling windows via csum - lag(csum) + lag12 ====== */
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y, c.csum_y2, c.csum_x, c.csum_x2, c.csum_xy,
    c.cnt_all, c.avg_all, c.avg2_all,
    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ====== 6) Per-row stats ====== */
calc AS (
  SELECT
    r.END_OF_MONTH_DATE,
    r.CONTRACT_SOURCE_SYSTEM,
    r.SOURCE_SYSTEM_BALANCE,
    r.rn, r.rn_f,
    r.csum_y, r.csum_y2, r.csum_x, r.csum_x2, r.csum_xy,
    r.cnt_all, r.avg_all, r.avg2_all,
    r.n6, r.n12,
    r.sum6_y, r.sum6_y2, r.sum12_x, r.sum12_y, r.sum12_x2, r.sum12_xy,
    r.lag12_balance,
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,
    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ====== 7) Latest month per system ====== */
latest_per_sys AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM, MAX(c.END_OF_MONTH_DATE) AS max_eom
  FROM calc c
  GROUP BY c.CONTRACT_SOURCE_SYSTEM
),

/* ====== 8) Backtest panel t-1 -> t (last ~12 origins) ====== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE AS model_asof_period,
    c.END_OF_MONTH_DATE AS forecast_period,
    c.SOURCE_SYSTEM_BALANCE AS actual,
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    ) AS forecast_val,
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    ) AS sigma_est,
    p.avg_all AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
    AND p.END_OF_MONTH_DATE <  l.max_eom
),

/* add synthetic flags */
backtest_split AS (
  SELECT b.CONTRACT_SOURCE_SYSTEM,
         b.model_asof_period,
         b.forecast_period,
         b.actual,
         b.forecast_val,
         b.sigma_est,
         b.avg_level_sys,
         f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM,
         c.END_OF_MONTH_DATE,
         c.SOURCE_SYSTEM_BALANCE,
         c.roll_std_6,
         c.regr_slope_12,
         c.lag12_balance,
         f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* handy join for “t = latest” */
latest_join AS (
  SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
  FROM latest_per_sys l
)

/* ====== FINAL UNION (unified 16 columns) ====== */
SELECT * FROM (
  /* A) HISTORY_LITE — latest only, non-synth */
  SELECT
    'HISTORY_LITE_MAIN'      AS row_type,
    c.CONTRACT_SOURCE_SYSTEM AS CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE      AS period_date,
    c.SOURCE_SYSTEM_BALANCE  AS actual,
    NULL::FLOAT8             AS forecast_val,
    NULL::FLOAT8             AS sigma_est,
    NULL::FLOAT8             AS pi95_lo,
    NULL::FLOAT8             AS pi95_hi,
    NULL::FLOAT8             AS dev_abs,
    NULL::FLOAT8             AS dev_pct,
    NULL::FLOAT8             AS z_score,
    NULL::FLOAT8             AS severity_0_100,
    NULL                     AS outside_95_band,
    c.roll_std_6             AS sigma_recent,
    c.regr_slope_12          AS regr_slope_12,
    c.lag12_balance          AS lag12_balance
  FROM calc_split c
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
   AND l.max_eom                = c.END_OF_MONTH_DATE
  WHERE c.is_synthetic = 0

  UNION ALL

  /* B) HISTORY_LITE — latest only, synth */
  SELECT
    'HISTORY_LITE_SYNTH'     AS row_type,
    c.CONTRACT_SOURCE_SYSTEM AS CONTRACT_SOURCE_SYSTEM,
    c.END_OF_MONTH_DATE      AS period_date,
    c.SOURCE_SYSTEM_BALANCE  AS actual,
    NULL::FLOAT8             AS forecast_val,
    NULL::FLOAT8             AS sigma_est,
    NULL::FLOAT8             AS pi95_lo,
    NULL::FLOAT8             AS pi95_hi,
    NULL::FLOAT8             AS dev_abs,
    NULL::FLOAT8             AS dev_pct,
    NULL::FLOAT8             AS z_score,
    NULL::FLOAT8             AS severity_0_100,
    NULL                     AS outside_95_band,
    c.roll_std_6             AS sigma_recent,
    c.regr_slope_12          AS regr_slope_12,
    c.lag12_balance          AS lag12_balance
  FROM calc_split c
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
   AND l.max_eom                = c.END_OF_MONTH_DATE
  WHERE c.is_synthetic = 1

  UNION ALL

  /* C) Historical error (t < latest) — non-synth */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period               AS period_date,
    b.actual                        AS actual,
    b.forecast_val                  AS forecast_val,
    b.sigma_est                     AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                   AS sigma_recent,
    NULL::FLOAT8                   AS regr_slope_12,
    NULL::FLOAT8                   AS lag12_balance
  FROM backtest_split b
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
  WHERE b.is_synthetic = 0
    AND b.forecast_period < l.max_eom

  UNION ALL

  /* D) Historical error (t < latest) — synth */
  SELECT
    'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual                         AS actual,
    b.forecast_val                   AS forecast_val,
    b.sigma_est                      AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                    AS sigma_recent,
    NULL::FLOAT8                    AS regr_slope_12,
    NULL::FLOAT8                    AS lag12_balance
  FROM backtest_split b
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
  WHERE b.is_synthetic = 1
    AND b.forecast_period < l.max_eom

  UNION ALL

  /* E) Latest close (t = latest) — anomalies (non-synth) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                AS period_date,
    b.actual                         AS actual,
    b.forecast_val                   AS forecast_val,
    b.sigma_est                      AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                    AS sigma_recent,
    NULL::FLOAT8                    AS regr_slope_12,
    NULL::FLOAT8                    AS lag12_balance
  FROM backtest_split b
  JOIN latest_join lj
    ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
   AND lj.max_eom                = b.forecast_period
  WHERE b.is_synthetic = 0

  UNION ALL

  /* F) Latest close (t = latest) — anomalies (synth) */
  SELECT
    'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
    b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
    b.forecast_period                 AS period_date,
    b.actual                          AS actual,
    b.forecast_val                    AS forecast_val,
    b.sigma_est                       AS sigma_est,
    (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
    (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
    (b.actual - b.forecast_val)             AS dev_abs,
    CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
    CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
    ) AS severity_0_100,
    CASE
      WHEN b.sigma_est IS NULL THEN NULL
      WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
      WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
      ELSE FALSE
    END AS outside_95_band,
    NULL::FLOAT8                     AS sigma_recent,
    NULL::FLOAT8                     AS regr_slope_12,
    NULL::FLOAT8                     AS lag12_balance
  FROM backtest_split b
  JOIN latest_join lj
    ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
   AND lj.max_eom                = b.forecast_period
  WHERE b.is_synthetic = 1
) final
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;








/* ===============================================
   0) Clean up any prior run
   =============================================== */
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.RNG_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.SYNTHETIC_LIST_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BASE_MONTHLY_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.SYS_FLAGS_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_PER_SYS_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.CALC_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BACKTEST_12M_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.BACKTEST_SPLIT_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.CALC_SPLIT_WRK;
DROP TABLE IF EXISTS CIDPR.DATAHUB.LATEST_JOIN_WRK;

/* ===============================================
   1) Parameters / latest window
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.LATEST_WRK AS
SELECT MAX(END_OF_MONTH_DATE) AS MAX_EOM
FROM V_DPRT_CREDIT_INSTRUMENTS_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
DISTRIBUTE ON RANDOM;

CREATE TABLE CIDPR.DATAHUB.RNG_WRK AS
SELECT ADD_MONTHS(MAX_EOM, -30) AS START_EOM, MAX_EOM
FROM CIDPR.DATAHUB.LATEST_WRK
DISTRIBUTE ON RANDOM;

/* ===============================================
   2) Synthetic systems lookup
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.SYNTHETIC_LIST_WRK (CONTRACT_SOURCE_SYSTEM VARCHAR(200))
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM);

INSERT INTO CIDPR.DATAHUB.SYNTHETIC_LIST_WRK (CONTRACT_SOURCE_SYSTEM) VALUES
 ('ACAR01-EXCPTN'),('HUBFSV-EXCPTN'),('INFL05-EXCPTN'),('INFL10-EXCPTN'),
 ('LNIQ01-EXCPTN'),('SBO001-EXCPTN'),('STKY01-EXCPTN'),('STRAT1-EXCPTN'),
 ('ALL'),('GL'),('LJ'),('SYN'),('FRDS_EXCPTN'),('ADJ');

/* ===============================================
   3) BASE monthly aggregation (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.BASE_MONTHLY_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
CROSS JOIN CIDPR.DATAHUB.RNG_WRK r
WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
  AND t.END_OF_MONTH_DATE BETWEEN r.START_EOM AND r.MAX_EOM
  AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM
;

GENERATE STATISTICS ON CIDPR.DATAHUB.BASE_MONTHLY_WRK;

/* Flag synthetic vs non-synthetic once and reuse */
CREATE TABLE CIDPR.DATAHUB.SYS_FLAGS_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT DISTINCT
       b.CONTRACT_SOURCE_SYSTEM,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.LATEST_PER_SYS_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM, MAX(b.END_OF_MONTH_DATE) AS MAX_EOM
FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
GROUP BY b.CONTRACT_SOURCE_SYSTEM
;

/* ===============================================
   4) CALC (windows on compact monthly table) (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.CALC_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
WITH idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS RN
  FROM CIDPR.DATAHUB.BASE_MONTHLY_WRK b
),
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.RN,
    CAST(i.RN AS FLOAT8) AS RN_F
  FROM idx1 i
),
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.RN,
    x.RN_F,
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_Y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_Y2,
    SUM(x.RN_F) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_X,
    SUM(CAST(x.RN_F * x.RN_F AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_X2,
    SUM(CAST(x.RN_F * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS CSUM_XY,
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS CNT_ALL,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS AVG_ALL,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS AVG2_ALL
  FROM idx2 x
),
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.RN,
    c.RN_F,
    c.CSUM_Y, c.CSUM_Y2, c.CSUM_X, c.CSUM_X2, c.CSUM_XY,
    c.CNT_ALL, c.AVG_ALL, c.AVG2_ALL,
    LEAST(c.RN, 6)  AS N6,
    LEAST(c.RN, 12) AS N12,
    (c.CSUM_Y  - COALESCE(LAG(c.CSUM_Y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM6_Y,
    (c.CSUM_Y2 - COALESCE(LAG(c.CSUM_Y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM6_Y2,
    (c.CSUM_X  - COALESCE(LAG(c.CSUM_X,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_X,
    (c.CSUM_Y  - COALESCE(LAG(c.CSUM_Y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_Y,
    (c.CSUM_X2 - COALESCE(LAG(c.CSUM_X2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_X2,
    (c.CSUM_XY - COALESCE(LAG(c.CSUM_XY, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS SUM12_XY,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS LAG12_BALANCE
  FROM csum c
)
SELECT
  r.END_OF_MONTH_DATE,
  r.CONTRACT_SOURCE_SYSTEM,
  r.SOURCE_SYSTEM_BALANCE,
  r.RN, r.RN_F,
  r.CSUM_Y, r.CSUM_Y2, r.CSUM_X, r.CSUM_X2, r.CSUM_XY,
  r.CNT_ALL, r.AVG_ALL, r.AVG2_ALL,
  r.N6, r.N12,
  r.SUM6_Y, r.SUM6_Y2, r.SUM12_X, r.SUM12_Y, r.SUM12_X2, r.SUM12_XY,
  r.LAG12_BALANCE,
  CASE WHEN r.N6 > 0 THEN r.SUM6_Y / CAST(r.N6 AS FLOAT8) ELSE NULL END AS ROLL_MEAN_6,
  CASE
    WHEN r.N6 > 1 THEN
      SQRT( GREATEST( (r.SUM6_Y2 - ( (r.SUM6_Y * r.SUM6_Y) / CAST(r.N6 AS FLOAT8) )), 0.0 )
           / CAST(r.N6 - 1 AS FLOAT8) )
    ELSE NULL
  END AS ROLL_STD_6,
  CASE
    WHEN r.N12 >= 2 AND ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) ) <> 0.0
      THEN ( (CAST(r.N12 AS FLOAT8) * r.SUM12_XY) - (r.SUM12_X * r.SUM12_Y) )
           / ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) )
    ELSE NULL
  END AS REGR_SLOPE_12,
  CASE
    WHEN r.N12 >= 1 THEN
      ( r.SUM12_Y
        - ( COALESCE(
              CASE
                WHEN r.N12 >= 2 AND ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) ) <> 0.0
                  THEN ( (CAST(r.N12 AS FLOAT8) * r.SUM12_XY) - (r.SUM12_X * r.SUM12_Y) )
                       / ( (CAST(r.N12 AS FLOAT8) * r.SUM12_X2) - (r.SUM12_X * r.SUM12_X) )
                ELSE NULL
              END, 0.0) * r.SUM12_X ) ) / CAST(r.N12 AS FLOAT8)
    ELSE NULL
  END AS REGR_INTERCEPT_12
FROM roll r
;

GENERATE STATISTICS ON CIDPR.DATAHUB.CALC_WRK;

/* ===============================================
   5) Backtest panel (t-1 -> t) (CTAS)
   =============================================== */
CREATE TABLE CIDPR.DATAHUB.BACKTEST_12M_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  p.CONTRACT_SOURCE_SYSTEM,
  p.END_OF_MONTH_DATE                                   AS MODEL_ASOF_PERIOD,
  c.END_OF_MONTH_DATE                                   AS FORECAST_PERIOD,
  c.SOURCE_SYSTEM_BALANCE                               AS ACTUAL,
  COALESCE(
    CASE
      WHEN p.REGR_SLOPE_12 IS NOT NULL AND p.REGR_INTERCEPT_12 IS NOT NULL
        THEN p.REGR_INTERCEPT_12 + p.REGR_SLOPE_12 * CAST(p.RN + 1 AS FLOAT8)
      ELSE NULL
    END,
    p.LAG12_BALANCE,
    p.ROLL_MEAN_6
  )                                                     AS FORECAST_VAL,
  COALESCE(
    p.ROLL_STD_6,
    CASE WHEN p.CNT_ALL > 1
         THEN SQRT( GREATEST(p.AVG2_ALL - (p.AVG_ALL * p.AVG_ALL), 0.0)
                    * (CAST(p.CNT_ALL AS FLOAT8) / CAST(p.CNT_ALL - 1 AS FLOAT8)) )
         ELSE NULL
    END
  )                                                     AS SIGMA_EST,
  p.AVG_ALL                                             AS AVG_LEVEL_SYS
FROM CIDPR.DATAHUB.CALC_WRK p
JOIN CIDPR.DATAHUB.CALC_WRK c
  ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
 AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.MAX_EOM, -12)
  AND p.END_OF_MONTH_DATE <  l.MAX_EOM
;

GENERATE STATISTICS ON CIDPR.DATAHUB.BACKTEST_12M_WRK;

/* Split/join flags for final SELECTs */
CREATE TABLE CIDPR.DATAHUB.BACKTEST_SPLIT_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM,
       b.MODEL_ASOF_PERIOD,
       b.FORECAST_PERIOD,
       b.ACTUAL,
       b.FORECAST_VAL,
       b.SIGMA_EST,
       b.AVG_LEVEL_SYS,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.BACKTEST_12M_WRK b
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.CALC_SPLIT_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT c.CONTRACT_SOURCE_SYSTEM,
       c.END_OF_MONTH_DATE,
       c.SOURCE_SYSTEM_BALANCE,
       c.ROLL_STD_6,
       c.REGR_SLOPE_12,
       c.LAG12_BALANCE,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS IS_SYNTHETIC
FROM CIDPR.DATAHUB.CALC_WRK c
LEFT JOIN CIDPR.DATAHUB.SYNTHETIC_LIST_WRK s
  ON s.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
;

CREATE TABLE CIDPR.DATAHUB.LATEST_JOIN_WRK
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT l.CONTRACT_SOURCE_SYSTEM, l.MAX_EOM
FROM CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
;

/* ===============================================
   6) FINAL OUTPUT (unified 16 columns)
   =============================================== */
SELECT * FROM (
/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.ROLL_STD_6               AS sigma_recent,
  c.REGR_SLOPE_12            AS regr_slope_12,
  c.LAG12_BALANCE            AS lag12_balance
FROM CIDPR.DATAHUB.CALC_SPLIT_WRK c
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.MAX_EOM                = c.END_OF_MONTH_DATE
WHERE c.IS_SYNTHETIC = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.ROLL_STD_6               AS sigma_recent,
  c.REGR_SLOPE_12            AS regr_slope_12,
  c.LAG12_BALANCE            AS lag12_balance
FROM CIDPR.DATAHUB.CALC_SPLIT_WRK c
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.MAX_EOM                = c.END_OF_MONTH_DATE
WHERE c.IS_SYNTHETIC = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD               AS period_date,
  b.ACTUAL                        AS actual,
  b.FORECAST_VAL                  AS forecast_val,
  b.SIGMA_EST                     AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                   AS sigma_recent,
  NULL::FLOAT8                   AS regr_slope_12,
  NULL::FLOAT8                   AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.IS_SYNTHETIC = 0
  AND b.FORECAST_PERIOD < l.MAX_EOM

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                AS period_date,
  b.ACTUAL                         AS actual,
  b.FORECAST_VAL                   AS forecast_val,
  b.SIGMA_EST                      AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_PER_SYS_WRK l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.IS_SYNTHETIC = 1
  AND b.FORECAST_PERIOD < l.MAX_EOM

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                AS period_date,
  b.ACTUAL                         AS actual,
  b.FORECAST_VAL                   AS forecast_val,
  b.SIGMA_EST                      AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_JOIN_WRK lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.MAX_EOM                = b.FORECAST_PERIOD
WHERE b.IS_SYNTHETIC = 0

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
  b.FORECAST_PERIOD                 AS period_date,
  b.ACTUAL                          AS actual,
  b.FORECAST_VAL                    AS forecast_val,
  b.SIGMA_EST                       AS sigma_est,
  (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) AS pi95_lo,
  (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) AS pi95_hi,
  (b.ACTUAL - b.FORECAST_VAL)             AS dev_abs,
  CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.FORECAST_VAL ELSE NULL END AS dev_pct,
  CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL) / b.SIGMA_EST ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.SIGMA_EST IS NOT NULL AND b.SIGMA_EST > 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.SIGMA_EST ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.FORECAST_VAL <> 0 THEN (b.ACTUAL - b.FORECAST_VAL)/b.FORECAST_VAL ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.ACTUAL - b.FORECAST_VAL) / NULLIF(b.AVG_LEVEL_SYS * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.SIGMA_EST IS NULL THEN NULL
    WHEN b.ACTUAL < (b.FORECAST_VAL - 1.9599 * b.SIGMA_EST) THEN TRUE
    WHEN b.ACTUAL > (b.FORECAST_VAL + 1.9599 * b.SIGMA_EST) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                     AS sigma_recent,
  NULL::FLOAT8                     AS regr_slope_12,
  NULL::FLOAT8                     AS lag12_balance
FROM CIDPR.DATAHUB.BACKTEST_SPLIT_WRK b
JOIN CIDPR.DATAHUB.LATEST_JOIN_WRK lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.MAX_EOM                = b.FORECAST_PERIOD
WHERE b.IS_SYNTHETIC = 1
) final
ORDER BY 2, 3;





/* =========================================================
   0) Session knobs (optional but often helpful)
   ========================================================= */
-- SET ENABLE_COLUMNAR_OUTPUT TO TRUE;    -- harmless if not supported
-- SET ENABLE_PARAMETER_MARKERS TO FALSE; -- avoid plan issues in CTAS
-- You can also increase RESOURCE QUEUE if you have one for ETL

/* =========================================================
   1) Parameters / latest window
   ========================================================= */
CREATE TEMP TABLE latest AS
SELECT MAX(END_OF_MONTH_DATE) AS max_eom
FROM V_DPRT_CREDIT_INSTRUMENTS_ME
WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL;

CREATE TEMP TABLE rng AS
SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom
FROM latest;

/* =========================================================
   2) Synthetic systems lookup
   ========================================================= */
CREATE TEMP TABLE synthetic_list (CONTRACT_SOURCE_SYSTEM VARCHAR(200));
INSERT INTO synthetic_list (CONTRACT_SOURCE_SYSTEM) VALUES
 ('ACAR01-EXCPTN'),('HUBFSV-EXCPTN'),('INFL05-EXCPTN'),('INFL10-EXCPTN'),
 ('LNIQ01-EXCPTN'),('SBO001-EXCPTN'),('STKY01-EXCPTN'),('STRAT1-EXCPTN'),
 ('ALL'),('GL'),('LJ'),('SYN'),('FRDS_EXCPTN'),('ADJ');

/* =========================================================
   3) BASE monthly aggregation (CTAS)  << BIGGEST SPEEDUP
      - Distribute by system for window partitions later
   ========================================================= */
CREATE TEMP TABLE base_monthly
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  t.END_OF_MONTH_DATE,
  t.CONTRACT_SOURCE_SYSTEM,
  CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
CROSS JOIN rng r
WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
  AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
GROUP BY t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM;

GENERATE STATISTICS ON base_monthly;

/* Flag synthetic vs non-synthetic once and reuse */
CREATE TEMP TABLE sys_flags
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT DISTINCT
       b.CONTRACT_SOURCE_SYSTEM,
       CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
FROM base_monthly b
LEFT JOIN synthetic_list s
  ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM;

/* Latest month per system (temp) */
CREATE TEMP TABLE latest_per_sys
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM, MAX(b.END_OF_MONTH_DATE) AS max_eom
FROM base_monthly b
GROUP BY b.CONTRACT_SOURCE_SYSTEM;

/* =========================================================
   4) CALC (windows on compact monthly table) (CTAS)
      - row numbers, cumulative sums, rolling windows, regression
   ========================================================= */
CREATE TEMP TABLE calc
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
WITH idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base_monthly b
),
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,
    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y,
    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_y2,
    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x,
    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_x2,
    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE) AS csum_xy,
    /* per-system overall stats */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y, c.csum_y2, c.csum_x, c.csum_x2, c.csum_xy,
    c.cnt_all, c.avg_all, c.avg2_all,
    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
)
SELECT
  r.END_OF_MONTH_DATE,
  r.CONTRACT_SOURCE_SYSTEM,
  r.SOURCE_SYSTEM_BALANCE,
  r.rn, r.rn_f,
  r.csum_y, r.csum_y2, r.csum_x, r.csum_x2, r.csum_xy,
  r.cnt_all, r.avg_all, r.avg2_all,
  r.n6, r.n12,
  r.sum6_y, r.sum6_y2, r.sum12_x, r.sum12_y, r.sum12_x2, r.sum12_xy,
  r.lag12_balance,
  /* rolling mean (6) */
  CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,
  /* rolling sample std (6) */
  CASE
    WHEN r.n6 > 1 THEN
      SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
           / CAST(r.n6 - 1 AS FLOAT8) )
    ELSE NULL
  END AS roll_std_6,
  /* 12-row regression slope & intercept */
  CASE
    WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
      THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
           / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
    ELSE NULL
  END AS regr_slope_12,
  CASE
    WHEN r.n12 >= 1 THEN
      ( r.sum12_y
        - ( COALESCE(
              CASE
                WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                  THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                       / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                ELSE NULL
              END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
    ELSE NULL
  END AS regr_intercept_12
FROM roll r
;

GENERATE STATISTICS ON calc;

/* =========================================================
   5) Backtest panel (t-1 -> t) (CTAS)
   ========================================================= */
CREATE TEMP TABLE backtest_12m
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT
  p.CONTRACT_SOURCE_SYSTEM,
  p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t-1 */
  c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
  c.SOURCE_SYSTEM_BALANCE                               AS actual,
  /* forecast chooser: 12M linear -> lag12 -> 6M mean */
  COALESCE(
    CASE
      WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
        THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
      ELSE NULL
    END,
    p.lag12_balance,
    p.roll_mean_6
  )                                                     AS forecast_val,
  /* sigma estimate */
  COALESCE(
    p.roll_std_6,
    CASE WHEN p.cnt_all > 1
         THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                    * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
         ELSE NULL
    END
  )                                                     AS sigma_est,
  p.avg_all                                             AS avg_level_sys
FROM calc p
JOIN calc c
  ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
 AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
  AND p.END_OF_MONTH_DATE <  l.max_eom
;

GENERATE STATISTICS ON backtest_12m;

/* Split/join flags for final SELECTs (CTAS) */
CREATE TEMP TABLE backtest_split
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT b.CONTRACT_SOURCE_SYSTEM,
       b.model_asof_period,
       b.forecast_period,
       b.actual,
       b.forecast_val,
       b.sigma_est,
       b.avg_level_sys,
       f.is_synthetic
FROM backtest_12m b
JOIN sys_flags f
  ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM;

CREATE TEMP TABLE calc_split
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT c.CONTRACT_SOURCE_SYSTEM,
       c.END_OF_MONTH_DATE,
       c.SOURCE_SYSTEM_BALANCE,
       c.roll_std_6,
       c.regr_slope_12,
       c.lag12_balance,
       f.is_synthetic
FROM calc c
JOIN sys_flags f
  ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM;

CREATE TEMP TABLE latest_join
DISTRIBUTE ON (CONTRACT_SOURCE_SYSTEM)
AS
SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
FROM latest_per_sys l;

/* =========================================================
   6) FINAL OUTPUT (same unified 16 columns)
   ========================================================= */
-- You can SELECT * FROM ( ... ) AS final ORDER BY 2,3; if your tool needs one statement

(
/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12            AS regr_slope_12,
  c.lag12_balance            AS lag12_balance
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM   AS CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                       AS outside_95_band,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12            AS regr_slope_12,
  c.lag12_balance            AS lag12_balance
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM        AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period               AS period_date,
  b.actual                        AS actual,
  b.forecast_val                  AS forecast_val,
  b.sigma_est                     AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                   AS sigma_recent,
  NULL::FLOAT8                   AS regr_slope_12,
  NULL::FLOAT8                   AS lag12_balance
FROM backtest_12m b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.forecast_period < l.max_eom
  AND b.CONTRACT_SOURCE_SYSTEM NOT IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual                         AS actual,
  b.forecast_val                   AS forecast_val,
  b.sigma_est                      AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM backtest_12m b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.forecast_period < l.max_eom
  AND b.CONTRACT_SOURCE_SYSTEM IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM         AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual                         AS actual,
  b.forecast_val                   AS forecast_val,
  b.sigma_est                      AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                    AS sigma_recent,
  NULL::FLOAT8                    AS regr_slope_12,
  NULL::FLOAT8                    AS lag12_balance
FROM backtest_12m b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.CONTRACT_SOURCE_SYSTEM NOT IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM          AS CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual                          AS actual,
  b.forecast_val                    AS forecast_val,
  b.sigma_est                       AS sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band,
  NULL::FLOAT8                     AS sigma_recent,
  NULL::FLOAT8                     AS regr_slope_12,
  NULL::FLOAT8                     AS lag12_balance
FROM backtest_12m b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.CONTRACT_SOURCE_SYSTEM IN (SELECT CONTRACT_SOURCE_SYSTEM FROM synthetic_list)
)
ORDER BY 2, 3;

/* =========================================================
   7) (Optional) Clean-up
   ========================================================= */
-- DROP TABLE IF EXISTS latest;
-- DROP TABLE IF EXISTS rng;
-- DROP TABLE IF EXISTS synthetic_list;
-- DROP TABLE IF EXISTS base_monthly;
-- DROP TABLE IF EXISTS sys_flags;
-- DROP TABLE IF EXISTS latest_per_sys;
-- DROP TABLE IF EXISTS calc;
-- DROP TABLE IF EXISTS backtest_12m;
-- DROP TABLE IF EXISTS backtest_split;
-- DROP TABLE IF EXISTS calc_split;
-- DROP TABLE IF EXISTS latest_join;





/* ================== PARAMETERS ================== */
/* Synthetic systems list (replace with ref table if you have one) */
WITH synthetic_list AS (
  SELECT 'ACAR01-EXCPTN'::VARCHAR(200) AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'HUBFSV-EXCPTN' UNION ALL
  SELECT 'INFL05-EXCPTN' UNION ALL
  SELECT 'INFL10-EXCPTN' UNION ALL
  SELECT 'LNIQ01-EXCPTN' UNION ALL
  SELECT 'SBO001-EXCPTN' UNION ALL
  SELECT 'STKY01-EXCPTN' UNION ALL
  SELECT 'STRAT1-EXCPTN' UNION ALL
  SELECT 'ALL'          UNION ALL
  SELECT 'GL'           UNION ALL
  SELECT 'LJ'           UNION ALL
  SELECT 'SYN'          UNION ALL
  SELECT 'FRDS_EXCPTN'  UNION ALL
  SELECT 'ADJ'
),

/* Latest close + 30-month window */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ========== 1) Monthly system totals (Total Loans) ========== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* Synthetic flag per system */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ========== 2) Row index per system ========== */
idx1 AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    b.SOURCE_SYSTEM_BALANCE,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ========== 3) Float index (materialized) ========== */
idx2 AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.SOURCE_SYSTEM_BALANCE,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ========== 4) Cumulative sums (windows only) ========== */
csum AS (
  SELECT
    x.END_OF_MONTH_DATE,
    x.CONTRACT_SOURCE_SYSTEM,
    x.SOURCE_SYSTEM_BALANCE,
    x.rn,
    x.rn_f,

    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    /* per-system overall stats (for fallback sigma) */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ========== 5) Rolling windows from cumulative sums + lag12 ========== */
roll AS (
  SELECT
    c.END_OF_MONTH_DATE,
    c.CONTRACT_SOURCE_SYSTEM,
    c.SOURCE_SYSTEM_BALANCE,
    c.rn,
    c.rn_f,
    c.csum_y,
    c.csum_y2,
    c.csum_x,
    c.csum_x2,
    c.csum_xy,
    c.cnt_all,
    c.avg_all,
    c.avg2_all,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    /* 6-row rolling sums */
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    /* 12-row rolling sums (for regression) */
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    /* simple seasonal anchor */
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ========== 6) Per-row stats (no window here) ========== */
calc AS (
  SELECT
    r.END_OF_MONTH_DATE,
    r.CONTRACT_SOURCE_SYSTEM,
    r.SOURCE_SYSTEM_BALANCE,
    r.rn,
    r.rn_f,
    r.csum_y,
    r.csum_y2,
    r.csum_x,
    r.csum_x2,
    r.csum_xy,
    r.cnt_all,
    r.avg_all,
    r.avg2_all,
    r.n6,
    r.n12,
    r.sum6_y,
    r.sum6_y2,
    r.sum12_x,
    r.sum12_y,
    r.sum12_x2,
    r.sum12_xy,
    r.lag12_balance,

    /* rolling mean (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    /* rolling sample std (6) */
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-row regression slope & intercept */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ========== 7) Latest month per system ========== */
latest_per_sys AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM, MAX(c.END_OF_MONTH_DATE) AS max_eom
  FROM calc c
  GROUP BY c.CONTRACT_SOURCE_SYSTEM
),

/* ========== 8) 12-month rolling BACKTEST panel (t−1 → t) ========== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t−1 */
    c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    /* forecast from the t−1 row's params (linear → lag12 → mean) */
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    /* sigma from t−1 (rolling std → fallback long-run σ) */
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   /* last ~12 model origins */
    AND p.END_OF_MONTH_DATE <  l.max_eom                    /* up to month before latest */
),

/* Split backtest + calc with synthetic flag */
backtest_split AS (
  SELECT b.CONTRACT_SOURCE_SYSTEM,
         b.model_asof_period,
         b.forecast_period,
         b.actual,
         b.forecast_val,
         b.sigma_est,
         b.avg_level_sys,
         f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.CONTRACT_SOURCE_SYSTEM,
         c.END_OF_MONTH_DATE,
         c.SOURCE_SYSTEM_BALANCE,
         c.roll_std_6,
         c.regr_slope_12,
         c.lag12_balance,
         f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* Helper for latest-month filter */
latest_join AS (
  SELECT l.CONTRACT_SOURCE_SYSTEM, l.max_eom
  FROM latest_per_sys l
)

/* ===================== FINAL OUTPUTS ===================== */

/* A) HISTORY_LITE (latest-only) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'        AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                        AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'       AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE        AS period_date,
  c.SOURCE_SYSTEM_BALANCE    AS actual,
  c.roll_std_6               AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8               AS forecast_val,
  NULL::FLOAT8               AS sigma_est,
  NULL::FLOAT8               AS pi95_lo,
  NULL::FLOAT8               AS pi95_hi,
  NULL::FLOAT8               AS dev_abs,
  NULL::FLOAT8               AS dev_pct,
  NULL::FLOAT8               AS z_score,
  NULL::FLOAT8               AS severity_0_100,
  NULL                        AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom                = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period               AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.is_synthetic = 0
  AND b.forecast_period < l.max_eom

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
WHERE b.is_synthetic = 1
  AND b.forecast_period < l.max_eom

UNION ALL

/* E) Latest close (t = latest) anomaly detection — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 0

UNION ALL

/* F) Latest close (t = latest) anomaly detection — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 1

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






ACAR01-EXCPTN
HUBFSV-EXCPTN
INFL05-EXCPTN
INFL10-EXCPTN
LNIQ01-EXCPTN
SBO001-EXCPTN
STKY01-EXCPTN
STRAT1-EXCPTN
ALL
GL
LJ
SYN
FRDS_EXCPTN
ADJ
SYN





/* ================== PARAMETERS ================== */
/* Maintain list of synthetic systems here (or replace with a SELECT from a reference table) */
WITH synthetic_list AS (
  SELECT 'SYS_SYNTH1'::VARCHAR(200) AS CONTRACT_SOURCE_SYSTEM UNION ALL
  SELECT 'SYS_SYNTH2'::VARCHAR(200) UNION ALL
  SELECT 'SYS_SYNTH3'::VARCHAR(200)
),

/* Latest close + 30-month window */
latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ========== 1) system × month (Total Loans) ========== */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* Tag systems as synthetic/non-synthetic */
sys_flags AS (
  SELECT DISTINCT
         b.CONTRACT_SOURCE_SYSTEM,
         CASE WHEN s.CONTRACT_SOURCE_SYSTEM IS NOT NULL THEN 1 ELSE 0 END AS is_synthetic
  FROM base b
  LEFT JOIN synthetic_list s
    ON s.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),

/* ========== 2) row index per system ========== */
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* ========== 3) float index (materialized) ========== */
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

/* ========== 4) cumulative sums (windows only) ========== */
csum AS (
  SELECT
    x.*,

    /* cumulative sums for y and y^2 */
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    /* cumulative x, x^2, and x*y */
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    /* per-system overall stats (for fallback sigma) */
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

/* ========== 5) rolling windows from cumulative sums + lag12 ========== */
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    /* 6-row rolling sums */
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    /* 12-row rolling sums (for regression) */
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    /* simple seasonal anchor */
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

/* ========== 6) per-row stats (no window here) ========== */
calc AS (
  SELECT
    r.*,

    /* rolling mean (6) */
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    /* rolling sample std (6) */
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
             / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    /* 12-row regression slope & intercept */
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

/* ========== 7) latest month per system ========== */
latest_per_sys AS (
  SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* ========== 8) 12-month rolling BACKTEST panel (t−1 → t) ========== */
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  /* t−1 */
    c.END_OF_MONTH_DATE                                   AS forecast_period,    /* t   */
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    /* forecast from the t−1 row's params (linear → lag12 → mean) */
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    /* sigma from t−1 (rolling std → fallback long-run σ) */
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   /* last ~12 model origins */
    AND p.END_OF_MONTH_DATE <  l.max_eom                    /* up to month before latest */
),

/* Split backtest into main vs synthetic; also tag calc rows for HISTORY_LITE */
backtest_split AS (
  SELECT b.*, f.is_synthetic
  FROM backtest_12m b
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
),
calc_split AS (
  SELECT c.*, f.is_synthetic
  FROM calc c
  JOIN sys_flags f
    ON f.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
),

/* Helper for latest-month filtering */
latest_join AS (
  SELECT ls.CONTRACT_SOURCE_SYSTEM, ls.max_eom
  FROM latest_per_sys ls
)

/* ===================== FINAL OUTPUTS ===================== */

/* A) HISTORY_LITE (latest-only diagnostics) — NON-SYNTHETIC */
SELECT
  'HISTORY_LITE_MAIN'    AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE    AS period_date,
  c.SOURCE_SYSTEM_BALANCE AS actual,
  c.roll_std_6           AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS sigma_est,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                    AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 0

UNION ALL

/* B) HISTORY_LITE (latest-only diagnostics) — SYNTHETIC */
SELECT
  'HISTORY_LITE_SYNTH'   AS row_type,
  c.CONTRACT_SOURCE_SYSTEM,
  c.END_OF_MONTH_DATE    AS period_date,
  c.SOURCE_SYSTEM_BALANCE AS actual,
  c.roll_std_6           AS sigma_recent,
  c.regr_slope_12,
  c.lag12_balance,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS sigma_est,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                    AS outside_95_band
FROM calc_split c
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
 AND l.max_eom = c.END_OF_MONTH_DATE
WHERE c.is_synthetic = 1

UNION ALL

/* C) Historical error (t < latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_MAIN' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period                  AS period_date,
  actual,
  forecast_val,
  sigma_est,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = backtest_split.CONTRACT_SOURCE_SYSTEM
WHERE is_synthetic = 0
  AND forecast_period < l.max_eom

UNION ALL

/* D) Historical error (t < latest) — SYNTHETIC */
SELECT
  'SUMMARY_HISTORICAL_ERROR_SYNTH' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period                   AS period_date,
  actual,
  forecast_val,
  sigma_est,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split
JOIN latest_per_sys l
  ON l.CONTRACT_SOURCE_SYSTEM = backtest_split.CONTRACT_SOURCE_SYSTEM
WHERE is_synthetic = 1
  AND forecast_period < l.max_eom

UNION ALL

/* E) Latest close anomaly detection (t = latest) — NON-SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_MAIN' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 0

UNION ALL

/* F) Latest close anomaly detection (t = latest) — SYNTHETIC */
SELECT
  'SUMMARY_ANOMALY_DETECTION_SYNTH' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period                 AS period_date,
  b.actual,
  b.forecast_val,
  b.sigma_est,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(b.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_split b
JOIN latest_join lj
  ON lj.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM
 AND lj.max_eom                = b.forecast_period
WHERE b.is_synthetic = 1

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month (Total Loans), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) float index (materialized)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows via (csum - lag(csum)); plus lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums (mean/std source)
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums (regression source)
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (no window here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - (sum y)^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7) latest month per system
latest_per_sys AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

-- 8) 12-month rolling BACKTEST panel:
--    for each system, take each month t-1 in the last up to 12 months,
#NAME?
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                   AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    -- forecast from the t-1 row's params
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    -- sigma estimated from t-1 window
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   -- last ~12 months of backtests
    AND p.END_OF_MONTH_DATE <  l.max_eom                    -- up to the month before latest
),

-- 9) latest row for forward forecast (optional)
last_latest AS (
  SELECT c.*
  FROM calc c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),

summary_next_fwd AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                 AS forecast_val,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                 AS sigma_est,

    l.avg_all                                         AS avg_level_sys
  FROM last_latest l
)

-- ===== FINAL OUTPUTS =====

-- A) Full HISTORY
SELECT
  'HISTORY'              AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE      AS period_date,
  SOURCE_SYSTEM_BALANCE  AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM calc

UNION ALL

-- B) Rolling 12-month BACKTEST panel (t-1 → t with actual)
SELECT
  'SUMMARY_BACKTEST_12M' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period         AS period_date,            -- month t
  actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m

UNION ALL

-- C) Forward forecast (latest → next month) — optional
SELECT
  'SUMMARY_NEXT_FWD'     AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period        AS period_date,            -- next month
  NULL::FLOAT8           AS actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM summary_next_fwd

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;








1. Executive Overview (for documentation)

Purpose:
This analysis detects unusual month-over-month changes in SOURCE_SYSTEM_BALANCE by CONTRACT_SOURCE_SYSTEM (system-level balances), using rolling statistics, regression trends, and seasonality adjustments.

Key Outputs:

	•	HISTORY: De-seasonalized series with rolling mean, rolling std, and regression parameters
	•	SUMMARY_BACKTEST_12M_SA: 12-month backtest comparing forecast vs. actual, with z-scores and severity ranking
	•	SUMMARY_NEXT_FWD_SA: Forward forecast for next month, with prediction intervals

How to Use:

	•	Analysts review SUMMARY_BACKTEST_12M_SA to investigate high-severity anomalies (sorted descending).
	•	Executives view the Power BI dashboard to understand portfolio stability, key drivers, and focus areas.







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* 1) Base monthly sums per system (Total Loans) */
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

/* 🚫 Fix correlated subquery: precompute avg level once */
sys_level_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM,
         AVG(SOURCE_SYSTEM_BALANCE) AS avg_level_sys
  FROM base
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* 2) Row index per system */
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

/* 3) Month-of-year seasonal indices (normalized to avg=1) */
base_moy AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    EXTRACT(MONTH FROM b.END_OF_MONTH_DATE) AS moy,
    b.SOURCE_SYSTEM_BALANCE
  FROM base b
),
sys_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM, AVG(SOURCE_SYSTEM_BALANCE) AS avg_all_sys
  FROM base_moy
  GROUP BY CONTRACT_SOURCE_SYSTEM
),
season_raw AS (
  SELECT
    m.CONTRACT_SOURCE_SYSTEM,
    m.moy,
    AVG(m.SOURCE_SYSTEM_BALANCE) / a.avg_all_sys AS factor_raw
  FROM base_moy m
  JOIN sys_avg a
    ON a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
  GROUP BY m.CONTRACT_SOURCE_SYSTEM, m.moy, a.avg_all_sys
),
season_norm AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.moy,
    s.factor_raw / NULLIF(AVG(s.factor_raw) OVER (PARTITION BY s.CONTRACT_SOURCE_SYSTEM), 0.0) AS season_factor
  FROM season_raw s
),

/* 4) Join factors; de-seasonalize; materialize float index */
base_d AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f,
    EXTRACT(MONTH FROM i.END_OF_MONTH_DATE) AS moy,
    i.SOURCE_SYSTEM_BALANCE,
    COALESCE(f.season_factor, 1.0) AS season_factor,
    CAST(i.SOURCE_SYSTEM_BALANCE / NULLIF(f.season_factor, 0.0) AS FLOAT8) AS y_d
  FROM idx1 i
  LEFT JOIN season_norm f
    ON f.CONTRACT_SOURCE_SYSTEM = i.CONTRACT_SOURCE_SYSTEM
   AND f.moy = EXTRACT(MONTH FROM i.END_OF_MONTH_DATE)
),

/* 5) Cumulative sums on de-seasonalized series */
csum_d AS (
  SELECT
    b.*,
    SUM(b.y_d)  OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y_d,
    SUM(CAST(b.y_d * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y2_d,
    SUM(b.rn_f) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x_d,
    SUM(CAST(b.rn_f * b.rn_f AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x2_d,
    SUM(CAST(b.rn_f * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_xy_d
  FROM base_d b
),

/* 6) Rolling windows via (csum - lag(csum)) */
roll_d AS (
  SELECT
    c.*,
    LEAST(c.rn, 6)  AS n6_d,
    LEAST(c.rn, 12) AS n12_d,

    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y_d,
    (c.csum_y2_d - COALESCE(LAG(c.csum_y2_d, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2_d,

    (c.csum_x_d  - COALESCE(LAG(c.csum_x_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x_d,
    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y_d,
    (c.csum_x2_d - COALESCE(LAG(c.csum_x2_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2_d,
    (c.csum_xy_d - COALESCE(LAG(c.csum_xy_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy_d
  FROM csum_d c
),

/* 7) Per-row stats on de-seasonalized series */
calc_d AS (
  SELECT
    r.*,

    CASE WHEN r.n6_d > 0 THEN r.sum6_y_d / CAST(r.n6_d AS FLOAT8) ELSE NULL END AS roll_mean_6_d,

    CASE
      WHEN r.n6_d > 1 THEN
        SQRT( GREATEST( (r.sum6_y2_d - ( (r.sum6_y_d * r.sum6_y_d) / CAST(r.n6_d AS FLOAT8) )), 0.0 )
              / CAST(r.n6_d - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6_d,

    CASE
      WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
        THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
             / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
      ELSE NULL
    END AS regr_slope_12_d,

    CASE
      WHEN r.n12_d >= 1 THEN
        ( r.sum12_y_d
          - ( COALESCE(
                CASE
                  WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
                    THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
                         / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
                  ELSE NULL
                END, 0.0) * r.sum12_x_d ) ) / CAST(r.n12_d AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12_d
  FROM roll_d r
),

/* 8) Latest month per system */
latest_per_sys AS (
  SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc_d
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* 9) Backtest 12M SA: forecast t from (t-1) in de-seasonalized space, re-seasonalize for t */
backtest_12m_sa AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                     AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                     AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                                 AS actual,

    COALESCE(fn.season_factor, 1.0)                         AS season_factor_next,

    CASE
      WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
        THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
      ELSE NULL
    END                                                     AS fc_linear_sa,

    /* simpler lag-12: join base once and its seasonal factor */
    c12.SOURCE_SYSTEM_BALANCE                               AS lag12_raw,
    fp12.season_factor                                      AS season_factor_prev12,

    CASE
      WHEN c12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
        THEN c12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
      ELSE NULL
    END                                                     AS fc_seasonal_sa,

    (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))     AS fc_rollmean_sa,

    COALESCE(
      CASE
        WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
          THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      CASE
        WHEN c12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
          THEN c12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
        ELSE NULL
      END,
      (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                       AS forecast_val,

    (COALESCE(p.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est
  FROM calc_d p
  JOIN calc_d c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM c.END_OF_MONTH_DATE)
  LEFT JOIN base c12
    ON c12.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c12.END_OF_MONTH_DATE      = ADD_MONTHS(c.END_OF_MONTH_DATE, -12)
  LEFT JOIN season_norm fp12
    ON fp12.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fp12.moy = EXTRACT(MONTH FROM c12.END_OF_MONTH_DATE)
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
    AND p.END_OF_MONTH_DATE <  l.max_eom
),

/* 10) Forward SA forecast: latest → next */
last_latest AS (
  SELECT c.*
  FROM calc_d c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),
summary_next_fwd_sa AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12_d IS NOT NULL AND l.regr_intercept_12_d IS NOT NULL
          THEN (l.regr_intercept_12_d + l.regr_slope_12_d * CAST(l.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      (l.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                 AS forecast_val,

    (COALESCE(l.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est
  FROM last_latest l
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM ADD_MONTHS(l.END_OF_MONTH_DATE, 1))
)

/* ================= FINAL OUTPUTS ================= */

-- A) HISTORY (same as before)
SELECT
  'HISTORY'                AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE        AS period_date,
  SOURCE_SYSTEM_BALANCE    AS actual,
  season_factor,
  y_d                      AS deseasonal_actual,
  roll_mean_6_d,
  roll_std_6_d,
  regr_slope_12_d,
  regr_intercept_12_d,
  NULL::FLOAT8             AS forecast_val,
  NULL::FLOAT8             AS pi95_lo,
  NULL::FLOAT8             AS pi95_hi,
  NULL::FLOAT8             AS dev_abs,
  NULL::FLOAT8             AS dev_pct,
  NULL::FLOAT8             AS z_score,
  NULL::FLOAT8             AS severity_0_100,
  NULL                     AS outside_95_band
FROM calc_d

UNION ALL

-- B) Seasonally-adjusted 12M backtest (join sys_level_avg to avoid correlated subquery)
SELECT
  'SUMMARY_BACKTEST_12M_SA' AS row_type,
  b.CONTRACT_SOURCE_SYSTEM,
  b.forecast_period          AS period_date,
  b.actual,
  NULL::FLOAT8               AS season_factor,
  NULL::FLOAT8               AS deseasonal_actual,
  NULL::FLOAT8               AS roll_mean_6_d,
  NULL::FLOAT8               AS roll_std_6_d,
  NULL::FLOAT8               AS regr_slope_12_d,
  NULL::FLOAT8               AS regr_intercept_12_d,
  b.forecast_val,
  (b.forecast_val - 1.9599 * b.sigma_est) AS pi95_lo,
  (b.forecast_val + 1.9599 * b.sigma_est) AS pi95_hi,
  (b.actual - b.forecast_val)             AS dev_abs,
  CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val) / b.forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val) / b.sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN b.sigma_est IS NOT NULL AND b.sigma_est > 0 THEN (b.actual - b.forecast_val)/b.sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN b.forecast_val <> 0 THEN (b.actual - b.forecast_val)/b.forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(b.actual - b.forecast_val) / NULLIF(a.avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN b.sigma_est IS NULL THEN NULL
    WHEN b.actual < (b.forecast_val - 1.9599 * b.sigma_est) THEN TRUE
    WHEN b.actual > (b.forecast_val + 1.9599 * b.sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m_sa b
JOIN sys_level_avg a
  ON a.CONTRACT_SOURCE_SYSTEM = b.CONTRACT_SOURCE_SYSTEM

UNION ALL

-- C) Seasonally-adjusted forward forecast (join sys_level_avg if you later need severity here)
SELECT
  'SUMMARY_NEXT_FWD_SA'     AS row_type,
  n.CONTRACT_SOURCE_SYSTEM,
  n.forecast_period         AS period_date,
  NULL::FLOAT8              AS actual,
  NULL::FLOAT8              AS season_factor,
  NULL::FLOAT8              AS deseasonal_actual,
  NULL::FLOAT8              AS roll_mean_6_d,
  NULL::FLOAT8              AS roll_std_6_d,
  NULL::FLOAT8              AS regr_slope_12_d,
  NULL::FLOAT8              AS regr_intercept_12_d,
  n.forecast_val,
  (n.forecast_val - 1.9599 * n.sigma_est) AS pi95_lo,
  (n.forecast_val + 1.9599 * n.sigma_est) AS pi95_hi,
  NULL::FLOAT8              AS dev_abs,
  NULL::FLOAT8              AS dev_pct,
  NULL::FLOAT8              AS z_score,
  NULL::FLOAT8              AS severity_0_100,
  NULL                      AS outside_95_band
FROM summary_next_fwd_sa n

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;




/* ====== PARAMETERS / RANGE ====== */
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

/* ====== ENRICHED MONTHLY PROFILE (system × industry × RC) ======
   Includes: balances, available_amount (for utilization),
   nonaccrual balances, account counts, safe numeric avg(PD_GRADE),
   and the descriptive codes you requested. */
profile_enriched AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    t.INDUSTRY_CODE,
    t.INDUSTRY_DESCRIPTION,
    t.RC_CODE,
    t.RC_DESCRIPTION,

    -- Core sums
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8)                               AS src_balance,
    CAST(SUM(COALESCE(t.AVAILABLE_AMOUNT, 0)) AS FLOAT8)                       AS available_amount,

    -- Non-accrual balance (using source balance; swap to GL if you prefer/if exists)
    CAST(SUM(CASE WHEN COALESCE(t.NON_ACCRUAL_FLAG,'N') = 'Y'
                  THEN t.SOURCE_SYSTEM_BALANCE ELSE 0 END) AS FLOAT8)          AS nonaccrual_balance,

    -- Account count
    COUNT(DISTINCT t.ACCOUNT_IDENTIFIER)                                       AS acct_count,

    /* Safe numeric PD_GRADE average:
       If PD_GRADE contains only digits and '.', treat as numeric; else ignore. */
    AVG(CASE
          WHEN TRANSLATE(COALESCE(t.PD_GRADE,''), '0123456789.', '') = ''
               AND LENGTH(COALESCE(t.PD_GRADE,'')) > 0
          THEN CAST(t.PD_GRADE AS FLOAT8)
          ELSE NULL
        END)                                                                    AS avg_pd_grade_num

  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY
    t.END_OF_MONTH_DATE, t.CONTRACT_SOURCE_SYSTEM,
    t.INDUSTRY_CODE, t.INDUSTRY_DESCRIPTION, t.RC_CODE, t.RC_DESCRIPTION
),

/* Derived ratios at the same grain for easy pivoting in Excel */
profile_with_ratios AS (
  SELECT
    p.*,
    -- Utilization = used / (used + available)
    CASE
      WHEN (p.src_balance + p.available_amount) <> 0
        THEN p.src_balance / (p.src_balance + p.available_amount)
      ELSE NULL
    END AS utilization_ratio,

    -- Non-accrual %
    CASE WHEN p.src_balance <> 0
         THEN p.nonaccrual_balance / p.src_balance
         ELSE NULL
    END AS nonaccrual_pct
  FROM profile_enriched p
),

/* ====== SYSTEM-LEVEL SERIES FOR MODELING (sum over Industry/RC) ====== */
base_sys AS (
  SELECT
    END_OF_MONTH_DATE,
    CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(src_balance) AS FLOAT8)            AS SOURCE_SYSTEM_BALANCE,
    CAST(SUM(available_amount) AS FLOAT8)       AS AVAILABLE_AMOUNT,
    CAST(SUM(nonaccrual_balance) AS FLOAT8)     AS NONACCRUAL_BALANCE,
    SUM(acct_count)                              AS ACCT_COUNT,
    AVG(avg_pd_grade_num)                        AS AVG_PD_GRADE_NUM   -- averaged across segments
  FROM profile_with_ratios
  GROUP BY 1,2
),

/* Row index for modeling */
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base_sys b
),

/* ====== Monthly seasonal indices (multiplicative), normalized to avg = 1 ====== */
base_moy AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    EXTRACT(MONTH FROM b.END_OF_MONTH_DATE) AS moy,
    b.SOURCE_SYSTEM_BALANCE
  FROM base_sys b
),
sys_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM, AVG(SOURCE_SYSTEM_BALANCE) AS avg_all_sys
  FROM base_moy
  GROUP BY CONTRACT_SOURCE_SYSTEM
),
season_raw AS (
  SELECT
    m.CONTRACT_SOURCE_SYSTEM,
    m.moy,
    AVG(m.SOURCE_SYSTEM_BALANCE) / a.avg_all_sys AS factor_raw
  FROM base_moy m
  JOIN sys_avg a
    ON a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
  GROUP BY m.CONTRACT_SOURCE_SYSTEM, m.moy, a.avg_all_sys
),
season_norm AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.moy,
    s.factor_raw / NULLIF(AVG(s.factor_raw) OVER (PARTITION BY s.CONTRACT_SOURCE_SYSTEM), 0.0) AS season_factor
  FROM season_raw s
),

/* ====== De-seasonalize & materialize float index ====== */
base_d AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f,
    EXTRACT(MONTH FROM i.END_OF_MONTH_DATE) AS moy,
    i.SOURCE_SYSTEM_BALANCE,
    COALESCE(f.season_factor, 1.0) AS season_factor,
    CAST(i.SOURCE_SYSTEM_BALANCE / NULLIF(f.season_factor, 0.0) AS FLOAT8) AS y_d,

    -- bring along business metrics for convenience (at system level)
    i.AVAILABLE_AMOUNT,
    i.NONACCRUAL_BALANCE,
    i.ACCT_COUNT,
    i.AVG_PD_GRADE_NUM
  FROM idx1 i
  LEFT JOIN season_norm f
    ON f.CONTRACT_SOURCE_SYSTEM = i.CONTRACT_SOURCE_SYSTEM
   AND f.moy = EXTRACT(MONTH FROM i.END_OF_MONTH_DATE)
),

/* Cumulative sums (window only) on de-seasonalized series */
csum_d AS (
  SELECT
    b.*,
    SUM(b.y_d)  OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y_d,
    SUM(CAST(b.y_d * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y2_d,
    SUM(b.rn_f) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x_d,
    SUM(CAST(b.rn_f * b.rn_f AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x2_d,
    SUM(CAST(b.rn_f * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_xy_d
  FROM base_d b
),

/* Rolling windows via (csum - lag(csum)) and raw lag-12 (if needed) */
roll_d AS (
  SELECT
    c.*,
    LEAST(c.rn, 6)  AS n6_d,
    LEAST(c.rn, 12) AS n12_d,

    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y_d,
    (c.csum_y2_d - COALESCE(LAG(c.csum_y2_d, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2_d,

    (c.csum_x_d  - COALESCE(LAG(c.csum_x_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x_d,
    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y_d,
    (c.csum_x2_d - COALESCE(LAG(c.csum_x2_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2_d,
    (c.csum_xy_d - COALESCE(LAG(c.csum_xy_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy_d,

    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_raw
  FROM csum_d c
),

/* Per-row stats on de-seasonalized series (no window here) */
calc_d AS (
  SELECT
    r.*,

    CASE WHEN r.n6_d > 0 THEN r.sum6_y_d / CAST(r.n6_d AS FLOAT8) ELSE NULL END AS roll_mean_6_d,

    CASE
      WHEN r.n6_d > 1 THEN
        SQRT( GREATEST( (r.sum6_y2_d - ( (r.sum6_y_d * r.sum6_y_d) / CAST(r.n6_d AS FLOAT8) )), 0.0 )
              / CAST(r.n6_d - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6_d,

    CASE
      WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
        THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
             / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
      ELSE NULL
    END AS regr_slope_12_d,

    CASE
      WHEN r.n12_d >= 1 THEN
        ( r.sum12_y_d
          - ( COALESCE(
                CASE
                  WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
                    THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
                         / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
                  ELSE NULL
                END, 0.0) * r.sum12_x_d ) ) / CAST(r.n12_d AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12_d
  FROM roll_d r
),

/* Latest month per system (for backtest horizon) */
latest_per_sys AS (
  SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc_d
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

/* 12-month seasonally-adjusted backtest: forecast t from (t-1), compare to actual at t */
backtest_12m_sa AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                       AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                       AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                                   AS actual,

    COALESCE(fn.season_factor, 1.0)                           AS season_factor_next,

    -- candidates (in seasonal space)
    CASE
      WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
        THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
      ELSE NULL
    END                                                       AS fc_linear_sa,

    CASE
      WHEN c_prev12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
        THEN c_prev12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
      ELSE NULL
    END                                                       AS fc_seasonal_sa,

    (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))       AS fc_rollmean_sa,

    COALESCE(
      CASE
        WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
          THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      CASE
        WHEN c_prev12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
          THEN c_prev12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
        ELSE NULL
      END,
      (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                         AS forecast_val,

    (COALESCE(p.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est,

    -- long-run average level for severity scaling (raw)
    (SELECT AVG(SOURCE_SYSTEM_BALANCE) FROM base_sys b WHERE b.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM) AS avg_level_sys
  FROM calc_d p
  JOIN calc_d c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM c.END_OF_MONTH_DATE)
  LEFT JOIN base_sys c_prev12
    ON c_prev12.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c_prev12.END_OF_MONTH_DATE      = ADD_MONTHS(c.END_OF_MONTH_DATE, -12)
  LEFT JOIN season_norm fp12
    ON fp12.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fp12.moy = EXTRACT(MONTH FROM c_prev12.END_OF_MONTH_DATE)
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
    AND p.END_OF_MONTH_DATE <  l.max_eom
),

/* Forward seasonally-adjusted forecast: latest → next month */
last_latest AS (
  SELECT c.*
  FROM calc_d c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),
summary_next_fwd_sa AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12_d IS NOT NULL AND l.regr_intercept_12_d IS NOT NULL
          THEN (l.regr_intercept_12_d + l.regr_slope_12_d * CAST(l.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      (l.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                 AS forecast_val,

    (COALESCE(l.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est,

    (SELECT AVG(SOURCE_SYSTEM_BALANCE) FROM base_sys b WHERE b.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM) AS avg_level_sys
  FROM last_latest l
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM ADD_MONTHS(l.END_OF_MONTH_DATE, 1))
)

/* ====== FINAL OUTPUTS ====== */

-- D) PROFILE: enriched analytic dataset at system × industry × RC × month
SELECT
  'PROFILE'               AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE       AS period_date,
  INDUSTRY_CODE,
  INDUSTRY_DESCRIPTION,
  RC_CODE,
  RC_DESCRIPTION,
  src_balance             AS actual_balance,
  available_amount,
  nonaccrual_balance,
  acct_count,
  avg_pd_grade_num,
  utilization_ratio,
  nonaccrual_pct,
  NULL::FLOAT8            AS season_factor,
  NULL::FLOAT8            AS deseasonal_actual,
  NULL::FLOAT8            AS roll_mean_6_d,
  NULL::FLOAT8            AS roll_std_6_d,
  NULL::FLOAT8            AS regr_slope_12_d,
  NULL::FLOAT8            AS regr_intercept_12_d,
  NULL::FLOAT8            AS forecast_val,
  NULL::FLOAT8            AS pi95_lo,
  NULL::FLOAT8            AS pi95_hi,
  NULL::FLOAT8            AS dev_abs,
  NULL::FLOAT8            AS dev_pct,
  NULL::FLOAT8            AS z_score,
  NULL::FLOAT8            AS severity_0_100,
  NULL                     AS outside_95_band
FROM profile_with_ratios

UNION ALL

-- A) HISTORY (system-level, seasonally de-trended stats for modeling)
SELECT
  'HISTORY'               AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE       AS period_date,
  NULL::VARCHAR(50)       AS INDUSTRY_CODE,
  NULL::VARCHAR(200)      AS INDUSTRY_DESCRIPTION,
  NULL::VARCHAR(50)       AS RC_CODE,
  NULL::VARCHAR(200)      AS RC_DESCRIPTION,
  SOURCE_SYSTEM_BALANCE   AS actual_balance,
  AVAILABLE_AMOUNT,
  NONACCRUAL_BALANCE,
  ACCT_COUNT,
  AVG_PD_GRADE_NUM,
  NULL::FLOAT8            AS utilization_ratio,
  NULL::FLOAT8            AS nonaccrual_pct,
  season_factor,
  y_d                     AS deseasonal_actual,
  roll_mean_6_d,
  roll_std_6_d,
  regr_slope_12_d,
  regr_intercept_12_d,
  NULL::FLOAT8            AS forecast_val,
  NULL::FLOAT8            AS pi95_lo,
  NULL::FLOAT8            AS pi95_hi,
  NULL::FLOAT8            AS dev_abs,
  NULL::FLOAT8            AS dev_pct,
  NULL::FLOAT8            AS z_score,
  NULL::FLOAT8            AS severity_0_100,
  NULL                    AS outside_95_band
FROM calc_d

UNION ALL

-- B) Seasonally-adjusted rolling 12M backtest (t-1 → t with actual)
SELECT
  'SUMMARY_BACKTEST_12M_SA' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period            AS period_date,
  NULL::VARCHAR(50)          AS INDUSTRY_CODE,
  NULL::VARCHAR(200)         AS INDUSTRY_DESCRIPTION,
  NULL::VARCHAR(50)          AS RC_CODE,
  NULL::VARCHAR(200)         AS RC_DESCRIPTION,
  actual                     AS actual_balance,
  NULL::FLOAT8               AS AVAILABLE_AMOUNT,
  NULL::FLOAT8               AS NONACCRUAL_BALANCE,
  NULL::INTEGER              AS ACCT_COUNT,
  NULL::FLOAT8               AS AVG_PD_GRADE_NUM,
  NULL::FLOAT8               AS utilization_ratio,
  NULL::FLOAT8               AS nonaccrual_pct,
  NULL::FLOAT8               AS season_factor,
  NULL::FLOAT8               AS deseasonal_actual,
  NULL::FLOAT8               AS roll_mean_6_d,
  NULL::FLOAT8               AS roll_std_6_d,
  NULL::FLOAT8               AS regr_slope_12_d,
  NULL::FLOAT8               AS regr_intercept_12_d,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m_sa

UNION ALL

-- C) Seasonally-adjusted forward forecast (latest → next)
SELECT
  'SUMMARY_NEXT_FWD_SA'     AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period           AS period_date,
  NULL::VARCHAR(50)         AS INDUSTRY_CODE,
  NULL::VARCHAR(200)        AS INDUSTRY_DESCRIPTION,
  NULL::VARCHAR(50)         AS RC_CODE,
  NULL::VARCHAR(200)        AS RC_DESCRIPTION,
  NULL::FLOAT8              AS actual_balance,
  NULL::FLOAT8              AS AVAILABLE_AMOUNT,
  NULL::FLOAT8              AS NONACCRUAL_BALANCE,
  NULL::INTEGER             AS ACCT_COUNT,
  NULL::FLOAT8              AS AVG_PD_GRADE_NUM,
  NULL::FLOAT8              AS utilization_ratio,
  NULL::FLOAT8              AS nonaccrual_pct,
  NULL::FLOAT8              AS season_factor,
  NULL::FLOAT8              AS deseasonal_actual,
  NULL::FLOAT8              AS roll_mean_6_d,
  NULL::FLOAT8              AS roll_std_6_d,
  NULL::FLOAT8              AS regr_slope_12_d,
  NULL::FLOAT8              AS regr_intercept_12_d,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8              AS dev_abs,
  NULL::FLOAT8              AS dev_pct,
  NULL::FLOAT8              AS z_score,
  NULL::FLOAT8              AS severity_0_100,
  NULL                      AS outside_95_band
FROM summary_next_fwd_sa

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) Base aggregation (per system × month), scoped to Total Loans
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) Row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) Compute month-of-year seasonal indices (multiplicative), normalized to avg=1
base_moy AS (
  SELECT
    b.END_OF_MONTH_DATE,
    b.CONTRACT_SOURCE_SYSTEM,
    EXTRACT(MONTH FROM b.END_OF_MONTH_DATE) AS moy,
    b.SOURCE_SYSTEM_BALANCE
  FROM base b
),
sys_avg AS (
  SELECT CONTRACT_SOURCE_SYSTEM, AVG(SOURCE_SYSTEM_BALANCE) AS avg_all_sys
  FROM base_moy
  GROUP BY CONTRACT_SOURCE_SYSTEM
),
season_raw AS (
  SELECT
    m.CONTRACT_SOURCE_SYSTEM,
    m.moy,
    AVG(m.SOURCE_SYSTEM_BALANCE) / a.avg_all_sys AS factor_raw
  FROM base_moy m
  JOIN sys_avg a
    ON a.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
  GROUP BY m.CONTRACT_SOURCE_SYSTEM, m.moy, a.avg_all_sys
),
season_norm AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.moy,
    s.factor_raw / NULLIF(AVG(s.factor_raw) OVER (PARTITION BY s.CONTRACT_SOURCE_SYSTEM), 0.0) AS season_factor
  FROM season_raw s
),

-- 4) Join factors; de-seasonalize; materialize float index
base_d AS (
  SELECT
    i.END_OF_MONTH_DATE,
    i.CONTRACT_SOURCE_SYSTEM,
    i.rn,
    CAST(i.rn AS FLOAT8) AS rn_f,
    EXTRACT(MONTH FROM i.END_OF_MONTH_DATE) AS moy,
    i.SOURCE_SYSTEM_BALANCE,
    COALESCE(f.season_factor, 1.0) AS season_factor,
    CAST(i.SOURCE_SYSTEM_BALANCE / NULLIF(f.season_factor, 0.0) AS FLOAT8) AS y_d
  FROM idx1 i
  LEFT JOIN season_norm f
    ON f.CONTRACT_SOURCE_SYSTEM = i.CONTRACT_SOURCE_SYSTEM
   AND f.moy = EXTRACT(MONTH FROM i.END_OF_MONTH_DATE)
),

-- 5) Cumulative sums on de-seasonalized series (window only here)
csum_d AS (
  SELECT
    b.*,
    SUM(b.y_d)  OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y_d,
    SUM(CAST(b.y_d * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_y2_d,
    SUM(b.rn_f) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x_d,
    SUM(CAST(b.rn_f * b.rn_f AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x2_d,
    SUM(CAST(b.rn_f * b.y_d AS FLOAT8)) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_xy_d
  FROM base_d b
),

-- 6) Rolling windows via (csum - lag(csum)) on de-seasonalized series; also raw lag-12 if needed
roll_d AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6_d,
    LEAST(c.rn, 12) AS n12_d,

    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y_d,
    (c.csum_y2_d - COALESCE(LAG(c.csum_y2_d, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2_d,

    (c.csum_x_d  - COALESCE(LAG(c.csum_x_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x_d,
    (c.csum_y_d  - COALESCE(LAG(c.csum_y_d,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y_d,
    (c.csum_x2_d - COALESCE(LAG(c.csum_x2_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2_d,
    (c.csum_xy_d - COALESCE(LAG(c.csum_xy_d, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy_d,

    -- raw series lag-12 (for optional seasonal-naive fallback scaling)
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_raw
  FROM csum_d c
),

-- 7) Per-row stats on de-seasonalized series (no window here): rolling mean/std and regression
calc_d AS (
  SELECT
    r.*,

    CASE WHEN r.n6_d > 0 THEN r.sum6_y_d / CAST(r.n6_d AS FLOAT8) ELSE NULL END AS roll_mean_6_d,

    CASE
      WHEN r.n6_d > 1 THEN
        SQRT( GREATEST( (r.sum6_y2_d - ( (r.sum6_y_d * r.sum6_y_d) / CAST(r.n6_d AS FLOAT8) )), 0.0 )
              / CAST(r.n6_d - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6_d,

    CASE
      WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
        THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
             / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
      ELSE NULL
    END AS regr_slope_12_d,

    CASE
      WHEN r.n12_d >= 1 THEN
        ( r.sum12_y_d
          - ( COALESCE(
                CASE
                  WHEN r.n12_d >= 2 AND ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) ) <> 0.0
                    THEN ( (CAST(r.n12_d AS FLOAT8) * r.sum12_xy_d) - (r.sum12_x_d * r.sum12_y_d) )
                         / ( (CAST(r.n12_d AS FLOAT8) * r.sum12_x2_d) - (r.sum12_x_d * r.sum12_x_d) )
                  ELSE NULL
                END, 0.0) * r.sum12_x_d ) ) / CAST(r.n12_d AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12_d
  FROM roll_d r
),

-- 8) Latest month per system
latest_per_sys AS (
  SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc_d
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

-- 9) Rolling 12M seasonally-adjusted backtest: forecast t from (t-1) in de-seasonalized space, re-seasonalize for t
backtest_12m_sa AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                     AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                     AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                                 AS actual,

    -- seasonal factors for re-scaling
    COALESCE(fn.season_factor, 1.0)                         AS season_factor_next,

    -- candidates in seasonal space
    CASE
      WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
        THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
      ELSE NULL
    END                                                     AS fc_linear_sa,

    -- seasonal-naive fallback using raw lag-12 if available (scaled to next month’s factor)
    CASE
      WHEN c_prev12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
        THEN c_prev12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
      ELSE NULL
    END                                                     AS fc_seasonal_sa,

    -- rolling-mean fallback (de-seasonalized mean re-seasonalized)
    (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))     AS fc_rollmean_sa,

    -- chosen forecast
    COALESCE(
      CASE
        WHEN p.regr_slope_12_d IS NOT NULL AND p.regr_intercept_12_d IS NOT NULL
          THEN (p.regr_intercept_12_d + p.regr_slope_12_d * CAST(p.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      CASE
        WHEN c_prev12.SOURCE_SYSTEM_BALANCE IS NOT NULL AND fp12.season_factor IS NOT NULL
          THEN c_prev12.SOURCE_SYSTEM_BALANCE * (COALESCE(fn.season_factor,1.0) / NULLIF(fp12.season_factor,1.0))
        ELSE NULL
      END,
      (p.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                       AS forecast_val,

    -- sigma estimated in de-seasonalized series, then re-seasonalized by S_t
    (COALESCE(p.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est,

    -- average level (raw) for severity scaling
    (SELECT AVG(SOURCE_SYSTEM_BALANCE) FROM base b WHERE b.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM) AS avg_level_sys
  FROM calc_d p
  JOIN calc_d c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM c.END_OF_MONTH_DATE)
  LEFT JOIN base c_prev12_raw
    ON c_prev12_raw.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c_prev12_raw.END_OF_MONTH_DATE      = ADD_MONTHS(c.END_OF_MONTH_DATE, -12)
  LEFT JOIN season_norm fp12
    ON fp12.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND fp12.moy = EXTRACT(MONTH FROM c_prev12_raw.END_OF_MONTH_DATE)
  LEFT JOIN base c_prev12
    ON c_prev12.CONTRACT_SOURCE_SYSTEM = c_prev12_raw.CONTRACT_SOURCE_SYSTEM
   AND c_prev12.END_OF_MONTH_DATE      = c_prev12_raw.END_OF_MONTH_DATE
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)
    AND p.END_OF_MONTH_DATE <  l.max_eom
),

-- 10) Forward seasonally-adjusted forecast: latest → next month
last_latest AS (
  SELECT c.*
  FROM calc_d c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),
summary_next_fwd_sa AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12_d IS NOT NULL AND l.regr_intercept_12_d IS NOT NULL
          THEN (l.regr_intercept_12_d + l.regr_slope_12_d * CAST(l.rn + 1 AS FLOAT8)) * COALESCE(fn.season_factor, 1.0)
        ELSE NULL
      END,
      (l.roll_mean_6_d * COALESCE(fn.season_factor, 1.0))
    )                                                 AS forecast_val,

    (COALESCE(l.roll_std_6_d, NULL) * COALESCE(fn.season_factor, 1.0)) AS sigma_est,

    (SELECT AVG(SOURCE_SYSTEM_BALANCE) FROM base b WHERE b.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM) AS avg_level_sys
  FROM last_latest l
  LEFT JOIN season_norm fn
    ON fn.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND fn.moy = EXTRACT(MONTH FROM ADD_MONTHS(l.END_OF_MONTH_DATE, 1))
)

-- ================= FINAL OUTPUTS =================

-- A) HISTORY: raw actuals + de-seasonalized stats and regression
SELECT
  'HISTORY'                AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE        AS period_date,
  SOURCE_SYSTEM_BALANCE    AS actual,
  season_factor,
  y_d                      AS deseasonal_actual,
  roll_mean_6_d,
  roll_std_6_d,
  regr_slope_12_d,
  regr_intercept_12_d,
  NULL::FLOAT8             AS forecast_val,
  NULL::FLOAT8             AS pi95_lo,
  NULL::FLOAT8             AS pi95_hi,
  NULL::FLOAT8             AS dev_abs,
  NULL::FLOAT8             AS dev_pct,
  NULL::FLOAT8             AS z_score,
  NULL::FLOAT8             AS severity_0_100,
  NULL                     AS outside_95_band
FROM calc_d

UNION ALL

-- B) Seasonally-adjusted rolling 12M backtest (t-1 → t with actual)
SELECT
  'SUMMARY_BACKTEST_12M_SA' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period            AS period_date,
  actual,
  NULL::FLOAT8               AS season_factor,
  NULL::FLOAT8               AS deseasonal_actual,
  NULL::FLOAT8               AS roll_mean_6_d,
  NULL::FLOAT8               AS roll_std_6_d,
  NULL::FLOAT8               AS regr_slope_12_d,
  NULL::FLOAT8               AS regr_intercept_12_d,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val)/sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val)/forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m_sa

UNION ALL

-- C) Seasonally-adjusted forward forecast (latest → next)
SELECT
  'SUMMARY_NEXT_FWD_SA'     AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period           AS period_date,
  NULL::FLOAT8              AS actual,
  NULL::FLOAT8              AS season_factor,
  NULL::FLOAT8              AS deseasonal_actual,
  NULL::FLOAT8              AS roll_mean_6_d,
  NULL::FLOAT8              AS roll_std_6_d,
  NULL::FLOAT8              AS regr_slope_12_d,
  NULL::FLOAT8              AS regr_intercept_12_d,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8              AS dev_abs,
  NULL::FLOAT8              AS dev_pct,
  NULL::FLOAT8              AS z_score,
  NULL::FLOAT8              AS severity_0_100,
  NULL                      AS outside_95_band
FROM summary_next_fwd_sa

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month (Total Loans), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) float index (materialized)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows via (csum - lag(csum)); plus lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums (mean/std source)
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums (regression source)
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (no window here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - (sum y)^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7) latest month per system
latest_per_sys AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

-- 8) 12-month rolling BACKTEST panel:
--    for each system, take each month t-1 in the last up to 12 months,
--    forecast month t and compare to actual at t
backtest_12m AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                   AS model_asof_period,  -- t-1
    c.END_OF_MONTH_DATE                                   AS forecast_period,    -- t
    c.SOURCE_SYSTEM_BALANCE                               AS actual,

    -- forecast from the t-1 row's params
    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                     AS forecast_val,

    -- sigma estimated from t-1 window
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                     AS sigma_est,

    p.avg_all                                             AS avg_level_sys
  FROM calc p
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE      = ADD_MONTHS(p.END_OF_MONTH_DATE, 1)
  JOIN latest_per_sys l
    ON l.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE p.END_OF_MONTH_DATE >= ADD_MONTHS(l.max_eom, -12)   -- last ~12 months of backtests
    AND p.END_OF_MONTH_DATE <  l.max_eom                    -- up to the month before latest
),

-- 9) latest row for forward forecast (optional)
last_latest AS (
  SELECT c.*
  FROM calc c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),

summary_next_fwd AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                           AS actual_last,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                 AS forecast_val,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                 AS sigma_est,

    l.avg_all                                         AS avg_level_sys
  FROM last_latest l
)

-- ===== FINAL OUTPUTS =====

-- A) Full HISTORY
SELECT
  'HISTORY'              AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE      AS period_date,
  SOURCE_SYSTEM_BALANCE  AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8           AS forecast_val,
  NULL::FLOAT8           AS pi95_lo,
  NULL::FLOAT8           AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM calc

UNION ALL

-- B) Rolling 12-month BACKTEST panel (t-1 → t with actual)
SELECT
  'SUMMARY_BACKTEST_12M' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period         AS period_date,            -- month t
  actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual - forecast_val)             AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM backtest_12m

UNION ALL

-- C) Forward forecast (latest → next month) — optional
SELECT
  'SUMMARY_NEXT_FWD'     AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period        AS period_date,            -- next month
  NULL::FLOAT8           AS actual,
  NULL::FLOAT8           AS roll_mean_6,
  NULL::FLOAT8           AS roll_std_6,
  NULL::FLOAT8           AS lag12_balance,
  NULL::FLOAT8           AS regr_slope_12,
  NULL::FLOAT8           AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8           AS dev_abs,
  NULL::FLOAT8           AS dev_pct,
  NULL::FLOAT8           AS z_score,
  NULL::FLOAT8           AS severity_0_100,
  NULL                   AS outside_95_band
FROM summary_next_fwd

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) RC_CODE × month (Total Loans only), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.RC_CODE,
    t.RC_DESCRIPTION,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2,3
),

-- 2) row index per RC
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (
      PARTITION BY b.RC_CODE, b.RC_DESCRIPTION
      ORDER BY b.END_OF_MONTH_DATE
    ) AS rn
  FROM base b
),

-- 3) float index
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums
csum AS (
  SELECT
    x.*,

    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.RC_CODE, x.RC_DESCRIPTION ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE, x.RC_DESCRIPTION ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    SUM(x.rn_f) OVER (
      PARTITION BY x.RC_CODE, x.RC_DESCRIPTION ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE, x.RC_DESCRIPTION ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE, x.RC_DESCRIPTION ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    COUNT(*) OVER (PARTITION BY x.RC_CODE, x.RC_DESCRIPTION) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.RC_CODE, x.RC_DESCRIPTION) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.RC_CODE, x.RC_DESCRIPTION) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows + lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.RC_CODE, c.RC_DESCRIPTION ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats
calc AS (
  SELECT
    r.*,

    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ((r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8))), 0.0 )
              / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    CASE
      WHEN r.n12 >= 2 AND ((CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x)) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ((CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x)) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                END, 0.0) * r.sum12_x )
        ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7a) latest month per RC
latest_per_rc AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY RC_CODE, RC_DESCRIPTION
),

-- 7b) previous month per RC
prev_per_rc AS (
  SELECT
    l.RC_CODE,
    l.RC_DESCRIPTION,
    MAX(c.END_OF_MONTH_DATE) AS prev_eom
  FROM latest_per_rc l
  JOIN calc c
    ON c.RC_CODE = l.RC_CODE
   AND c.RC_DESCRIPTION = l.RC_DESCRIPTION
   AND c.END_OF_MONTH_DATE < l.max_eom
  GROUP BY l.RC_CODE, l.RC_DESCRIPTION
),

-- 7c) rows for latest and previous months
last_latest AS (
  SELECT c.*
  FROM calc c
  JOIN latest_per_rc l
    ON c.RC_CODE = l.RC_CODE
   AND c.RC_DESCRIPTION = l.RC_DESCRIPTION
   AND c.END_OF_MONTH_DATE = l.max_eom
),
last_prev AS (
  SELECT c.*
  FROM calc c
  JOIN prev_per_rc p
    ON c.RC_CODE = p.RC_CODE
   AND c.RC_DESCRIPTION = p.RC_DESCRIPTION
   AND c.END_OF_MONTH_DATE = p.prev_eom
),

-- 7d) latest actual for backtest comparison
latest_actual AS (
  SELECT
    ll.RC_CODE,
    ll.RC_DESCRIPTION,
    ll.END_OF_MONTH_DATE AS latest_eom,
    ll.SOURCE_SYSTEM_BALANCE AS actual_latest
  FROM last_latest ll
),

-- 8) forecast: latest → next month
summary_next_fwd AS (
  SELECT
    l.RC_CODE,
    l.RC_DESCRIPTION,
    l.END_OF_MONTH_DATE                                           AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                            AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                                       AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
    END                                                           AS fc_linear,
    l.lag12_balance                                               AS fc_seasonal,
    l.roll_mean_6                                                 AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                             AS forecast_val,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
      END
    )                                                             AS sigma_est,

    l.avg_all                                                     AS avg_level_rc
  FROM last_latest l
),

-- 9) backtest: previous → latest, compare to actual
summary_backtest AS (
  SELECT
    p.RC_CODE,
    p.RC_DESCRIPTION,
    p.END_OF_MONTH_DATE                                           AS model_asof_period,
    a.latest_eom                                                  AS forecast_period,
    a.actual_latest                                               AS actual_latest,

    CASE
      WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
        THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
    END                                                           AS fc_linear,
    p.lag12_balance                                               AS fc_seasonal,
    p.roll_mean_6                                                 AS fc_rollmean,

    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                             AS forecast_val,

    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
      END
    )                                                             AS sigma_est,

    p.avg_all                                                     AS avg_level_rc
  FROM last_prev p
  JOIN latest_actual a
    ON a.RC_CODE = p.RC_CODE
   AND a.RC_DESCRIPTION = p.RC_DESCRIPTION
)

-- ===== FINAL OUTPUTS =====
-- 1) HISTORY (one row per month per RC with stats)
SELECT
  'HISTORY'                AS row_type,
  RC_CODE                  AS rc_code,
  RC_DESCRIPTION           AS rc_description,
  END_OF_MONTH_DATE        AS period_date,
  SOURCE_SYSTEM_BALANCE    AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8             AS forecast_val,
  NULL::FLOAT8             AS pi95_lo,
  NULL::FLOAT8             AS pi95_hi,
  NULL::FLOAT8             AS dev_abs,
  NULL::FLOAT8             AS dev_pct,
  NULL::FLOAT8             AS z_score,
  NULL::FLOAT8             AS severity_0_100,
  NULL                     AS outside_95_band
FROM calc

UNION ALL

-- 2) BACKTEST: prev→latest forecast with actual comparison
SELECT
  'SUMMARY_BACKTEST'       AS row_type,
  RC_CODE                  AS rc_code,
  RC_DESCRIPTION           AS rc_description,
  forecast_period          AS period_date,          -- latest month
  actual_latest            AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual_latest - forecast_val)      AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual_latest - forecast_val) / NULLIF(avg_level_rc * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual_latest < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual_latest > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM summary_backtest

UNION ALL

-- 3) FORWARD: latest→next forecast (no actual yet)
SELECT
  'SUMMARY_NEXT_FWD'       AS row_type,
  RC_CODE                  AS rc_code,
  RC_DESCRIPTION           AS rc_description,
  forecast_period          AS period_date,          -- next month
  NULL::FLOAT8             AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8                         AS dev_abs,
  NULL::FLOAT8                         AS dev_pct,
  NULL::FLOAT8                         AS z_score,
  NULL::FLOAT8                         AS severity_0_100,
  NULL                                 AS outside_95_band
FROM summary_next_fwd

ORDER BY rc_code, rc_description, period_date;







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) RC_CODE × month (Total Loans only), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.RC_CODE,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per RC_CODE
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) float index (materialized)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.RC_CODE ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.RC_CODE ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.RC_CODE ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-RC_CODE moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.RC_CODE) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.RC_CODE) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.RC_CODE) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows via (csum - lag(csum)); plus lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums (mean/std source)
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums (regression source)
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.RC_CODE ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (no window here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7a) latest month per RC_CODE
latest_per_rc AS (
  SELECT
    RC_CODE,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY RC_CODE
),

-- 7b) prior (previous) month per RC_CODE
prev_per_rc AS (
  SELECT
    l.RC_CODE,
    MAX(c.END_OF_MONTH_DATE) AS prev_eom
  FROM latest_per_rc l
  JOIN calc c
    ON c.RC_CODE = l.RC_CODE
   AND c.END_OF_MONTH_DATE < l.max_eom
  GROUP BY l.RC_CODE
),

-- 7c) rows for latest month and prior month (for both modes)
last_latest AS (  -- latest row: basis for FORWARD forecast (to next month)
  SELECT c.*
  FROM calc c
  JOIN latest_per_rc l
    ON c.RC_CODE = l.RC_CODE
   AND c.END_OF_MONTH_DATE = l.max_eom
),
last_prev AS (    -- previous row: basis for BACKTEST forecast (to latest month)
  SELECT c.*
  FROM calc c
  JOIN prev_per_rc p
    ON c.RC_CODE = p.RC_CODE
   AND c.END_OF_MONTH_DATE = p.prev_eom
),

-- 7d) bring in the latest actual (value at latest month) for backtest comparison
latest_actual AS (
  SELECT
    ll.RC_CODE,
    ll.END_OF_MONTH_DATE AS latest_eom,
    ll.SOURCE_SYSTEM_BALANCE AS actual_latest
  FROM last_latest ll
),

-- 8) SUMMARY_NEXT_FWD: forecast from latest → next month
summary_next_fwd AS (
  SELECT
    l.RC_CODE,
    l.END_OF_MONTH_DATE                                           AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                            AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                                       AS actual_last,

    -- candidate forecasts
    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                           AS fc_linear,
    l.lag12_balance                                               AS fc_seasonal,
    l.roll_mean_6                                                 AS fc_rollmean,

    -- choose forecast: linear → seasonal → rolling mean
    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                             AS forecast_val,

    -- sigma: prefer rolling-6 else overall sample std from moments
    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                             AS sigma_est,

    l.avg_all                                                     AS avg_level_rc
  FROM last_latest l
),

-- 9) SUMMARY_BACKTEST: forecast from previous → latest month, compare to latest actual
summary_backtest AS (
  SELECT
    p.RC_CODE,
    p.END_OF_MONTH_DATE                                           AS model_asof_period,  -- prev month (model trained up to here)
    a.latest_eom                                                  AS forecast_period,    -- latest month (target)
    a.actual_latest                                               AS actual_latest,

    -- candidate forecasts (from previous row’s params ⇒ step ahead 1)
    CASE
      WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
        THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                           AS fc_linear,
    p.lag12_balance                                               AS fc_seasonal,
    p.roll_mean_6                                                 AS fc_rollmean,

    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                             AS forecast_val,

    -- sigma estimated from previous window
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                             AS sigma_est,

    p.avg_all                                                     AS avg_level_rc
  FROM last_prev p
  JOIN latest_actual a
    ON a.RC_CODE = p.RC_CODE
)

-- ===== FINAL OUTPUTS =====
-- 1) Full HISTORY (one row per month per RC_CODE with stats)
SELECT
  'HISTORY'                AS row_type,
  RC_CODE                  AS key_col,
  END_OF_MONTH_DATE        AS period_date,
  SOURCE_SYSTEM_BALANCE    AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8             AS forecast_val,
  NULL::FLOAT8             AS pi95_lo,
  NULL::FLOAT8             AS pi95_hi,
  NULL::FLOAT8             AS dev_abs,
  NULL::FLOAT8             AS dev_pct,
  NULL::FLOAT8             AS z_score,
  NULL::FLOAT8             AS severity_0_100,
  NULL                     AS outside_95_band
FROM calc

UNION ALL

-- 2) BACKTEST: prev→latest forecast with actual comparison
SELECT
  'SUMMARY_BACKTEST'       AS row_type,
  RC_CODE                  AS key_col,
  forecast_period          AS period_date,          -- latest month (e.g., 2025-08-31)
  actual_latest            AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual_latest - forecast_val)      AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual_latest - forecast_val) / NULLIF(avg_level_rc * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual_latest < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual_latest > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM summary_backtest

UNION ALL

-- 3) FORWARD: latest→next forecast (no actual yet)
SELECT
  'SUMMARY_NEXT_FWD'       AS row_type,
  RC_CODE                  AS key_col,
  forecast_period          AS period_date,          -- next month (e.g., 2025-09-30)
  NULL::FLOAT8             AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8                         AS dev_abs,
  NULL::FLOAT8                         AS dev_pct,
  NULL::FLOAT8                         AS z_score,
  NULL::FLOAT8                         AS severity_0_100,
  NULL                                 AS outside_95_band
FROM summary_next_fwd

ORDER BY key_col, period_date;







Date	Category	Description	 Amount 	Type
9/6/2025	Coffee	Starbucks	 9.82 	Wants
9/6/2025	Zyn	Shell	 6.00 	Wants
9/6/2025	Snacks	Shell	 5.00 	Wants
9/6/2025	Subscriptions	Netflix	 10.00 	Wants
9/6/2025	Subscriptions	Hulu/Disney/ESPN	 10.00 	Wants
9/6/2025	Clothing	J.Crew	 168.92 	Wants
9/6/2025	Rent	Rent	 1,720.00 	Needs
9/6/2025	Internet	Internet	 33.00 	Needs
9/6/2025	Coffee	Starbucks	 3.86 	Wants
9/6/2025	Alcohol	The Local	 13.00 	Wants
9/6/2025	Alcohol	CVS	 12.00 	Wants
9/6/2025	Alcohol	R-Day	 20.00 	Wants
9/6/2025	Transit	Uber	 28.00 	Wants
9/6/2025	Transit	Uber	 30.00 	Wants
9/6/2025	Dining Out	Sizzle & Crunch	 30.20 	Wants
9/7/2025	Coffee	Starbucks	 10.00 	Wants
9/7/2025	Alcohol	Old Stove	 11.40 	Wants
9/7/2025	Transit	Limes	 14.75 	Wants
9/7/2025	Dining Out	Tom Douglas (Half Shell)	 76.91 	Wants
9/7/2025	Dining Out	Mochinut	 20.97 	Wants
9/7/2025	Entertainment	Toys	 32.73 	Wants
9/7/2025	Coffee	Starbucks	 3.68 	Wants
9/7/2025	Coffee	Starbucks	 3.68 	Wants
9/7/2025	Groceries	Wholefoods	 12.00 	Needs
9/7/2025	Coffee	Starbucks	 3.00 	Wants
9/7/2025	Coffee	Starbucks	 8.18 	Wants
9/7/2025	Snacks	Starbucks	 7.46 	Wants
9/9/2025	Entertainment	Sandbox VR	 121.39 	Wants
9/9/2025	Health & Fitness	Row House	 135.00 	Wants
9/9/2025	Coffee	Starbucks	 4.00 	Wants
9/9/2025	Dining Out	Starbucks	 7.00 	Wants
9/9/2025	Transit	Parking Ticket	 123.00 	Wants
9/10/2025	Snacks	CVS	 7.00 	Wants
9/10/2025	Coffee	CVS	 13.00 	Wants
9/11/2025	Transit	Parking Ticket	 93.50 	Wants
9/11/2025	Dining Out	Jimmy John's	 18.09 	Wants
9/11/2025	Dining Out	Thomas Street Tavern	 35.21 	Wants
9/11/2025	Alcohol	Thomas Street Tavern	 20.00 	Wants
9/12/2025	Coffee	Starbucks	 4.00 	Wants
9/12/2025	Dining Out	Starbucks	 6.00 	Wants
9/12/2025	Dining Out	Vitality Bowls	 16.53 	Wants
9/12/2025	Snacks	CVS	 7.20 	Wants
9/12/2025	Alcohol	CVS	 16.00 	Wants
9/12/2025	Groceries	Wholefoods	 119.00 	Needs
9/13/2025	Subscriptions	ChatGPT	 22.00 	Wants
9/13/2025	Subscriptions	Apple iCloud Storage	 2.99 	Wants
9/13/2025	Coffee	Starbucks	 10.65 	Wants
9/13/2025	Zyn	Shell	 6.00 	Wants
9/13/2025	Groceries	Wholefoods	 83.81 	Needs
9/13/2025	Miscellaneous	Flowers for Kim	 42.80 	Wants
9/13/2025	Alcohol	Urban Family	 35.00 	Wants
9/14/2025	Groceries	Wholefoods	 17.63 	Needs
9/14/2025	Travel	Chase Travel	 286.89 	Wants
9/15/2025	Auto	Ford Credit	 605.00 	Needs
9/15/2025	Student Loans	Mohela	 189.00 	Needs
9/15/2025	Entertainment	Habs Ticket	 97.00 	Wants
9/15/2025	Zyn	Shell	 6.59 	Wants
9/15/2025	Pet Care	CVS	 17.00 	Wants
9/15/2025	Alcohol	CVS	 16.00 	Wants
9/15/2025	Snacks	CVS	 2.00 	Wants
9/16/2025	Coffee	Starbucks	 3.81 	Wants
9/16/2025	Dining Out	Starbucks	 7.13 	Wants
9/16/2025	Utilities	Lights	 25.00 	Needs
9/16/2025	Auto	Insurance	 308.82 	Needs
9/17/2025	HOA	Kuester	 448.79 	Needs
9/16/2025	Hockey	Jersey	 120.00 	Wants
9/16/2025	Groceries	QFC	 126.77 	Needs
9/16/2025	Gas	Chevron	 76.67 	Needs
9/17/2025	Hockey	Tape	 4.34 	Wants
9/17/2025	Hockey	Eagles	 1,005.00 	Wants
9/17/2025	Zyn	Shell	 6.59 	Wants







WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month (Total Loans only), cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) float index (materialized)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

-- 5) rolling windows via (csum - lag(csum)); plus lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums (mean/std source)
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums (regression source)
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (no window here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - (sum y)^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7a) latest month per system
latest_per_sys AS (
  SELECT
    CONTRACT_SOURCE_SYSTEM,
    MAX(END_OF_MONTH_DATE) AS max_eom
  FROM calc
  GROUP BY CONTRACT_SOURCE_SYSTEM
),

-- 7b) prior (previous) month per system
prev_per_sys AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    MAX(c.END_OF_MONTH_DATE) AS prev_eom
  FROM latest_per_sys l
  JOIN calc c
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE < l.max_eom
  GROUP BY l.CONTRACT_SOURCE_SYSTEM
),

-- 7c) rows for latest month and prior month (for both modes)
last_latest AS (  -- latest row: basis for FORWARD forecast (to next month)
  SELECT c.*
  FROM calc c
  JOIN latest_per_sys l
    ON c.CONTRACT_SOURCE_SYSTEM = l.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = l.max_eom
),
last_prev AS (    -- previous row: basis for BACKTEST forecast (to latest month)
  SELECT c.*
  FROM calc c
  JOIN prev_per_sys p
    ON c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = p.prev_eom
),

-- 7d) bring in the latest actual (value at latest month) for backtest comparison
latest_actual AS (
  SELECT
    ll.CONTRACT_SOURCE_SYSTEM,
    ll.END_OF_MONTH_DATE AS latest_eom,
    ll.SOURCE_SYSTEM_BALANCE AS actual_latest
  FROM last_latest ll
),

-- 8) SUMMARY_NEXT_FWD: forecast from latest → next month
summary_next_fwd AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                           AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                            AS forecast_period,
    l.SOURCE_SYSTEM_BALANCE                                       AS actual_last,

    -- candidate forecasts
    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                           AS fc_linear,
    l.lag12_balance                                               AS fc_seasonal,
    l.roll_mean_6                                                 AS fc_rollmean,

    -- choose forecast: linear → seasonal → rolling mean
    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                             AS forecast_val,

    -- sigma: prefer rolling-6 else overall sample std from moments
    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                             AS sigma_est,

    l.avg_all                                                     AS avg_level_sys
  FROM last_latest l
),

-- 9) SUMMARY_BACKTEST: forecast from previous → latest month, compare to latest actual
summary_backtest AS (
  SELECT
    p.CONTRACT_SOURCE_SYSTEM,
    p.END_OF_MONTH_DATE                                           AS model_asof_period,  -- prev month (model trained up to here)
    a.latest_eom                                                  AS forecast_period,    -- latest month (target)
    a.actual_latest                                               AS actual_latest,

    -- candidate forecasts (from previous row’s params ⇒ step ahead 1)
    CASE
      WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
        THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                           AS fc_linear,
    p.lag12_balance                                               AS fc_seasonal,
    p.roll_mean_6                                                 AS fc_rollmean,

    COALESCE(
      CASE
        WHEN p.regr_slope_12 IS NOT NULL AND p.regr_intercept_12 IS NOT NULL
          THEN p.regr_intercept_12 + p.regr_slope_12 * CAST(p.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      p.lag12_balance,
      p.roll_mean_6
    )                                                             AS forecast_val,

    -- sigma estimated from previous window
    COALESCE(
      p.roll_std_6,
      CASE WHEN p.cnt_all > 1
           THEN SQRT( GREATEST(p.avg2_all - (p.avg_all * p.avg_all), 0.0)
                      * (CAST(p.cnt_all AS FLOAT8) / CAST(p.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                             AS sigma_est,

    p.avg_all                                                     AS avg_level_sys
  FROM last_prev p
  JOIN latest_actual a
    ON a.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
)

-- ===== FINAL OUTPUTS =====
-- 1) Full HISTORY (one row per month per system with stats)
SELECT
  'HISTORY'                AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE        AS period_date,
  SOURCE_SYSTEM_BALANCE    AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8             AS forecast_val,
  NULL::FLOAT8             AS pi95_lo,
  NULL::FLOAT8             AS pi95_hi,
  NULL::FLOAT8             AS dev_abs,
  NULL::FLOAT8             AS dev_pct,
  NULL::FLOAT8             AS z_score,
  NULL::FLOAT8             AS severity_0_100,
  NULL                     AS outside_95_band
FROM calc

UNION ALL

-- 2) BACKTEST: prev→latest forecast with actual comparison
SELECT
  'SUMMARY_BACKTEST'       AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period          AS period_date,          -- latest month (e.g., 2025-08-31)
  actual_latest            AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  (actual_latest - forecast_val)      AS dev_abs,
  CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE NULL END AS dev_pct,
  CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE NULL END AS z_score,
  100.0 * (
    0.5 * LEAST(ABS(CASE WHEN sigma_est IS NOT NULL AND sigma_est > 0 THEN (actual_latest - forecast_val) / sigma_est ELSE 0 END) / 3.0, 1.0)
  + 0.3 * LEAST(ABS(CASE WHEN forecast_val <> 0 THEN (actual_latest - forecast_val) / forecast_val ELSE 0 END) / 0.10, 1.0)
  + 0.2 * LEAST(ABS(actual_latest - forecast_val) / NULLIF(avg_level_sys * 0.10, 0), 1.0)
  ) AS severity_0_100,
  CASE
    WHEN sigma_est IS NULL THEN NULL
    WHEN actual_latest < (forecast_val - 1.9599 * sigma_est) THEN TRUE
    WHEN actual_latest > (forecast_val + 1.9599 * sigma_est) THEN TRUE
    ELSE FALSE
  END AS outside_95_band
FROM summary_backtest

UNION ALL

-- 3) FORWARD: latest→next forecast (no actual yet)
SELECT
  'SUMMARY_NEXT_FWD'       AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  forecast_period          AS period_date,          -- next month (e.g., 2025-09-30)
  NULL::FLOAT8             AS actual,
  NULL::FLOAT8             AS roll_mean_6,
  NULL::FLOAT8             AS roll_std_6,
  NULL::FLOAT8             AS lag12_balance,
  NULL::FLOAT8             AS regr_slope_12,
  NULL::FLOAT8             AS regr_intercept_12,
  forecast_val,
  (forecast_val - 1.9599 * sigma_est) AS pi95_lo,
  (forecast_val + 1.9599 * sigma_est) AS pi95_hi,
  NULL::FLOAT8                         AS dev_abs,
  NULL::FLOAT8                         AS dev_pct,
  NULL::FLOAT8                         AS z_score,
  NULL::FLOAT8                         AS severity_0_100,
  NULL                                 AS outside_95_band
FROM summary_next_fwd

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month, filtered to Total Loans, cast to FLOAT8
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY 1,2
),

-- 2) row index per system (window only here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) materialize float index (no window use of fresh alias later)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments for fallback sigma
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx2 x
),

-- 5) build rolling windows via (csum - lag(csum)); also lag-12
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)  AS n6,
    LEAST(c.rn, 12) AS n12,

    -- 6-row rolling sums
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-row rolling sums for regression
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) per-row stats (plain math; no window functions here)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - (sum y)^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 7) last row per system (for next-period summary)
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 8) per-system next-period forecast + sigma and size
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                                                 AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                                                  AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                                             AS actual_last,

    -- candidate forecasts
    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                                                 AS fc_linear,
    l.lag12_balance                                                                     AS fc_seasonal,
    l.roll_mean_6                                                                       AS fc_rollmean,

    -- choose forecast: linear → seasonal → rolling mean
    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                                                   AS forecast_next,

    -- sigma: prefer rolling-6 else overall sample std from moments
    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                                                   AS sigma_est,

    l.avg_all                                                                           AS avg_level_sys
  FROM last_per_sys l
),

-- 9) score + bands for the summary
scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)                                            AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)                                            AS pi95_hi,

    (s.actual_last - s.forecast_next)                                                   AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE NULL END AS dev_pct_vs_last,
    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE NULL END AS z_vs_last,

    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) / NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                                                   AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                                                 AS outside_95_band_vs_last
  FROM summary_next s
)

-- FINAL OUTPUT: union of full HISTORY and one-row-per-system SUMMARY_NEXT
SELECT
  'HISTORY'               AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  END_OF_MONTH_DATE       AS period_date,
  SOURCE_SYSTEM_BALANCE   AS actual,
  roll_mean_6,
  roll_std_6,
  lag12_balance,
  regr_slope_12,
  regr_intercept_12,
  NULL::FLOAT8            AS forecast_next,
  NULL::FLOAT8            AS pi95_lo,
  NULL::FLOAT8            AS pi95_hi,
  NULL::FLOAT8            AS dev_abs_vs_last,
  NULL::FLOAT8            AS dev_pct_vs_last,
  NULL::FLOAT8            AS z_vs_last,
  NULL::FLOAT8            AS severity_0_100,
  NULL                    AS outside_95_band_vs_last
FROM calc

UNION ALL

SELECT
  'SUMMARY_NEXT'          AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  next_period             AS period_date,
  NULL::FLOAT8            AS actual,
  NULL::FLOAT8            AS roll_mean_6,
  NULL::FLOAT8            AS roll_std_6,
  NULL::FLOAT8            AS lag12_balance,
  NULL::FLOAT8            AS regr_slope_12,
  NULL::FLOAT8            AS regr_intercept_12,
  forecast_next,
  pi95_lo,
  pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next

ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month, cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
  GROUP BY 1,2
),

-- 2) add integer row index per system
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn
  FROM base b
),

-- 3) materialize float index in its own CTE (so it can be used by window funcs later)
idx2 AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f
  FROM idx1 i
),

-- 4) cumulative sums (window functions only here)
csum AS (
  SELECT
    x.*,

    -- cumulative sums for y and y^2
    SUM(x.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y,

    SUM(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y  (rn_f is a real column now)
    SUM(x.rn_f) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x,

    SUM(CAST(x.rn_f * x.rn_f AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_x2,

    SUM(CAST(x.rn_f * x.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY x.CONTRACT_SOURCE_SYSTEM ORDER BY x.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (fallback sigma)
    COUNT(*) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM)                                        AS cnt_all,
    AVG(x.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM)                    AS avg_all,
    AVG(CAST(x.SOURCE_SYSTEM_BALANCE * x.SOURCE_SYSTEM_BALANCE AS FLOAT8))
      OVER (PARTITION BY x.CONTRACT_SOURCE_SYSTEM)                                               AS avg2_all
  FROM idx2 x
),

-- 5) build 6-row and 12-row rolling windows via csum - lag(csum)
roll AS (
  SELECT
    c.*,

    LEAST(c.rn, 6)   AS n6,
    LEAST(c.rn, 12)  AS n12,

    -- 6-length rolling sums
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-length rolling sums for regression
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 6) compute rolling mean/std (6) and regression slope/intercept (12) — plain math, no window funcs
calc AS (
  SELECT
    r.*,

    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END                                            AS roll_mean_6,

    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 )
              / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END                                                                                                              AS roll_std_6,

    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END                                                                                                              AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END                                                                                                              AS regr_intercept_12
  FROM roll r
),

-- 7) last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 8) next-month forecast + scoring
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                                                 AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                                                  AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                                             AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                                                 AS fc_linear,

    l.lag12_balance                                                                     AS fc_seasonal,
    l.roll_mean_6                                                                       AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                                                   AS forecast_next,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0)
                      * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                                                   AS sigma_est,

    l.avg_all                                                                           AS avg_level_sys
  FROM last_per_sys l
),

scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)                                            AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)                                            AS pi95_hi,

    (s.actual_last - s.forecast_next)                                                   AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE NULL END AS dev_pct_vs_last,
    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE NULL END AS z_vs_last,

    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) / NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                                                   AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                                                 AS outside_95_band_vs_last
  FROM summary_next s
)

SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;






WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month, cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional filters:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
  GROUP BY 1,2
),

-- 2) assign row index (window function ONLY here)
idx1 AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE)  AS rn
  FROM base b
),

-- 3) add a float index and compute cumulative sums (window functions ONLY here)
csum AS (
  SELECT
    i.*,
    CAST(i.rn AS FLOAT8) AS rn_f,

    -- cumulative sums for y and y^2
    SUM(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS csum_y,
    SUM(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x, x^2, and x*y  (no nesting; rn_f already computed)
    SUM(i.rn_f) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS csum_x,
    SUM(CAST(i.rn_f * i.rn_f AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS csum_x2,
    SUM(CAST(i.rn_f * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE
    ) AS csum_xy,

    -- overall per-system moments (for fallback sigma)
    COUNT(*) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                                         AS cnt_all,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                     AS avg_all,
    AVG(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
    ) AS avg2_all
  FROM idx1 i
),

-- 4) build 6-row and 12-row rolling windows via csum - lag(csum)
roll AS (
  SELECT
    c.*,

    -- window sizes
    LEAST(c.rn, 6)   AS n6,
    LEAST(c.rn, 12)  AS n12,

    -- 6-length rolling sums
    (c.csum_y  - COALESCE(LAG(c.csum_y,  6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (c.csum_y2 - COALESCE(LAG(c.csum_y2, 6) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-length rolling sums for regression
    (c.csum_x  - COALESCE(LAG(c.csum_x,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (c.csum_y  - COALESCE(LAG(c.csum_y,  12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (c.csum_x2 - COALESCE(LAG(c.csum_x2, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (c.csum_xy - COALESCE(LAG(c.csum_xy, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(c.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY c.CONTRACT_SOURCE_SYSTEM ORDER BY c.END_OF_MONTH_DATE) AS lag12_balance
  FROM csum c
),

-- 5) compute rolling mean/std (6) and regression slope/intercept (12) — NO window functions here
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / CAST(r.n6 AS FLOAT8) ELSE NULL END AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - sum y^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 6) last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 7) next-month forecast + scoring
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                                                 AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                                                  AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                                             AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                                                 AS fc_linear,

    l.lag12_balance                                                                     AS fc_seasonal,
    l.roll_mean_6                                                                       AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                                                   AS forecast_next,

    COALESCE(
      l.roll_std_6,
      CASE WHEN l.cnt_all > 1
           THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0) * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
           ELSE NULL
      END
    )                                                                                   AS sigma_est,

    l.avg_all                                                                           AS avg_level_sys
  FROM last_per_sys l
),

scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)                                            AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)                                            AS pi95_hi,

    (s.actual_last - s.forecast_next)                                                   AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE NULL END AS dev_pct_vs_last,
    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE NULL END AS z_vs_last,

    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) / NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                                                   AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                                                 AS outside_95_band_vs_last
  FROM summary_next s
)

SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;






WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month (cast to FLOAT8 early)
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
  GROUP BY 1,2
),

-- 2) row index and cumulative sums (build rolling windows via csum - lag)
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE)      AS rn,
    CAST(ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE)
         AS FLOAT8)                                                                              AS rn_f,

    -- cumulative sums for y and y^2
    SUM(b.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    )                                                                                            AS csum_y,
    SUM(CAST(b.SOURCE_SYSTEM_BALANCE * b.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    )                                                                                            AS csum_y2,

    -- cumulative x (time index), x^2, and x*y  — avoid POWER(); use rn_f*rn_f
    SUM(rn_f) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    )                                                                                            AS csum_x,
    SUM(CAST(rn_f * rn_f AS FLOAT8)) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    )                                                                                            AS csum_x2,
    SUM(CAST(rn_f * b.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    )                                                                                            AS csum_xy
  FROM base b
),

-- 3) 6-row and 12-row rolling windows via (csum - lagged csum)
roll AS (
  SELECT
    i.*,
    COALESCE(i.rn,0)                                                                              AS n_all,

    LEAST(i.rn, 6)                                                                                AS n6,
    (i.csum_y  - COALESCE(LAG(i.csum_y,  6) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (i.csum_y2 - COALESCE(LAG(i.csum_y2, 6) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    LEAST(i.rn, 12)                                                                               AS n12,
    (i.csum_x  - COALESCE(LAG(i.csum_x,  12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (i.csum_y  - COALESCE(LAG(i.csum_y,  12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (i.csum_x2 - COALESCE(LAG(i.csum_x2, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (i.csum_xy - COALESCE(LAG(i.csum_xy, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- seasonal anchor
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE) AS lag12_balance,

    -- per-system moments for fallback sigma
    COUNT(*) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                                                         AS cnt_all,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                                     AS avg_all,
    AVG(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx i
),

-- 4) rolling mean/std(6) and regression slope/intercept(12)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / r.n6 ELSE NULL END                                                         AS roll_mean_6,

    -- sample std over last 6 rows: sqrt( max( (sum y^2 - sum y^2 / n) / (n-1), 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / CAST(r.n6 AS FLOAT8) )), 0.0 ) / CAST(r.n6 - 1 AS FLOAT8) )
      ELSE NULL
    END                                                                                                           AS roll_std_6,

    -- regression slope / intercept over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
        THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
             / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
      ELSE NULL
    END                                                                                                           AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        ( r.sum12_y
          - ( COALESCE(
                CASE
                  WHEN r.n12 >= 2 AND ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) ) <> 0.0
                    THEN ( (CAST(r.n12 AS FLOAT8) * r.sum12_xy) - (r.sum12_x * r.sum12_y) )
                         / ( (CAST(r.n12 AS FLOAT8) * r.sum12_x2) - (r.sum12_x * r.sum12_x) )
                  ELSE NULL
                END, 0.0) * r.sum12_x ) ) / CAST(r.n12 AS FLOAT8)
      ELSE NULL
    END                                                                                                           AS regr_intercept_12
  FROM roll r
),

-- 5) last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 6) next-month forecast + scoring
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                                                 AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                                                  AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                                             AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
      ELSE NULL
    END                                                                                 AS fc_linear,

    l.lag12_balance                                                                     AS fc_seasonal,
    l.roll_mean_6                                                                       AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * CAST(l.rn + 1 AS FLOAT8)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                                                   AS forecast_next,

    COALESCE(l.roll_std_6,
             CASE WHEN l.cnt_all > 1
                  THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0) * (CAST(l.cnt_all AS FLOAT8) / CAST(l.cnt_all - 1 AS FLOAT8)) )
                  ELSE NULL END
    )                                                                                   AS sigma_est,

    l.avg_all                                                                           AS avg_level_sys
  FROM last_per_sys l
),

scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)                                            AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)                                            AS pi95_hi,

    (s.actual_last - s.forecast_next)                                                   AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE NULL END AS dev_pct_vs_last,
    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE NULL END AS z_vs_last,

    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) / NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                                                   AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                                                 AS outside_95_band_vs_last
  FROM summary_next s
)

SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;





WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) system × month, cast to FLOAT8 early
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    CAST(SUM(t.SOURCE_SYSTEM_BALANCE) AS FLOAT8) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional filters:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
  GROUP BY 1,2
),

-- 2) row index, cumulative sums (for rolling windows)
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS rn,

    -- cumulative sums for y, y^2
    SUM(b.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    ) AS csum_y,
    SUM(CAST(b.SOURCE_SYSTEM_BALANCE * b.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (
      PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE
    ) AS csum_y2,

    -- cumulative x (time index), x^2, and x*y (for regression)
    SUM(CAST(ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS FLOAT8))
      OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x,
    SUM(CAST(POWER(ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE),2) AS FLOAT8))
      OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_x2,
    SUM(
      CAST(ROW_NUMBER() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS FLOAT8)
      * b.SOURCE_SYSTEM_BALANCE
    ) OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS csum_xy
  FROM base b
),

-- 3) build 6-row and 12-row window sums via csum - lag(csum, window)
roll AS (
  SELECT
    i.*,

    -- 6-length rolling (use rn for count)
    COALESCE(i.rn,0)                                       AS n_all,
    LEAST(i.rn, 6)                                         AS n6,
    (i.csum_y  - COALESCE(LAG(i.csum_y,  6) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum6_y,
    (i.csum_y2 - COALESCE(LAG(i.csum_y2, 6) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum6_y2,

    -- 12-length rolling for regression
    LEAST(i.rn, 12)                                        AS n12,
    (i.csum_x  - COALESCE(LAG(i.csum_x,  12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_x,
    (i.csum_y  - COALESCE(LAG(i.csum_y,  12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_y,
    (i.csum_x2 - COALESCE(LAG(i.csum_x2, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_x2,
    (i.csum_xy - COALESCE(LAG(i.csum_xy, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE), 0.0)) AS sum12_xy,

    -- lag-12 seasonal anchor
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM ORDER BY i.END_OF_MONTH_DATE) AS lag12_balance,

    -- overall per-system moments (for fallback sigma)
    COUNT(*) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                                          AS cnt_all,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                      AS avg_all,
    AVG(CAST(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE AS FLOAT8)) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM) AS avg2_all
  FROM idx i
),

-- 4) stats: rolling mean/std(6), regression slope/intercept(12)
calc AS (
  SELECT
    r.*,

    -- rolling mean (6)
    CASE WHEN r.n6 > 0 THEN r.sum6_y / r.n6 ELSE NULL END AS roll_mean_6,

    -- sample std (6): sqrt( max( (sum(y^2) - sum(y)^2/n)/ (n-1) , 0 ) )
    CASE
      WHEN r.n6 > 1 THEN
        SQRT( GREATEST( (r.sum6_y2 - ( (r.sum6_y * r.sum6_y) / r.n6 )), 0.0 ) / (r.n6 - 1) )
      ELSE NULL
    END AS roll_std_6,

    -- linear regression over last up-to-12 rows
    CASE
      WHEN r.n12 >= 2 AND (r.n12 * r.sum12_x2 - (r.sum12_x * r.sum12_x)) <> 0
        THEN (r.n12 * r.sum12_xy - (r.sum12_x * r.sum12_y)) / (r.n12 * r.sum12_x2 - (r.sum12_x * r.sum12_x))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN r.n12 >= 1 THEN
        (r.sum12_y - ( (CASE
                          WHEN r.n12 >= 2 AND (r.n12 * r.sum12_x2 - (r.sum12_x * r.sum12_x)) <> 0
                            THEN (r.n12 * r.sum12_xy - (r.sum12_x * r.sum12_y)) / (r.n12 * r.sum12_x2 - (r.sum12_x * r.sum12_x))
                          ELSE 0.0
                        END) * r.sum12_x)) / NULLIF(r.n12,0)
      ELSE NULL
    END AS regr_intercept_12
  FROM roll r
),

-- 5) last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 6) next forecast + scoring
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                               AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                                AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                           AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * (l.rn + 1)
      ELSE NULL
    END                                                               AS fc_linear,

    l.lag12_balance                                                   AS fc_seasonal,
    l.roll_mean_6                                                     AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * (l.rn + 1)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                                 AS forecast_next,

    -- sigma: prefer rolling-6 else overall sample std from moments
    COALESCE(l.roll_std_6,
             CASE WHEN l.cnt_all > 1
                  THEN SQRT( GREATEST(l.avg2_all - (l.avg_all * l.avg_all), 0.0) * (l.cnt_all::FLOAT8 / (l.cnt_all - 1)) )
                  ELSE NULL END
    )                                                                 AS sigma_est,

    l.avg_all                                                         AS avg_level_sys
  FROM last_per_sys l
),

scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)                          AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)                          AS pi95_hi,

    (s.actual_last - s.forecast_next)                                 AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE NULL END AS dev_pct_vs_last,
    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE NULL END AS z_vs_last,

    100.0 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0 THEN (s.actual_last - s.forecast_next) / s.sigma_est ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0 THEN (s.actual_last - s.forecast_next) / s.forecast_next ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) / NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                                 AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                               AS outside_95_band_vs_last
  FROM summary_next s
)

SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;





-- Adjust lookback here (use -24 for exactly two years)
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) Aggregate to system × month
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    -- force to FLOAT8 early to avoid DECIMAL overflow later
    SUM(t.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional filters:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
  GROUP BY 1,2
),

-- 2) Time index per system
idx AS (
  SELECT
    b.*,
    DENSE_RANK() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS t_idx
  FROM base b
),

-- 3) Rolling baselines, seasonal anchor, and overall stats (FLOAT8-safe)
roll AS (
  SELECT
    i.*,

    COUNT(*) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS cnt6,

    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (                    -- FLOAT8 already
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS roll_mean_6,

    AVG( (i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE)::FLOAT8 ) OVER (   -- square as FLOAT8
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS roll_mean2_6,

    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
    )                                                      AS lag12_balance,

    COUNT(*) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)  AS cnt_all,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG( (i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE)::FLOAT8 )
      OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)         AS avg2_all
  FROM idx i
),

-- 4) 12-mo rolling regression via window sums (all FLOAT8-safe)
trend AS (
  SELECT
    r.*,

    COUNT(*) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS n12,

    SUM(r.t_idx)::FLOAT8 OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumx12,

    SUM(r.SOURCE_SYSTEM_BALANCE)::FLOAT8 OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumy12,

    SUM( (r.t_idx::FLOAT8 * r.SOURCE_SYSTEM_BALANCE)::FLOAT8 ) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumxy12,

    SUM( (r.t_idx::FLOAT8 * r.t_idx::FLOAT8)::FLOAT8 ) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumxx12
  FROM roll r
),

-- 5) Compute slope/intercept & rolling/sample sigmas (FLOAT8)
calc AS (
  SELECT
    t.*,

    CASE
      WHEN cnt6 > 1 THEN
        SQRT( GREATEST( (roll_mean2_6 - (roll_mean_6 * roll_mean_6))::FLOAT8 , 0.0::FLOAT8 )
              * ( (cnt6::FLOAT8) / (cnt6 - 1)::FLOAT8 ) )
      ELSE NULL
    END AS roll_std_6,

    CASE
      WHEN cnt_all > 1 THEN
        SQRT( GREATEST( (avg2_all - (avg_all * avg_all))::FLOAT8 , 0.0::FLOAT8 )
              * ( (cnt_all::FLOAT8) / (cnt_all - 1)::FLOAT8 ) )
      ELSE NULL
    END AS std_all,

    CASE
      WHEN n12 >= 2 AND (n12 * sumxx12 - (sumx12 * sumx12)) <> 0::FLOAT8
        THEN (n12 * sumxy12 - (sumx12 * sumy12)) / (n12 * sumxx12 - (sumx12 * sumx12))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN n12 >= 1 THEN
        (sumy12 - ( (CASE
                        WHEN n12 >= 2 AND (n12 * sumxx12 - (sumx12 * sumx12)) <> 0::FLOAT8
                          THEN (n12 * sumxy12 - (sumx12 * sumy12)) / (n12 * sumxx12 - (sumx12 * sumx12))
                        ELSE 0.0::FLOAT8
                      END) * sumx12)) / NULLIF(n12,0.0::FLOAT8)
      ELSE NULL
    END AS regr_intercept_12
  FROM trend t
),

-- 6) Last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 7) Next-month forecast + scoring
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                     AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                      AS next_period,
    l.SOURCE_SYSTEM_BALANCE                                 AS actual_last,

    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN (l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx::FLOAT8 + 1.0::FLOAT8))::FLOAT8
      ELSE NULL
    END                                                     AS fc_linear,

    l.lag12_balance                                         AS fc_seasonal,
    l.roll_mean_6                                           AS fc_rollmean,

    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN (l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx::FLOAT8 + 1.0::FLOAT8))::FLOAT8
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                       AS forecast_next,

    COALESCE(l.roll_std_6, l.std_all)                       AS sigma_est,
    l.avg_all                                               AS avg_level_sys
  FROM last_per_sys l
),

-- 8) Score & bands (FLOAT8 math)
scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599::FLOAT8 * s.sigma_est)::FLOAT8 AS pi95_lo,
    (s.forecast_next + 1.9599::FLOAT8 * s.sigma_est)::FLOAT8 AS pi95_hi,

    (s.actual_last - s.forecast_next)::FLOAT8                AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0::FLOAT8
         THEN ((s.actual_last - s.forecast_next) / s.forecast_next)::FLOAT8
         ELSE NULL
    END                                                      AS dev_pct_vs_last,

    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0::FLOAT8
         THEN ((s.actual_last - s.forecast_next) / s.sigma_est)::FLOAT8
         ELSE NULL
    END                                                      AS z_vs_last,

    (100.0::FLOAT8 * (
      0.5::FLOAT8 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0::FLOAT8
                                   THEN ((s.actual_last - s.forecast_next) / s.sigma_est)
                                   ELSE 0.0::FLOAT8 END) / 3.0::FLOAT8, 1.0::FLOAT8)
    + 0.3::FLOAT8 * LEAST(ABS(CASE WHEN s.forecast_next <> 0::FLOAT8
                                   THEN ((s.actual_last - s.forecast_next) / s.forecast_next)
                                   ELSE 0.0::FLOAT8 END) / 0.10::FLOAT8, 1.0::FLOAT8)
    + 0.2::FLOAT8 * LEAST(ABS(s.actual_last - s.forecast_next) /
                          NULLIF(s.avg_level_sys * 0.10::FLOAT8, 0.0::FLOAT8), 1.0::FLOAT8)
    ))                                                       AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599::FLOAT8 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599::FLOAT8 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                      AS outside_95_band_vs_last
  FROM summary_next s
)

-- Final: one row per system for the next period
SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;






-- Adjust lookback here (use -24 for exactly two years)
WITH latest AS (
  SELECT MAX(END_OF_MONTH_DATE) AS max_eom
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
  SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom FROM latest
),

-- 1) Aggregate to system × month in window
base AS (
  SELECT
    t.END_OF_MONTH_DATE,
    t.CONTRACT_SOURCE_SYSTEM,
    SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
  FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
  CROSS JOIN rng r
  WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
    -- Optional filters:
    -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
  GROUP BY 1,2
),

-- 2) Add a time index per system
idx AS (
  SELECT
    b.*,
    DENSE_RANK() OVER (PARTITION BY b.CONTRACT_SOURCE_SYSTEM ORDER BY b.END_OF_MONTH_DATE) AS t_idx
  FROM base b
),

-- 3) Rolling baselines, seasonal anchor, and overall stats (all with standard window sums)
roll AS (
  SELECT
    i.*,

    -- === 6-month rolling mean & sample std without STDDEV_* ===
    -- window: last 6 rows (current + 5 preceding)
    COUNT(*) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS cnt6,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS roll_mean_6,
    AVG(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )                                                      AS roll_mean2_6,

    -- Seasonal naive anchor (value 12 months ago)
    LAG(i.SOURCE_SYSTEM_BALANCE, 12) OVER (
      PARTITION BY i.CONTRACT_SOURCE_SYSTEM
      ORDER BY i.END_OF_MONTH_DATE
    )                                                      AS lag12_balance,

    -- Overall (per system) average & second moment for sample std fallback
    COUNT(*)      OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                AS cnt_all,
    AVG(i.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM) AS avg_all,
    AVG(i.SOURCE_SYSTEM_BALANCE * i.SOURCE_SYSTEM_BALANCE)
                 OVER (PARTITION BY i.CONTRACT_SOURCE_SYSTEM)                 AS avg2_all
  FROM idx i
),

-- 4) 12-month rolling linear regression via window sums (no REGR_*):
-- slope = (n*sum(xy) - sum(x)sum(y)) / (n*sum(x^2) - (sum(x))^2)
-- intercept = (sum(y) - slope*sum(x)) / n
trend AS (
  SELECT
    r.*,

    -- Rolling window (current + 11 preceding) for linear regression
    COUNT(*) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS n12,

    SUM(r.t_idx) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumx12,

    SUM(r.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumy12,

    SUM(r.t_idx * r.SOURCE_SYSTEM_BALANCE) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumxy12,

    SUM(r.t_idx * r.t_idx) OVER (
      PARTITION BY r.CONTRACT_SOURCE_SYSTEM
      ORDER BY r.END_OF_MONTH_DATE
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS sumxx12
  FROM roll r
),

-- 5) Compute slope/intercept & rolling/sample sigmas
calc AS (
  SELECT
    t.*,

    -- 6-month sample std (sqrt( max( avg(x^2) - avg(x)^2, 0 ) * n/(n-1) ))
    CASE
      WHEN cnt6 > 1 THEN
        SQRT(GREATEST(roll_mean2_6 - (roll_mean_6 * roll_mean_6), 0) * (cnt6::FLOAT / (cnt6 - 1)))
      ELSE NULL
    END AS roll_std_6,

    -- overall sample std fallback
    CASE
      WHEN cnt_all > 1 THEN
        SQRT(GREATEST(avg2_all - (avg_all * avg_all), 0) * (cnt_all::FLOAT / (cnt_all - 1)))
      ELSE NULL
    END AS std_all,

    -- Linear regression slope/intercept on last up-to-12 months
    CASE
      WHEN n12 >= 2 AND (n12 * sumxx12 - (sumx12 * sumx12)) <> 0
        THEN (n12 * sumxy12 - (sumx12 * sumy12)) / (n12 * sumxx12 - (sumx12 * sumx12))
      ELSE NULL
    END AS regr_slope_12,

    CASE
      WHEN n12 >= 1 THEN
        (sumy12 - ( (CASE
                        WHEN n12 >= 2 AND (n12 * sumxx12 - (sumx12 * sumx12)) <> 0
                          THEN (n12 * sumxy12 - (sumx12 * sumy12)) / (n12 * sumxx12 - (sumx12 * sumx12))
                        ELSE NULL
                      END) * sumx12)) / n12
      ELSE NULL
    END AS regr_intercept_12
  FROM trend t
),

-- 6) Last row per system
last_per_sys AS (
  SELECT c.*
  FROM calc c
  JOIN (
    SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
    FROM calc
    GROUP BY CONTRACT_SOURCE_SYSTEM
  ) m
    ON c.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
   AND c.END_OF_MONTH_DATE     = m.max_eom
),

-- 7) Build next-month forecast + scoring per system
summary_next AS (
  SELECT
    l.CONTRACT_SOURCE_SYSTEM,
    l.END_OF_MONTH_DATE                                AS last_period,
    ADD_MONTHS(l.END_OF_MONTH_DATE, 1)                 AS next_period,
    l.SOURCE_SYSTEM_BALANCE                            AS actual_last,

    -- candidate forecasts
    CASE
      WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
        THEN l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx + 1)
      ELSE NULL
    END                                                AS fc_linear,
    l.lag12_balance                                    AS fc_seasonal,
    l.roll_mean_6                                      AS fc_rollmean,

    -- choose: linear → seasonal → rolling mean
    COALESCE(
      CASE
        WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
          THEN l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx + 1)
        ELSE NULL
      END,
      l.lag12_balance,
      l.roll_mean_6
    )                                                  AS forecast_next,

    -- sigma for bands: prefer rolling-6, else overall
    COALESCE(l.roll_std_6, l.std_all)                  AS sigma_est,

    -- overall average as size proxy
    l.avg_all                                          AS avg_level_sys
  FROM last_per_sys l
),

-- 8) Score & bands
scored_next AS (
  SELECT
    s.CONTRACT_SOURCE_SYSTEM,
    s.last_period,
    s.next_period,
    s.actual_last,
    s.fc_linear,
    s.fc_seasonal,
    s.fc_rollmean,
    s.forecast_next,

    (s.forecast_next - 1.9599 * s.sigma_est)           AS pi95_lo,
    (s.forecast_next + 1.9599 * s.sigma_est)           AS pi95_hi,

    (s.actual_last - s.forecast_next)                  AS dev_abs_vs_last,
    CASE WHEN s.forecast_next <> 0
         THEN (s.actual_last - s.forecast_next) / s.forecast_next
         ELSE NULL
    END                                                AS dev_pct_vs_last,

    CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0
         THEN (s.actual_last - s.forecast_next) / s.sigma_est
         ELSE NULL
    END                                                AS z_vs_last,

    100 * (
      0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0
                           THEN (s.actual_last - s.forecast_next) / s.sigma_est
                           ELSE 0 END) / 3.0, 1.0)
    + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0
                           THEN (s.actual_last - s.forecast_next) / s.forecast_next
                           ELSE 0 END) / 0.10, 1.0)
    + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) /
                  NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
    )                                                  AS severity_0_100,

    CASE
      WHEN s.sigma_est IS NULL THEN NULL
      WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
      WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
      ELSE FALSE
    END                                                AS outside_95_band_vs_last
  FROM summary_next s
)

-- Choose one of the final outputs:

-- (A) One row per system for the NEXT period (ranked by severity)
SELECT
  'SUMMARY_NEXT' AS row_type,
  CONTRACT_SOURCE_SYSTEM,
  last_period,
  next_period,
  actual_last,
  fc_linear,
  fc_seasonal,
  fc_rollmean,
  forecast_next,
  pi95_lo, pi95_hi,
  dev_abs_vs_last,
  dev_pct_vs_last,
  z_vs_last,
  severity_0_100,
  outside_95_band_vs_last
FROM scored_next
ORDER BY severity_0_100 DESC, CONTRACT_SOURCE_SYSTEM;

-- -- (B) If you also want history rows, say the word and I’ll add a HISTORY union like before.





-- Change this to -24 if you want exactly 24 months
WITH latest AS (
    SELECT MAX(END_OF_MONTH_DATE) AS max_eom
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
),
rng AS (
    SELECT ADD_MONTHS(max_eom, -30) AS start_eom, max_eom
    FROM latest
),
-- 1) Aggregate to system x month within window
base AS (
    SELECT
        t.END_OF_MONTH_DATE,
        t.CONTRACT_SOURCE_SYSTEM,
        SUM(t.SOURCE_SYSTEM_BALANCE) AS SOURCE_SYSTEM_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME t
    CROSS JOIN rng r
    WHERE t.SOURCE_SYSTEM_BALANCE IS NOT NULL
      AND t.END_OF_MONTH_DATE BETWEEN r.start_eom AND r.max_eom
      -- Optional filters:
      -- AND t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
      -- AND t.BANK_CODE IN ('L-FCB','L-CIT','L-SVB')
    GROUP BY 1,2
),
-- 2) Index per system for trend math
idx AS (
    SELECT
        END_OF_MONTH_DATE,
        CONTRACT_SOURCE_SYSTEM,
        SOURCE_SYSTEM_BALANCE,
        DENSE_RANK() OVER (PARTITION BY CONTRACT_SOURCE_SYSTEM ORDER BY END_OF_MONTH_DATE) AS t_idx
    FROM base
),
-- 3) Rolling baselines, seasonal anchor, and per-system level
stats AS (
    SELECT
        i.*,
        -- 6-month rolling mean/std (use 12 if you prefer)
        AVG(SOURCE_SYSTEM_BALANCE) OVER (
            PARTITION BY CONTRACT_SOURCE_SYSTEM
            ORDER BY END_OF_MONTH_DATE
            ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
        ) AS roll_mean_6,
        STDDEV_SAMP(SOURCE_SYSTEM_BALANCE) OVER (
            PARTITION BY CONTRACT_SOURCE_SYSTEM
            ORDER BY END_OF_MONTH_DATE
            ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
        ) AS roll_std_6,

        -- Seasonal naive anchor (value 12 months ago)
        LAG(SOURCE_SYSTEM_BALANCE, 12) OVER (
            PARTITION BY CONTRACT_SOURCE_SYSTEM
            ORDER BY END_OF_MONTH_DATE
        ) AS lag12_balance,

        -- Per-system average level (used to normalize impact)
        AVG(SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY CONTRACT_SOURCE_SYSTEM) AS avg_level_sys
    FROM idx i
),
-- 4) Linear trend fit using regression aggregates on a 12-month rolling window (or fewer if not enough)
trend AS (
    SELECT
        s.*,
        -- slope/intercept of SSB vs time index over last up to 12 months
        REGR_SLOPE(SOURCE_SYSTEM_BALANCE, t_idx) OVER (
            PARTITION BY CONTRACT_SOURCE_SYSTEM
            ORDER BY END_OF_MONTH_DATE
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        ) AS regr_slope_12,
        REGR_INTERCEPT(SOURCE_SYSTEM_BALANCE, t_idx) OVER (
            PARTITION BY CONTRACT_SOURCE_SYSTEM
            ORDER BY END_OF_MONTH_DATE
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        ) AS regr_intercept_12
    FROM stats s
),
-- 5) Last row per system (to compute NEXT-month forecast and severity vs last actual)
last_per_sys AS (
    SELECT t.*
    FROM trend t
    JOIN (
        SELECT CONTRACT_SOURCE_SYSTEM, MAX(END_OF_MONTH_DATE) AS max_eom
        FROM trend
        GROUP BY CONTRACT_SOURCE_SYSTEM
    ) m
      ON t.CONTRACT_SOURCE_SYSTEM = m.CONTRACT_SOURCE_SYSTEM
     AND t.END_OF_MONTH_DATE     = m.max_eom
),
-- 6) Build next-month summary per system
summary_next AS (
    SELECT
        l.CONTRACT_SOURCE_SYSTEM,
        l.END_OF_MONTH_DATE                         AS last_period,
        ADD_MONTHS(l.END_OF_MONTH_DATE, 1)          AS next_period,
        l.SOURCE_SYSTEM_BALANCE                     AS actual_last,

        -- Next-month forecasts:
        -- Linear trend (if regression available) at t_idx + 1
        (CASE
            WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
                 THEN l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx + 1)
            ELSE NULL
         END)                                       AS fc_linear,

        -- Seasonal naive (last year's same month)
        l.lag12_balance                              AS fc_seasonal,

        -- Choose forecast: linear > seasonal > rolling mean
        COALESCE(
            (CASE WHEN l.regr_slope_12 IS NOT NULL AND l.regr_intercept_12 IS NOT NULL
                  THEN l.regr_intercept_12 + l.regr_slope_12 * (l.t_idx + 1)
             END),
            l.lag12_balance,
            l.roll_mean_6
        )                                            AS forecast_next,

        -- Use rolling std as sigma proxy for PI (fallback to overall std if null)
        COALESCE(l.roll_std_6,
                 STDDEV_SAMP(l.SOURCE_SYSTEM_BALANCE) OVER (PARTITION BY l.CONTRACT_SOURCE_SYSTEM)) AS sigma_est,

        l.avg_level_sys
    FROM last_per_sys l
),
-- 7) Compute intervals, deviations, z, severity and flag
scored_next AS (
    SELECT
        s.CONTRACT_SOURCE_SYSTEM,
        s.last_period,
        s.next_period,
        s.actual_last,
        s.fc_linear,
        s.fc_seasonal,
        s.forecast_next,

        (s.forecast_next - (1.9599 * s.sigma_est))  AS pi95_lo,
        (s.forecast_next + (1.9599 * s.sigma_est))  AS pi95_hi,

        (s.actual_last - s.forecast_next)           AS dev_abs_vs_last,
        CASE WHEN s.forecast_next <> 0
             THEN (s.actual_last - s.forecast_next) / s.forecast_next
             ELSE NULL
        END                                         AS dev_pct_vs_last,

        CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0
             THEN (s.actual_last - s.forecast_next) / s.sigma_est
             ELSE NULL
        END                                         AS z_vs_last,

        -- Severity = 100 * (0.5 * z_term + 0.3 * pct_term + 0.2 * impact_term)
        100 * (
            0.5 * LEAST(ABS(CASE WHEN s.sigma_est IS NOT NULL AND s.sigma_est > 0
                                 THEN (s.actual_last - s.forecast_next) / s.sigma_est
                                 ELSE 0 END) / 3.0, 1.0)
          + 0.3 * LEAST(ABS(CASE WHEN s.forecast_next <> 0
                                 THEN (s.actual_last - s.forecast_next) / s.forecast_next
                                 ELSE 0 END) / 0.10, 1.0)
          + 0.2 * LEAST(ABS(s.actual_last - s.forecast_next) /
                        NULLIF(s.avg_level_sys * 0.10, 0), 1.0)
        )                                           AS severity_0_100,

        CASE
            WHEN s.sigma_est IS NULL THEN NULL
            WHEN s.actual_last < (s.forecast_next - 1.9599 * s.sigma_est) THEN TRUE
            WHEN s.actual_last > (s.forecast_next + 1.9599 * s.sigma_est) THEN TRUE
            ELSE FALSE
        END                                         AS outside_95_band_vs_last
    FROM summary_next s
),
-- 8) History rows with rolling diagnostics (for charts / QA)
history AS (
    SELECT
        'HISTORY'                                   AS row_type,
        t.CONTRACT_SOURCE_SYSTEM,
        t.END_OF_MONTH_DATE                         AS period_date,
        t.SOURCE_SYSTEM_BALANCE                     AS actual,
        t.roll_mean_6,
        t.roll_std_6,
        t.lag12_balance,
        t.regr_slope_12,
        t.regr_intercept_12,
        t.avg_level_sys,
        -- simple z-score vs rolling mean
        CASE WHEN t.roll_std_6 IS NOT NULL AND t.roll_std_6 > 0
             THEN (t.SOURCE_SYSTEM_BALANCE - t.roll_mean_6) / t.roll_std_6
             ELSE NULL
        END                                         AS z_vs_roll
    FROM trend t
)

-- ===== Choose ONE of the following SELECTS =====

-- (A) SUMMARY ONLY (one row per CONTRACT_SOURCE_SYSTEM for next month)
-- SELECT
--     'SUMMARY_NEXT'             AS row_type,
--     s.CONTRACT_SOURCE_SYSTEM,
--     s.last_period,
--     s.next_period,
--     s.actual_last,
--     s.fc_linear,
--     s.fc_seasonal,
--     s.forecast_next,
--     s.pi95_lo, s.pi95_hi,
--     s.dev_abs_vs_last,
--     s.dev_pct_vs_last,
--     s.z_vs_last,
--     s.severity_0_100,
--     s.outside_95_band_vs_last
-- FROM scored_next s
-- ORDER BY s.severity_0_100 DESC, s.CONTRACT_SOURCE_SYSTEM;

-- (B) HISTORY + SUMMARY together (filter in Excel/BI as needed)
SELECT * FROM history
UNION ALL
SELECT
    'SUMMARY_NEXT'               AS row_type,
    s.CONTRACT_SOURCE_SYSTEM,
    s.next_period                AS period_date,      -- use next-period date for summary rows
    NULL                         AS actual,
    NULL                         AS roll_mean_6,
    NULL                         AS roll_std_6,
    NULL                         AS lag12_balance,
    NULL                         AS regr_slope_12,
    NULL                         AS regr_intercept_12,
    NULL                         AS avg_level_sys,
    NULL                         AS z_vs_roll
FROM scored_next s
ORDER BY CONTRACT_SOURCE_SYSTEM, period_date;






=PY("import numpy as np, pandas as pd
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing; _HAS_SM=True
except Exception:
    _HAS_SM=False
SP=12; H=1; Z80=1.2816; Z95=1.9599; WZ,WP,WI=0.5,0.3,0.2
df=args[0].copy()
df.columns=[c.strip().upper() for c in df.columns]
req={'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
mis=req-set(df.columns)
if mis: raise ValueError('Missing required columns: '+str(mis))
df['END_OF_MONTH_DATE']=pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE']=pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df=df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df=(df.groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'],as_index=False)['SOURCE_SYSTEM_BALANCE'].sum()
       .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))
def rstd(r):
    r=r[~np.isnan(r)]
    if r.size==0: return np.nan
    med=np.nanmedian(r); mad=np.nanmedian(np.abs(r-med))
    return 1.4826*mad if mad and mad>0 else (np.nanstd(r) if r.size>1 else np.nan)
def s_naive(y,h,sp):
    n=len(y); out=[]
    for _ in range(h):
        out.append(y.iloc[n-sp] if n-sp>=0 else y.iloc[-1])
    return pd.Series(out,index=range(h),dtype=float)
def fit_fc(y,h,sp):
    y=pd.Series(pd.to_numeric(y,errors='coerce').astype(float).values)
    name='SeasonalNaive'; fit=None
    if _HAS_SM:
        try:
            if len(y)>=2*sp:
                fit=ExponentialSmoothing(y,trend='add',seasonal='add',seasonal_periods=sp,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,A)'
            elif len(y)>=6:
                fit=ExponentialSmoothing(y,trend='add',seasonal=None,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,N)'
            else:
                fit=ExponentialSmoothing(y,trend=None,seasonal=None,initialization_method='estimated').fit(optimized=True); name='SES'
        except Exception:
            fit=None
        if fit is not None:
            fv=pd.Series(fit.fittedvalues); fc=pd.Series(fit.forecast(h).values,index=range(h))
            return name,fv,fc
    fc=s_naive(y,h,sp)
    fv=pd.Series(index=y.index,dtype=float)
    if len(y)>sp:
        fv.iloc[:sp]=y.values[0]; fv.iloc[sp:]=y.values[:-sp]
    else:
        fv[:]=np.nanmean(y.values)
    return name,fv,fc
rows=[]
for sys,g in df.groupby('CONTRACT_SOURCE_SYSTEM',sort=False):
    g=g.sort_values('END_OF_MONTH_DATE'); y=g['SOURCE_SYSTEM_BALANCE']
    name,fv,fc=fit_fc(y,H,SP)
    n=min(len(y),len(fv)); resid=(y.iloc[:n].values-np.nan_to_num(fv.iloc[:n].values,nan=np.nan)).astype(float)
    resid=resid[~np.isnan(resid)]; sig=rstd(resid)
    last_d=g['END_OF_MONTH_DATE'].iloc[-1]; last_a=float(y.iloc[-1]); med=float(np.nanmedian(y.values)) if len(y) else 1.0
    for step in range(len(fc)):
        f=float(fc.iloc[step]); next_d=last_d+pd.offsets.MonthEnd(step+1)
        if sig is not None and np.isfinite(sig):
            lo80,hi80=f-Z80*sig,f+Z80*sig; lo95,hi95=f-Z95*sig,f+Z95*sig
        else:
            lo80=hi80=lo95=hi95=np.nan
        dev_abs=last_a-f; dev_pct=(dev_abs/f) if f!=0 else np.nan; z=(dev_abs/sig) if (sig is not None and np.isfinite(sig) and sig>0) else np.nan
        zt=min(abs(z)/3.0,1.0) if pd.notna(z) else 0.0; pt=min(abs(dev_pct)/0.1,1.0) if pd.notna(dev_pct) else 0.0; it=min((abs(dev_abs)/(med*0.1)) if med>0 else 0.0,1.0)
        sev=100.0*(WZ*zt+WP*pt+WI*it); flag95=(pd.notna(last_a) and pd.notna(lo95) and (last_a<lo95 or last_a>hi95))
        rows.append({'CONTRACT_SOURCE_SYSTEM':sys,'MODEL':name,'LAST_PERIOD':last_d,'NEXT_PERIOD':next_d,'STEP_AHEAD':step+1,'ACTUAL_LAST':last_a,'FORECAST':f,'PI80_LO':lo80,'PI80_HI':hi80,'PI95_LO':lo95,'PI95_HI':hi95,'DEV_ABS_vs_LAST':dev_abs,'DEV_PCT_vs_LAST':dev_pct,'Z_SCORE_vs_LAST':z,'SEVERITY_0_100':sev,'OUTSIDE_95_BAND_vs_LAST':bool(flag95)})
res=pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'],ascending=[True,False])
return res", tblSSB[#All])








#!/usr/bin/env python3
"""
ssb_forecast.py

End-to-end forecasting + anomaly scoring for SOURCE_SYSTEM_BALANCE (SSB) by CONTRACT_SOURCE_SYSTEM.

Inputs
------
- An input file containing at least these columns:
    END_OF_MONTH_DATE, CONTRACT_SOURCE_SYSTEM, SOURCE_SYSTEM_BALANCE
- File can be .xlsx/.xls (Excel) or .csv

Outputs
-------
- Excel file with 3 sheets:
    1) Summary            -> per-system next-month forecast, PIs, severity rank
    2) Forecast_Horizon   -> per-system multi-step forecasts (1..H)
    3) Fitted_History     -> in-sample fitted values per system (for QA/plots)
- (Optional) Per-system CSVs if --per_system_csv_dir is provided

Usage
-----
python ssb_forecast.py --input data.xlsx --sheet Sheet1 --output ssb_forecast_output.xlsx --horizon 1 --seasonal_periods 12

Notes
-----
- Uses statsmodels ExponentialSmoothing if installed; otherwise falls back to seasonal-naive.
- Severity score blends Z-score surprise, percent deviation, and $ impact normalized by median system size.
"""

import argparse
import os
import sys
from typing import Tuple, Optional

import numpy as np
import pandas as pd

# Try to import statsmodels; fallback if unavailable
_HAS_SM = True
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing
except Exception:
    _HAS_SM = False

# -----------------------------
# Config defaults
# -----------------------------
DEFAULT_SEASONAL_PERIODS = 12     # monthly data -> yearly seasonality
DEFAULT_HORIZON = 1               # months ahead
Z80 = 1.2816
Z95 = 1.9599
# Severity weights (z, percent, impact)
WZ, WPCT, WIMP = 0.5, 0.3, 0.2

REQUIRED_COLS = {'END_OF_MONTH_DATE', 'CONTRACT_SOURCE_SYSTEM', 'SOURCE_SYSTEM_BALANCE'}


# -----------------------------
# Helpers
# -----------------------------
def robust_sigma(resid: np.ndarray) -> float:
    """Robust sigma using MAD; fallback to std if needed."""
    resid = resid[~np.isnan(resid)]
    if resid.size == 0:
        return np.nan
    med = np.nanmedian(resid)
    mad = np.nanmedian(np.abs(resid - med))
    if mad and mad > 0:
        return 1.4826 * mad
    return float(np.nanstd(resid)) if resid.size > 1 else np.nan


def seasonal_naive_forecast(y: pd.Series, h: int, sp: int) -> pd.Series:
    """Seasonal naive: yhat(t+h) = y(t+h-sp)."""
    out = []
    n = len(y)
    for k in range(1, h + 1):
        idx = n - sp
        out.append(y.iloc[idx] if idx >= 0 else y.iloc[-1])
    return pd.Series(out, index=range(h), dtype=float)


def fit_and_forecast(y: pd.Series, h: int, sp: int) -> Tuple[str, pd.Series, pd.Series]:
    """Fit ETS if possible; else fallback to seasonal naive. Returns (model_name, fitted_vals, forecast)."""
    y = pd.Series(pd.to_numeric(y, errors='coerce').astype(float).values)  # clean index 0..n-1, drop weird types
    model_name = 'SeasonalNaive'
    fitted_vals = pd.Series(index=y.index, dtype=float)

    if _HAS_SM:
        fit = None
        # ETS(A,A,A) if long enough for seasonality
        if len(y) >= 2 * sp:
            try:
                m = ExponentialSmoothing(
                    y, trend='add', seasonal='add', seasonal_periods=sp, initialization_method='estimated'
                )
                fit = m.fit(optimized=True)
                model_name = 'ETS(A,A,A)'
            except Exception:
                fit = None
        # ETS(A,A,N) (trend, no season)
        if fit is None and len(y) >= 6:
            try:
                m = ExponentialSmoothing(y, trend='add', seasonal=None, initialization_method='estimated')
                fit = m.fit(optimized=True)
                model_name = 'ETS(A,A,N)'
            except Exception:
                fit = None
        # SES (no trend/season)
        if fit is None:
            try:
                m = ExponentialSmoothing(y, trend=None, seasonal=None, initialization_method='estimated')
                fit = m.fit(optimized=True)
                model_name = 'SES'
            except Exception:
                fit = None

        if fit is not None:
            fitted_vals = pd.Series(fit.fittedvalues, index=y.index, dtype=float)
            fcast = pd.Series(fit.forecast(h).values, index=range(h), dtype=float)
            return model_name, fitted_vals, fcast

    # Fallback: seasonal naive + pseudo-fitted
    fcast = seasonal_naive_forecast(y, h=h, sp=sp)
    if len(y) > sp:
        fitted_vals.iloc[:sp] = y.values[0]
        fitted_vals.iloc[sp:] = y.values[:-sp]
    else:
        fitted_vals[:] = float(np.nanmean(y.values))
    return model_name, fitted_vals, fcast


def load_input(path: str, sheet: Optional[str] = None) -> pd.DataFrame:
    """Load data from CSV or Excel; return DataFrame."""
    ext = os.path.splitext(path)[1].lower()
    if ext in ('.xlsx', '.xls'):
        df = pd.read_excel(path, sheet_name=sheet)
    elif ext == '.csv':
        df = pd.read_csv(path)
    else:
        raise ValueError(f'Unsupported file extension: {ext}. Use .xlsx/.xls or .csv')
    return df


def normalize_and_aggregate(df: pd.DataFrame) -> pd.DataFrame:
    """Standardize columns, ensure types, aggregate to system x month."""
    df = df.copy()
    df.columns = [c.strip().upper() for c in df.columns]
    missing = REQUIRED_COLS - set(df.columns)
    if missing:
        raise ValueError(f'Missing required columns: {missing}')
    df['END_OF_MONTH_DATE'] = pd.to_datetime(df['END_OF_MONTH_DATE'])
    df['SOURCE_SYSTEM_BALANCE'] = pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
    df = df.dropna(subset=['END_OF_MONTH_DATE', 'SOURCE_SYSTEM_BALANCE'])

    # Aggregate in case duplicates exist at month/system
    df = (df.groupby(['CONTRACT_SOURCE_SYSTEM', 'END_OF_MONTH_DATE'], as_index=False)['SOURCE_SYSTEM_BALANCE']
            .sum()
            .sort_values(['CONTRACT_SOURCE_SYSTEM', 'END_OF_MONTH_DATE']))
    return df


def compute_outputs(df: pd.DataFrame, horizon: int, sp: int) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """
    For each system:
      - fit model, compute in-sample fitted/residuals/sigma
      - create next H forecasts with simple normal-approx PIs from residual sigma
      - compute severity vs last actual for step=1
    Returns: (summary_df, horizon_df, fitted_history_df)
    """
    summary_rows = []
    horizon_rows = []
    fitted_rows = []

    for system, g in df.groupby('CONTRACT_SOURCE_SYSTEM', sort=False):
        g = g.sort_values('END_OF_MONTH_DATE')
        y = g['SOURCE_SYSTEM_BALANCE'].astype(float)
        last_date = g['END_OF_MONTH_DATE'].iloc[-1]
        last_actual = float(y.iloc[-1])
        med_level = float(np.nanmedian(y.values)) if len(y) else 1.0

        model_name, fitted_vals, fcast = fit_and_forecast(y, h=horizon, sp=sp)

        # Residuals & sigma (align lengths)
        n = min(len(y), len(fitted_vals))
        resid = (y.iloc[:n].values - fitted_vals.iloc[:n].values).astype(float)
        sigma = robust_sigma(resid)

        # Save fitted history rows
        for t_idx, (dt, actual, fitted) in enumerate(zip(g['END_OF_MONTH_DATE'].iloc[:n], y.iloc[:n], fitted_vals.iloc[:n])):
            fitted_rows.append({
                'CONTRACT_SOURCE_SYSTEM': system,
                'DATE': pd.to_datetime(dt),
                'ACTUAL': float(actual),
                'FITTED': float(fitted) if not np.isnan(fitted) else np.nan,
                'MODEL': model_name
            })

        # Build horizon rows and summary for step=1
        for step in range(len(fcast)):
            f = float(fcast.iloc[step])
            next_period = last_date + pd.offsets.MonthEnd(step + 1)

            if sigma is not None and np.isfinite(sigma):
                lo80, hi80 = f - Z80 * sigma, f + Z80 * sigma
                lo95, hi95 = f - Z95 * sigma, f + Z95 * sigma
            else:
                lo80 = hi80 = lo95 = hi95 = np.nan

            horizon_rows.append({
                'CONTRACT_SOURCE_SYSTEM': system,
                'MODEL': model_name,
                'LAST_PERIOD': last_date,
                'NEXT_PERIOD': next_period,
                'STEP_AHEAD': step + 1,
                'FORECAST': f,
                'PI80_LO': lo80, 'PI80_HI': hi80,
                'PI95_LO': lo95, 'PI95_HI': hi95
            })

            # Only compute severity vs last actual for step=1 (most actionable)
            if step == 0:
                dev_abs = last_actual - f
                dev_pct = (dev_abs / f) if f != 0 else np.nan
                zscore = (dev_abs / sigma) if (sigma is not None and np.isfinite(sigma) and sigma > 0) else np.nan

                z_term = min(abs(zscore) / 3.0, 1.0) if not np.isnan(zscore) else 0.0  # cap ~3Ï
                pct_term = min(abs(dev_pct) / 0.1, 1.0) if not np.isnan(dev_pct) else 0.0  # cap 10%
                imp_term = min((abs(dev_abs) / (med_level * 0.1)) if med_level > 0 else 0.0, 1.0)  # 10% median cap

                severity = 100.0 * (WZ * z_term + WPCT * pct_term + WIMP * imp_term)
                flag95 = (not np.isnan(last_actual) and not np.isnan(lo95) and (last_actual < lo95 or last_actual > hi95))

                summary_rows.append({
                    'CONTRACT_SOURCE_SYSTEM': system,
                    'MODEL': model_name,
                    'LAST_PERIOD': last_date,
                    'NEXT_PERIOD': next_period,
                    'ACTUAL_LAST': last_actual,
                    'FORECAST_NEXT': f,
                    'PI80_LO': lo80, 'PI80_HI': hi80,
                    'PI95_LO': lo95, 'PI95_HI': hi95,
                    'DEV_ABS_vs_LAST': dev_abs,
                    'DEV_PCT_vs_LAST': dev_pct,
                    'Z_SCORE_vs_LAST': zscore,
                    'SEVERITY_0_100': severity,
                    'OUTSIDE_95_BAND_vs_LAST': bool(flag95)
                })

    summary_df = pd.DataFrame(summary_rows).sort_values('SEVERITY_0_100', ascending=False)
    horizon_df = pd.DataFrame(horizon_rows).sort_values(['STEP_AHEAD', 'CONTRACT_SOURCE_SYSTEM'])
    fitted_df = pd.DataFrame(fitted_rows).sort_values(['CONTRACT_SOURCE_SYSTEM', 'DATE'])
    return summary_df, horizon_df, fitted_df


def main():
    p = argparse.ArgumentParser(description='Forecast SOURCE_SYSTEM_BALANCE per CONTRACT_SOURCE_SYSTEM with severity scoring.')
    p.add_argument('--input', required=True, help='Input file path (.xlsx/.xls or .csv)')
    p.add_argument('--sheet', default=None, help='Excel sheet name (if input is .xlsx/.xls)')
    p.add_argument('--output', default='ssb_forecast_output.xlsx', help='Output Excel file path')
    p.add_argument('--horizon', type=int, default=DEFAULT_HORIZON, help='Forecast horizon in months (default: 1)')
    p.add_argument('--seasonal_periods', type=int, default=DEFAULT_SEASONAL_PERIODS, help='Seasonal periods (default: 12 for monthly)')
    p.add_argument('--per_system_csv_dir', default=None, help='Optional dir to write per-system CSVs')
    args = p.parse_args()

    # Load and prep
    df_raw = load_input(args.input, sheet=args.sheet)
    df = normalize_and_aggregate(df_raw)

    # Compute outputs
    summary_df, horizon_df, fitted_df = compute_outputs(df, horizon=args.horizon, sp=args.seasonal_periods)

    # Ensure output dir exists
    out_dir = os.path.dirname(os.path.abspath(args.output))
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir, exist_ok=True)

    # Write Excel
    with pd.ExcelWriter(args.output, engine='openpyxl') as xw:
        summary_df.to_excel(xw, sheet_name='Summary', index=False)
        horizon_df.to_excel(xw, sheet_name='Forecast_Horizon', index=False)
        fitted_df.to_excel(xw, sheet_name='Fitted_History', index=False)

    # Optional per-system CSVs
    if args.per_system_csv_dir:
        os.makedirs(args.per_system_csv_dir, exist_ok=True)
        for sys_name, g in summary_df.groupby('CONTRACT_SOURCE_SYSTEM', sort=False):
            safe = ''.join(ch if ch.isalnum() or ch in ('-', '_') else '_' for ch in str(sys_name))
            path = os.path.join(args.per_system_csv_dir, f'{safe}_summary.csv')
            g.to_csv(path, index=False)
        for sys_name, g in fitted_df.groupby('CONTRACT_SOURCE_SYSTEM', sort=False):
            safe = ''.join(ch if ch.isalnum() or ch in ('-', '_') else '_' for ch in str(sys_name))
            path = os.path.join(args.per_system_csv_dir, f'{safe}_fitted_history.csv')
            g.to_csv(path, index=False)
        for sys_name, g in horizon_df.groupby('CONTRACT_SOURCE_SYSTEM', sort=False):
            safe = ''.join(ch if ch.isalnum() or ch in ('-', '_') else '_' for ch in str(sys_name))
            path = os.path.join(args.per_system_csv_dir, f'{safe}_horizon.csv')
            g.to_csv(path, index=False)

    print(f'Wrote: {args.output}')
    if args.per_system_csv_dir:
        print(f'Per-system CSVs in: {args.per_system_csv_dir}')


if __name__ == '__main__':
    main()







import numpy as np, pandas as pd
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing; _HAS_SM=True
except Exception:
    _HAS_SM=False
SP=12; H=1; Z80=1.2816; Z95=1.9599; WZ,WP,WI=0.5,0.3,0.2
df=args[0].copy()
df.columns=[c.strip().upper() for c in df.columns]
req={'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
mis=req-set(df.columns)
if mis: raise ValueError(f'Missing required columns: {mis}')
df['END_OF_MONTH_DATE']=pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE']=pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df=df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df=(df.groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'],as_index=False)['SOURCE_SYSTEM_BALANCE'].sum()
       .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))
def rstd(r):
    if r.size==0: return np.nan
    med=np.nanmedian(r); mad=np.nanmedian(np.abs(r-med))
    return 1.4826*mad if mad and mad>0 else (np.nanstd(r) if r.size>1 else np.nan)
def s_naive(y,h,sp):
    n=len(y); out=[]
    for k in range(1,h+1):
        out.append(y.iloc[n-sp] if n-sp>=0 else y.iloc[-1])
    return pd.Series(out,index=range(h))
def fit_fc(y,h,sp):
    y=pd.Series(y.astype(float).values)
    name='SeasonalNaive'; fit=None
    if _HAS_SM:
        try:
            if len(y)>=2*sp:
                fit=ExponentialSmoothing(y,trend='add',seasonal='add',seasonal_periods=sp,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,A)'
            elif len(y)>=6:
                fit=ExponentialSmoothing(y,trend='add',seasonal=None,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,N)'
            else:
                fit=ExponentialSmoothing(y,trend=None,seasonal=None,initialization_method='estimated').fit(optimized=True); name='SES'
        except Exception:
            fit=None
        if fit is not None:
            fv=pd.Series(fit.fittedvalues); fc=pd.Series(fit.forecast(H).values,index=range(H))
            return name,fv,fc
    fc=s_naive(y,H,sp)
    fv=pd.Series(index=y.index,dtype=float)
    if len(y)>sp:
        fv.iloc[:sp]=y.values[0]; fv.iloc[sp:]=y.values[:-sp]
    else:
        fv[:]=np.nanmean(y.values)
    return name,fv,fc
rows=[]
for sys,g in df.groupby('CONTRACT_SOURCE_SYSTEM',sort=False):
    g=g.sort_values('END_OF_MONTH_DATE'); y=g['SOURCE_SYSTEM_BALANCE']
    name,fv,fc=fit_fc(y,H,SP)
    n=min(len(y),len(fv)); resid=(y.iloc[:n].values-np.nan_to_num(fv.iloc[:n].values,nan=np.nan)).astype(float)
    resid=resid[~np.isnan(resid)]; sig=rstd(resid)
    last_d=g['END_OF_MONTH_DATE'].iloc[-1]; last_a=float(y.iloc[-1]); med=float(np.nanmedian(y.values)) if len(y) else 1.0
    for step in range(len(fc)):
        f=float(fc.iloc[step]); next_d=last_d+pd.offsets.MonthEnd(step+1)
        if sig is not None and np.isfinite(sig):
            lo80,hi80=f-Z80*sig,f+Z80*sig; lo95,hi95=f-Z95*sig,f+Z95*sig
        else:
            lo80=hi80=lo95=hi95=np.nan
        dev_abs=last_a-f; dev_pct=(dev_abs/f) if f!=0 else np.nan; z=(dev_abs/sig) if (sig is not None and np.isfinite(sig) and sig>0) else np.nan
        zt=min(abs(z)/3.0,1.0) if pd.notna(z) else 0.0; pt=min(abs(dev_pct)/0.1,1.0) if pd.notna(dev_pct) else 0.0; it=min((abs(dev_abs)/(med*0.1)) if med>0 else 0.0,1.0)
        sev=100.0*(WZ*zt+WP*pt+WI*it); flag95=(pd.notna(last_a) and pd.notna(lo95) and (last_a<lo95 or last_a>hi95))
        rows.append({'CONTRACT_SOURCE_SYSTEM':sys,'MODEL':name,'LAST_PERIOD':last_d,'NEXT_PERIOD':next_d,'STEP_AHEAD':step+1,'ACTUAL_LAST':last_a,'FORECAST':f,'PI80_LO':lo80,'PI80_HI':hi80,'PI95_LO':lo95,'PI95_HI':hi95,'DEV_ABS_vs_LAST':dev_abs,'DEV_PCT_vs_LAST':dev_pct,'Z_SCORE_vs_LAST':z,'SEVERITY_0_100':sev,'OUTSIDE_95_BAND_vs_LAST':bool(flag95)})
res=pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'],ascending=[True,False])
return res






=PY("import numpy as np, pandas as pd
try:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing; _HAS_SM=True
except Exception:
    _HAS_SM=False
SP=12; H=1; Z80=1.2816; Z95=1.9599; WZ,WP,WI=0.5,0.3,0.2
df=args[0].copy()
df.columns=[c.strip().upper() for c in df.columns]
req={'END_OF_MONTH_DATE','CONTRACT_SOURCE_SYSTEM','SOURCE_SYSTEM_BALANCE'}
mis=req-set(df.columns)
if mis: raise ValueError(f'Missing required columns: {mis}')
df['END_OF_MONTH_DATE']=pd.to_datetime(df['END_OF_MONTH_DATE'])
df['SOURCE_SYSTEM_BALANCE']=pd.to_numeric(df['SOURCE_SYSTEM_BALANCE'], errors='coerce')
df=df.dropna(subset=['END_OF_MONTH_DATE','SOURCE_SYSTEM_BALANCE'])
df=(df.groupby(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE'],as_index=False)['SOURCE_SYSTEM_BALANCE'].sum()
       .sort_values(['CONTRACT_SOURCE_SYSTEM','END_OF_MONTH_DATE']))
def rstd(r):
    if r.size==0: return np.nan
    med=np.nanmedian(r); mad=np.nanmedian(np.abs(r-med))
    return 1.4826*mad if mad and mad>0 else (np.nanstd(r) if r.size>1 else np.nan)
def s_naive(y,h,sp):
    n=len(y); out=[]
    for k in range(1,h+1):
        out.append(y.iloc[n-sp] if n-sp>=0 else y.iloc[-1])
    return pd.Series(out,index=range(h))
def fit_fc(y,h,sp):
    y=pd.Series(y.astype(float).values)
    name='SeasonalNaive'; fit=None; fcast=None
    if _HAS_SM:
        try:
            if len(y)>=2*sp:
                fit=ExponentialSmoothing(y,trend='add',seasonal='add',seasonal_periods=sp,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,A)'
            elif len(y)>=6:
                fit=ExponentialSmoothing(y,trend='add',seasonal=None,initialization_method='estimated').fit(optimized=True); name='ETS(A,A,N)'
            else:
                fit=ExponentialSmoothing(y,trend=None,seasonal=None,initialization_method='estimated').fit(optimized=True); name='SES'
        except Exception: fit=None
        if fit is not None:
            fv=pd.Series(fit.fittedvalues); fc=pd.Series(fit.forecast(h).values,index=range(h))
            return name,fv,fc
    fc=s_naive(y,h,sp)
    fv=pd.Series(index=y.index,dtype=float)
    if len(y)>sp:
        fv.iloc[:sp]=y.values[0]; fv.iloc[sp:]=y.values[:-sp]
    else:
        fv[:]=np.nanmean(y.values)
    return name,fv,fc
rows=[]
for sys,g in df.groupby('CONTRACT_SOURCE_SYSTEM',sort=False):
    g=g.sort_values('END_OF_MONTH_DATE'); y=g['SOURCE_SYSTEM_BALANCE']
    name,fv,fc=fit_fc(y,H,SP)
    n=min(len(y),len(fv)); resid=(y.iloc[:n].values-np.nan_to_num(fv.iloc[:n].values,nan=np.nan)).astype(float)
    resid=resid[~np.isnan(resid)]; sig=rstd(resid)
    last_d=g['END_OF_MONTH_DATE'].iloc[-1]; last_a=float(y.iloc[-1]); med=float(np.nanmedian(y.values)) if len(y) else 1.0
    for step in range(len(fc)):
        f=float(fc.iloc[step]); next_d=last_d+pd.offsets.MonthEnd(step+1)
        if sig is not None and np.isfinite(sig):
            lo80,hi80=f-Z80*sig,f+Z80*sig; lo95,hi95=f-Z95*sig,f+Z95*sig
        else:
            lo80=hi80=lo95=hi95=np.nan
        dev=f-last_a; pct=(dev/f) if f!=0 else np.nan; z=(dev/sig) if (sig is not None and np.isfinite(sig) and sig>0) else np.nan
        zt=min(abs(z)/3.0,1.0) if pd.notna(z) else 0.0; pt=min(abs(pct)/0.1,1.0) if pd.notna(pct) else 0.0; it=min((abs(dev)/(med*0.1)) if med>0 else 0.0,1.0)
        sev=100.0*(WZ*zt+WP*pt+WI*it); flag95=(pd.notna(last_a) and pd.notna(lo95) and (last_a<lo95 or last_a>hi95))
        rows.append({'CONTRACT_SOURCE_SYSTEM':sys,'MODEL':name,'LAST_PERIOD':last_d,'NEXT_PERIOD':next_d,'STEP_AHEAD':step+1,'ACTUAL_LAST':last_a,'FORECAST':f,'PI80_LO':lo80,'PI80_HI':hi80,'PI95_LO':lo95,'PI95_HI':hi95,'DEV_ABS_vs_LAST':last_a-f,'DEV_PCT_vs_LAST':(last_a-f)/f if f!=0 else np.nan,'Z_SCORE_vs_LAST':(last_a-f)/sig if (sig is not None and np.isfinite(sig) and sig>0) else np.nan,'SEVERITY_0_100':sev,'OUTSIDE_95_BAND_vs_LAST':bool(flag95)})
res=pd.DataFrame(rows).sort_values(['STEP_AHEAD','SEVERITY_0_100'],ascending=[True,False])
return res
", tblSSB[#All])





-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (fixed PREV_TOT_GL and RC_DESCRIPTION)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,
        0.40::FLOAT  AS w_zscore,
        0.30::FLOAT  AS w_pct,
        0.20::FLOAT  AS w_abs,
        0.10::FLOAT  AS w_share,
        2.00::FLOAT  AS z_cap,
        0.25::FLOAT  AS pct_cap,
        100000::FLOAT AS abs_cap,
        0.02::FLOAT  AS share_cap,
        2.00::FLOAT  AS z_thresh,
        0.25::FLOAT  AS pct_thresh,
        100000::FLOAT AS abs_thresh
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RC_DESCRIPTION,                          -- <-- renamed
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS & PRIOR-MONTH TOTAL AT MONTH GRAIN ======== */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),
tot_with_prev AS (
    SELECT
        EOM,
        TOT_GL AS CURR_TOT_GL,
        LAG(TOT_GL) OVER (ORDER BY EOM) AS PREV_TOT_GL
    FROM tot
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RC_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL
    FROM base b
),

/* ====== 5) ENRICH WITH MONTH TOTALS, Z-SCORE, SHARE METRICS ============== */
enriched AS (
    SELECT
        c.*,
        t.CURR_TOT_GL,
        t.PREV_TOT_GL,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN t.CURR_TOT_GL > 0 THEN c.GL_BALANCE / t.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN t.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN t.CURR_TOT_GL > 0 AND t.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / t.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / t.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
    JOIN tot_with_prev t
      ON t.EOM = c.EOM
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RC_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE WHEN Z_SCORE_12_EXCL IS NULL THEN 0 ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1) END AS z_norm,
        CASE WHEN MOM_PCT_CHANGE IS NULL THEN 0 ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1) END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE WHEN SHARE_DELTA IS NULL THEN 0 ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1) END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RC_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;






-- =====================================================================
-- MASTER RC_CODE VARIANCE + ANOMALY + SEVERITY (Run as a single query)
-- =====================================================================

WITH
/* ========================== 1) PARAMETERS =========================== */
params AS (
    SELECT
        12::INTEGER  AS lookback_months,   -- months of history (e.g., 12)
        /* Severity weighting (roughly sum to 1.0) */
        0.40::FLOAT  AS w_zscore,          -- weight for Z-score
        0.30::FLOAT  AS w_pct,             -- weight for MoM % change
        0.20::FLOAT  AS w_abs,             -- weight for MoM $ change
        0.10::FLOAT  AS w_share,           -- weight for portfolio share shift
        /* Normalization caps for 0..1 scaling */
        2.00::FLOAT  AS z_cap,             -- cap for |Z| (e.g., 2σ)
        0.25::FLOAT  AS pct_cap,           -- cap for |MoM %| (e.g., 25%)
        100000::FLOAT AS abs_cap,          -- cap for |MoM $| (materiality)
        0.02::FLOAT  AS share_cap,         -- cap for |share delta| (2% of total)
        /* Anomaly trip wires for IS_ANOMALY */
        2.00::FLOAT  AS z_thresh,          -- flag if |Z| >= 2.0
        0.25::FLOAT  AS pct_thresh,        -- with $ threshold
        100000::FLOAT AS abs_thresh        -- with % threshold
),

/* ====== 2) BASE RC_CODE MONTHLY AGGREGATE (GL_BALANCE > 0) ========= */
base AS (
    SELECT
        CAST(END_OF_MONTH_DATE AS DATE)          AS EOM,
        RC_CODE,
        RV_DESCRIPTION,
        SUM(GL_BALANCE)                          AS GL_BALANCE
    FROM V_DPRT_CREDIT_INSTRUMENTS_ME
    WHERE GL_BALANCE > 0
      AND END_OF_MONTH_DATE >= ADD_MONTHS(DATE_TRUNC('month', CURRENT_DATE),
                                          - (SELECT lookback_months FROM params))
    GROUP BY 1,2,3
),

/* ========== 3) PORTFOLIO TOTALS BY MONTH (for share calculations) ========= */
tot AS (
    SELECT EOM, SUM(GL_BALANCE) AS TOT_GL
    FROM base
    GROUP BY 1
),

/* ====== 4) MOM DELTAS + ROLLING STATS (excluding current month) ========== */
calc AS (
    SELECT
        b.EOM,
        b.RC_CODE,
        b.RV_DESCRIPTION,
        b.GL_BALANCE,
        LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM) AS PREV_GL_BALANCE,

        /* absolute change */
        b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM)
            AS MOM_ABS_CHANGE,

        /* percent change (NULL if prev = 0) */
        CASE
            WHEN NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0) IS NULL
                THEN NULL
            ELSE (b.GL_BALANCE - LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM))
                 / NULLIF(LAG(b.GL_BALANCE) OVER (PARTITION BY b.RC_CODE ORDER BY b.EOM),0)
        END AS MOM_PCT_CHANGE,

        /* rolling mean/std over prior 12 rows (exclude current) */
        AVG(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_MEAN_12_EXCL,

        /* If STDDEV_SAMP isn't available in your Netezza version, use STDDEV */
        STDDEV_SAMP(b.GL_BALANCE) OVER (
            PARTITION BY b.RC_CODE
            ORDER BY b.EOM
            ROWS BETWEEN 12 PRECEDING AND 1 PRECEDING
        ) AS ROLL_STD_12_EXCL,

        t.TOT_GL AS CURR_TOT_GL,
        LAG(t.TOT_GL) OVER (ORDER BY b.EOM) AS PREV_TOT_GL
    FROM base b
    JOIN tot  t ON t.EOM = b.EOM
),

/* ====== 5) ENRICH WITH Z-SCORE & PORTFOLIO SHARE / SHARE DELTA ========== */
enriched AS (
    SELECT
        c.*,
        CASE
            WHEN c.ROLL_STD_12_EXCL IS NULL OR c.ROLL_STD_12_EXCL = 0 THEN NULL
            ELSE (c.GL_BALANCE - c.ROLL_MEAN_12_EXCL) / c.ROLL_STD_12_EXCL
        END AS Z_SCORE_12_EXCL,
        CASE WHEN c.CURR_TOT_GL > 0 THEN c.GL_BALANCE / c.CURR_TOT_GL ELSE NULL END AS CURR_SHARE,
        CASE WHEN c.PREV_TOT_GL > 0 THEN COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL ELSE NULL END AS PREV_SHARE,
        CASE
            WHEN c.CURR_TOT_GL > 0 AND c.PREV_TOT_GL > 0 THEN
                (c.GL_BALANCE / c.CURR_TOT_GL) - (COALESCE(c.PREV_GL_BALANCE,0) / c.PREV_TOT_GL)
            ELSE NULL
        END AS SHARE_DELTA
    FROM calc c
),

/* ====== 6) ANOMALY FLAG (trip rules) ===================================== */
flagged AS (
    SELECT
        e.*,
        CASE
            WHEN (e.ROLL_STD_12_EXCL IS NOT NULL AND e.ROLL_STD_12_EXCL > 0
                  AND ABS(e.Z_SCORE_12_EXCL) >= (SELECT z_thresh FROM params))
              OR (COALESCE(ABS(e.MOM_PCT_CHANGE),0) >= (SELECT pct_thresh FROM params)
                  AND COALESCE(ABS(e.MOM_ABS_CHANGE),0) >= (SELECT abs_thresh FROM params))
            THEN 1 ELSE 0
        END AS IS_ANOMALY
    FROM enriched e
),

/* ====== 7) SEVERITY SCORE (0..100), RANKS, TIERS ========================= */
scored AS (
    SELECT
        f.*,
        p.w_zscore, p.w_pct, p.w_abs, p.w_share,
        p.z_cap, p.pct_cap, p.abs_cap, p.share_cap
    FROM flagged f
    CROSS JOIN params p
),
assembled AS (
    SELECT
        EOM                               AS END_OF_MONTH_DATE,
        RC_CODE,
        RV_DESCRIPTION,
        GL_BALANCE,
        PREV_GL_BALANCE,
        MOM_ABS_CHANGE,
        MOM_PCT_CHANGE,
        ROLL_MEAN_12_EXCL,
        ROLL_STD_12_EXCL,
        Z_SCORE_12_EXCL,
        CURR_TOT_GL,
        PREV_TOT_GL,
        CURR_SHARE,
        PREV_SHARE,
        SHARE_DELTA,
        IS_ANOMALY,

        /* Normalized components 0..1 (capped) */
        CASE
            WHEN Z_SCORE_12_EXCL IS NULL THEN 0
            ELSE LEAST(ABS(Z_SCORE_12_EXCL) / NULLIF(z_cap,0), 1)
        END AS z_norm,
        CASE
            WHEN MOM_PCT_CHANGE IS NULL THEN 0
            ELSE LEAST(ABS(MOM_PCT_CHANGE) / NULLIF(pct_cap,0), 1)
        END AS pct_norm,
        LEAST(ABS(COALESCE(MOM_ABS_CHANGE,0)) / NULLIF(abs_cap,0), 1) AS abs_norm,
        CASE
            WHEN SHARE_DELTA IS NULL THEN 0
            ELSE LEAST(ABS(SHARE_DELTA) / NULLIF(share_cap,0), 1)
        END AS share_norm,

        w_zscore, w_pct, w_abs, w_share
    FROM scored
),
final AS (
    SELECT
        *,
        100 * (w_zscore * z_norm
             + w_pct    * pct_norm
             + w_abs    * abs_norm
             + w_share  * share_norm)     AS SEVERITY_SCORE_RAW
    FROM assembled
)

SELECT
    END_OF_MONTH_DATE,
    RC_CODE,
    RV_DESCRIPTION,
    GL_BALANCE,
    PREV_GL_BALANCE,
    MOM_ABS_CHANGE,
    MOM_PCT_CHANGE,
    ROLL_MEAN_12_EXCL,
    ROLL_STD_12_EXCL,
    Z_SCORE_12_EXCL,
    CURR_TOT_GL,
    PREV_TOT_GL,
    CURR_SHARE,
    PREV_SHARE,
    SHARE_DELTA,
    IS_ANOMALY,

    /* Rounded/clipped severity for presentation */
    GREATEST(0, LEAST(100, ROUND(SEVERITY_SCORE_RAW,1))) AS SEVERITY_SCORE,

    /* Rank within each month (highest score = rank 1) */
    DENSE_RANK() OVER (PARTITION BY END_OF_MONTH_DATE
                       ORDER BY SEVERITY_SCORE_RAW DESC) AS MONTHLY_RANK,

    /* Tiering */
    CASE
        WHEN SEVERITY_SCORE_RAW >= 85 THEN 'CRITICAL'
        WHEN SEVERITY_SCORE_RAW >= 70 THEN 'HIGH'
        WHEN SEVERITY_SCORE_RAW >= 50 THEN 'MEDIUM'
        WHEN SEVERITY_SCORE_RAW >= 30 THEN 'LOW'
        ELSE 'INFO'
    END AS SEVERITY_TIER

FROM final
ORDER BY END_OF_MONTH_DATE, MONTHLY_RANK, RC_CODE;







/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)








/* ===================== TAB 2 – MoM Change Analysis (Non-Accrual) ===================== */
/* Reuses NonAccrual, Months, MonthPairs already defined earlier. If not present,
   copy those CTEs from your existing query. */

-- Detailed current-vs-prev for accounts (drives adds & persisting deltas)
Tab2_CurrVsPrev_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    c.ACCOUNT_IDENTIFIER,
    c.CONTRACT_SOURCE_SYSTEM,
    SUM(c.Balance) AS CurrBal,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
  LEFT JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
   AND p.ACCOUNT_IDENTIFIER = c.ACCOUNT_IDENTIFIER
   AND p.CONTRACT_SOURCE_SYSTEM = c.CONTRACT_SOURCE_SYSTEM
  GROUP BY mp.CurrMonth, mp.PrevMonth, c.ACCOUNT_IDENTIFIER, c.CONTRACT_SOURCE_SYSTEM
),

-- Accounts present in prev but missing in current (drives removals)
Tab2_PrevNotCurr_Account AS (
  SELECT
    mp.CurrMonth,
    mp.PrevMonth,
    p.ACCOUNT_IDENTIFIER,
    p.CONTRACT_SOURCE_SYSTEM,
    SUM(p.Balance) AS PrevBal
  FROM MonthPairs mp
  JOIN NonAccrual p
    ON p.MonthEnd = mp.PrevMonth
  LEFT JOIN NonAccrual c
    ON c.MonthEnd = mp.CurrMonth
   AND c.ACCOUNT_IDENTIFIER = p.ACCOUNT_IDENTIFIER
   AND c.CONTRACT_SOURCE_SYSTEM = p.CONTRACT_SOURCE_SYSTEM
  WHERE c.ACCOUNT_IDENTIFIER IS NULL
  GROUP BY mp.CurrMonth, mp.PrevMonth, p.ACCOUNT_IDENTIFIER, p.CONTRACT_SOURCE_SYSTEM
),

-- Adds / Removals by system (month-level) for a clustered bar in Tab 2
Tab2_AddsRemovals_BySystem AS (
  SELECT
    'Tab2_AddsRemovals_BySystem' AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim1,      -- Legend: system
    'Adds'                       AS Metric,
    SUM(CASE WHEN a.PrevBal IS NULL THEN a.CurrBal ELSE 0 END) AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  GROUP BY a.CurrMonth, a.CONTRACT_SOURCE_SYSTEM

  UNION ALL

  SELECT
    'Tab2_AddsRemovals_BySystem',
    r.CurrMonth,
    r.CONTRACT_SOURCE_SYSTEM,
    'Removals',
    SUM(-r.PrevBal),
    CAST(NULL AS VARCHAR(100))
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.CONTRACT_SOURCE_SYSTEM
),

-- Persisting movers (delta for accounts present in both months) – Top 25 by abs(delta) per month
Tab2_PersistingMovers_TopN AS (
  SELECT
    a.CurrMonth                                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER                         AS AccountId,
    a.CONTRACT_SOURCE_SYSTEM                     AS SystemName,
    SUM(a.CurrBal - a.PrevBal)                   AS Delta
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NOT NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_PersistingMovers_Ranked AS (
  SELECT
    MonthEnd,
    AccountId,
    SystemName,
    Delta,
    ROW_NUMBER() OVER (PARTITION BY MonthEnd ORDER BY ABS(Delta) DESC) AS rn
  FROM Tab2_PersistingMovers_TopN
),
Tab2_PersistingMovers_Long AS (
  SELECT
    'Tab2_PersistingMovers'      AS Dataset,
    MonthEnd,
    AccountId                    AS Dim1,      -- use as category on bar chart (Top 25)
    'DeltaSigned'                AS Metric,
    Delta                        AS Value,
    SystemName                   AS Dim2       -- optional: color by system in small multiples
  FROM Tab2_PersistingMovers_Ranked
  WHERE rn <= 25
),

-- Detailed ADDs and REMOVALs (account-level tables)
Tab2_AddsDetail AS (
  SELECT
    'Tab2_AddsDetail'            AS Dataset,
    a.CurrMonth                  AS MonthEnd,
    a.ACCOUNT_IDENTIFIER         AS Dim1,      -- account id
    'Add_Balance'                AS Metric,
    SUM(a.CurrBal)               AS Value,
    a.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_CurrVsPrev_Account a
  WHERE a.PrevBal IS NULL
  GROUP BY a.CurrMonth, a.ACCOUNT_IDENTIFIER, a.CONTRACT_SOURCE_SYSTEM
),
Tab2_RemovalsDetail AS (
  SELECT
    'Tab2_RemovalsDetail'        AS Dataset,
    r.CurrMonth                  AS MonthEnd,
    r.ACCOUNT_IDENTIFIER         AS Dim1,
    'Removal_Balance'            AS Metric,
    SUM(r.PrevBal)               AS Value,     -- positive amount (you can flip sign in PBI if desired)
    r.CONTRACT_SOURCE_SYSTEM     AS Dim2
  FROM Tab2_PrevNotCurr_Account r
  GROUP BY r.CurrMonth, r.ACCOUNT_IDENTIFIER, r.CONTRACT_SOURCE_SYSTEM
),

/* ===================== TAB 4 – Risk & Concentration (Non-Accrual) ===================== */

-- PD_Grade buckets (adjust thresholds if your PD scale differs)
Tab4_PD_Buckets AS (
  SELECT
    n.MonthEnd,
    CASE
      WHEN n.PD_GRADE_NUM IS NULL THEN 'Missing'
      WHEN n.PD_GRADE_NUM < 3      THEN 'PD 1–2'
      WHEN n.PD_GRADE_NUM < 6      THEN 'PD 3–5'
      WHEN n.PD_GRADE_NUM < 9      THEN 'PD 6–8'
      ELSE 'PD 9+'
    END AS PDBand,
    n.Balance
  FROM NonAccrual n
),
Tab4_PD_Distribution AS (
  SELECT
    'Tab4_PD_Distribution'       AS Dataset,
    MonthEnd,
    PDBand                       AS Dim1,
    'Balance'                    AS Metric,
    SUM(Balance)                 AS Value,
    CAST(NULL AS VARCHAR(100))   AS Dim2
  FROM Tab4_PD_Buckets
  GROUP BY MonthEnd, PDBand
),

-- Top 10 accounts by balance (per month)
Tab4_TopAccounts AS (
  SELECT
    n.MonthEnd,
    n.ACCOUNT_IDENTIFIER                                   AS AccountId,
    n.CONTRACT_SOURCE_SYSTEM                               AS SystemName,
    SUM(n.Balance)                                         AS Bal,
    ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
  FROM NonAccrual n
  GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER, n.CONTRACT_SOURCE_SYSTEM
),
Tab4_Top10Accounts_Long AS (
  SELECT
    'Tab4_Top10_Accounts'      AS Dataset,
    MonthEnd,
    AccountId                  AS Dim1,
    'Balance'                  AS Metric,
    Bal                        AS Value,
    SystemName                 AS Dim2
  FROM Tab4_TopAccounts
  WHERE rn <= 10
),

-- Top-5 concentration % (sum of top 5 balances / total non-accrual balance)
Tab4_Top5Conc AS (
  SELECT
    n.MonthEnd,
    SUM(n.Balance) AS TotalNA
  FROM NonAccrual n
  GROUP BY n.MonthEnd
),
Tab4_Top5Conc_Top AS (
  SELECT
    t.MonthEnd,
    SUM(t.Bal) AS Top5Bal
  FROM (
    SELECT
      n.MonthEnd,
      n.ACCOUNT_IDENTIFIER,
      SUM(n.Balance) AS Bal,
      ROW_NUMBER() OVER (PARTITION BY n.MonthEnd ORDER BY SUM(n.Balance) DESC) AS rn
    FROM NonAccrual n
    GROUP BY n.MonthEnd, n.ACCOUNT_IDENTIFIER
  ) t
  WHERE t.rn <= 5
  GROUP BY t.MonthEnd
),
Tab4_Top5Conc_Long AS (
  SELECT
    'Tab4_Top5_Concentration'   AS Dataset,
    c.MonthEnd                  AS MonthEnd,
    'Top5Pct'                   AS Dim1,
    'Percent'                   AS Metric,
    (tc.Top5Bal / NULLIF(c.TotalNA,0)) * 100.0 AS Value,
    CAST(NULL AS VARCHAR(100))                 AS Dim2
  FROM Tab4_Top5Conc c
  JOIN Tab4_Top5Conc_Top tc ON tc.MonthEnd = c.MonthEnd
),

/* ===================== TAB 5 – Anomaly Detection ===================== */
/* Replace <YOUR_ANOMALY_TABLE> and column names as needed. 
   Expect columns: EventDate (date or timestamp), Severity ('Critical'/'Warning'), System (optional). */

AnomalySrc AS (
  SELECT
    CAST(EventDate AS DATE)        AS EventDate,
    UPPER(TRIM(CAST(Severity AS VARCHAR(20)))) AS Severity,
    CAST(SystemName AS VARCHAR(100)) AS SystemName   -- optional; remove if not available
  FROM <YOUR_ANOMALY_TABLE>                           -- <<< TODO: set this
  WHERE EventDate IS NOT NULL
),
AnomalyByMonth AS (
  SELECT
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,  -- normalize to month-end
    CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END AS Sev,
    COUNT(*) AS Cnt
  FROM AnomalySrc
  GROUP BY ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1, 
           CASE WHEN Severity IN ('CRITICAL','WARNING') THEN Severity ELSE 'OTHER' END
),
Tab5_AnomalyTrend AS (
  SELECT
    'Tab5_Anomaly_Trend'     AS Dataset,
    MonthEnd                 AS MonthEnd,
    Sev                      AS Dim1,     -- 'CRITICAL' / 'WARNING' / 'OTHER'
    'Count'                  AS Metric,
    Cnt                      AS Value,
    CAST(NULL AS VARCHAR(100)) AS Dim2
  FROM AnomalyByMonth
),
-- Optional: latest anomaly table for a detail grid
Tab5_AnomalyTable AS (
  SELECT
    'Tab5_Anomaly_Table'     AS Dataset,
    ADD_MONTHS(DATE_TRUNC('month', EventDate), 1) - 1 AS MonthEnd,
    CAST(EventDate AS VARCHAR(30)) AS Dim1,   -- show actual datetime in the table
    'Count'                  AS Metric,
    1                        AS Value,
    Severity                 AS Dim2
  FROM AnomalySrc
  WHERE EventDate >= ADD_MONTHS(CURRENT_DATE, -3)   -- last 3 months (adjust)
)






/* ===== Last 12 months detail with derived System & Commitment ===== */
WITH bounds AS (
    SELECT AsOfMonthEnd = (SELECT MAX(m.LoadDate) FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly AS m)
),
win AS (
    SELECT AsOfMonthEnd, StartMonthEnd = DATEADD(MONTH, -11, AsOfMonthEnd)
    FROM bounds
)
SELECT
    LoadDate         = CONVERT(date, m.LoadDate),             -- month end (from Credit_Line_Monthly)
    ApplID           = m.ApplID,                              -- keep if present; drop if not
    CreditLineNumber = m.CreditLineNumber,
    SecUnfunded      = u.SecUnfunded,                         -- from Calculated_Unfunded
    NetUtilized      = m.NetUtilized,
    Commitment       = m.NetUtilized + u.SecUnfunded,
    System = CASE
                WHEN c.Cust_Line_Number IS NOT NULL           THEN 'Cards'          -- Cards first
                WHEN m.Source = 'CF'                          THEN 'CFD'
                WHEN m.CreditLineNumber LIKE '%iMX%'          THEN 'iMX'
                WHEN m.Source = 'LN'                          THEN 'CBS'
                WHEN m.Source = 'LO'                          THEN 'UBS'
                WHEN m.Source = 'LJ'                          THEN 'LJ'
                ELSE ISNULL(NULLIF(m.Source,''), 'Unknown')
             END
FROM CRDLMTUFCALC.dbo.Credit_Line_Monthly            AS m
JOIN CRDLMTUFCALC.dbo.Calculated_Unfunded            AS u
  ON u.CreditLineNumber = m.CreditLineNumber
 AND u.LoadDate         = m.LoadDate
LEFT JOIN crdadmprd.dbo.CDM_Cards_Loan               AS c
  ON c.Cust_Line_Number = m.CreditLineNumber
CROSS JOIN win w
WHERE m.LoadDate >= w.StartMonthEnd
  AND m.LoadDate <= w.AsOfMonthEnd
ORDER BY m.LoadDate, m.CreditLineNumber;
