WITH params AS (
  SELECT DATE '2025-09-30' AS this_eom, DATE '2025-08-31' AS prev_eom
),
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_ID,
    CAST(t.Exposure_Amount AS DECIMAL(18,2)) AS Exposure,
    t.RC_Code,
    t.PD_Grade,
    t.Industry_Code
  FROM dbo.Your_MonthEnd_Table t
  JOIN params p ON t.End_of_Month_Date IN (p.this_eom, p.prev_eom)
  WHERE t.Source_System_Balance > 0
),
kde_long AS (
  SELECT End_of_Month_Date, Account_ID, Exposure, 'RC_Code' AS KDE_NAME, CAST(RC_Code AS VARCHAR(50)) AS KDE_VALUE FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'PD_Grade',  CAST(PD_Grade AS VARCHAR(50))  FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'Industry_Code', CAST(Industry_Code AS VARCHAR(50)) FROM base
),
agg AS (
  SELECT
    End_of_Month_Date,
    KDE_NAME,
    COUNT(DISTINCT Account_ID) AS Cnt,
    SUM(Exposure) AS Exp
  FROM kde_long
  GROUP BY End_of_Month_Date, KDE_NAME
),
curr AS (
  SELECT a.* FROM agg a JOIN params p ON a.End_of_Month_Date = p.this_eom
),
prev AS (
  SELECT a.* FROM agg a JOIN params p ON a.End_of_Month_Date = p.prev_eom
),
joined AS (
  SELECT
    c.KDE_NAME,
    COALESCE(c.Cnt,0) AS Cnt_Curr,
    COALESCE(p.Cnt,0) AS Cnt_Prev,
    COALESCE(c.Exp,0) AS Exp_Curr,
    COALESCE(p.Exp,0) AS Exp_Prev
  FROM curr c
  FULL OUTER JOIN prev p ON c.KDE_NAME = p.KDE_NAME
),
summary AS (
  SELECT
    KDE_NAME,
    (Cnt_Curr - Cnt_Prev) AS Cnt_Change,
    CASE WHEN Cnt_Prev <> 0 THEN (Cnt_Curr - Cnt_Prev) / (Cnt_Prev * 1.0) END AS Cnt_Pct_Change,
    (Exp_Curr - Exp_Prev) AS Exp_Change,
    CASE WHEN Exp_Prev <> 0 THEN (Exp_Curr - Exp_Prev) / (Exp_Prev * 1.0) END AS Exp_Pct_Change
  FROM joined
)
SELECT
  KDE_NAME,
  Cnt_Change,
  Cnt_Pct_Change,
  Exp_Change,
  Exp_Pct_Change,
  RANK() OVER (ORDER BY ABS(Exp_Pct_Change) DESC) AS Rank_By_ExpVolatility
FROM summary
ORDER BY ABS(Exp_Pct_Change) DESC;





-- Simple KDE MoM change analysis (Netezza-safe)

WITH params AS (
  SELECT
    DATE '2025-09-30' AS this_eom,          -- target month end
    DATE '2025-08-31' AS prev_eom           -- prior month end
),
base AS (
  /* Replace schema.table + columns with your real source/fields.
     Required: End_of_Month_Date, Account_ID, Exposure_Amount, KDE columns.
     Optional: Source_System_Balance > 0 filter (stabilize MoM). */
  SELECT
    t.End_of_Month_Date,
    t.Account_ID,                                -- unique loan/instrument key
    CAST(t.Exposure_Amount AS DECIMAL(18,2)) AS Exposure,
    t.RC_Code,                                   -- KDE example 1
    t.PD_Grade,                                  -- KDE example 2
    t.Industry_Code,                             -- KDE example 3
    t.Source_System_Balance
  FROM dbo.Your_MonthEnd_Table t
  JOIN params p
    ON t.End_of_Month_Date IN (p.this_eom, p.prev_eom)
  WHERE t.Source_System_Balance > 0              -- optional; drop if not desired
),
kde_long AS (
  /* UNPIVOT via UNION ALL; CAST all KDEs to VARCHAR to normalize datatypes */
  SELECT End_of_Month_Date, Account_ID, Exposure, 'RC_Code'       AS KDE_NAME,
         CAST(RC_Code AS VARCHAR(100))       AS KDE_VALUE FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'PD_Grade'      AS KDE_NAME,
         CAST(PD_Grade AS VARCHAR(100))      AS KDE_VALUE FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'Industry_Code' AS KDE_NAME,
         CAST(Industry_Code AS VARCHAR(100)) AS KDE_VALUE FROM base
),
agg AS (
  SELECT
    End_of_Month_Date,
    KDE_NAME,
    KDE_VALUE,
    COUNT(DISTINCT Account_ID) AS Cnt,
    SUM(Exposure)              AS Exp
  FROM kde_long
  GROUP BY End_of_Month_Date, KDE_NAME, KDE_VALUE
),
curr AS (
  SELECT a.*
  FROM agg a JOIN params p ON a.End_of_Month_Date = p.this_eom
),
prev AS (
  SELECT a.*
  FROM agg a JOIN params p ON a.End_of_Month_Date = p.prev_eom
),
joined AS (
  SELECT
    COALESCE(c.KDE_NAME,  p.KDE_NAME)  AS KDE_NAME,
    COALESCE(c.KDE_VALUE, p.KDE_VALUE) AS KDE_VALUE,

    /* Current month */
    MAX(c.End_of_Month_Date) AS This_Month_End,
    COALESCE(MAX(c.Cnt), 0)  AS Cnt_Curr,
    COALESCE(MAX(c.Exp), 0)  AS Exp_Curr,

    /* Prior month */
    MAX(p.End_of_Month_Date) AS Prev_Month_End,
    COALESCE(MAX(p.Cnt), 0)  AS Cnt_Prev,
    COALESCE(MAX(p.Exp), 0)  AS Exp_Prev
  FROM curr c
  FULL OUTER JOIN prev p
    ON  c.KDE_NAME  = p.KDE_NAME
    AND c.KDE_VALUE = p.KDE_VALUE
  GROUP BY COALESCE(c.KDE_NAME, p.KDE_NAME),
           COALESCE(c.KDE_VALUE, p.KDE_VALUE)
),
metrics AS (
  SELECT
    KDE_NAME,
    KDE_VALUE,
    Prev_Month_End,
    This_Month_End,

    Cnt_Prev,
    Cnt_Curr,
    (Cnt_Curr - Cnt_Prev)                           AS Cnt_Delta,
    CASE WHEN Cnt_Prev <> 0
         THEN (Cnt_Curr - Cnt_Prev) * 1.0 / Cnt_Prev
         ELSE NULL
    END                                             AS Cnt_Pct_Change,

    CAST(Exp_Prev AS DECIMAL(18,2))                 AS Exp_Prev,
    CAST(Exp_Curr AS DECIMAL(18,2))                 AS Exp_Curr,
    CAST(Exp_Curr - Exp_Prev AS DECIMAL(18,2))      AS Exp_Delta,
    CASE WHEN Exp_Prev <> 0
         THEN (Exp_Curr - Exp_Prev) / (Exp_Prev * 1.0)
         ELSE NULL
    END                                             AS Exp_Pct_Change,

    /* For ranking: absolute % change on exposure */
    ABS(CASE WHEN Exp_Prev <> 0
             THEN (Exp_Curr - Exp_Prev) / (Exp_Prev * 1.0)
             ELSE NULL
        END)                                        AS Exp_Pct_Change_Abs,

    /* Helper to emulate NULLS LAST for DESC sorts */
    CASE WHEN
      ABS(CASE WHEN Exp_Prev <> 0
               THEN (Exp_Curr - Exp_Prev)/(Exp_Prev * 1.0)
               ELSE NULL END) IS NULL
    THEN 1 ELSE 0 END                               AS Exp_Pct_Change_IsNull
  FROM joined
)
SELECT
  KDE_NAME,
  KDE_VALUE,
  Prev_Month_End,
  This_Month_End,

  Cnt_Prev,
  Cnt_Curr,
  Cnt_Delta,
  Cnt_Pct_Change,

  Exp_Prev,
  Exp_Curr,
  Exp_Delta,
  Exp_Pct_Change,

  RANK() OVER (
    ORDER BY Exp_Pct_Change_IsNull ASC,       -- puts NULLs last
             Exp_Pct_Change_Abs DESC
  ) AS Rank_By_Abs_Exp_PctChange
FROM metrics
ORDER BY Exp_Pct_Change_IsNull ASC, Exp_Pct_Change_Abs DESC, KDE_NAME, KDE_VALUE;





kde_long AS (
  SELECT End_of_Month_Date, Account_ID, Exposure, 'RC_Code' AS KDE_NAME, 
         CAST(RC_Code AS VARCHAR(50)) AS KDE_VALUE 
  FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'PD_Grade' AS KDE_NAME, 
         CAST(PD_Grade AS VARCHAR(50)) AS KDE_VALUE 
  FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'Industry_Code' AS KDE_NAME, 
         CAST(Industry_Code AS VARCHAR(50)) AS KDE_VALUE 
  FROM base
),





-- Simple KDE MoM change analysis (Netezza)
-- How to use:
--   1) Set the two month-end dates in the params CTE (DATE 'YYYY-MM-DD')
--   2) Point `FROM` at your month-end table
--   3) List your KDE columns in the UNION ALL block (kde_long CTE)

WITH params AS (
  SELECT
    DATE '2025-09-30' AS this_eom,          -- target month end
    DATE '2025-08-31' AS prev_eom           -- prior month end
),
base AS (
  /* Replace dbo.Your_MonthEnd_Table + columns with your real source/fields.
     Required cols: End_of_Month_Date, Account_ID, Exposure, KDE columns.
     Optional filter: Source_System_Balance > 0 (stabilize MoM) */
  SELECT
    t.End_of_Month_Date,
    t.Account_ID,                               -- unique loan/instrument key
    CAST(t.Exposure_Amount AS DECIMAL(18,2)) AS Exposure,
    t.RC_Code,                                  -- KDE example 1
    t.PD_Grade,                                 -- KDE example 2
    t.Industry_Code,                            -- KDE example 3
    t.Source_System_Balance
  FROM dbo.Your_MonthEnd_Table t
  JOIN params p
    ON t.End_of_Month_Date IN (p.this_eom, p.prev_eom)
  WHERE t.Source_System_Balance > 0             -- optional; remove if not desired
),
kde_long AS (
  /* UNPIVOT via UNION ALL (Netezza-safe) — add/remove KDEs as needed */
  SELECT End_of_Month_Date, Account_ID, Exposure, 'RC_Code'       AS KDE_NAME, RC_Code       AS KDE_VALUE FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'PD_Grade'      AS KDE_NAME, PD_Grade      AS KDE_VALUE FROM base
  UNION ALL
  SELECT End_of_Month_Date, Account_ID, Exposure, 'Industry_Code' AS KDE_NAME, Industry_Code AS KDE_VALUE FROM base
),
agg AS (
  /* Aggregate by month + KDE */
  SELECT
    End_of_Month_Date,
    KDE_NAME,
    KDE_VALUE,
    COUNT(DISTINCT Account_ID)       AS Cnt,
    SUM(Exposure)                    AS Exp
  FROM kde_long
  GROUP BY End_of_Month_Date, KDE_NAME, KDE_VALUE
),
split AS (
  /* Split into current vs prior sets for an easy FULL OUTER JOIN */
  SELECT a.* FROM agg a JOIN params p ON a.End_of_Month_Date = p.this_eom
),
split_prev AS (
  SELECT a.* FROM agg a JOIN params p ON a.End_of_Month_Date = p.prev_eom
),
joined AS (
  SELECT
    COALESCE(c.KDE_NAME,  p.KDE_NAME)  AS KDE_NAME,
    COALESCE(c.KDE_VALUE, p.KDE_VALUE) AS KDE_VALUE,

    /* Current month */
    MAX(CASE WHEN c.End_of_Month_Date IS NOT NULL THEN c.End_of_Month_Date END) AS This_Month_End,
    COALESCE(c.Cnt, 0) AS Cnt_Curr,
    COALESCE(c.Exp, 0) AS Exp_Curr,

    /* Prior month */
    MAX(CASE WHEN p.End_of_Month_Date IS NOT NULL THEN p.End_of_Month_Date END) AS Prev_Month_End,
    COALESCE(p.Cnt, 0) AS Cnt_Prev,
    COALESCE(p.Exp, 0) AS Exp_Prev
  FROM split c
  FULL OUTER JOIN split_prev p
    ON  c.KDE_NAME  = p.KDE_NAME
    AND c.KDE_VALUE = p.KDE_VALUE
  GROUP BY
    COALESCE(c.KDE_NAME,  p.KDE_NAME),
    COALESCE(c.KDE_VALUE, p.KDE_VALUE),
    COALESCE(c.Cnt, 0), COALESCE(c.Exp, 0),
    COALESCE(p.Cnt, 0), COALESCE(p.Exp, 0)
),
metrics AS (
  SELECT
    KDE_NAME,
    KDE_VALUE,
    Prev_Month_End,
    This_Month_End,

    Cnt_Prev,
    Cnt_Curr,
    (Cnt_Curr - Cnt_Prev)                                  AS Cnt_Delta,
    CASE WHEN Cnt_Prev <> 0
         THEN (Cnt_Curr - Cnt_Prev) * 1.0 / Cnt_Prev
         ELSE NULL
    END                                                    AS Cnt_Pct_Change,

    CAST(Exp_Prev AS DECIMAL(18,2))                        AS Exp_Prev,
    CAST(Exp_Curr AS DECIMAL(18,2))                        AS Exp_Curr,
    CAST(Exp_Curr - Exp_Prev AS DECIMAL(18,2))             AS Exp_Delta,
    CASE WHEN Exp_Prev <> 0
         THEN (Exp_Curr - Exp_Prev) / Exp_Prev
         ELSE NULL
    END                                                    AS Exp_Pct_Change,

    /* For ranking: absolute % change on exposure (tweak if you prefer count) */
    ABS(CASE WHEN Exp_Prev <> 0
             THEN (Exp_Curr - Exp_Prev) / Exp_Prev
             ELSE NULL
        END)                                               AS Exp_Pct_Change_Abs
  FROM joined
)
SELECT
  KDE_NAME,
  KDE_VALUE,
  Prev_Month_End,
  This_Month_End,

  Cnt_Prev,
  Cnt_Curr,
  Cnt_Delta,
  Cnt_Pct_Change,

  Exp_Prev,
  Exp_Curr,
  Exp_Delta,
  Exp_Pct_Change,

  RANK() OVER (ORDER BY Exp_Pct_Change_Abs DESC NULLS LAST) AS Rank_By_Abs_Exp_%Change
FROM metrics
-- Optional: limit to “material” changes
-- WHERE (Exp_Pct_Change IS NULL OR ABS(Exp_Pct_Change) >= 0.05)
ORDER BY Exp_Pct_Change_Abs DESC NULLS LAST, KDE_NAME, KDE_VALUE;




Portfolio_R2_Avg :=
VAR eom = MAX ( 'Date'[MonthEnd] )
VAR base =
    FILTER (
        ADDCOLUMNS (
            -- pick the grain you compute R2 at (KDE, segment, model id, etc.)
            SUMMARIZE ( ALLSELECTED ( T ), T[KDE_Name] ),
            "R2m",
                CALCULATE ( [R2], KEEPFILTERS ( T[End_of_Month_Date] = eom ) )
        ),
        NOT ISBLANK ( [R2m] )
    )
RETURN
COALESCE ( AVERAGEX ( base, [R2m] ), 0 )




-- PARAMETERS
-- change the date literal to your target EOM
WITH
base AS (
  SELECT
      a.End_of_Month_Date      AS EOM,
      a.Account_Key,
      a.Contract_Source_System AS Source_System,
      a.Portfolio_Type,
      a.RC_Code,
      a.KDE_Name,
      a.Current_Value,
      a.Prior_Value,
      (a.Current_Value - a.Prior_Value) AS Variance,
      a.Anomaly_Flag,
      a.Severity_0_100
  FROM ANOMALY_OUT a
  WHERE a.End_of_Month_Date = DATE '2025-09-30'  -- << set EOM
),
event_map AS (
  SELECT
      e.Account_Key,
      CASE
        WHEN e.Event_Type IN ('CHARGEOFF','CO') THEN 'ChargeOff'
        WHEN e.Event_Type IN ('PAYOFF','PO')    THEN 'Payoff'
        WHEN e.Event_Type IN ('DOWNGRADE')      THEN 'Rating_Downgrade'
        WHEN e.Event_Type IN ('UPGRADE')        THEN 'Rating_Upgrade'
        ELSE 'Other_Credit_Event'
      END AS Event_Bucket
  FROM EVENTS_CREDIT e
  WHERE DATE_TRUNC('month', e.Event_Date) = DATE '2025-09-01'   -- month of EOM
  GROUP BY e.Account_Key,
           CASE
             WHEN e.Event_Type IN ('CHARGEOFF','CO') THEN 'ChargeOff'
             WHEN e.Event_Type IN ('PAYOFF','PO')    THEN 'Payoff'
             WHEN e.Event_Type IN ('DOWNGRADE')      THEN 'Rating_Downgrade'
             WHEN e.Event_Type IN ('UPGRADE')        THEN 'Rating_Upgrade'
             ELSE 'Other_Credit_Event'
           END
),
topside_map AS (
  SELECT DISTINCT Account_Key, 1 AS Is_Topside
  FROM TOPSIDE_LEDGER
  WHERE As_Of_EOM = DATE '2025-09-30'
),
timing_map AS (
  SELECT
      s.Account_Key,
      s.Source_System,
      CASE
        WHEN DATE(MAX(s.Last_Update_Timestamp)) > DATE '2025-09-30' THEN 1 ELSE 0
      END AS Post_Close_Update
  FROM SYSTEM_TIMESTAMPS s
  GROUP BY s.Account_Key, s.Source_System
),
compose AS (
  SELECT
      b.EOM, b.Portfolio_Type, b.RC_Code, b.KDE_Name, b.Source_System, b.Account_Key,
      b.Variance, b.Anomaly_Flag, b.Severity_0_100,
      COALESCE(em.Event_Bucket,'No_Credit_Event') AS Event_Bucket,
      COALESCE(tm.Post_Close_Update,0)            AS Post_Close_Update,
      COALESCE(t.Is_Topside,0)                    AS Is_Topside
  FROM base b
  LEFT JOIN event_map  em ON em.Account_Key = b.Account_Key
  LEFT JOIN timing_map tm ON tm.Account_Key = b.Account_Key AND tm.Source_System = b.Source_System
  LEFT JOIN topside_map t ON t.Account_Key  = b.Account_Key
)
SELECT
    EOM,
    Portfolio_Type,
    RC_Code,
    KDE_Name,
    Source_System,
    Event_Bucket,
    CASE
      WHEN Is_Topside=1 THEN 'Topside'
      WHEN Post_Close_Update=1 THEN 'Timing/Data'
      ELSE 'None'
    END AS Data_System_Driver,
    SUM(Variance) AS Variance_Sum,
    SUM(ABS(Variance)) AS Variance_AbsSum,
    SUM(CASE WHEN Anomaly_Flag=1 THEN ABS(Variance) ELSE 0 END) AS Anom_Abs_Variance,
    AVG(Severity_0_100) AS Avg_Severity,
    SUM(CASE WHEN Anomaly_Flag=1 THEN 1 ELSE 0 END) AS Count_Anomalies,
    COUNT(DISTINCT Account_Key) AS Accounts_Count
FROM compose
GROUP BY 1,2,3,4,5,6,7
ORDER BY ABS(SUM(Variance)) DESC;



-- Netezza / ANSI
SELECT
  KDE_Name,
  AVG(CASE WHEN Anomaly_Flag=1 THEN (Current_Value - Prior_Value) END) AS Avg_Delta_Anom,
  AVG(CASE WHEN Anomaly_Flag=0 THEN (Current_Value - Prior_Value) END) AS Avg_Delta_Norm,
  (AVG(CASE WHEN Anomaly_Flag=1 THEN (Current_Value - Prior_Value) END)
   - AVG(CASE WHEN Anomaly_Flag=0 THEN (Current_Value - Prior_Value) END)) AS Peer_Diff
FROM ANOMALY_OUT
WHERE End_of_Month_Date = DATE '2025-09-30'
GROUP BY KDE_Name
ORDER BY ABS(
  (AVG(CASE WHEN Anomaly_Flag=1 THEN (Current_Value - Prior_Value) END)
   - AVG(CASE WHEN Anomaly_Flag=0 THEN (Current_Value - Prior_Value) END))
) DESC;




-- Netezza / ANSI; run after the first CTE block if you want precise mapping,
-- or reuse ANOMALY_OUT + EVENTS/Topside as shown
WITH drivers AS (
  /* paste the 'compose' CTE from the big query, or simplify: */
  SELECT
      a.Account_Key,
      (a.Current_Value - a.Prior_Value) AS Variance,
      CASE
        WHEN t.Account_Key IS NOT NULL THEN 'Topside'
        WHEN CAST(s.Last_Update_Timestamp AS DATE) > DATE '2025-09-30' THEN 'Timing/Data'
        ELSE 'None'
      END AS Data_System_Driver,
      CASE
        WHEN e.Event_Type IN ('PAYOFF','PO') THEN 'Payoffs'
        WHEN e.Event_Type IN ('CHARGEOFF','CO') THEN 'ChargeOffs'
        WHEN e.Event_Type='DOWNGRADE' THEN 'Rating_Downgrades'
        WHEN e.Event_Type='UPGRADE'   THEN 'Rating_Upgrades'
        ELSE 'Other'
      END AS Event_Driver
  FROM ANOMALY_OUT a
  LEFT JOIN TOPSIDE_LEDGER t ON t.Account_Key=a.Account_Key AND t.As_Of_EOM=DATE '2025-09-30'
  LEFT JOIN SYSTEM_TIMESTAMPS s ON s.Account_Key=a.Account_Key AND s.Source_System=a.Contract_Source_System
  LEFT JOIN EVENTS_CREDIT e ON e.Account_Key=a.Account_Key
    AND DATE_TRUNC('month', e.Event_Date)=DATE '2025-09-01'
  WHERE a.End_of_Month_Date=DATE '2025-09-30'
)
SELECT Driver, SUM(Variance) AS Impact
FROM (
  SELECT Event_Driver AS Driver, Variance FROM drivers
  UNION ALL SELECT 'Topside_Adjustments', Variance FROM drivers WHERE Data_System_Driver='Topside'
  UNION ALL SELECT 'Timing/Data', Variance FROM drivers WHERE Data_System_Driver='Timing/Data'
) x
GROUP BY Driver
ORDER BY ABS(SUM(Variance)) DESC;









Portfolio_R2_Latest =
VAR lm       = EOMONTH ( MAX ( T[Month_End] ), 0 )
VAR winStart = EOMONTH ( lm, -11 )

/* Keep only RCs with at least 2 months in the window */
VAR RC_Eligible =
    FILTER (
        VALUES ( T[RC_CODE] ),
        CALCULATE (
            DISTINCTCOUNT ( T[Month_End] ),
            REMOVEFILTERS ( T[Month_End] ),
            T[Month_End] >= winStart, T[Month_End] <= lm
        ) >= 2
    )

/* Sum SSE and SST per RC, then pool */
VAR SSE_Sum =
    SUMX (
        RC_Eligible,
        CALCULATE (
            SUMX ( T, ( T[Actual] - T[Forecast_Selected] ) ^ 2 ),
            REMOVEFILTERS ( T[Month_End] ),
            T[Month_End] >= winStart, T[Month_End] <= lm
        )
    )

VAR SST_Sum =
    SUMX (
        RC_Eligible,
        CALCULATE (
            VAR mu = AVERAGE ( T[Actual] )
            RETURN SUMX ( T, ( T[Actual] - mu ) ^ 2 ),
            REMOVEFILTERS ( T[Month_End] ),
            T[Month_End] >= winStart, T[Month_End] <= lm
        )
    )

RETURN
IF ( SST_Sum = 0, BLANK(), 1 - DIVIDE ( SSE_Sum, SST_Sum ) )




Portfolio_R2_Latest =
VAR lm       = EOMONTH ( MAX ( T[Month_End] ), 0 )
VAR winStart = EOMONTH ( lm, -11 )
RETURN
AVERAGEX (
    VALUES ( T[RC_CODE] ),
    CALCULATE (
        [R2],                                  -- your existing R2 measure
        FILTER (
            ALL ( T[Month_End] ),              -- remove month filter, then apply window
            T[Month_End] >= winStart
                && T[Month_End] <= lm
        )
    )
)



Portfolio_R2_Latest =
VAR lm       = EOMONTH ( MAX ( T[Month_End] ), 0 )
VAR winStart = EOMONTH ( lm, -11 )
RETURN
AVERAGEX (
    VALUES ( T[RC_CODE] ),
    CALCULATE (
        [R2],
        REMOVEFILTERS ( T[Month_End] ),
        T[Month_End] >= winStart,
        T[Month_End] <= lm
    )
)









=LET(
  /* weights */
  wZ, W_ZResid, wPeer, W_ZPeer, wAbs, W_PctAbs, wMoM, W_ZMoM,
  Wtot, wZ+wPeer+wAbs+wMoM + (wZ+wPeer+wAbs+wMoM=0),

  /* terms */
  zTerm,     wZ   * ABS(IFERROR([@Z_Resid],0)),
  peerTerm,  wPeer* ABS(IFERROR([@Z_Peer],0)),
  absTerm,   wAbs * IFERROR([@PctRank_AbsResid_Month],
                     /* fallback: compute rank within LatestMonth if your column is missing */
                     IFERROR(PERCENTRANK.INC(IF(T[Month_End]=LatestMonth, T[AbsResid]), [@AbsResid]), 0)
           ),
  momTerm,   wMoM * ABS(IFERROR([@Z_MoM_Abs],0)),

  raw, (zTerm + peerTerm + absTerm + momTerm) / Wtot,
  ROUND(100*(1-EXP(-raw)),0)
)


=--([@Severity_Core] >= FlagThreshold)


=LET(
  rc, [@RC_CODE],
  me, [@Month_End],
  look, PersistLookback,                /* named cell, e.g., 3 */
  start, EDATE(me, -(look-1)),
  num, SUMIFS(T[Flag_Anom_Core], T[RC_CODE], rc, T[Month_End], ">="&start, T[Month_End], "<="&me),
  den, COUNTIFS(T[RC_CODE], rc, T[Month_End], ">="&start, T[Month_End], "<="&me),
  IF(den=0, 0, num/den)
)


=LET(
  wZ, W_ZResid, wPeer, W_ZPeer, wAbs, W_PctAbs, wMoM, W_ZMoM, wPers, W_Persist,
  Wtot, wZ+wPeer+wAbs+wMoM+wPers + (wZ+wPeer+wAbs+wMoM+wPers=0),

  raw, (
        wZ   * ABS(IFERROR([@Z_Resid],0)) +
        wPeer* ABS(IFERROR([@Z_Peer],0)) +
        wAbs * IFERROR([@PctRank_AbsResid_Month],
                       IFERROR(PERCENTRANK.INC(IF(T[Month_End]=LatestMonth, T[AbsResid]), [@AbsResid]), 0)) +
        wMoM * ABS(IFERROR([@Z_MoM_Abs],0)) +
        wPers* IFERROR([@Persist_3m],0)
       ) / Wtot,

  ROUND(100*(1-EXP(-raw)),0)
)


=--([@Severity_Final_v5] >= FlagThreshold)









=LET(
  lm, LatestMonth,
  wZ, W_ZResid, wMZ, W_ZMoM, wA, W_Abs, wMA, W_MoMAbs,
  Wtot, wZ+wMZ+wA+wMA + (wZ+wMZ+wA+wMA=0),

  /* latest-month ranks without FILTER (avoids empty spills) */
  vecAbs, IF(T[Month_End]=lm, T[AbsResid]),
  vecMoM, IF(T[Month_End]=lm, T[MoM_Abs]),
  nLM,   SUM(--(T[Month_End]=lm)),
  rAbs,  IF(nLM=0, 0, IFERROR(PERCENTRANK.INC(vecAbs, [@AbsResid]), 0)),
  rMoM,  IF(nLM=0, 0, IFERROR(PERCENTRANK.INC(vecMoM, [@MoM_Abs]), 0)),

  raw, ( wZ*ABS(IFERROR([@Z_Resid],0))
       + wMZ*ABS(IFERROR([@Z_MoM_Abs],0))
       + wA*rAbs
       + wMA*rMoM ) / Wtot,

  ROUND(100*(1-EXP(-raw)),0)
)



=--([@Severity_Core] >= FlagThreshold)


=LET(
  rc, [@RC_CODE],
  me, [@Month_End],
  look, PersistLookback,                 /* e.g., 3; or hardcode 3 */
  start, EDATE(me, -(look-1)),
  num, SUMIFS(T[Flag_Anom_Core], T[RC_CODE], rc, T[Month_End], ">="&start, T[Month_End], "<="&me),
  den, COUNTIFS(T[RC_CODE], rc, T[Month_End], ">="&start, T[Month_End], "<="&me),
  IF(den=0, 0, num/den)
)


=LET(
  boost, PersistBoost,           /* e.g., 15; or hardcode 15 */
  MIN(100, ROUND([@Severity_Core] + boost*[@Persist_3m], 0))
)


=LET(
  mult, 1 + 0.25*[@Persist_3m],         /* up to +25% */
  MIN(100, ROUND([@Severity_Core]*mult, 0))
)


=--([@Severity_Final] >= FlagThreshold)





/* Base helpers */
Total Exposure $ := SUM ( T[Actual] )
Residual := SUMX ( T, T[Actual] - T[Forecast_Selected] )      -- context-aware
Residual^2 := SUMX ( T, (T[Actual]-T[Forecast_Selected])^2 )  -- context-aware

/* Per-context RMSE, MAE, Bias */
RMSE :=
VAR n = COUNTROWS ( T )
RETURN IF ( n = 0, BLANK(), SQRT ( [Residual^2] / n ) )

MAE :=
VAR n = COUNTROWS ( T )
VAR s = SUMX ( T, ABS ( T[Actual]-T[Forecast_Selected] ) )
RETURN DIVIDE ( s, n )

Bias (Mean Residual) :=
VAR n = COUNTROWS ( T )
RETURN DIVIDE ( [Residual], n )

/* Portfolio-style R² in current filter context (RC or portfolio, over selected time window) */
R2 :=
VAR mu  = AVERAGE ( T[Actual] )
VAR SSE = [Residual^2]
VAR SST = SUMX ( T, ( T[Actual] - mu )^2 )
RETURN IF ( SST = 0, BLANK(), 1 - DIVIDE ( SSE, SST ) )

/* MAPE excluding zero Actuals */
MAPE % :=
VAR tbl =
    FILTER ( T, NOT ISBLANK ( T[Actual] ) && T[Actual] <> 0 )
VAR n = COUNTROWS ( tbl )
VAR s = SUMX ( tbl, ABS ( ( T[Actual]-T[Forecast_Selected] ) / T[Actual] ) )
RETURN DIVIDE ( s, n )



/* Average of per-RC R² in the current time window */
Avg R2 by RC :=
AVERAGEX ( VALUES ( T[RC_CODE] ), [R2] )

/* Exposure-weighted RMSE over RCs (optional) */
Weighted RMSE :=
VAR byRC =
    ADDCOLUMNS (
        VALUES ( T[RC_CODE] ),
        "rmse", [RMSE],
        "w", CALCULATE ( [Total Exposure $] )
    )
VAR num = SUMX ( byRC, [rmse] * [w] )
VAR den = SUMX ( byRC, [w] )
RETURN DIVIDE ( num, den )

/* Latest-month exposure for the selected RC (for scatter size or tooltips) */
Latest Month := MAX ( T[Month_End] )

Latest Exposure $ (for RC) :=
VAR lm = [Latest Month]
RETURN CALCULATE ( [Total Exposure $], T[Month_End] = lm )






MoM % :=
VAR curMonth = MAX ( T[Month_End] )
VAR prevVal  =
    CALCULATE (
        [Total Exposure $],
        FILTER ( ALL ( T[Month_End] ), T[Month_End] = EOMONTH ( curMonth, -1 ) )
    )
RETURN
DIVIDE ( [Total Exposure $] - prevVal, prevVal )


Severity Delta :=
VAR curMonth = MAX ( T[Month_End] )
VAR prevSev  =
    CALCULATE (
        [Severity (Avg)],
        FILTER ( ALL ( T[Month_End] ), T[Month_End] = EOMONTH ( curMonth, -1 ) )
    )
RETURN
[Severity (Avg)] - prevSev


Flag Change :=
VAR curMonth = MAX ( T[Month_End] )
VAR curFlag  = [Current Flag]     -- 0 or 1
VAR prevFlag =
    CALCULATE (
        MAX ( T[Flag_Anom] ),
        FILTER ( ALL ( T[Month_End] ), T[Month_End] = EOMONTH ( curMonth, -1 ) )
    )
RETURN
SWITCH (
    TRUE(),
    curFlag = 1 && prevFlag = 0, "🆕 New Flag",
    curFlag = 0 && prevFlag = 1, "✅ Cleared",
    curFlag = 1 && prevFlag = 1, "↔ Still Flagged",
    "—"
)

Indicator Tag (Current) :=
SELECTEDVALUE ( T[Indicator_Tag], "—" )

Indicator Tag (Latest) :=
VAR lm =
    CALCULATE ( MAX ( T[Month_End] ), ALLEXCEPT ( T, T[RC_CODE] ) )
RETURN
CALCULATE ( SELECTEDVALUE ( T[Indicator_Tag], "—" ), T[Month_End] = lm )










Metrics_Definitions =
DATATABLE (
    "Metric", STRING,
    "Definition", STRING,
    "Calc_Type", STRING,
    "Formula_Text", STRING,
    "Unit", STRING,
{
    { "Actual", "Recorded month-end balance for the RC_Code.", "Column", "T[Actual]", "$" },
    { "Forecast_Selected", "Chosen forecast after model & seasonality selection.", "Column/Calc", "Selected model (REG12/REG36/MA6/MA12) × seasonal lift.", "$" },
    { "Residual", "Difference between Actual and Forecast.", "Row Calc", "Actual − Forecast_Selected", "$" },
    { "AbsResid", "Magnitude of the residual.", "Row Calc", "ABS(Residual)", "$" },
    { "MoM_Abs", "Month-over-month absolute change in balance.", "Row Calc", "ABS(Actual − Prev_Month_Actual)", "$" },
    { "MoM_Pct_Abs", "Absolute % change vs prior month.", "Row Calc", "ABS((Actual − Prev)/Prev)", "%" },
    { "Z_Resid", "Standardized residual vs own history.", "Window Stat", "(AbsResid − mean_abs_resid) / sd_abs_resid", "Z" },
    { "Z_MoM_Abs", "Standardized MoM $ change vs own history.", "Window Stat", "(MoM_Abs − mean_mom_abs) / sd_mom_abs", "Z" },
    { "Z_MoM_Pct", "Standardized MoM % change vs own history.", "Window Stat", "(MoM_Pct_Abs − mean_mom_pct) / sd_mom_pct", "Z" },

    { "Severity_Raw", "Weighted signal combining Z-scores and $ impact.", "Row Calc",
      "0.65*|Z_Resid| + 0.07*|Z_MoM_Abs| + 0.25*RankLM(AbsResid) + 0.03*RankLM(MoM_Abs)", "unitless" },

    { "Severity_0_100_v5", "0–100 nonlinear scaling of Severity_Raw.", "Row Calc",
      "ROUND(100*(1 − EXP(−Severity_Raw)),0)", "0–100" },

    { "Flag_Anom", "Anomaly flag for latest month (severity above threshold).", "Row Flag",
      "IF(Severity_0_100_v5 ≥ Threshold, 1, 0)", "0/1" },

    { "Persist_3m", "Share of last N months flagged (recurrence).", "Cohort Stat",
      "AVG(Flag_Anom over last N months)", "0–1" },

    { "Latest_Exposure", "Actual balance for the latest month.", "Agg (Latest)",
      "SUMX( rows where Month_End = MAX(Month_End), Actual )", "$" },

    { "Portfolio R²", "Fit quality: variance explained by forecasts.", "Portfolio Stat",
      "1 − SSE/SST; SSE=Σ(Act−Fcst)², SST=Σ(Act−mean(Act))²", "0–1" },

    { "RMSE", "Root mean square error (typical $ forecast error).", "Stat",
      "SQRT( AVG( (Act−Fcst)² ) )", "$" },

    { "MAE", "Mean absolute error (typical |$| error).", "Stat",
      "AVG( ABS(Act−Fcst) )", "$" },

    { "MAPE", "Mean absolute % error (scale-independent).", "Stat",
      "AVG( ABS((Act−Fcst)/Act) ), ignoring Act=0", "%" },

    { "Bias (Mean Residual)", "Average signed error (over/under-forecast).", "Stat",
      "AVG( Act−Fcst )", "$" },

    { "Best_Model", "Model picked per RC based on fit rules.", "Label",
      "Argmin(RMSE) with R² guardrails → REG12/REG36/MA6/MA12", "-" },

    { "Seasonal Lift (lift_final)", "Quarterly adjustment damped for spikes.", "Window Calc",
      "Capped & shrunk quarter lift; extra damp if recent spikes.", "multiplier" },

    { "Flagged Exposure %", "Share of exposure in flagged RCs (latest).", "Portfolio KPI",
      "SUM(Actual where Severity≥Thr) / SUM(Actual)", "%" },

    { "Severity_Category", "Bucketed bands for communication.", "Label",
      "Low<40, Moderate 40–69, High 70–84, Critical 85+", "-" }
})





Flow_Steps =
DATATABLE (
    "Step_ID", INTEGER,
    "Step_Label", STRING,
    "Step_Description", STRING,
    "Icon", STRING,
    {
        { 1, "Detect Anomalies", "Identify RC_Codes or systems with unusual changes.", "🔍" },
        { 2, "Rank Severity", "Rank anomalies based on severity score (0–100).", "⚖️" },
        { 3, "Investigate RC_Code", "Drill into RC_Code details and variance metrics.", "🧩" },
        { 4, "Drill to Accounts", "Analyze top accounts driving residuals.", "📊" },
        { 5, "Tag Cause", "Assign likely cause (structural change, timing, etc.)", "🏷️" },
        { 6, "Report Summary", "Summarize findings and portfolio impact.", "📈" }
    }
)




=AVERAGEIFS(T[AbsResid], T[RC_CODE], [@RC_CODE])

=LET(rc,[@RC_CODE], IFERROR( AVERAGEIFS(T[Resid], T[RC_CODE], rc), 0 ))

=LET(
  rc,[@RC_CODE],
  ybar, SUMIFS(T[Actual],T[RC_CODE],rc) / COUNTIFS(T[RC_CODE],rc),
  sse,  SUMPRODUCT( (T[RC_CODE]=rc) * (T[Actual]-T[Forecast_Selected])^2 ),
  sst,  SUMPRODUCT( (T[RC_CODE]=rc) * (T[Actual]-ybar)^2 ),
  IF(sst=0,0,1 - sse/sst)
)

=LET(
  rc,[@RC_CODE],
  n, COUNTIFS(T[RC_CODE],rc),
  IF(n=0,0, SQRT( SUMPRODUCT((T[RC_CODE]=rc)*(T[Actual]-T[Forecast_Selected])^2) / n ))
)

=LET(rc,[@RC_CODE], IFERROR( AVERAGEIFS(ABS(T[Actual]-T[Forecast_Selected]), T[RC_CODE], rc), 0 ))


=LET(rc,[@RC_CODE], IFERROR( AVERAGEIFS(T[Resid], T[RC_CODE], rc), 0 ))


=LET(rc,[@RC_CODE], STDEV.S( IF(T[RC_CODE]=rc, T[Resid]) ))






=LET(rc,[@RC_CODE],
y,FILTER(T[Actual],T[RC_CODE]=rc),
yhat,FILTER(T[Forecast_Selected],T[RC_CODE]=rc),
ybar,AVERAGE(y),
SSE,SUMPRODUCT((y-yhat)^2),
SST,SUMPRODUCT((y-ybar)^2),
IF(SST=0,0,1-SSE/SST))

=SUMPRODUCT(Summary[R2_per_RC],Summary[Latest_Exposure]) / SUM(Summary[Latest_Exposure])

=COUNTIF(Summary[R2_per_RC],"<0.5")/COUNTA(Summary[R2_per_RC])





=1 - (SUMXMY2(T[Actual],T[Forecast_Selected]) / SUMPRODUCT((T[Actual]-AVERAGE(T[Actual]))^2))

=LET(
lm,$H$2,
Amean,SUMIFS(T[Actual],T[Month_End],lm)/COUNTIFS(T[Month_End],lm),
SSE,SUMPRODUCT((T[Month_End]=lm)*(T[Actual]-T[Forecast_Selected])^2),
SST,SUMPRODUCT((T[Month_End]=lm)*(T[Actual]-Amean)^2),
IF(SST=0,0,1 - SSE/SST)
)

=SQRT( SUMXMY2(T[Actual],T[Forecast_Selected]) / COUNT(T[Actual]) )


=LET(lm,$H$2, SQRT(SUMPRODUCT((T[Month_End]=lm)*(T[Actual]-T[Forecast_Selected])^2) / COUNTIFS(T[Month_End],lm)))

=AVERAGE(ABS(T[Actual]-T[Forecast_Selected]))

=AVERAGEIFS(ABS(T[Actual]-T[Forecast_Selected]), T[Month_End], $H$2)

=AVERAGE(IFERROR(ABS((T[Actual]-T[Forecast_Selected])/T[Actual]),NA()))


=AVERAGE(T[Actual]-T[Forecast_Selected])


=STDEV.S(T[Actual]-T[Forecast_Selected])







=SUMIFS(T[Actual], T[Month_End], $H$2, T[Severity_0_100], ">=70")



=COUNTIFS(T[Month_End],$H$2,T[Severity_0_100],">=70") / COUNTIFS(T[Month_End],$H$2)



=IFERROR(
  SUMIFS(T[Severity_0_100_v5], T[month_end],$H$2, T[Include3_AnyPos],1, T[Severity_0_100_v5],">=",70)
/ COUNTIFS(T[month_end],$H$2, T[Include3_AnyPos],1)
,0)

=SUMIFS(T[Actual], T[month_end],$H$2, T[Include3_AnyPos],1, T[Severity_0_100_v5],">=",70)


=MEDIAN(IF((T[month_end]=$H$2)*(T[Include3_AnyPos]=1), T[AbsResid]))