/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),





Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] )
- AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )


Band_Height (Per RC) :=
VAR rc = SELECTEDVALUE ( 'RC_Code_Model_Base'[RC_CODE] )
RETURN
CALCULATE(
    AVERAGE ( 'RC_Code_Model_Base'[PI_Hi] ) - AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] ),
    KEEPFILTERS ( 'RC_Code_Model_Base'[RC_CODE] = rc )
)








Band_Base :=
AVERAGE ( 'RC_Code_Model_Base'[PI_Lo] )

Band_Height :=
AVERAGEX (
    'RC_Code_Model_Base',
    VAR hi = 'RC_Code_Model_Base'[PI_Hi]
    VAR lo = 'RC_Code_Model_Base'[PI_Lo]
    RETURN IF ( NOT ( ISBLANK ( hi ) || ISBLANK ( lo ) ), hi - lo )
)





Dynamic Y Min :=
VAR lo =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Lo]
    )
VAR act =
    MINX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MIN(lo, act)


Dynamic Y Max :=
VAR hi =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[PI_Hi]
    )
VAR act =
    MAXX(
        ALLSELECTED('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[bal_num]
    )
RETURN
MAX(hi, act)








R2_Scatter =
VAR SS_Total =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLSELECTED ( RC_Code_Model_Base ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        ALLSELECTED ( RC_Code_Model_Base ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )



R2_By_Model =
VAR SS_Total =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Actual] ) ),
        POWER ( [Actual] - CALCULATE ( AVERAGE ( [Actual] ), ALLEXCEPT ( RC_Code_Model_Base, RC_Code_Model_Base[RC_Code], RC_Code_Model_Base[Model_Type] ) ), 2 )
    )
VAR SS_Residual =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
1 - DIVIDE ( SS_Residual, SS_Total )


RMSE_By_Model =
VAR Count_Obs =
    COUNTROWS ( FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ) )
VAR Sum_Squared_Errors =
    SUMX (
        FILTER ( RC_Code_Model_Base, NOT ISBLANK ( [Predicted] ) ),
        POWER ( [Actual] - [Predicted], 2 )
    )
RETURN
SQRT ( DIVIDE ( Sum_Squared_Errors, Count_Obs ) )











Avg MoM % Abs (3M) :=
VAR currentMonth = MAX('RC_Code_Model_Base'[month_end])
RETURN
AVERAGEX(
    FILTER(
        ALL('RC_Code_Model_Base'),
        'RC_Code_Model_Base'[RC_CODE] = SELECTEDVALUE('RC_Code_Model_Base'[RC_CODE])
        && 'RC_Code_Model_Base'[month_end] <= currentMonth
        && 'RC_Code_Model_Base'[month_end] > EDATE(currentMonth, -3)
    ),
    'RC_Code_Model_Base'[MoM_Pct_Abs]
)





Latest Month :=
CALCULATE( MAX('RC_Code_Model_Base'[month_end]), ALL('RC_Code_Model_Base') )

Selected Months := DISTINCTCOUNT('RC_Code_Model_Base'[month_end])

RMSE :=
VAR sse =
    SUMX(
        'RC_Code_Model_Base',
        VAR r = 'RC_Code_Model_Base'[Resid]
        RETURN r * r
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN IF(n>0, SQRT( sse / n ))

MAE :=
AVERAGEX( 'RC_Code_Model_Base', ABS('RC_Code_Model_Base'[Resid]) )

MAPE :=
AVERAGEX(
    'RC_Code_Model_Base',
    VAR f = 'RC_Code_Model_Base'[Forecast_Selected]
    VAR a = 'RC_Code_Model_Base'[bal_num]
    RETURN IF( NOT ISBLANK(f) && f<>0, ABS( (a - f) / f ), BLANK() )
)


Inside PI % :=
VAR hits =
    SUMX(
        'RC_Code_Model_Base',
        VAR a = 'RC_Code_Model_Base'[bal_num]
        VAR lo = 'RC_Code_Model_Base'[PI_Lo]
        VAR hi = 'RC_Code_Model_Base'[PI_Hi]
        RETURN IF( NOT(ISBLANK(lo)||ISBLANK(hi)) && a>=lo && a<=hi, 1, 0 )
    )
VAR n = COUNTROWS('RC_Code_Model_Base')
RETURN DIVIDE(hits,n)

RMSE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [RMSE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAE],  TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

MAPE (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [MAPE], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )

Inside PI % (Latest) :=
VAR lm = [Latest Month]
RETURN CALCULATE( [Inside PI %], TREATAS({lm}, 'RC_Code_Model_Base'[month_end]) )


RMSE Last 6 :=
VAR lm = [Latest Month]
VAR period =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base', 'RC_Code_Model_Base'[month_end] IN period)
    )
RETURN IF(n>0, SQRT(sse/n))

RMSE Prev 12 (excl last 6) :=
VAR lm = [Latest Month]
VAR last6 = DATESINPERIOD('RC_Code_Model_Base'[month_end], lm, -6, MONTH)
VAR prev12 =
    DATESINPERIOD('RC_Code_Model_Base'[month_end], MAXX(last6,[Value])-1, -12, MONTH)
RETURN
VAR sse =
    SUMX(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        ),
        VAR r = 'RC_Code_Model_Base'[Resid] RETURN r*r
    )
VAR n =
    COUNTROWS(
        FILTER('RC_Code_Model_Base',
            'RC_Code_Model_Base'[month_end] IN prev12 &&
            NOT('RC_Code_Model_Base'[month_end] IN last6)
        )
    )
RETURN IF(n>0, SQRT(sse/n))

Break Ratio (Err Vol) :=
DIVIDE( [RMSE Last 6], [RMSE Prev 12 (excl last 6)] )


RMSE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [RMSE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )

MAE by Best Model :=
VAR bm = SELECTEDVALUE('RC_Code_Model_Base'[Best_Model])
RETURN
CALCULATE( [MAE], KEEPFILTERS( 'RC_Code_Model_Base'[Best_Model] = bm ) )


Resid Mean := AVERAGE('RC_Code_Model_Base'[Resid])
Resid SD   := STDEVX.S('RC_Code_Model_Base', 'RC_Code_Model_Base'[Resid])

+2 SD := [Resid Mean] + 2*[Resid SD]
-2 SD := [Resid Mean] - 2*[Resid SD]





-- Severity (latest)
Avg Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    AVERAGE ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

RC Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

High Severity Count (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE ( [High Severity Count (Latest)], [RC Count (Latest)] )





-- Anchor
Latest Month :=
CALCULATE ( MAX ( 'RC_Code_Model_Base'[month_end] ), ALL ( 'RC_Code_Model_Base' ) )

Is Latest Month :=
VAR lm = [Latest Month]
RETURN IF ( MAX ( 'RC_Code_Model_Base'[month_end] ) = lm, 1, 0 )


-- Portfolio totals (latest)
Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE ( [Total Residual (Latest)], [Total Forecast (Latest)] )



-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    DISTINCTCOUNT ( 'RC_Code_Model_Base'[RC_CODE] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] ),
    'RC_Code_Model_Base'[Resid] > 0
)


Top Severity (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE (
    MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
    TREATAS ( { lm }, 'RC_Code_Model_Base'[month_end] )
)

Severity Tier (Latest) :=
VAR sev =
    CALCULATE (
        MAX ( 'RC_Code_Model_Base'[Severity_0_100] ),
        TREATAS ( { [Latest Month] }, 'RC_Code_Model_Base'[month_end] )
    )
RETURN
SWITCH (
    TRUE (),
    ISBLANK ( sev ), BLANK (),
    sev >= 80, "Critical",
    sev >= 60, "High",
    sev >= 40, "Moderate",
    "Stable"
)






Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

Total Balance (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Forecast (Latest) :=
VAR lm = [Latest Month]
RETURN
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    FILTER(
        ALL('RC_Code_Model_Base'[month_end]),
        'RC_Code_Model_Base'[month_end] = lm
    )
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )




-- Reusable anchor
Latest Month :=
CALCULATE(
    MAX ( 'RC_Code_Model_Base'[month_end] ),
    ALL ( 'RC_Code_Model_Base' )
)

-- Boolean-as-1/0 flag for visuals that need it
Is Latest Month :=
IF (
    MAX ( 'RC_Code_Model_Base'[month_end] ) = [Latest Month],
    1, 0
)


-- Totals (latest)
Total Balance (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[bal_num] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Forecast (Latest) :=
CALCULATE(
    SUM ( 'RC_Code_Model_Base'[Forecast_Selected] ),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

Total Residual (Latest) :=
[Total Balance (Latest)] - [Total Forecast (Latest)]

Avg Residual % (Latest) :=
DIVIDE( [Total Residual (Latest)], [Total Forecast (Latest)] )

-- Severity (latest)
Avg Severity (Latest) :=
CALCULATE(
    AVERAGE('RC_Code_Model_Base'[Severity_0_100]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

RC Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month]
)

High Severity Count (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Severity_0_100] >= 70
)

Pct High Severity (Latest) :=
DIVIDE( [High Severity Count (Latest)], [RC Count (Latest)] )

-- Improving / Deteriorating (latest)
Improving RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] < 0
)

Deteriorating RCs (Latest) :=
CALCULATE(
    DISTINCTCOUNT('RC_Code_Model_Base'[RC_CODE]),
    'RC_Code_Model_Base'[month_end] = [Latest Month],
    'RC_Code_Model_Base'[Resid] > 0
)





/* --- rank top components WITHOUT LISTAGG --- */
exp_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_exp_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_exp_component) DESC
    ) AS rn_exp
  FROM psi_calc p
),
cnt_rank AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket, p.psi_cnt_component,
    ROW_NUMBER() OVER (
      PARTITION BY p.kde_name, p.month_end
      ORDER BY ABS(p.psi_cnt_component) DESC
    ) AS rn_cnt
  FROM psi_calc p
),

/* pivot top 3 exposure drivers */
exp_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_exp=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp1,
    MAX(CASE WHEN rn_exp=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp2,
    MAX(CASE WHEN rn_exp=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_exp_component, 'FM999999990.0000') END) AS exp3
  FROM exp_rank
  WHERE rn_exp <= 3
  GROUP BY kde_name, month_end
),

/* pivot top 3 count drivers */
cnt_top3 AS (
  SELECT
    kde_name, month_end,
    MAX(CASE WHEN rn_cnt=1 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt1,
    MAX(CASE WHEN rn_cnt=2 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt2,
    MAX(CASE WHEN rn_cnt=3 THEN kde_bucket || ':' ||
         TO_CHAR(psi_cnt_component, 'FM999999990.0000') END) AS cnt3
  FROM cnt_rank
  WHERE rn_cnt <= 3
  GROUP BY kde_name, month_end
)

/* --- final result (no LISTAGG) --- */
SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,

  /* build comma-separated strings manually */
  TRIM(BOTH ', ' FROM
      COALESCE(e.exp1,'') ||
      CASE WHEN e.exp1 IS NOT NULL AND e.exp2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp2,'') ||
      CASE WHEN (e.exp1 IS NOT NULL OR e.exp2 IS NOT NULL) AND e.exp3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(e.exp3,'')
  ) AS top_exp_drivers,

  TRIM(BOTH ', ' FROM
      COALESCE(c.cnt1,'') ||
      CASE WHEN c.cnt1 IS NOT NULL AND c.cnt2 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt2,'') ||
      CASE WHEN (c.cnt1 IS NOT NULL OR c.cnt2 IS NOT NULL) AND c.cnt3 IS NOT NULL THEN ', ' ELSE '' END ||
      COALESCE(c.cnt3,'')
  ) AS top_cnt_drivers

FROM psi_tot t
LEFT JOIN exp_top3 e ON e.kde_name = t.kde_name AND e.month_end = t.month_end
LEFT JOIN cnt_top3 c ON c.kde_name = t.kde_name AND c.month_end = t.month_end
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;




/* ================= KDE Distribution Drift (PSI) ==================== */
/* Filters portfolio, maps long tails to _OTHER, computes PSI Count/Exposure */
/* =================================================================== */

WITH
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE) AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8   AS exposure,
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* Flatten per KDE as categories (explicit VARCHAR sizes for Netezza) */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure, CAST(PD_GRADE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure, CAST(FDIC_CALL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure, CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure, CAST(INDUSTRY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure, CAST(LTV AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure, CAST(GL_ACCOUNT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure, CAST(DAYS_PAST_DUE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure, CAST(RBC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure, CAST(MATURITY_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure, CAST(NAICS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure, CAST(RC_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure, CAST(REVOLVING_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure, CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure, CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure, CAST(BOOK_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure, CAST(BUS_UNIT_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure, CAST(COLLATERAL_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure, CAST(ISSUE_DATE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure, CAST(OCCUPANCY_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure, CAST(PAST_DUE_FLAG AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure, CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure, CAST(PURPOSE_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure, CAST(STATUS_CODE AS VARCHAR(255)) FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure, CAST(RISK_UNIT AS VARCHAR(255)) FROM base
),

/* Define the 12-month window and pick Top 20 values per KDE by exposure */
max_me AS ( SELECT MAX(month_end) AS max_me FROM kde_flat ),
last12 AS (
  SELECT * FROM kde_flat, max_me WHERE month_end >= ADD_MONTHS(max_me, -11)
),
topvals AS (
  SELECT kde_name, kde_value,
         ROW_NUMBER() OVER (PARTITION BY kde_name ORDER BY SUM(exposure) DESC) AS rn
  FROM last12
  GROUP BY kde_name, kde_value
),
value_map AS (
  SELECT f.kde_name, f.Account_Identifier, f.month_end, f.exposure,
         CASE WHEN t.rn IS NOT NULL AND t.rn <= 20
              THEN f.kde_value ELSE '_OTHER' END AS kde_bucket
  FROM kde_flat f
  LEFT JOIN topvals t
    ON t.kde_name = f.kde_name AND t.kde_value = f.kde_value
),

/* Current distributions (per KDE x month x bucket) */
dist_cur AS (
  SELECT kde_name, month_end, kde_bucket,
         COUNT(DISTINCT Account_Identifier)            AS cnt,
         SUM(exposure)                                 AS exp
  FROM value_map
  GROUP BY kde_name, month_end, kde_bucket
),
dist_tot AS (
  SELECT kde_name, month_end,
         SUM(cnt) AS cnt_tot,
         SUM(exp) AS exp_tot
  FROM dist_cur
  GROUP BY kde_name, month_end
),
dist_cur_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         c.cnt, c.exp, t.cnt_tot, t.exp_tot,
         CASE WHEN t.cnt_tot=0 THEN 0 ELSE c.cnt::FLOAT8 / t.cnt_tot END AS p_cnt,
         CASE WHEN t.exp_tot=0 THEN 0 ELSE c.exp::FLOAT8 / t.exp_tot END AS p_exp
  FROM dist_cur c
  JOIN dist_tot t USING (kde_name, month_end)
),

/* Previous month distributions aligned to current month_end */
dist_prev_p AS (
  SELECT c.kde_name, c.month_end, c.kde_bucket,
         COALESCE(p.p_cnt, 0) AS q_cnt,
         COALESCE(p.p_exp, 0) AS q_exp
  FROM dist_cur_p c
  LEFT JOIN dist_cur_p p
    ON p.kde_name = c.kde_name
   AND p.kde_bucket = c.kde_bucket
   AND p.month_end = ADD_MONTHS(c.month_end, -1)
),

/* PSI components and totals */
psi_calc AS (
  SELECT
    c.kde_name, c.month_end, c.kde_bucket,
    c.p_cnt, v.q_cnt,
    c.p_exp, v.q_exp,
    /* Small epsilon to avoid ln(0) */
    ( (c.p_cnt - v.q_cnt)
      * LN( (CASE WHEN c.p_cnt <= 0 THEN 1e-9 ELSE c.p_cnt END)
          / (CASE WHEN v.q_cnt <= 0 THEN 1e-9 ELSE v.q_cnt END) )
    ) AS psi_cnt_component,
    ( (c.p_exp - v.q_exp)
      * LN( (CASE WHEN c.p_exp <= 0 THEN 1e-9 ELSE c.p_exp END)
          / (CASE WHEN v.q_exp <= 0 THEN 1e-9 ELSE v.q_exp END) )
    ) AS psi_exp_component
  FROM dist_cur_p c
  JOIN dist_prev_p v
    ON v.kde_name = c.kde_name
   AND v.kde_bucket = c.kde_bucket
   AND v.month_end = c.month_end
),
psi_tot AS (
  SELECT
    kde_name, month_end,
    SUM(psi_cnt_component) AS psi_count,
    SUM(psi_exp_component) AS psi_exposure
  FROM psi_calc
  GROUP BY kde_name, month_end
),
/* Rank top contributing buckets each month */
psi_top_components AS (
  SELECT
    p.kde_name, p.month_end, p.kde_bucket,
    psi_cnt_component, psi_exp_component,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_exp_component) DESC) AS rk_exp,
    DENSE_RANK() OVER (PARTITION BY p.kde_name, p.month_end
                       ORDER BY ABS(psi_cnt_component) DESC) AS rk_cnt
  FROM psi_calc p
)

SELECT
  t.kde_name,
  t.month_end,
  t.psi_count,
  t.psi_exposure,
  /* Optional: top 3 exposure-contributing buckets for explainability */
  LISTAGG(CASE WHEN c.rk_exp <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_exp_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_exp) AS top_exp_drivers,
  LISTAGG(CASE WHEN c.rk_cnt <= 3
               THEN c.kde_bucket || ':' || TO_CHAR(c.psi_cnt_component, 'FM999999990.0000')
          END, ', ') WITHIN GROUP (ORDER BY c.rk_cnt) AS top_cnt_drivers
FROM psi_tot t
LEFT JOIN psi_top_components c
  ON c.kde_name = t.kde_name AND c.month_end = t.month_end
GROUP BY t.kde_name, t.month_end, t.psi_count, t.psi_exposure
ORDER BY t.month_end DESC, ABS(t.psi_exposure) DESC;






/* 1) Flatten per KDE (UNION ALL) with explicit VARCHAR sizes */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CAST(CRE_FLAG AS VARCHAR(255)) AS kde_value,
         LAG(CAST(CRE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL
  SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         CAST(PD_GRADE AS VARCHAR(255)),
         LAG(CAST(PD_GRADE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         CAST(FDIC_CALL_CODE AS VARCHAR(255)),
         LAG(CAST(FDIC_CALL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         CAST(NON_ACCRUAL_FLAG AS VARCHAR(255)),
         LAG(CAST(NON_ACCRUAL_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         CAST(INDUSTRY_CODE AS VARCHAR(255)),
         LAG(CAST(INDUSTRY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'LTV', Account_Identifier, month_end, exposure,
         CAST(LTV AS VARCHAR(255)),
         LAG(CAST(LTV AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         CAST(GL_ACCOUNT_CODE AS VARCHAR(255)),
         LAG(CAST(GL_ACCOUNT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         CAST(DAYS_PAST_DUE AS VARCHAR(255)),
         LAG(CAST(DAYS_PAST_DUE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         CAST(RBC_CODE AS VARCHAR(255)),
         LAG(CAST(RBC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         CAST(MATURITY_DATE AS VARCHAR(255)),
         LAG(CAST(MATURITY_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         CAST(NAICS_CODE AS VARCHAR(255)),
         LAG(CAST(NAICS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         CAST(RC_CODE AS VARCHAR(255)),
         LAG(CAST(RC_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         CAST(REVOLVING_CODE AS VARCHAR(255)),
         LAG(CAST(REVOLVING_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255)),
         LAG(CAST(NEXT_RATE_CHANGE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255)),
         LAG(CAST(ACCOUNT_OFFICER_NAME AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         CAST(BOOK_DATE AS VARCHAR(255)),
         LAG(CAST(BOOK_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         CAST(BUS_UNIT_CODE AS VARCHAR(255)),
         LAG(CAST(BUS_UNIT_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         CAST(COLLATERAL_CODE AS VARCHAR(255)),
         LAG(CAST(COLLATERAL_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         CAST(ISSUE_DATE AS VARCHAR(255)),
         LAG(CAST(ISSUE_DATE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         CAST(OCCUPANCY_CODE AS VARCHAR(255)),
         LAG(CAST(OCCUPANCY_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         CAST(PAST_DUE_FLAG AS VARCHAR(255)),
         LAG(CAST(PAST_DUE_FLAG AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255)),
         LAG(CAST(PROD_HIER_LEVEL_5 AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         CAST(PURPOSE_CODE AS VARCHAR(255)),
         LAG(CAST(PURPOSE_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         CAST(STATUS_CODE AS VARCHAR(255)),
         LAG(CAST(STATUS_CODE AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL
  SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         CAST(RISK_UNIT AS VARCHAR(255)),
         LAG(CAST(RISK_UNIT AS VARCHAR(255))) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure) OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
)





/* ============== KDE MoM Changes — Full History (Netezza-safe) ==============
   - Per KDE x month: totals, CHANGES-ONLY deltas (incl. NULL flips), MoM%, rolling stats,
     Z-scores, Severity 0–100, and per-month ranks.
   - No POWER; no views; ANSI/Netezza functions only.
   ========================================================================== */

WITH
/* 0) Base monthly rows filtered to Total Loans */
base AS (
  SELECT
    Account_Identifier,
    CAST(END_OF_MONTH_DATE AS DATE)   AS month_end,
    SOURCE_SYSTEM_BALANCE::FLOAT8     AS exposure,
    -- ---- KDE columns ----
    CRE_FLAG, PD_GRADE, FDIC_CALL_CODE, NON_ACCRUAL_FLAG, INDUSTRY_CODE, LTV,
    GL_ACCOUNT_CODE, DAYS_PAST_DUE, RBC_CODE, MATURITY_DATE, NAICS_CODE, RC_CODE,
    REVOLVING_CODE, NEXT_RATE_CHANGE_DATE, ACCOUNT_OFFICER_NAME, BOOK_DATE,
    BUS_UNIT_CODE, COLLATERAL_CODE, ISSUE_DATE, OCCUPANCY_CODE, PAST_DUE_FLAG,
    PROD_HIER_LEVEL_5, PURPOSE_CODE, STATUS_CODE, RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
),

/* 1) Flatten per KDE (UNION ALL pattern) with current & previous values and exposures */
kde_flat AS (
  SELECT 'CRE_FLAG' AS kde_name, Account_Identifier, month_end, exposure,
         CRE_FLAG::VARCHAR AS kde_value,
         LAG(CRE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_kde_value,
         LAG(exposure)        OVER (PARTITION BY Account_Identifier ORDER BY month_end) AS prev_exposure
  FROM base
  UNION ALL SELECT 'PD_GRADE', Account_Identifier, month_end, exposure,
         PD_GRADE::VARCHAR,
         LAG(PD_GRADE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'FDIC_CALL_CODE', Account_Identifier, month_end, exposure,
         FDIC_CALL_CODE::VARCHAR,
         LAG(FDIC_CALL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NON_ACCRUAL_FLAG', Account_Identifier, month_end, exposure,
         NON_ACCRUAL_FLAG::VARCHAR,
         LAG(NON_ACCRUAL_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                  OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'INDUSTRY_CODE', Account_Identifier, month_end, exposure,
         INDUSTRY_CODE::VARCHAR,
         LAG(INDUSTRY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'LTV', Account_Identifier, month_end, exposure,
         LTV::VARCHAR,
         LAG(LTV::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)     OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'GL_ACCOUNT_CODE', Account_Identifier, month_end, exposure,
         GL_ACCOUNT_CODE::VARCHAR,
         LAG(GL_ACCOUNT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'DAYS_PAST_DUE', Account_Identifier, month_end, exposure,
         DAYS_PAST_DUE::VARCHAR,
         LAG(DAYS_PAST_DUE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RBC_CODE', Account_Identifier, month_end, exposure,
         RBC_CODE::VARCHAR,
         LAG(RBC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)          OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'MATURITY_DATE', Account_Identifier, month_end, exposure,
         MATURITY_DATE::VARCHAR,
         LAG(MATURITY_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NAICS_CODE', Account_Identifier, month_end, exposure,
         NAICS_CODE::VARCHAR,
         LAG(NAICS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RC_CODE', Account_Identifier, month_end, exposure,
         RC_CODE::VARCHAR,
         LAG(RC_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)         OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'REVOLVING_CODE', Account_Identifier, month_end, exposure,
         REVOLVING_CODE::VARCHAR,
         LAG(REVOLVING_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'NEXT_RATE_CHANGE_DATE', Account_Identifier, month_end, exposure,
         NEXT_RATE_CHANGE_DATE::VARCHAR,
         LAG(NEXT_RATE_CHANGE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                       OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ACCOUNT_OFFICER_NAME', Account_Identifier, month_end, exposure,
         ACCOUNT_OFFICER_NAME::VARCHAR,
         LAG(ACCOUNT_OFFICER_NAME::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                      OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BOOK_DATE', Account_Identifier, month_end, exposure,
         BOOK_DATE::VARCHAR,
         LAG(BOOK_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'BUS_UNIT_CODE', Account_Identifier, month_end, exposure,
         BUS_UNIT_CODE::VARCHAR,
         LAG(BUS_UNIT_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'COLLATERAL_CODE', Account_Identifier, month_end, exposure,
         COLLATERAL_CODE::VARCHAR,
         LAG(COLLATERAL_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                 OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'ISSUE_DATE', Account_Identifier, month_end, exposure,
         ISSUE_DATE::VARCHAR,
         LAG(ISSUE_DATE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)            OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'OCCUPANCY_CODE', Account_Identifier, month_end, exposure,
         OCCUPANCY_CODE::VARCHAR,
         LAG(OCCUPANCY_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PAST_DUE_FLAG', Account_Identifier, month_end, exposure,
         PAST_DUE_FLAG::VARCHAR,
         LAG(PAST_DUE_FLAG::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)               OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PROD_HIER_LEVEL_5', Account_Identifier, month_end, exposure,
         PROD_HIER_LEVEL_5::VARCHAR,
         LAG(PROD_HIER_LEVEL_5::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)                   OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'PURPOSE_CODE', Account_Identifier, month_end, exposure,
         PURPOSE_CODE::VARCHAR,
         LAG(PURPOSE_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)              OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'STATUS_CODE', Account_Identifier, month_end, exposure,
         STATUS_CODE::VARCHAR,
         LAG(STATUS_CODE::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)             OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
  UNION ALL SELECT 'RISK_UNIT', Account_Identifier, month_end, exposure,
         RISK_UNIT::VARCHAR,
         LAG(RISK_UNIT::VARCHAR) OVER (PARTITION BY Account_Identifier ORDER BY month_end),
         LAG(exposure)           OVER (PARTITION BY Account_Identifier ORDER BY month_end)
  FROM base
),

/* 2) Row-level changed flag (NULL-safe) + exposure delta */
chg_rows AS (
  SELECT
    kde_name,
    Account_Identifier,
    month_end,
    exposure,
    prev_exposure,
    kde_value,
    prev_kde_value,
    CASE
      WHEN (kde_value IS NULL AND prev_kde_value IS NULL) THEN 0
      WHEN (kde_value IS NULL AND prev_kde_value IS NOT NULL) THEN 1
      WHEN (kde_value IS NOT NULL AND prev_kde_value IS NULL) THEN 1
      WHEN (kde_value <> prev_kde_value) THEN 1
      ELSE 0
    END AS changed_flag,
    (exposure - COALESCE(prev_exposure,0.0))::FLOAT8 AS delta_exposure
  FROM kde_flat
),

/* 3) Aggregate per KDE x month: totals and changes-only */
agg_m AS (
  SELECT
    kde_name,
    month_end,
    COUNT(DISTINCT Account_Identifier)                                   AS total_accts,
    SUM(exposure)                                                        AS total_exposure,
    COUNT(DISTINCT CASE WHEN changed_flag=1 THEN Account_Identifier END) AS chg_accts,
    SUM(CASE WHEN changed_flag=1 THEN delta_exposure ELSE 0.0 END)       AS chg_exposure
  FROM chg_rows
  GROUP BY kde_name, month_end
),

/* 4) Add prior totals, MoM %, and rolling 12m stats */
with_mom AS (
  SELECT
    a.*,
    LAG(total_accts)    OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_accts,
    LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) AS prev_total_exposure,

    /* Overall MoM % (relative to prior total exposure) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE (total_exposure - LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end))
                / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS total_exp_mom_pct,

    /* Changes-only % (relative to prior total exposure/accounts) */
    CASE WHEN LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_exposure / NULLIF(LAG(total_exposure) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_exp_mom_pct,

    CASE WHEN LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end) = 0
         THEN NULL
         ELSE chg_accts::FLOAT8 / NULLIF(LAG(total_accts) OVER (PARTITION BY kde_name ORDER BY month_end),0)
    END AS chg_cnt_mom_pct,

    /* Rolling 12m stats on changes-only exposure & count (levels) */
    AVG(chg_exposure)  OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_ma12,
    STDDEV_SAMP(chg_exposure) OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_exp_sd12,
    AVG(chg_accts)     OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_ma12,
    STDDEV_SAMP(chg_accts)    OVER (PARTITION BY kde_name ORDER BY month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS chg_cnt_sd12
  FROM agg_m a
),

/* 5) Z-scores and severity */
scored AS (
  SELECT
    w.*,
    CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
         ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END AS z_chg_exposure,
    CASE WHEN w.chg_cnt_sd12 IS NULL OR w.chg_cnt_sd12 = 0 THEN NULL
         ELSE (w.chg_accts   - w.chg_cnt_ma12) / w.chg_cnt_sd12 END AS z_chg_count,

    ( 0.55 * ABS(COALESCE(
          CASE WHEN w.chg_exp_sd12 IS NULL OR w.chg_exp_sd12 = 0 THEN NULL
               ELSE (w.chg_exposure - w.chg_exp_ma12) / w.chg_exp_sd12 END, 0))
    + 0.30 * ABS(COALESCE(w.chg_exp_mom_pct,0))
    + 0.15 * ABS(COALESCE(w.chg_cnt_mom_pct,0))
    ) AS severity_raw
  FROM with_mom w
),

/* 6) KDE grouping for visuals */
labeled AS (
  SELECT
    s.*,
    CASE
      WHEN kde_name IN ('RC_CODE','RBC_CODE','RISK_UNIT','STATUS_CODE') THEN 'Risk/Reg'
      WHEN kde_name IN ('LTV','COLLATERAL_CODE','OCCUPANCY_CODE') THEN 'Collateral'
      WHEN kde_name IN ('PROD_HIER_LEVEL_5','PURPOSE_CODE','GL_ACCOUNT_CODE','REVOLVING_CODE') THEN 'Product'
      WHEN kde_name IN ('PD_GRADE','NON_ACCRUAL_FLAG','PAST_DUE_FLAG','DAYS_PAST_DUE') THEN 'Credit Quality'
      WHEN kde_name IN ('NAICS_CODE','INDUSTRY_CODE','BUS_UNIT_CODE','ACCOUNT_OFFICER_NAME') THEN 'Org/Segment'
      WHEN kde_name IN ('MATURITY_DATE','BOOK_DATE','ISSUE_DATE','NEXT_RATE_CHANGE_DATE') THEN 'Dates'
      ELSE 'Other'
    END AS kde_group
  FROM scored s
),

/* 7) Final compute: severity squash + per-month ranks */
final AS (
  SELECT
    l.*,
    /* 0..100 severity via 1 - exp(-x) */
    ROUND(100 * (1 - EXP(-COALESCE(l.severity_raw,0))), 0)::INT AS severity_0_100,

    /* Per-month ranks (null-safe using COALESCE) */
    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY ABS(COALESCE(l.chg_exposure, -1e308)) DESC
    ) AS rank_exp_abs,

    DENSE_RANK() OVER (
      PARTITION BY l.month_end
      ORDER BY COALESCE(l.chg_cnt_mom_pct, -1e308) DESC
    ) AS rank_cnt_pct
  FROM labeled l
)

SELECT
  kde_name,
  kde_group,
  month_end,
  /* Totals */
  total_accts,
  total_exposure,
  prev_total_accts,
  prev_total_exposure,
  total_exp_mom_pct,
  /* Changes-only */
  chg_accts,
  chg_exposure,
  chg_cnt_mom_pct,
  chg_exp_mom_pct,
  /* Rolling & Z */
  chg_exp_ma12, chg_exp_sd12, z_chg_exposure,
  chg_cnt_ma12, chg_cnt_sd12, z_chg_count,
  /* Severity & ranks */
  severity_0_100,
  rank_exp_abs,
  rank_cnt_pct
FROM final
-- Optional history limiter (e.g., last 36 months):
-- WHERE month_end >= ADD_MONTHS(CURRENT_DATE, -36)
ORDER BY month_end DESC, rank_exp_abs ASC;





import pandas as pd

latest = df["month_end"].max()
d = df[df["month_end"]==latest].copy()
top = d.sort_values("severity_0_100", ascending=False).head(5)

lines = [f"Month: {latest.date()}"]
lines.append(f"Outside PI: {int((d['outside_pi']).sum())} of {len(d)} RCs")
lines.append(f"Persistent (3 of 6): {int((d['persistent_outlier_3of6']==1).sum())}")

for _, r in top.iterrows():
    lines.append(f"- {r['rc_code']}: Sev {int(r['severity_0_100'])} — {r.get('reason_code','')}; "
                 f\"Δ vs Fcst = {r['actual']-r['forecast_selected']:.0f}; "
                 f"MoM=$ {r.get('mom_abs',float('nan')):.0f}; Outside PI={bool(r['outside_pi'])}\")

"\n".join(lines)




import pandas as pd
import numpy as np

# assumes df already loaded/cleaned from Step 1 and has lowercase headers
d = df.copy()

# --- correlations per RC (safe even if some columns are missing) ---
def _corr(a, b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a": a, "b": b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs  = "absresid" in d.columns
have_mom  = "mom_abs" in d.columns
have_momp = "mom_pct_abs" in d.columns

rows = []
for rc, g in d.groupby("rc_code"):
    rows.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(rows)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (flat index) ---
dd = d.sort_values(["rc_code", "month_end"]).copy()
dd["se"] = (pd.to_numeric(dd["actual"], errors="coerce") - pd.to_numeric(dd["forecast_selected"], errors="coerce"))**2

dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick the latest row per RC (no droplevel needed)
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code", "break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




import pandas as pd
import numpy as np

# assume df already loaded/cleaned from Step 1
d = df.copy()

# --- correlations per RC ---
def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce")
    b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3:
        return np.nan
    return m["a"].corr(m["b"])

have_abs   = "absresid" in d.columns
have_mom$  = "mom_abs" in d.columns
have_momp  = "mom_pct_abs" in d.columns

parts = []
for rc, g in d.groupby("rc_code"):
    parts.append({
        "rc_code": rc,
        "corr_resid_momabs": _corr(g["absresid"], g["mom_abs"]) if (have_abs and have_mom$) else np.nan,
        "corr_resid_mompct": _corr(g["absresid"], g["mom_pct_abs"]) if (have_abs and have_momp) else np.nan,
    })
diag = pd.DataFrame(parts)

# --- drift signal: 3-mo MSE / prior 9-mo MSE (no MultiIndex) ---
dd = d.sort_values(["rc_code","month_end"]).copy()
dd["se"] = (dd["actual"] - dd["forecast_selected"])**2

# rolling means via transform (keeps a flat index)
dd["mse_curr3"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(3, min_periods=2).mean())
dd["mse_prev9"] = dd.groupby("rc_code")["se"].transform(lambda s: s.rolling(12, min_periods=10).mean().shift(3))

dd["break_ratio"] = np.where(
    (dd["mse_prev9"] > 0) & np.isfinite(dd["mse_prev9"]),
    dd["mse_curr3"] / dd["mse_prev9"],
    np.nan
)

# pick latest row per RC without droplevel
latest_idx = dd.groupby("rc_code")["month_end"].idxmax()
drift = dd.loc[latest_idx, ["rc_code","break_ratio"]].reset_index(drop=True)

# final diagnostics table
diag_final = diag.merge(drift, on="rc_code", how="left")
diag_final




Error:Python
ValueError: Cannot remove 1 levels from an index with 1 levels: at least one level must be left.




import pandas as pd

d = df.copy()
latest = d["month_end"].max()
top = (
    d[d["month_end"]==latest]
    .sort_values("severity_0_100", ascending=False)
    .loc[:, ["rc_code","rc_description","month_end","severity_0_100","outside_pi",
             "persistent_outlier_3of6","reason_code","z_resid","z_mom_abs","mom_abs"]]
    .head(25)
    .reset_index(drop=True)
)
top



import pandas as pd
import numpy as np

g = df.groupby("rc_code", as_index=False)

def _corr(a,b):
    a = pd.to_numeric(a, errors="coerce"); b = pd.to_numeric(b, errors="coerce")
    m = pd.DataFrame({"a":a,"b":b}).dropna()
    if len(m) < 3: return np.nan
    return m["a"].corr(m["b"])

diag = g.apply(lambda x: pd.Series({
    "corr_resid_momabs": _corr(x["absresid"], x["mom_abs"]) if "absresid" in x and "mom_abs" in x else np.nan,
    "corr_resid_mompct": _corr(x["absresid"], x["mom_pct_abs"]) if "mom_pct_abs" in x else np.nan
})).reset_index(drop=True)

# Drift signal: 3-mo MSE / prior 9-mo MSE
df_sorted = df.sort_values(["rc_code","month_end"]).copy()
df_sorted["se"] = (df_sorted["actual"] - df_sorted["forecast_selected"])**2
df_sorted["mse_curr3"] = df_sorted.groupby("rc_code")["se"].rolling(3, min_periods=2).mean().reset_index(level=0, drop=True)
df_sorted["mse_prev9"] = df_sorted.groupby("rc_code")["se"].rolling(12, min_periods=10).mean().reset_index(level=0, drop=True).shift(3)
drift = (df_sorted
         .assign(break_ratio=lambda x: np.where((x["mse_prev9"]>0)&np.isfinite(x["mse_prev9"]),
                                                x["mse_curr3"]/x["mse_prev9"], np.nan))
         .groupby("rc_code", as_index=False)
         .apply(lambda x: x.loc[x["month_end"].idxmax(), ["rc_code","break_ratio"]])
         .droplevel(0)
)
diag = diag.merge(drift, on="rc_code", how="left")
diag




import pandas as pd
import numpy as np

# If you created RC_Anom_Clean, read that; otherwise reuse df from above cell
try:
    df2 = xl("RC_Anom_Clean").copy()
    df2.columns = [str(c).strip().lower().replace(" ","_") for c in df2.columns]
    df2["month_end"] = pd.to_datetime(df2["month_end"], errors="coerce")
    df2["severity_0_100"] = pd.to_numeric(df2["severity_0_100"], errors="coerce")
    df2["outside_pi"] = df2["outside_pi"].astype(bool)
except:
    df2 = df.copy()

thresholds = list(range(55, 91, 5))  # 55,60,...,90
rows = []
for thr in thresholds:
    pred = df2["severity_0_100"] >= thr
    tp = int((pred & df2["outside_pi"]).sum())
    fp = int((pred & ~df2["outside_pi"]).sum())
    fn = int((~pred & df2["outside_pi"]).sum())
    alerts = int(pred.sum())
    prec = tp / (tp + fp) if (tp+fp) else np.nan
    rec  = tp / (tp + fn) if (tp+fn) else np.nan
    rows.append((thr, alerts, tp, fp, fn, prec, rec))

cal = pd.DataFrame(rows, columns=["threshold","alerts","true_pos","false_pos","false_neg","precision","recall"])

# Add avg alerts per latest month (how noisy will it be?)
latest = df2["month_end"].max()
latest_alerts = df2.loc[df2["month_end"]==latest, ["rc_code","severity_0_100"]]
cal["alerts_latest"] = cal["threshold"].map(lambda t: int((latest_alerts["severity_0_100"]>=t).sum()))

cal




import pandas as pd
import numpy as np

# Read the whole table (headers + data), then promote first row as headers
raw = xl("RC_Anomaly_all").copy()
hdr = raw.iloc[0].astype(str).tolist()
df  = raw.iloc[1:].copy()
df.columns = [h.strip().lower().replace(" ","_") for h in hdr]

# Types
num_cols = ["actual","forecast_selected","pi_lo","pi_hi","severity_0_100","absresid","mom_abs","z_resid","z_mom_abs"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")
df["month_end"] = pd.to_datetime(df["month_end"], errors="coerce")

# Helpful boolean: outside prediction interval
df["outside_pi"] = (df["actual"] < df["pi_lo"]) | (df["actual"] > df["pi_hi"])

# (Optional) persist back to Excel visually
df






/* Clean up temp tables */
IF OBJECT_ID('tempdb..#FLUX')   IS NOT NULL DROP TABLE #FLUX;
IF OBJECT_ID('tempdb..#CARDS')  IS NOT NULL DROP TABLE #CARDS;

/* Params */
DECLARE @system NVARCHAR(150);
DECLARE @current_period DATETIME = '2025-08-31';
DECLARE @prior_period   DATETIME = '2025-07-31';

/* Cards for system tagging */
SELECT DISTINCT LOADDT, CUST_LINE_NBR
INTO #CARDS
FROM CRDADMPRD.CRDADMPRD.dbo.CDM_CARDS_LOAN
WHERE CAST(LOADDT AS DATE) IN (@current_period, @prior_period);

/* === Latest row per table, per date & credit line === */
WITH CLM AS (
    SELECT
        CAST(a.LoadDate AS DATE) AS LoadDate,
        a.CreditLineNumber,
        a.NetUtilized,
        a.ApplID,
        a.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(a.LoadDate AS DATE), a.CreditLineNumber
            ORDER BY a.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CREDIT_LINE_MONTHLY a
    WHERE CAST(a.LoadDate AS DATE) IN (@current_period, @prior_period)
),
CLM_Latest AS (
    SELECT * FROM CLM WHERE rn = 1
),
UF AS (
    SELECT
        CAST(b.LoadDate AS DATE) AS LoadDate,
        b.CreditLineNumber,
        b.SecUnfunded,
        b.RunID,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(b.LoadDate AS DATE), b.CreditLineNumber
            ORDER BY b.RunID DESC
        ) AS rn
    FROM CRDLMTUFCALC.dbo.CALCULATED_UNFUNDED b
    WHERE CAST(b.LoadDate AS DATE) IN (@current_period, @prior_period)
),
UF_Latest AS (
    SELECT * FROM UF WHERE rn = 1
)

/* Build flux set (one row per date & credit line) */
SELECT
    c.LoadDate,
    c.CreditLineNumber,
    (c.NetUtilized + COALESCE(u.SecUnfunded, 0)) AS commitment,
    c.NetUtilized,
    COALESCE(u.SecUnfunded, 0) AS SecUnfunded,
    c.ApplID,
    @system AS [system]
INTO #FLUX
FROM CLM_Latest c
LEFT JOIN UF_Latest u
  ON u.LoadDate = c.LoadDate
 AND u.CreditLineNumber = c.CreditLineNumber;

/* System tagging (date-scoped) */
UPDATE f
SET    [system] = 'Cards'
FROM   #FLUX f
JOIN   #CARDS c
  ON   c.CUST_LINE_NBR = f.CreditLineNumber
 AND   CAST(c.LOADDT AS DATE) = f.LoadDate
WHERE  f.[system] IS NULL;

UPDATE #FLUX SET [system] = 'CFD'            WHERE ApplID IN ('CF')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Lines'    WHERE ApplID IN ('ML')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'Miser Mortgage' WHERE ApplID IN ('MO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'iMX'            WHERE CreditLineNumber LIKE '%iMX%' AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'CBS'            WHERE ApplID IN ('LN')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'UBS'            WHERE ApplID IN ('LO')         AND [system] IS NULL;
UPDATE #FLUX SET [system] = 'LJ'             WHERE ApplID IN ('LJ')         AND [system] IS NULL;

/* Results */
SELECT *
FROM #FLUX;




/* ================= RC_Code Anomaly Detection — PBI-safe (no views, no POWER) ================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages (then restrict) */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 5 PRECEDING AND CURRENT ROW)::FLOAT8  AS fc_ma6,
    AVG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means/SST per window */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE, SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics */
metrics AS (
  SELECT
    x.RC_CODE,
    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM (SELECT DISTINCT RC_CODE FROM idx_tm) x
  LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
  LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
  LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
  LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) In-sample best model (fallback) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality (unchanged from your logic) */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT RC_CODE, AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT RC_CODE, qnum,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
         SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT RC_CODE,
         AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE, q.qnum,
    CASE WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
         ELSE q.avg_q_nospike / a.avg_all_nospike END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q q
  LEFT JOIN seasonal_all a ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE, l.qnum,
    CASE WHEN l.lift_raw IS NULL THEN 1.0
         WHEN l.lift_raw < 0.85 THEN 0.85
         WHEN l.lift_raw > 1.15 THEN 1.15
         ELSE l.lift_raw END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE, f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0))::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36', fc_reg36
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6',   fc_ma6
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12',  fc_ma12
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Attach prev_bal and pos3_count */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residual/MoM stats per (RC,Model) */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,
    CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL
             WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
             ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for PI */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) OOS MSE (last 3 months) */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
/* Pivot OOS to columns to avoid correlated subqueries */
oos_pivot AS (
  SELECT
    RC_CODE,
    MAX(CASE WHEN model='REG12' THEN mse_oos END) AS mse_reg12,
    MAX(CASE WHEN model='REG36' THEN mse_oos END) AS mse_reg36,
    MAX(CASE WHEN model='MA6'   THEN mse_oos END) AS mse_ma6,
    MAX(CASE WHEN model='MA12'  THEN mse_oos END) AS mse_ma12
  FROM oos
  GROUP BY RC_CODE
),
best_model_oos AS (
  SELECT
    m.RC_CODE,
    CASE
      /* prefer regressions only if their R2 gate passes */
      WHEN m.r2_reg12 >= 0.5 AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_reg36,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg12,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG12'
      WHEN m.r2_reg36 >= 0.5 AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma6,9e99))
                               AND (COALESCE(o.mse_reg36,9e99) <= COALESCE(o.mse_ma12,9e99))
        THEN 'REG36'
      /* otherwise choose the better moving average */
      WHEN COALESCE(o.mse_ma6,9e99) <= COALESCE(o.mse_ma12,9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_OOS
  FROM metrics m
  LEFT JOIN oos_pivot o ON o.RC_CODE = m.RC_CODE
),

/* 18) Final model: OOS if present else in-sample */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows with PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    CASE WHEN z.prev_bal IS NULL THEN NULL ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid, z.Z_MoM_Abs, z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 via rank (no percentile func) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT RC_CODE, AbsResid,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT RC_CODE, MoM_Abs,
           ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
           COUNT(*)    OVER (PARTITION BY RC_CODE)                    AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity (robust scaling) */
sev AS (
  SELECT
    f.*,
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - CASE WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0 ELSE s.Severity_Raw END )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier (3 of last 6 months, threshold 70) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code without GREATEST */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= CASE
                               WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0)) THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
                               ELSE ABS(COALESCE(p.MoM_Abs,0.0))
                             END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






/* ======================== RC_Code Anomaly Detection (Enhanced, single query) =========================
   - Models: REG12, REG36, MA6, MA12 with best model chosen by out-of-sample (last 3 months) RMSE,
             falling back to your original in-sample rule if needed.
   - Seasonality: Quarterly lifts from non-spike months, capped & shrunken, damped if recent spikes.
   - Residual / MoM metrics & Z-scores (per RC, per chosen model window).
   - Prediction Intervals: ±1.96 * RMSE (per-RC, per-model).
   - Severity: uses per-RC P95 scale for AbsResid and MoM_Abs (no POWER; no percentile functions).
               P95 is computed via rank logic: the first value at or above 95th percentile.
   - Flags: Persistent outlier (3 of last 6) and Reason_Code for explainability.
   - No views; no POWER().
   ================================================================================================ */

WITH
/* 0) Base */
base AS (
  SELECT
    RC_CODE,
    RC_DESCRIPTION,
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)
),

/* 1) Index and tmax; also prev_bal and Month/Quarter tags */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t
  FROM base b
),
idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum
  FROM idx i
),

/* 2) Evaluation windows */
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),

/* 3) Regression params (grouped) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),
reg36_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n36,
    SUM(t)::FLOAT8         AS sumx36,
    SUM(bal_num)::FLOAT8   AS sumy36,
    SUM(t*bal_num)::FLOAT8 AS sumxy36,
    SUM(t*t)::FLOAT8       AS sumx2_36
  FROM last36
  GROUP BY RC_CODE
),

/* 4) Regression fits over their windows */
reg12_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),
reg36_fit AS (
  SELECT
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,
    CASE
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0
      THEN
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )
      ELSE NULL
    END::FLOAT8 AS fc_reg36
  FROM last36 l
  JOIN reg36_params p USING (RC_CODE)
),

/* 5) Moving averages once, then restrict to windows */
ma_all AS (
  SELECT
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma6,
    AVG(i.bal_num) OVER (
      PARTITION BY i.RC_CODE ORDER BY i.month_end
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    )::FLOAT8 AS fc_ma12
  FROM idx_tm i
),
ma6_last12 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)
  WHERE m.fc_ma6 IS NOT NULL
),
ma12_last36 AS (
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)
  WHERE m.fc_ma12 IS NOT NULL
),

/* 6) Means and SST per window (grouped) */
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),

sst12 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12
  FROM last12 l JOIN mean12 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),
sst36 AS (
  SELECT l.RC_CODE,
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36
  FROM last36 l JOIN mean36 m USING (RC_CODE)
  GROUP BY l.RC_CODE
),

/* 7) SSE + counts per model/window (grouped) */
agg_reg12 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,
         COUNT(*) AS n_reg12
  FROM reg12_fit f
  WHERE f.fc_reg12 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_reg36 AS (
  SELECT f.RC_CODE,
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,
         COUNT(*) AS n_reg36
  FROM reg36_fit f
  WHERE f.fc_reg36 IS NOT NULL
  GROUP BY f.RC_CODE
),
agg_ma6_12 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,
         COUNT(*) AS n_ma6
  FROM ma6_last12 m
  GROUP BY m.RC_CODE
),
agg_ma12_36 AS (
  SELECT m.RC_CODE,
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,
         COUNT(*) AS n_ma12
  FROM ma12_last36 m
  GROUP BY m.RC_CODE
),

/* 8) Metrics (arithmetic only) */
metrics AS (
  SELECT
    x.RC_CODE,

    s12.sst12,  s36.sst36,
    ar12.sse_reg12, ar12.n_reg12,
    ar36.sse_reg36, ar36.n_reg36,
    am6.sse_ma6,    am6.n_ma6,
    am12.sse_ma12,  am12.n_ma12,

    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,

    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,

    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,

    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12
  FROM
    (SELECT DISTINCT RC_CODE FROM idx_tm) x
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE
),

/* 9) Original best-model rule (fallback if OOS cannot be computed) */
best_model_insample AS (
  SELECT
    m.RC_CODE,
    CASE
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG12'
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma6, 9e99)
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)
         <= COALESCE(m.rmse_ma12, 9e99)
      THEN 'REG36'
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'
      ELSE 'MA12'
    END AS Best_Model_InSample
  FROM metrics m
),

/* 10) MoM & spike-aware seasonality */
mom_base AS (
  SELECT
    t.*,
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,
    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)
    END::FLOAT8 AS mom_pct
  FROM idx_tm t
),
mom_stats AS (
  SELECT
    RC_CODE,
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs
  FROM mom_base
  GROUP BY RC_CODE
),
mom_flag AS (
  SELECT
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,
    CASE
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1
      ELSE 0
    END AS is_spike
  FROM mom_base b
  LEFT JOIN mom_stats s USING (RC_CODE)
),
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),
recent_spike AS (
  SELECT f.RC_CODE,
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike
  FROM mom_flag f
  JOIN max_me m USING (RC_CODE)
  GROUP BY f.RC_CODE
),
seasonal_q AS (
  SELECT
    RC_CODE,
    qnum,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q
  FROM mom_flag
  GROUP BY RC_CODE, qnum
),
seasonal_all AS (
  SELECT
    RC_CODE,
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike
  FROM mom_flag
  GROUP BY RC_CODE
),
seasonal_lifts AS (
  SELECT
    q.RC_CODE,
    q.qnum,
    CASE
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0
      ELSE q.avg_q_nospike / a.avg_all_nospike
    END::FLOAT8 AS lift_raw,
    q.n_q
  FROM seasonal_q   q
  LEFT JOIN seasonal_all a
    ON a.RC_CODE = q.RC_CODE
),
seasonal_final AS (
  SELECT
    l.RC_CODE,
    l.qnum,
    CASE
      WHEN l.lift_raw IS NULL THEN 1.0
      WHEN l.lift_raw < 0.85 THEN 0.85
      WHEN l.lift_raw > 1.15 THEN 1.15
      ELSE l.lift_raw
    END::FLOAT8 AS lift_capped,
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight
  FROM seasonal_lifts l
),
seasonal_ready AS (
  SELECT
    f.RC_CODE,
    f.qnum,
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)
          * f.hist_weight * (f.lift_capped - 1.0)
    )::FLOAT8 AS lift_final
  FROM seasonal_final f
  LEFT JOIN recent_spike r USING (RC_CODE)
),

/* 11) Union forecasts by model (limit rows to each model's window) */
fits_union AS (
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL
  UNION ALL
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL
),

/* 12) Apply seasonal lift to forecast */
fits_seasonal AS (
  SELECT
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj
  FROM fits_union u
  LEFT JOIN seasonal_ready s
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum
),

/* 13) Add prev_bal & "active last 3 months" flag */
union_with_prev AS (
  SELECT
    f.*,
    t.prev_bal,
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count
  FROM fits_seasonal f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end
),

/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */
union_enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,

    CASE WHEN x.prev_bal IS NULL THEN NULL
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,

    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS mom_pct_abs,

    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,

    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,
    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct
  FROM union_with_prev x
),

/* 15) Z-scores */
union_with_z AS (
  SELECT
    e.*,
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct
  FROM union_enriched e
),

/* 16) Per-model RMSE for prediction intervals */
rmse_by_model AS (
  SELECT RC_CODE, 'REG12' AS model, rmse_reg12 AS rmse FROM metrics
  UNION ALL SELECT RC_CODE, 'REG36', rmse_reg36 FROM metrics
  UNION ALL SELECT RC_CODE, 'MA6',   rmse_ma6   FROM metrics
  UNION ALL SELECT RC_CODE, 'MA12',  rmse_ma12  FROM metrics
),

/* 17) Out-of-sample (last 3 months of each model) selection */
scored AS (
  SELECT
    z.RC_CODE, z.model, z.month_end, z.bal_num, z.forecast_adj,
    ROW_NUMBER() OVER (PARTITION BY z.RC_CODE, z.model ORDER BY z.month_end DESC) AS rn_desc
  FROM union_with_z z
),
oos AS (
  SELECT
    RC_CODE, model,
    AVG( (bal_num - forecast_adj) * (bal_num - forecast_adj) ) AS mse_oos,
    COUNT(*) AS n_oos
  FROM scored
  WHERE rn_desc <= 3
  GROUP BY RC_CODE, model
),
best_model_oos AS (
  /* Pick lowest OOS MSE, with R2 ≥ 0.5 gates for regressions; else fall back to MA6/MA12 */
  SELECT d.RC_CODE,
         CASE
           WHEN (SELECT r2_reg12 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o1.mse_oos,9e99) FROM oos o1 WHERE o1.RC_CODE=d.RC_CODE AND o1.model='REG12')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='REG36'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG12'

           WHEN (SELECT r2_reg36 FROM metrics m WHERE m.RC_CODE=d.RC_CODE) >= 0.5
             AND (SELECT COALESCE(o2.mse_oos,9e99) FROM oos o2 WHERE o2.RC_CODE=d.RC_CODE AND o2.model='REG36')
                 <= LEAST(
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99),
                       COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
                    )
           THEN 'REG36'

           WHEN COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA6'),9e99)
                <= COALESCE((SELECT mse_oos FROM oos WHERE RC_CODE=d.RC_CODE AND model='MA12'),9e99)
           THEN 'MA6'
           ELSE 'MA12'
         END AS Best_Model_OOS
  FROM (SELECT DISTINCT RC_CODE FROM union_with_z) d
),

/* 18) Choose final best model: OOS if available else in-sample rule */
best_model_final AS (
  SELECT
    i.RC_CODE,
    COALESCE(o.Best_Model_OOS, i.Best_Model_InSample) AS Best_Model
  FROM best_model_insample i
  LEFT JOIN best_model_oos o ON o.RC_CODE = i.RC_CODE
),

/* 19) Final rows for chosen model; attach RMSE and PI */
final AS (
  SELECT
    z.RC_CODE,
    z.RC_DESCRIPTION,
    z.month_end,
    bm.Best_Model,
    z.prev_bal,
    z.forecast_adj       AS Forecast_Selected,
    z.bal_num            AS Actual,
    (z.bal_num - z.forecast_adj)::FLOAT8 AS Resid,
    ABS(z.bal_num - z.forecast_adj)::FLOAT8 AS AbsResid,
    /* MoM absolute & percent (already abs for pct) */
    CASE WHEN z.prev_bal IS NULL THEN NULL
         ELSE ABS(z.bal_num - z.prev_bal) END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN z.prev_bal IS NULL THEN NULL
      WHEN ABS(z.prev_bal) < 1.0 THEN ABS(z.bal_num - z.prev_bal) / 1.0
      ELSE ABS(z.bal_num - z.prev_bal) / ABS(z.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,
    z.Z_Resid,
    z.Z_MoM_Abs,
    z.Z_MoM_Pct,
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos,
    r.rmse,
    /* 95% prediction interval (no POWER) */
    (z.forecast_adj - (1.96 * r.rmse))::FLOAT8 AS PI_Lo,
    (z.forecast_adj + (1.96 * r.rmse))::FLOAT8 AS PI_Hi
  FROM union_with_z z
  JOIN best_model_final bm
    ON bm.RC_CODE = z.RC_CODE AND z.model = bm.Best_Model
  LEFT JOIN rmse_by_model r
    ON r.RC_CODE = z.RC_CODE AND r.model = bm.Best_Model
),

/* 20) Per-RC P95 scales for AbsResid and MoM_Abs (computed via rank, no percentile fn) */
p95_abs AS (
  SELECT RC_CODE,
         MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid)                      AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                         AS n
    FROM final
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),
p95_mom AS (
  SELECT RC_CODE,
         MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs)                        AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                                          AS n
    FROM final
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 21) Severity using robust (per-RC) P95 scales */
sev AS (
  SELECT
    f.*,
    /* robust components: guard denominators with NULLIF */
    ( 0.25 * ( f.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
    + 0.65 * ABS(f.Z_Resid)
    + 0.07 * ABS(f.Z_MoM_Abs)
    + 0.03 * ( f.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM final f
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = f.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = f.RC_CODE
),
sev_scaled AS (
  /* Exponential squash to 0..100; no POWER used */
  SELECT
    s.*,
    ROUND(100.0 * (1.0 - EXP( - GREATEST(0.0, COALESCE(s.Severity_Raw,0.0)) )), 0)::INTEGER AS Severity_0_100
  FROM sev s
),

/* 22) Persistent outlier: 3 of last 6 months (threshold 70, adjust as needed) */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),
pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 23) Reason code (simple dominance logic) */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >= GREATEST(ABS(COALESCE(p.Z_MoM_Abs,0.0)), ABS(COALESCE(p.MoM_Abs,0.0))) THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2 THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL AND p95m.p95_mom_abs IS NOT NULL AND p.MoM_Abs > p95m.p95_mom_abs THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = p.RC_CODE
)

SELECT
  RC_CODE,
  RC_DESCRIPTION,
  month_end,
  Best_Model,
  Forecast_Selected,
  Actual,
  Resid,
  AbsResid,
  MoM_Abs,
  MoM_Pct_Abs,
  Z_Resid,
  Z_MoM_Abs,
  Z_MoM_Pct,
  rmse,
  PI_Lo,
  PI_Hi,
  Severity_0_100,
  Persistent_Outlier_3of6,
  Reason_Code
FROM reasoned
ORDER BY RC_CODE, month_end;






--QUERY 1										
/* ======================== RC_Code Anomaly Detection =========================										
   - Runs Seasonally Adjusted Regression (12mo, 36mo) and Moving Average (6mo, 12mo), selecting model w/ best fit										
   - Assigns severity score based on various Z-Scores and materiality										
   ============================================================================ */										
WITH										
/* 0) Base */										
base AS (										
  SELECT										
    RC_CODE,										
    RC_DESCRIPTION,										
    CAST(END_OF_MONTH_DATE AS DATE)      AS month_end,										
    SUM(SOURCE_SYSTEM_BALANCE)::FLOAT8   AS bal_num										
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB										
  WHERE SOURCE_SYSTEM_BALANCE IS NOT NULL										
    AND GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'										
  GROUP BY RC_CODE, RC_DESCRIPTION, CAST(END_OF_MONTH_DATE AS DATE)										
),										
										
/* 1) Index and tmax; also prev_bal and Month/Quarter tags */										
idx AS (										
  SELECT										
    b.*,										
    ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY month_end) AS t										
  FROM base b										
),										
idx_tm AS (										
  SELECT										
    i.*,										
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,										
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,										
    EXTRACT(MONTH   FROM i.month_end)::INT AS mnum,										
    ((EXTRACT(MONTH FROM i.month_end)::INT + 2) / 3)::INT AS qnum										
  FROM idx i										
),										
										
/* 2) Evaluation windows */										
last12 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 11 ),										
last36 AS ( SELECT * FROM idx_tm WHERE t >= tmax - 35 ),										
										
/* 3) Regression params (grouped) */										
reg12_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n12,										
    SUM(t)::FLOAT8           AS sumx12,										
    SUM(bal_num)::FLOAT8     AS sumy12,										
    SUM(t*bal_num)::FLOAT8   AS sumxy12,										
    SUM(t*t)::FLOAT8         AS sumx2_12										
  FROM last12										
  GROUP BY RC_CODE										
),										
reg36_params AS (										
  SELECT										
    RC_CODE,										
    COUNT(*)                 AS n36,										
    SUM(t)::FLOAT8           AS sumx36,										
    SUM(bal_num)::FLOAT8     AS sumy36,										
    SUM(t*bal_num)::FLOAT8   AS sumxy36,										
    SUM(t*t)::FLOAT8         AS sumx2_36										
  FROM last36										
  GROUP BY RC_CODE										
),										
										
/* 4) Regression fits over their windows */										
reg12_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0										
      THEN										
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t										
        + ( (p.sumy12/p.n12) - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12) / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * (p.sumx12/p.n12) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg12										
  FROM last12 l										
  JOIN reg12_params p USING (RC_CODE)										
),										
reg36_fit AS (										
  SELECT										
    l.RC_CODE, l.month_end, l.RC_DESCRIPTION, l.bal_num, l.t, l.qnum,										
    CASE										
      WHEN p.n36 >= 2 AND (p.n36*p.sumx2_36 - p.sumx36*p.sumx36) <> 0										
      THEN										
        ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * l.t										
        + ( (p.sumy36/p.n36) - ((p.n36*p.sumxy36 - p.sumx36*p.sumy36) / (p.n36*p.sumx2_36 - p.sumx36*p.sumx36)) * (p.sumx36/p.n36) )										
      ELSE NULL										
    END::FLOAT8 AS fc_reg36										
  FROM last36 l										
  JOIN reg36_params p USING (RC_CODE)										
),										
										
/* 5) Moving averages once, then restrict to windows */										
ma_all AS (										
  SELECT										
    i.RC_CODE, i.month_end, i.RC_DESCRIPTION, i.bal_num, i.t, i.tmax, i.prev_bal, i.qnum,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma6,										
    AVG(i.bal_num) OVER (										
      PARTITION BY i.RC_CODE ORDER BY i.month_end										
      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW										
    )::FLOAT8 AS fc_ma12										
  FROM idx_tm i										
),										
ma6_last12 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma6										
  FROM ma_all m JOIN last12 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma6 IS NOT NULL										
),										
ma12_last36 AS (										
  SELECT m.RC_CODE, m.month_end, m.RC_DESCRIPTION, m.bal_num, m.t, m.prev_bal, m.qnum, m.fc_ma12										
  FROM ma_all m JOIN last36 l USING (RC_CODE, month_end)										
  WHERE m.fc_ma12 IS NOT NULL										
),										
										
/* 6) Means and SST per window (grouped) */										
mean12 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y12 FROM last12 GROUP BY RC_CODE ),										
mean36 AS ( SELECT RC_CODE, AVG(bal_num)::FLOAT8 AS mean_y36 FROM last36 GROUP BY RC_CODE ),										
										
sst12 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y12) * (l.bal_num - m.mean_y12) )::FLOAT8 AS sst12										
  FROM last12 l JOIN mean12 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
sst36 AS (										
  SELECT l.RC_CODE,										
         SUM( (l.bal_num - m.mean_y36) * (l.bal_num - m.mean_y36) )::FLOAT8 AS sst36										
  FROM last36 l JOIN mean36 m USING (RC_CODE)										
  GROUP BY l.RC_CODE										
),										
										
/* 7) SSE + counts per model/window (grouped) */										
agg_reg12 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg12) * (f.bal_num - f.fc_reg12) )::FLOAT8 AS sse_reg12,										
         COUNT(*) AS n_reg12										
  FROM reg12_fit f										
  WHERE f.fc_reg12 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_reg36 AS (										
  SELECT f.RC_CODE,										
         SUM( (f.bal_num - f.fc_reg36) * (f.bal_num - f.fc_reg36) )::FLOAT8 AS sse_reg36,										
         COUNT(*) AS n_reg36										
  FROM reg36_fit f										
  WHERE f.fc_reg36 IS NOT NULL										
  GROUP BY f.RC_CODE										
),										
agg_ma6_12 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma6) * (m.bal_num - m.fc_ma6) )::FLOAT8 AS sse_ma6,										
         COUNT(*) AS n_ma6										
  FROM ma6_last12 m										
  GROUP BY m.RC_CODE										
),										
agg_ma12_36 AS (										
  SELECT m.RC_CODE,										
         SUM( (m.bal_num - m.fc_ma12) * (m.bal_num - m.fc_ma12) )::FLOAT8 AS sse_ma12,										
         COUNT(*) AS n_ma12										
  FROM ma12_last36 m										
  GROUP BY m.RC_CODE										
),										
										
/* 8) Metrics (arithmetic only) */										
metrics AS (										
  SELECT										
    x.RC_CODE,										
										
    s12.sst12,  s36.sst36,										
    ar12.sse_reg12, ar12.n_reg12,										
    ar36.sse_reg36, ar36.n_reg36,										
    am6.sse_ma6,    am6.n_ma6,										
    am12.sse_ma12,  am12.n_ma12,										
										
    CASE WHEN ar12.n_reg12 > 1 THEN SQRT(ar12.sse_reg12 / ar12.n_reg12) ELSE NULL END AS rmse_reg12,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - ar12.sse_reg12 / s12.sst12     ELSE NULL END AS r2_reg12,										
										
    CASE WHEN ar36.n_reg36 > 1 THEN SQRT(ar36.sse_reg36 / ar36.n_reg36) ELSE NULL END AS rmse_reg36,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - ar36.sse_reg36 / s36.sst36     ELSE NULL END AS r2_reg36,										
										
    CASE WHEN am6.n_ma6    > 1 THEN SQRT(am6.sse_ma6   / am6.n_ma6)     ELSE NULL END AS rmse_ma6,										
    CASE WHEN s12.sst12   > 0 THEN 1.0 - am6.sse_ma6   / s12.sst12      ELSE NULL END AS r2_ma6,										
										
    CASE WHEN am12.n_ma12  > 1 THEN SQRT(am12.sse_ma12 / am12.n_ma12)   ELSE NULL END AS rmse_ma12,										
    CASE WHEN s36.sst36   > 0 THEN 1.0 - am12.sse_ma12 / s36.sst36      ELSE NULL END AS r2_ma12										
  FROM										
    (SELECT DISTINCT RC_CODE FROM idx_tm) x										
    LEFT JOIN sst12 s12          ON s12.RC_CODE = x.RC_CODE										
    LEFT JOIN sst36 s36          ON s36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg12 ar12     ON ar12.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_reg36 ar36     ON ar36.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma6_12 am6     ON am6.RC_CODE = x.RC_CODE										
    LEFT JOIN agg_ma12_36 am12   ON am12.RC_CODE = x.RC_CODE										
),										
										
/* 9) Best model pick (no aggregates) */										
best_model AS (										
  SELECT										
    m.RC_CODE,										
    CASE										
      WHEN (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg12 IS NOT NULL AND m.r2_reg12 >= 0.5 THEN m.rmse_reg12 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG12'										
      WHEN (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma6, 9e99)										
       AND (CASE WHEN m.r2_reg36 IS NOT NULL AND m.r2_reg36 >= 0.5 THEN m.rmse_reg36 ELSE 9e99 END)										
         <= COALESCE(m.rmse_ma12, 9e99)										
      THEN 'REG36'										
      WHEN COALESCE(m.rmse_ma6, 9e99) <= COALESCE(m.rmse_ma12, 9e99) THEN 'MA6'										
      ELSE 'MA12'										
    END AS Best_Model										
  FROM metrics m										
),										
										
/* 10) --- Robust seasonality: compute spike-aware quarterly lifts --- */										
										
/* 10a) Build MoM (on full series) and spike flags per RC */										
mom_base AS (										
  SELECT										
    t.*,										
    CASE WHEN t.prev_bal IS NULL THEN NULL ELSE (t.bal_num - t.prev_bal) END::FLOAT8 AS mom_abs,										
    CASE										
      WHEN t.prev_bal IS NULL THEN NULL										
      WHEN ABS(t.prev_bal) < 1.0 THEN (t.bal_num - t.prev_bal) / 1.0										
      ELSE (t.bal_num - t.prev_bal) / NULLIF(t.prev_bal,0)										
    END::FLOAT8 AS mom_pct										
  FROM idx_tm t										
),										
mom_stats AS (										
  SELECT										
    RC_CODE,										
    AVG(ABS(mom_abs))::FLOAT8 AS mean_mom_abs										
  FROM mom_base										
  GROUP BY RC_CODE										
),										
mom_flag AS (										
  /* spike = big percentage change OR big absolute jump relative to typical */										
  SELECT										
    b.RC_CODE, b.month_end, b.qnum, b.bal_num,										
    CASE										
      WHEN b.mom_pct IS NOT NULL AND ABS(b.mom_pct) >= 0.40 THEN 1										
      WHEN s.mean_mom_abs IS NOT NULL AND b.mom_abs IS NOT NULL AND ABS(b.mom_abs) >= 3.0 * s.mean_mom_abs THEN 1										
      ELSE 0										
    END AS is_spike										
  FROM mom_base b										
  LEFT JOIN mom_stats s USING (RC_CODE)										
),										
/* 10b) recent spike signal (last 6 months relative to series max month) */										
max_me AS ( SELECT RC_CODE, MAX(month_end) AS max_me FROM idx_tm GROUP BY RC_CODE ),										
recent_spike AS (										
  SELECT f.RC_CODE,										
         MAX(CASE WHEN f.month_end >= ADD_MONTHS(m.max_me, -5) AND f.is_spike = 1 THEN 1 ELSE 0 END) AS has_recent_spike										
  FROM mom_flag f										
  JOIN max_me m USING (RC_CODE)										
  GROUP BY f.RC_CODE										
),										
										
/* 10c) Seasonal lifts per RC×Quarter using NON-spike months (revised) */										
seasonal_q AS (										
  SELECT										
    RC_CODE,										
    qnum,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_q_nospike,										
    SUM(CASE WHEN is_spike = 0 THEN 1 ELSE 0 END)                  AS n_q										
  FROM mom_flag										
  GROUP BY RC_CODE, qnum										
),										
seasonal_all AS (										
  SELECT										
    RC_CODE,										
    AVG(CASE WHEN is_spike = 0 THEN bal_num ELSE NULL END)::FLOAT8 AS avg_all_nospike										
  FROM mom_flag										
  GROUP BY RC_CODE										
),										
seasonal_lifts AS (										
  SELECT										
    q.RC_CODE,										
    q.qnum,										
    /* raw lift */										
    CASE										
      WHEN a.avg_all_nospike IS NULL OR a.avg_all_nospike = 0 THEN 1.0										
      ELSE q.avg_q_nospike / a.avg_all_nospike										
    END::FLOAT8 AS lift_raw,										
    q.n_q										
  FROM seasonal_q   q										
  LEFT JOIN seasonal_all a										
    ON a.RC_CODE = q.RC_CODE										
),										
										
/* 10d) Cap & shrink lifts; shrink more if few points or recent spikes (unchanged) */										
seasonal_final AS (										
  SELECT										
    l.RC_CODE,										
    l.qnum,										
    /* cap to [0.85, 1.15] */										
    CASE										
      WHEN l.lift_raw IS NULL THEN 1.0										
      WHEN l.lift_raw < 0.85 THEN 0.85										
      WHEN l.lift_raw > 1.15 THEN 1.15										
      ELSE l.lift_raw										
    END::FLOAT8 AS lift_capped,										
    /* history-based shrink 0..1 (min points to fully trust ≈ 8) */										
    LEAST(1.0, COALESCE(l.n_q,0)/8.0)::FLOAT8 AS hist_weight										
  FROM seasonal_lifts l										
),										
seasonal_ready AS (										
  SELECT										
    f.RC_CODE,										
    f.qnum,										
    /* extra damp if recent spikes: halve the effect */										
    (1.0 + (CASE WHEN r.has_recent_spike = 1 THEN 0.5 ELSE 1.0 END)										
          * f.hist_weight * (f.lift_capped - 1.0)										
    )::FLOAT8 AS lift_final										
  FROM seasonal_final f										
  LEFT JOIN recent_spike r USING (RC_CODE)										
),										
/* 11) Union forecasts by model (limit rows to each model's window) */										
fits_union AS (										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG12' AS model, fc_reg12 AS forecast										
  FROM reg12_fit WHERE fc_reg12 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'REG36' AS model, fc_reg36 AS forecast										
  FROM reg36_fit WHERE fc_reg36 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA6'   AS model, fc_ma6   AS forecast										
  FROM ma6_last12 WHERE fc_ma6 IS NOT NULL										
  UNION ALL										
  SELECT RC_CODE, month_end, RC_DESCRIPTION, bal_num, qnum, 'MA12'  AS model, fc_ma12  AS forecast										
  FROM ma12_last36 WHERE fc_ma12 IS NOT NULL										
),										
										
/* 12) Apply seasonal lift to forecast */										
fits_seasonal AS (										
  SELECT										
    u.RC_CODE, u.month_end, u.RC_DESCRIPTION, u.bal_num, u.qnum, u.model,										
    (u.forecast * COALESCE(s.lift_final, 1.0))::FLOAT8 AS forecast_adj										
  FROM fits_union u										
  LEFT JOIN seasonal_ready s										
    ON s.RC_CODE = u.RC_CODE AND s.qnum = u.qnum										
),										
										
/* 13) Add prev_bal & "active last 3 months" flag */										
union_with_prev AS (										
  SELECT										
    f.*,										
    t.prev_bal,										
    SUM(CASE WHEN t.bal_num > 0 THEN 1 ELSE 0 END)										
      OVER (PARTITION BY t.RC_CODE ORDER BY t.month_end ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS pos3_count										
  FROM fits_seasonal f										
  JOIN idx_tm t										
    ON t.RC_CODE = f.RC_CODE AND t.month_end = f.month_end										
),										
										
/* 14) Residuals, MoM, per (RC,Model) stats based on seasonally adjusted forecast */										
union_enriched AS (										
  SELECT										
    x.*,										
    (x.bal_num - x.forecast_adj)::FLOAT8 AS resid,										
    ABS(x.bal_num - x.forecast_adj)::FLOAT8 AS abs_resid,										
										
    CASE WHEN x.prev_bal IS NULL THEN NULL										
         ELSE ABS(x.bal_num - x.prev_bal) END::FLOAT8 AS mom_abs,										
										
    CASE										
      WHEN x.prev_bal IS NULL THEN NULL										
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
    END::FLOAT8 AS mom_pct_abs,										
										
    AVG(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_abs_resid,										
    STDDEV_SAMP(ABS(x.bal_num - x.forecast_adj)) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_abs_resid,										
										
    AVG(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_abs,										
    STDDEV_SAMP(CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END)										
      OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_abs,										
										
    AVG(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS mean_mom_pct,										
    STDDEV_SAMP(										
      CASE										
        WHEN x.prev_bal IS NULL THEN NULL										
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0										
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)										
      END										
    ) OVER (PARTITION BY x.RC_CODE, x.model) AS sd_mom_pct										
  FROM union_with_prev x										
),										
										
/* 15) Z-scores */										
union_with_z AS (										
  SELECT										
    e.*,										
    CASE WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0										
         ELSE (e.abs_resid - e.mean_abs_resid) / e.sd_abs_resid END::FLOAT8 AS Z_Resid,										
    CASE WHEN e.sd_mom_abs   IS NULL OR e.sd_mom_abs   = 0 THEN 0										
         ELSE (e.mom_abs   - e.mean_mom_abs)   / e.sd_mom_abs   END::FLOAT8 AS Z_MoM_Abs,										
    CASE WHEN e.sd_mom_pct   IS NULL OR e.sd_mom_pct   = 0 THEN 0										
         ELSE (e.mom_pct_abs - e.mean_mom_pct) / e.sd_mom_pct   END::FLOAT8 AS Z_MoM_Pct										
  FROM union_enriched e										
),										
										
/* 16) Portfolio-wide scales for severity */										
port_scales AS (										
  SELECT										
    MAX(abs_resid) AS max_abs_resid,										
    MAX(mom_abs)   AS max_mom_abs										
  FROM union_with_z										
),										
										
/* 17) Best model decided earlier; join and return FULL history inside chosen window */										
final AS (										
  SELECT										
    z.RC_CODE,										
    z.RC_DESCRIPTION,										
    z.month_end,										
    bm.Best_Model,										
    z.prev_bal,										
    z.forecast_adj       AS Forecast_Selected,										
    z.bal_num            AS Actual,										
    z.resid              AS Resid,										
    z.abs_resid          AS AbsResid,										
    z.mom_abs            AS MoM_Abs,										
    z.mom_pct_abs        AS MoM_Pct_Abs,										
    z.Z_Resid,										
    z.Z_MoM_Abs,										
    z.Z_MoM_Pct,										
    CASE WHEN z.pos3_count >= 1 THEN 1 ELSE 0 END AS Include3_AnyPos										
  FROM union_with_z z										
  JOIN best_model bm										
    ON bm.RC_CODE = z.RC_CODE										
  WHERE z.model = bm.Best_Model										
)										
										
SELECT										
  f.*,										
  /* Severity emphasizing AbsResid and Z_Resid */										
  (										
    0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
  + 0.65 * ABS(f.Z_Resid)										
  + 0.07 * ABS(f.Z_MoM_Abs)										
  + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
  )::FLOAT8 AS Severity_Raw,										
										
  ROUND(										
    100.0 * (1.0 - EXP(										
      -(										
        0.25 * ( f.AbsResid / NULLIF(ps.max_abs_resid,0) )										
      + 0.65 * ABS(f.Z_Resid)										
      + 0.07 * ABS(f.Z_MoM_Abs)										
      + 0.03 * ( f.MoM_Abs / NULLIF(ps.max_mom_abs,0) )										
      )										
    )),										
0										
  )::INTEGER AS Severity_0_100										
FROM final f										
CROSS JOIN port_scales ps										
ORDER BY f.RC_CODE, f.month_end;										





import pandas as pd
import numpy as np

# Read the whole table (headers + data) via the named range
raw = xl("KDE_Clean_all").copy()

# Promote first row to headers
header = raw.iloc[0].astype(str).tolist()
df = raw.iloc[1:].copy()
df.columns = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header]

# Sanity check
print("rows:", len(df))
print("cols:", list(df.columns))

# Types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# Rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple slope
    t = np.arange(len(g), dtype=float); y = g["exp_changed"].astype(float).to_numpy()
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c, y_c = t - t.mean(), y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c*y_c).sum()/denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)
df_feat





import pandas as pd

df = xl("KDE_Clean").copy()
print("rows:", len(df))
print("columns:", list(df.columns))
df.head()



import pandas as pd
import numpy as np

df = xl("KDE_Clean").copy()
# normalize in case of variations
df.columns = [str(c).strip().lower().replace(" ", "_") for c in df.columns]

# required
for col in ["kde_name","this_eom","exp_changed"]:
    if col not in df.columns:
        raise KeyError(f"Missing column: {col}. Got: {list(df.columns)}")

# types
df["this_eom"]    = pd.to_datetime(df["this_eom"], errors="coerce")
df["exp_changed"] = pd.to_numeric(df["exp_changed"], errors="coerce")

# rolling features per KDE
def add_roll(g):
    g = g.sort_values("this_eom").copy()
    g["exp_changed_ma12"] = g["exp_changed"].rolling(12, min_periods=3).mean()
    g["exp_changed_sd12"] = g["exp_changed"].rolling(12, min_periods=3).std(ddof=0)
    g["exp_changed_z12"]  = (g["exp_changed"] - g["exp_changed_ma12"]) / g["exp_changed_sd12"]
    # simple OLS slope (no sklearn): slope = cov(t,y)/var(t)
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].to_numpy(dtype=float)
    if len(g) >= 2 and np.isfinite(y).sum() >= 2:
        t_c = t - t.mean()
        y_c = y - np.nanmean(y)
        denom = (t_c**2).sum()
        slope = float((t_c * y_c).sum() / denom) if denom else np.nan
    else:
        slope = np.nan
    g["exp_changed_trend_slope"] = slope
    return g

df_feat = df.groupby("kde_name", group_keys=False).apply(add_roll).reset_index(drop=True)

# return full table; convert to an Excel Table named KDE_Features after it renders
df_feat




import pandas as pd

# get data body
dat = xl("KDE_Summary3").copy()

# get header row from the new named range
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols
print("rows:", len(dat), "| cols:", cols)
dat




import pandas as pd

# data body (no headers) comes from the table name
dat = xl("KDE_Summary3").copy()

# headers come from the named range you just created
hdr = xl("KDE_Summary3_headers").copy()
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

dat.columns = cols

print("rows:", len(dat), "| cols:", cols)
dat  # returns full table with proper headers




import pandas as pd

TBL = "KDE_Summary3"   # exact Table Name from Table Design

# Read the header row and the data body separately
hdr = xl(f"{TBL}[#Headers]").copy()
dat = xl(f"{TBL}[#Data]").copy()

# Convert the single header row to a list of strings, then clean the names
header_row = hdr.iloc[0].astype(str).tolist()
cols = [h.replace("\n"," ").strip().lower().replace(" ", "_") for h in header_row]

# Apply headers to the data body
dat.columns = cols

# Show a quick summary and the FULL dataframe (no .head/.tail)
print("rows:", len(dat), "cols:", cols)
dat





import pandas as pd
df = xl("KDE_Summary3").copy()
print(list(df.columns))
df.head(3)




tbl = "KDE_Summary3[#All]"   # note the [#All]
df = xl(tbl).copy()
print(df.shape, list(df.columns))


df = xl("KDE_Summary3").copy()




import pandas as pd

tbl = "KDE_Summary3"  # <-- make sure this matches Table Design > Table Name exactly
df = xl(tbl).copy()

print("shape:", df.shape)
print("columns (as Excel passes them):", list(df.columns))
df.head(3)



Error:Python
KeyError: "Couldn't find a KDE identifier column. Expected one of ['kde_name', 'kde', 'key_data_element', 'field_name', 'attribute_name', 'attribute']. Got: ['next_rate_change_date', '2025-09-30_00:00:00', '71809863129.06', '100970', '0.583402', '173071', '171867', '-1204', '-0.006957', '92887577678.95', '93253920099.4', '366342420.45', '0.003944', '-1085822458.44966', '70338547296.7333', '7053855244.00191', '0.208583218882717', '1']"





import pandas as pd
import numpy as np

df_raw = xl("KDE_Summary").copy()
print("raw rows:", len(df_raw))

# If headers came through as numbers, promote first row to headers
if all(isinstance(c, (int, float)) for c in df_raw.columns):
    header = df_raw.iloc[0].tolist()
    df = df_raw.iloc[1:].copy()
    df.columns = [str(x).strip() if pd.notna(x) else f"col_{i}" for i, x in enumerate(header)]
else:
    df = df_raw.copy()

# normalize headers
def norm(c): return str(c).replace("\n"," ").strip().lower().replace(" ", "_")
df.columns = [norm(c) for c in df.columns]
print("normalized columns:", list(df.columns))
print("rows after normalization:", len(df))

# find key columns
kde_candidates  = ["kde_name","kde","key_data_element","field_name","attribute_name","attribute"]
date_candidates = ["this_eom","end_of_month_date","end_of_month","month_end","eom","eom_date","as_of_eom","as_of_date"]

kde_col  = next((c for c in kde_candidates if c in df.columns), None)
date_col = next((c for c in date_candidates if c in df.columns), None)

if kde_col is None:
    raise KeyError(f"Couldn't find a KDE identifier column. Expected one of {kde_candidates}. Got: {list(df.columns)}")

if date_col is None:
    # try auto-detect a date-like column
    for c in df.columns:
        s = pd.to_datetime(df[c], errors="coerce")
        if s.notna().sum() >= max(3, int(0.5*len(s))):
            df["this_eom"] = s
            date_col = "this_eom"
            break
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

# type-cast numerics where present
for c in ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# sort for readability
df = df.sort_values([kde_col, "this_eom"]).reset_index(drop=True)

print("kde column:", kde_col, "| date column:", "this_eom")
print("final row count:", len(df))

# IMPORTANT: return the full DataFrame (no .head() / .tail())
df





import pandas as pd
import numpy as np

# ---- 1) Load the Excel table ----
# If your table name isn't KDE_Summary, change it here:
df = xl("KDE_Summary").copy()

# Show raw headers (helps debugging)
print("Raw columns:", list(df.columns))

# ---- 2) Normalize headers safely (handles non-string headers) ----
def to_str(x):
    try:
        return "_".join(map(str, x)).strip() if isinstance(x, tuple) else str(x).strip()
    except Exception:
        return str(x)

df.columns = [to_str(c) for c in df.columns]
df.columns = [c.replace("\n"," ") for c in df.columns]  # remove line breaks from header cells
df.columns = [c.lower().replace(" ", "_") for c in df.columns]

print("Normalized columns:", list(df.columns))

# ---- 3) Find the EOM/date column (handles THIS_EOM and common aliases) ----
aliases = [
    "this_eom","end_of_month_date","end_of_month","month_end",
    "eom","eom_date","as_of_eom","as_of_date","report_eom"
]
date_col = next((c for c in aliases if c in df.columns), None)

# If not found by name, try to detect a date-like column
if date_col is None:
    name_candidates = [c for c in df.columns if any(k in c for k in ["date","eom","month"])]
    parsed = []
    for c in name_candidates + list(df.columns):
        try:
            s = pd.to_datetime(df[c], errors="coerce")
            if s.notna().sum() >= max(3, int(0.5*len(s))):  # at least half the rows look like dates
                parsed.append((c, s))
        except Exception:
            pass
    if parsed:
        date_col, s = parsed[0]
        df["this_eom"] = s
    else:
        raise KeyError(f"Could not find a date column to use as 'this_eom'. "
                       f"Available columns: {list(df.columns)}")
else:
    df["this_eom"] = pd.to_datetime(df[date_col], errors="coerce")

print("Using date column as this_eom:", date_col)

# ---- 4) Make sure key numeric columns are numeric (skip if absent) ----
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

# ---- 5) Sort & preview ----
key_name = "kde_name" if "kde_name" in df.columns else (next((c for c in df.columns if "kde" in c and "name" in c), None))
if key_name is None:
    print("Warning: couldn't find KDE name column (expected 'KDE_NAME'). Continuing without it.")
    df = df.sort_values(["this_eom"]).reset_index(drop=True)
else:
    df = df.sort_values([key_name, "this_eom"]).reset_index(drop=True)

df.tail(10)



import pandas as pd
import numpy as np

df = xl("KDE_Summary").copy()

# convert all headers to lowercase
df.columns = [c.lower() for c in df.columns]

# now you can safely reference 'this_eom'
df['this_eom'] = pd.to_datetime(df['this_eom'], errors='coerce')

# continue with your numeric conversions, sorting, etc.
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct",
            "exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["kde_name","this_eom"]).reset_index(drop=True)
df.tail(10)




import pandas as pd
import numpy as np

# Pull the Excel table into pandas
df = xl("KDE_Summary").copy()

# Basic typing & ordering
df["this_eom"] = pd.to_datetime(df["this_eom"])
num_cols = ["exp_changed","cnt_changed","cnt_changed_pct","exp_prev","exp_curr","exp_mom_delta","exp_mom_pct"]
for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.sort_values(["KDE_NAME","this_eom"]).reset_index(drop=True)

# Show a peek
df.tail(10)





import matplotlib.pyplot as plt

kde = xl("SelectedKDE") if "SelectedKDE" in dir() else None
if not kde:
    kde = df_feat["KDE_NAME"].iloc[0]

g = df_feat[df_feat["KDE_NAME"]==kde].sort_values("this_eom")

plt.figure()
plt.plot(g["this_eom"], g["exp_changed"], label="exp_changed")
if g["exp_changed_ma12"].notna().any():
    plt.plot(g["this_eom"], g["exp_changed_ma12"], linestyle=":", label="MA12")
# add a straight trend line from the slope if you want a visual guide
if len(g) >= 2 and np.isfinite(g["exp_changed"]).sum() >= 2:
    t = np.arange(len(g), dtype=float)
    y = g["exp_changed"].astype(float).values
    # reconstruct fit using mean-centered form with the slope we computed
    slope = g["exp_changed_trend_slope"].iloc[-1]
    y_hat = (t - t.mean()) * slope + np.nanmean(y)
    plt.plot(g["this_eom"], y_hat, linestyle="--", label="trend")

plt.title(f"{kde} — exp_changed, MA12 & trend")
plt.xlabel("Month End")
plt.ylabel("Exposure changed")
plt.legend()
plt.tight_layout()





import pandas as pd
from sklearn.linear_model import LinearRegression

df = dataset
df = df.groupby('KDE_NAME', as_index=False)['exp_changed'].mean()
model = LinearRegression().fit(df.index.values.reshape(-1,1), df['exp_changed'])
df['trend'] = model.coef_[0]






-- HISTORY + TRENDS (Netezza-safe, no POWER(), no analytic REGR_*)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)

WITH
params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

/* Month index across the window and its prior month */
months AS (
  SELECT DISTINCT t.End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date) AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

/* Base pull: choose exposure and carry all KDEs */
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

/* UNPIVOT via UNION ALL, cast all KDEs to VARCHAR to align types */
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

/* Pair each current month with its previous month using months_seq */
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m
    ON l.End_of_Month_Date = m.End_of_Month_Date
),

/* Compare prev vs curr at (Account, KDE, month) grain */
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

/* Row-level flags and attributions */
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,
    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,
    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,
    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

/* Monthly KDE rollups */
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom) AS this_eom,
    SUM(changed_flag) AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag) AS cnt_prev,
    SUM(curr_flag) AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END) AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END) AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

/* MoM metrics per KDE per month */
metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

/* Linear trend slope of exp_changed across the window (per KDE) — no POWER() */
trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
            - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION)))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(t_idx AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(t_idx AS DOUBLE PRECISION))) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

/* Rolling 12-means and stdev for exp_changed (uses multiplications, no POWER()) */
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - (
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          *
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(CAST(exp_changed AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - (
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            *
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),

/* Join trend + rolling stats back to monthly metrics */
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

/* Latest month only + ranking */
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  /* ranking keys */
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  /* MoM context */
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  /* trend context */
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;



base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,
    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
  WHERE t.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'     -- 🔹 added filter
),






trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
            - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION))) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION))) 
          - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), CAST(2.0 AS DOUBLE PRECISION)) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),




rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            CAST(2.0 AS DOUBLE PRECISION)
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), CAST(2.0 AS DOUBLE PRECISION)))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              CAST(2.0 AS DOUBLE PRECISION)
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),




[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(FLOAT8, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





trend_all AS (
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM(CAST(t_idx AS DOUBLE PRECISION) * CAST(exp_changed AS DOUBLE PRECISION))
          - (SUM(CAST(t_idx AS DOUBLE PRECISION)) * SUM(CAST(exp_changed AS DOUBLE PRECISION))) )
        /
        ( COUNT(*) * SUM(POWER(CAST(t_idx AS DOUBLE PRECISION), 2)) - POWER(SUM(CAST(t_idx AS DOUBLE PRECISION)), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(CAST(exp_changed AS DOUBLE PRECISION))
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    CASE
      WHEN (
        AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
          OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
        - POWER(
            AVG(CAST(exp_changed AS DOUBLE PRECISION))
              OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
            2
          )
      ) < 0
        THEN 0
      ELSE
        SQRT(
          AVG(POWER(CAST(exp_changed AS DOUBLE PRECISION), 2))
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(CAST(exp_changed AS DOUBLE PRECISION))
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW),
              2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'POWER(NUMERIC, INT4)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts






-- ***** REPLACE trend_all CTE *****
trend_all AS (
  /* slope = Cov(x,y) / Var(x)
     = ( n*Σ(xy) - Σx*Σy ) / ( n*Σ(x^2) - (Σx)^2 ) */
  SELECT
    KDE_NAME,
    CASE
      WHEN (COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2)) = 0
        THEN NULL
      ELSE
        ( COUNT(*) * SUM( (t_idx*1.0) * (exp_changed*1.0) )
          - (SUM(t_idx*1.0) * SUM(exp_changed*1.0)) )
        /
        ( COUNT(*) * SUM( (t_idx*1.0)*(t_idx*1.0) ) - POWER(SUM(t_idx*1.0), 2) )
    END AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),


-- ***** REPLACE rolling_stats CTE *****
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,

    /* rolling mean over last 12 (or fewer for early months) */
    AVG(exp_changed*1.0)
      OVER (PARTITION BY KDE_NAME ORDER BY t_idx
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,

    /* rolling stdev using sqrt(E[x^2] - (E[x])^2) */
    CASE
      WHEN
        ( AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        ) < 0
        THEN 0  -- guard against tiny negative from floating error
      ELSE
        SQRT(
          AVG( (exp_changed*1.0)*(exp_changed*1.0) )
            OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                  ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
          - POWER(
              AVG(exp_changed*1.0)
                OVER (PARTITION BY KDE_NAME ORDER BY t_idx
                      ROWS BETWEEN 11 PRECEDING AND CURRENT ROW), 2
            )
        )
    END AS exp_changed_sd12
  FROM metrics_monthly
),





[Code: 1100, SQL State: HY000]  ERROR:  Function 'REGR_SLOPE(NUMERIC, NUMERIC)' does not exist
	Unable to identify a function that satisfies the given argument types
	You may need to add explicit typecasts





-- KDE Changes-Only History + Trend (Netezza-safe, patched)
-- Ranking: 1) exp_changed DESC, 2) cnt_changed_pct DESC (NULLs last)
-- Window: set your start/end month-ends below

WITH params AS (
  SELECT
    DATE '2025-01-31' AS start_eom,
    DATE '2025-09-30' AS end_eom
),

-- Distinct month-ends in range, and previous month for each
months AS (
  SELECT DISTINCT End_of_Month_Date
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),
months_seq AS (
  SELECT
    End_of_Month_Date,
    ROW_NUMBER() OVER (ORDER BY End_of_Month_Date)           AS t_idx,
    LAG(End_of_Month_Date) OVER (ORDER BY End_of_Month_Date) AS prev_eom
  FROM months
),

-- Base rows (exposure: Derived -> Amortized)
base AS (
  SELECT
    t.End_of_Month_Date,
    t.Account_Identifier,
    CAST(COALESCE(t.DERIVED_AMORTIZED_COST_BASIS, t.AMORTIZED_COST_BASIS, 0) AS DECIMAL(18,2)) AS Exposure,

    t.CRE_FLAG, t.PD_GRADE, t.FDIC_CALL_CODE, t.NON_ACCRUAL_FLAG,
    t.INDUSTRY_CODE, t.LTV, t.GL_ACCOUNT_CODE, t.DAYS_PAST_DUE, t.RBC_CODE,
    t.MATURITY_DATE, t.NAICS_CODE, t.RC_CODE, t.REVOLVING_CODE, t.NEXT_RATE_CHANGE_DATE,
    t.ACCOUNT_OFFICER_NAME, t.BOOK_DATE, t.BUS_UNIT_CODE, t.COLLATERAL_CODE,
    t.ISSUE_DATE, t.OCCUPANCY_CODE, t.PAST_DUE_FLAG, t.PROD_HIER_LEVEL_5,
    t.PURPOSE_CODE, t.STATUS_CODE, t.RISK_UNIT
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB t
  JOIN params p
    ON t.End_of_Month_Date BETWEEN p.start_eom AND p.end_eom
),

-- UNPIVOT via UNION ALL (cast to VARCHAR for type alignment)
kde_long AS (
  SELECT End_of_Month_Date, Account_Identifier, Exposure, 'CRE_FLAG'              AS KDE_NAME, CAST(CRE_FLAG              AS VARCHAR(200)) AS KDE_VALUE FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PD_GRADE',               CAST(PD_GRADE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'FDIC_CALL_CODE',         CAST(FDIC_CALL_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NON_ACCRUAL_FLAG',       CAST(NON_ACCRUAL_FLAG       AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'INDUSTRY_CODE',          CAST(INDUSTRY_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'LTV',                    CAST(LTV                    AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'GL_ACCOUNT_CODE',        CAST(GL_ACCOUNT_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'DAYS_PAST_DUE',          CAST(DAYS_PAST_DUE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RBC_CODE',               CAST(RBC_CODE               AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'MATURITY_DATE',          CAST(MATURITY_DATE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NAICS_CODE',             CAST(NAICS_CODE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RC_CODE',                CAST(RC_CODE                AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'REVOLVING_CODE',         CAST(REVOLVING_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'NEXT_RATE_CHANGE_DATE',  CAST(NEXT_RATE_CHANGE_DATE  AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ACCOUNT_OFFICER_NAME',   CAST(ACCOUNT_OFFICER_NAME   AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BOOK_DATE',              CAST(BOOK_DATE              AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'BUS_UNIT_CODE',          CAST(BUS_UNIT_CODE          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'COLLATERAL_CODE',        CAST(COLLATERAL_CODE        AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'ISSUE_DATE',             CAST(ISSUE_DATE             AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'OCCUPANCY_CODE',         CAST(OCCUPANCY_CODE         AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PAST_DUE_FLAG',          CAST(PAST_DUE_FLAG          AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PROD_HIER_LEVEL_5',      CAST(PROD_HIER_LEVEL_5      AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'PURPOSE_CODE',           CAST(PURPOSE_CODE           AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'STATUS_CODE',            CAST(STATUS_CODE            AS VARCHAR(200)) FROM base
  UNION ALL SELECT End_of_Month_Date, Account_Identifier, Exposure, 'RISK_UNIT',              CAST(RISK_UNIT              AS VARCHAR(200)) FROM base
),

-- Pair each month with its previous month
prev_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.prev_eom
),
curr_kde AS (
  SELECT l.*, m.t_idx
  FROM kde_long l
  JOIN months_seq m ON l.End_of_Month_Date = m.End_of_Month_Date
),

-- *** FIXED joined CTE (no GROUP BY; no stray attrs) ***
joined AS (
  SELECT
    COALESCE(c.Account_Identifier, p.Account_Identifier) AS Account_Identifier,
    COALESCE(c.KDE_NAME,         p.KDE_NAME)             AS KDE_NAME,
    COALESCE(c.t_idx,            p.t_idx)                AS t_idx,
    c.End_of_Month_Date AS this_eom,
    p.End_of_Month_Date AS prev_eom,
    p.KDE_VALUE AS KDE_VALUE_Prev,
    c.KDE_VALUE AS KDE_VALUE_Curr,
    p.Exposure  AS Exp_Prev_Row,
    c.Exposure  AS Exp_Curr_Row
  FROM prev_kde p
  FULL OUTER JOIN curr_kde c
    ON  p.Account_Identifier = c.Account_Identifier
    AND p.KDE_NAME           = c.KDE_NAME
    AND p.t_idx              = c.t_idx
),

-- Row-level flags & attribution
row_flags AS (
  SELECT
    KDE_NAME,
    t_idx,
    this_eom,

    CASE
      WHEN (KDE_VALUE_Prev IS NULL AND KDE_VALUE_Curr IS NOT NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NULL)
        OR (KDE_VALUE_Prev IS NOT NULL AND KDE_VALUE_Curr IS NOT NULL AND KDE_VALUE_Prev <> KDE_VALUE_Curr)
      THEN 1 ELSE 0 END AS changed_flag,

    COALESCE(Exp_Curr_Row, Exp_Prev_Row, 0) AS exp_changed_row,

    CASE WHEN KDE_VALUE_Prev IS NOT NULL THEN 1 ELSE 0 END AS prev_flag,
    CASE WHEN KDE_VALUE_Curr IS NOT NULL THEN 1 ELSE 0 END AS curr_flag,
    COALESCE(Exp_Prev_Row, 0) AS exp_prev_row,
    COALESCE(Exp_Curr_Row, 0) AS exp_curr_row
  FROM joined
),

-- Monthly KDE rollups
roll_monthly AS (
  SELECT
    KDE_NAME,
    t_idx,
    MAX(this_eom)                                             AS this_eom,
    SUM(changed_flag)                                         AS cnt_changed,
    SUM(CASE WHEN changed_flag=1 THEN exp_changed_row ELSE 0 END) AS exp_changed,
    SUM(prev_flag)                                            AS cnt_prev,
    SUM(curr_flag)                                            AS cnt_curr,
    SUM(exp_prev_row * CASE WHEN prev_flag=1 THEN 1 ELSE 0 END)   AS exp_prev,
    SUM(exp_curr_row * CASE WHEN curr_flag=1 THEN 1 ELSE 0 END)   AS exp_curr
  FROM row_flags
  GROUP BY KDE_NAME, t_idx
),

metrics_monthly AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    cnt_changed,
    CAST(exp_changed AS DECIMAL(18,2)) AS exp_changed,
    CASE WHEN cnt_prev <> 0 THEN (cnt_changed * 1.0) / cnt_prev ELSE NULL END AS cnt_changed_pct,
    cnt_prev,
    cnt_curr,
    (cnt_curr - cnt_prev) AS cnt_mom_delta,
    CASE WHEN cnt_prev <> 0 THEN (cnt_curr - cnt_prev) * 1.0 / cnt_prev ELSE NULL END AS cnt_mom_pct,
    CAST(exp_prev AS DECIMAL(18,2)) AS exp_prev,
    CAST(exp_curr AS DECIMAL(18,2)) AS exp_curr,
    CAST(exp_curr - exp_prev AS DECIMAL(18,2)) AS exp_mom_delta,
    CASE WHEN exp_prev <> 0 THEN (exp_curr - exp_prev) / (exp_prev * 1.0) ELSE NULL END AS exp_mom_pct
  FROM roll_monthly
),

-- ***** FIX: compute regression as an aggregate (no OVER) *****
trend_all AS (
  SELECT
    KDE_NAME,
    REGR_SLOPE(exp_changed * 1.0, t_idx * 1.0) AS exp_changed_trend_slope
  FROM metrics_monthly
  GROUP BY KDE_NAME
),

-- Rolling 12-month stats (still analytic — supported in Netezza)
rolling_stats AS (
  SELECT
    KDE_NAME,
    this_eom,
    t_idx,
    exp_changed,
    AVG(exp_changed)    OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_ma12,
    STDDEV_SAMP(exp_changed) OVER (PARTITION BY KDE_NAME ORDER BY t_idx ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS exp_changed_sd12
  FROM metrics_monthly
),

-- Join trend + rolling stats back to the monthly metrics
trend_joined AS (
  SELECT
    m.*,
    ta.exp_changed_trend_slope,
    rs.exp_changed_ma12,
    rs.exp_changed_sd12,
    CASE
      WHEN rs.exp_changed_sd12 IS NULL OR rs.exp_changed_sd12 = 0 THEN NULL
      ELSE (m.exp_changed - rs.exp_changed_ma12) / rs.exp_changed_sd12
    END AS exp_changed_z12
  FROM metrics_monthly m
  LEFT JOIN trend_all ta
    ON ta.KDE_NAME = m.KDE_NAME
  LEFT JOIN rolling_stats rs
    ON rs.KDE_NAME = m.KDE_NAME
   AND rs.t_idx    = m.t_idx
),

-- Latest month only + ranking by changes-only exposure, then by count %
rank_prep AS (
  SELECT
    x.*,
    CASE WHEN x.cnt_changed_pct IS NULL THEN 1 ELSE 0 END AS cnt_changed_pct_is_null
  FROM trend_joined x
  WHERE x.this_eom = (SELECT MAX(End_of_Month_Date) FROM months_seq)
)

SELECT
  KDE_NAME,
  this_eom,

  -- changes-only (ranking keys)
  exp_changed,
  cnt_changed,
  cnt_changed_pct,

  -- MoM context
  cnt_prev, cnt_curr, cnt_mom_delta, cnt_mom_pct,
  exp_prev, exp_curr, exp_mom_delta, exp_mom_pct,

  -- Trend features
  exp_changed_trend_slope,
  exp_changed_ma12,
  exp_changed_sd12,
  exp_changed_z12,

  RANK() OVER (
    ORDER BY exp_changed DESC,
             cnt_changed_pct_is_null ASC,
             cnt_changed_pct DESC
  ) AS rank_by_changes_only_exp_then_cntpct
FROM rank_prep
ORDER BY exp_changed DESC, cnt_changed_pct_is_null ASC, cnt_changed_pct DESC, KDE_NAME;
